<!DOCTYPE html><html lang="ko" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="면접준비 - Java GC(Garbage Collection) 상세설명" /><meta name="author" content="minseok" /><meta property="og:locale" content="ko" /><meta name="description" content="오타, 지적 환영입니다." /><meta property="og:description" content="오타, 지적 환영입니다." /><link rel="canonical" href="https://kkminseok.github.io/posts/1001TIL2/" /><meta property="og:url" content="https://kkminseok.github.io/posts/1001TIL2/" /><meta property="og:site_name" content="민석강" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-10-01T02:02:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="면접준비 - Java GC(Garbage Collection) 상세설명" /><meta name="twitter:site" content="@none" /><meta name="twitter:creator" content="@minseok" /><meta name="google-site-verification" content="_icgy_j24DLYroQvKYTiffcqemP7ldWCxmrM2cGtYck" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"minseok"},"dateModified":"2022-10-02T03:56:23+09:00","datePublished":"2022-10-01T02:02:00+09:00","description":"오타, 지적 환영입니다.","headline":"면접준비 - Java GC(Garbage Collection) 상세설명","mainEntityOfPage":{"@type":"WebPage","@id":"https://kkminseok.github.io/posts/1001TIL2/"},"url":"https://kkminseok.github.io/posts/1001TIL2/"}</script><title>면접준비 - Java GC(Garbage Collection) 상세설명 | 민석강</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="민석강"><meta name="application-name" content="민석강"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src=" /assets/img/sample/logo.jpg " alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">민석강</a></div><div class="site-subtitle font-italic">3년차 개발자. 40살에 100억벌고 은퇴</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/kkminseok" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/none" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['minseok19950727','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>면접준비 - Java GC(Garbage Collection) 상세설명</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>면접준비 - Java GC(Garbage Collection) 상세설명</h1><div class="post-meta text-muted"><div> By <em> <a href="https://github.com/kkminseok">minseok</a> </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" data-ts="1664557320" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-10-01 </em> </span> <span> Updated <em class="timeago" data-ts="1664650583" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-10-02 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4125 words"> <em>22 min</em> read</span></div></div></div><div class="post-content"><blockquote class="prompt-info"><div><p>오타, 지적 환영입니다.</p></div></blockquote><h2 id="배경"><span class="mr-2"><strong>배경</strong></span><a href="#배경" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>C언어는 메모리를 직접 해제할 수 있다. <code class="language-plaintext highlighter-rouge">free()</code>를 통해서 직접 메모리를 해제하고 <code class="language-plaintext highlighter-rouge">malloc()</code>등을 통해 메모리를 할당할 수 있다. 또한 포인터를 통해 주소값에 직접 접근이 가능하다.</p><p>하지만, Java에서는 JVM가 메모리를 관리한다. 직접 주소에 접근할 수도 없다.</p><p>앞의 포스팅에서 JVM의 메모리구조에 대해서 말했다.</p><ul><li>Stack<li>PC Register<li>Native Method Stack<li>Method Area<li>Heap</ul><p>으로 이루어져있는데, 보통 런타임시에는 빈번하게 접근이 일어나는게 <strong>Stack</strong>과 <strong>Heap</strong>이다.</p><p>메소드와 지역변수들은 실행순서대로 스택에 쌓인다.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">main</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">call</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">call</span><span class="o">(){</span>
        <span class="nc">Spot</span> <span class="n">home</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Spot</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Spot</span><span class="o">{</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="n">x</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">y</span><span class="o">;</span>
    <span class="nc">Spot</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span><span class="kt">int</span> <span class="n">y</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>

</pre></table></code></div></div><p>이러한 코드가 있다고 치면 스택과 힙에는 이렇게 쌓일것이다.</p><div class="language-text highlighter-rouge"><div class="code-header"> <span data-label-text="Text"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>| home   |     |     |
| call() |     |Spot1| home -&gt; Spot1
| main() |     |     |
+++++++++      +++++++
Stack           Heap
</pre></table></code></div></div><p>call()에서는 <code class="language-plaintext highlighter-rouge">home</code> 살아있다. 만약 call()호출이 끝나면 <code class="language-plaintext highlighter-rouge">home</code>인스턴스는 어떻게 되는것인가? 사라질 것이다. 그러면 가리키고 있던 <code class="language-plaintext highlighter-rouge">Spot1</code>은?</p><div class="language-text highlighter-rouge"><div class="code-header"> <span data-label-text="Text"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>|        |     |     |
|        |     |Spot1| ? -&gt; Spot1
| main() |     |     |
+++++++++      +++++++
Stack           Heap
</pre></table></code></div></div><p>이 정리를 GC가 담당한다.</p><p>그러면 GC는 언제 이 메모리들을 정리한다는 것일까?</p><hr /><h2 id="garbage-collection-algorithm"><span class="mr-2"><strong>Garbage Collection Algorithm</strong></span><a href="#garbage-collection-algorithm" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>단순한건 메소드 호출이 끝날때마다 해주는 것이다. 하지만 메모리를 계속 모니터링해야하고, GC자체도 프로그램 성능에 영향을 주기에 문제가 있다. 그렇기에 GC알고리즘을 개선한다는 것은 <strong>GC시점을 언제 정하여 성능에 최대한 덜 지장을 주는가에 있다.</strong></p><h3 id="reference-counting"><span class="mr-2"><strong>Reference Counting</strong></span><a href="#reference-counting" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>GC를 수행할때 오브젝트에 몇 개의 레퍼런스가 연결되어 있는지 체크하는 방법이다.</p><p>위의 경우</p><div class="language-text highlighter-rouge"><div class="code-header"> <span data-label-text="Text"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>| home   |     |     |
| call() |     |Spot1| home -&gt; Spot1
| main() |     |     |
+++++++++      +++++++
Stack           Heap
</pre></table></code></div></div><p>에서 <code class="language-plaintext highlighter-rouge">call()</code>의 지역변수 <code class="language-plaintext highlighter-rouge">home</code>은 <code class="language-plaintext highlighter-rouge">Spot1</code>이라는 오브젝트를 가리키므로 <code class="language-plaintext highlighter-rouge">Spot1</code>의 카운트는 1이다. 이처럼 객체를 참조하는 변수의 수가 늘어나면 1을 올리고 사라지면 1을 내려 카운트가 0이되면 GC를 수행할 때 제거하는 방법이다.<br /> 직관적이지만 문제가 있다. 서로가 서로를 가리킬 때이다.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">call</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">call</span><span class="o">(){</span>
        <span class="nc">Home</span> <span class="n">home</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Home</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">);</span>
        <span class="nc">School</span> <span class="n">school</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">School</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">);</span>
        
        <span class="n">home</span><span class="o">.</span><span class="na">mySchool</span><span class="o">(</span><span class="n">school</span><span class="o">);</span>
        <span class="n">school</span><span class="o">.</span><span class="na">myHome</span><span class="o">(</span><span class="n">home</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Spot</span><span class="o">{</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="n">x</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">y</span><span class="o">;</span>
    <span class="nc">Spot</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span><span class="kt">int</span> <span class="n">y</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Home</span> <span class="kd">extends</span> <span class="nc">Spot</span><span class="o">{</span>
    <span class="kd">private</span> <span class="nc">School</span> <span class="n">school</span><span class="o">;</span>
    <span class="nc">Home</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">mySchool</span><span class="o">(</span><span class="nc">School</span> <span class="n">school</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">school</span> <span class="o">=</span> <span class="n">school</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">School</span> <span class="kd">extends</span> <span class="nc">Spot</span><span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Home</span> <span class="n">home</span><span class="o">;</span>
    <span class="nc">School</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">myHome</span><span class="o">(</span><span class="nc">Home</span> <span class="n">home</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">home</span> <span class="o">=</span> <span class="n">home</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>이렇게 짜는 경우는 없겠지만.. 내 머릿속에서 생각한 예제의 한계이다.</p><p>아무튼 이 경우</p><div class="language-text highlighter-rouge"><div class="code-header"> <span data-label-text="Text"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>| myHome()   | 
| mySchool() |
| school     |
| home       |     |school1[2] |  home -&gt; Home1
| call()     |     |home1[2]   |  school -&gt; School1
| main()     |     |           |  Home1 -&gt; school -&gt; School1 
+++++++++          ++++++++++++   School1 -&gt; home -&gt; Home1
Stack               Heap
</pre></table></code></div></div><p>이렇게 서로가 서로를 참조할 경우에는 <code class="language-plaintext highlighter-rouge">call()</code>이 끝나도 힙에 남아있는 <code class="language-plaintext highlighter-rouge">Home1</code>이 결국 <code class="language-plaintext highlighter-rouge">School1</code>을 가리킬것이기에 사라지지 않을 것이다.</p><h3 id="tracing"><span class="mr-2"><strong>Tracing</strong></span><a href="#tracing" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>오브젝트의 레퍼런스를 추적한다.</p><p>처음에는 스택의 지역변수에서 시작해 해당 변수가 가리키는 오브젝트를 찾는다.</p><p>오브젝트가 연결되어 있다면 해당 오브젝트의 <code class="language-plaintext highlighter-rouge">marked</code>값을 <code class="language-plaintext highlighter-rouge">true</code>로 바꾼다.</p><div class="language-text highlighter-rouge"><div class="code-header"> <span data-label-text="Text"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>| myHome()   | 
| mySchool() |
| school     |
| home       |     |school1[true] |  home -&gt; Home1
| call()     |     |home1[true]   |  school -&gt; School1
| main()     |     |           |  Home1 -&gt; school -&gt; School1 
+++++++++          ++++++++++++   School1 -&gt; home -&gt; Home1
Stack               Heap
</pre></table></code></div></div><p>지역변수로부터 레퍼런스가 끊기면 <code class="language-plaintext highlighter-rouge">marked</code>의 값을 <code class="language-plaintext highlighter-rouge">false</code>로 바꿔 GC수행시에 <code class="language-plaintext highlighter-rouge">false</code>인 오브젝트들을 메모리에서 해제시킨다.</p><div class="language-text highlighter-rouge"><div class="code-header"> <span data-label-text="Text"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>
|            |     |school1[false] |  ? -&gt; Home1
|            |     |home1[false]   |  ? -&gt; School1
| main()     |     |               |  Home1 -&gt; school(School1)
++++++++++++++     +++++++++++++++++   School1 -&gt; home(Home1)
Stack               Heap
</pre></table></code></div></div><p>하지만 이럴경우 메모리에 빈 공간이 생기게 되는데, 빈 공간이 늘어날때마다 이를 피해서 비집고 들어가는 상황이 발생하기에 메모리 공간은 충분하지만 할당되지 못하는 문제가 생긴다.<br /> 효율적이지 않다.</p><p>이미 할당된 메모리 공간을 다른 한 쪽으로 모아주는 <strong>compacting</strong>작업을 해줘야한다. 이것도 GC에서 수행되고, Tracing기법은 <strong>mark-and-sweep</strong>으로도 불린다.</p><p>mark-and-sweep -&gt; Compacting 작업이 수행되기에 MSC(Mark,Sweep,Compacting)으로도 불린다.</p><hr /><h3 id="generational-gc"><span class="mr-2"><strong>Generational GC</strong></span><a href="#generational-gc" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>JVM은 GC를 더 효율적으로 수행하기 위해 힙 메모리 구조를 더 세밀하게 분류한다. GC는 오버헤드가 큰 작업이다. 왜냐하면 GC가 시작될 때마다 JVM이 <strong>stop-the-world</strong>라는 프로그램의 스레드를 모두 멈추고 MSC를 수행한다. 따라서 GC주기가 잦으면 규모가 클수록 오버헤드가 커진다.</p><p>보통 오브젝트가 생성된지 얼마 안되어서 레퍼런스가 사라진다. 이러한 점을 착안해서 만든게 이 알고리즘이고, heap영역을 세대별로 쪼개 관리한다.</p><p>5가지 영역으로 Eden, S0, S1, Tenured, Permanent로 나누어진다. 이는 Java8 버전 이전이다. Java8버전 이후에는 Permanent가 사라지고 Metaspace가 생겼다.</p><p>Java8버전 이전이 설명하기 편하므로 이를 기준으로 정리해보겠다.</p><div class="language-text highlighter-rouge"><div class="code-header"> <span data-label-text="Text"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>                 |--------- Old ---------|
+------+----+----+-----------+-----------+
| Eden | S0 | S1 |  Tenured  | Permanent |
+------+----+----+-----------+-----------+
|----- Young ----|
</pre></table></code></div></div><p>Eden, S0, S1은 Young영역이라고 생성된지 얼마 안 된 오브젝트들이 쌓이는 공간이다.</p><ul><li>Eden : 오브젝트가 처음 생성되었을 때 Eden에 들어간다.<li>Survivor 0, Suvivor1 : 생성된 이후 시간이 흐르면 garbage되지 않은 오브젝트들이 eden에서 여기로 옮겨진다. 즉, 에덴에서 살아남은 오브젝트들이 들어가서 suvivor space라고도 불러진다. 두 개로 분리된것은 보통 하나의 Suvivor 공간이 꽉차게되면 다른 Suvivor공간으로 옮겨진다. 이 메커니즘 때문에 Suvivor들 중 하나의 공간은 비워지게 된다. 옮겨진 오브젝트들은 <strong>age count</strong>가 1 증가한 상태로 넘어간다.</ul><p>이 과정에서 1차 GC라고 하는 <code class="language-plaintext highlighter-rouge">Minor GC</code>가 발생하게 된다. 이 GC를 통해 Eden 또는 Suvivor영역들에 사용되지 않은 객체들을 메모리 해제하게 된다.</p><p>이 과정을 반복해도 살아남은 객체들의 <code class="language-plaintext highlighter-rouge">age counter</code>가 일정 이상으로 넘어가버리면 <code class="language-plaintext highlighter-rouge">Old</code>영역인 <code class="language-plaintext highlighter-rouge">tenured</code>로 보내 Suvivor영역이 꽉 차지 않게 한다.</p><p>이렇게 오브젝트가 살아남아 다음 세대로 넘어가는 것을 <strong>promotion</strong>이라고 한다.</p><p>Old 영역은 GC가 잘 발생하지 않으므로 메모리가 크게 할당된다.</p><p><strong>Permanent</strong>영역은 Method Area라고도 하는데, 객체나 문자열정보를 저장하는 곳이며, GC가 절대 발생하는 곳은 아니고 발생한다. 이는 <strong>Major GC</strong>에 포함된다.</p><blockquote class="prompt-tip"><div><p>Eden영역에서 바로 Old영역으로 넘어가는 객체가 있는데, 이는 객체의 크기가 아주 큰 경우를 말한다. Survivor영역의 크기가 20MB인데, 객체의 크기가 24MB인 그런 경우에 해당한다.</p></div></blockquote><hr /><h2 id="java-8버전-이후-gc"><span class="mr-2"><strong>Java 8버전 이후 GC</strong></span><a href="#java-8버전-이후-gc" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p><img data-src="/assets/img/interview/gc8.png" alt="not found" data-proofer-ignore></p><p>Permanent영역이 Metaspace로 변경되었다. 기존 Permanent 영역에는 다음과 같은 정보가 저정되어 있었다.</p><ul><li>Class Meta정보<li>Method Meta정보<li>Static Object<li>상수화된 String Object<li>Class 관련 배열 객체 및 객체 Meta 정보<li>JVM 내부적인 객체들과 최적화컴파일러(JIT)의 최적화 정보</ul><p>이는 Metaspace가 생기면서 다음과 같이 바뀌었다.</p><ul><li>Class Meta정보 -&gt; Metaspace로 이동<li>Method Meta정보 -&gt; Metaspace로 이동<li>Static Object -&gt; <strong>Heap영역으로 이동</strong><li>상수화된 String Object -&gt; <strong>Heap영역으로 이동</strong><li>Class 관련 배열 객체 및 객체 Meta 정보 -&gt; Metaspace로 이동<li>JVM 내부적인 객체들과 최적화컴파일러(JIT)의 최적화 정보 -&gt; Metaspace로 이동</ul><p>왜 이렇게 바뀌었냐면 Permanet에 있던 Static Object들이 문제를 유발했다고 한다. 이를 Heap영역으로 옮겨서 최대한 GC대상이 되도록 변경했다고 한다.</p><p>다음과 같은 오류를 발생했다고 한다.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nc">OutOfMemoryError</span> <span class="o">:</span> <span class="nc">PermGen</span> <span class="nc">Space</span> <span class="n">error</span>
</pre></table></code></div></div><p>이는 메모리 누수가 발생했을때 나타나는 예외이고 로딩된 클래스와 클래스 로더가 종료될때 이것들이 GC되지 않았을때 발생한다고 한다.</p><p>수정될 필요가 없는 정보만 <strong>Metaspace</strong>에 저장하고 JVM의 필요에 따라 리사이징할 수 있게 바뀌었다고한다.</p><hr /><h2 id="gc-방식"><span class="mr-2"><strong>GC 방식</strong></span><a href="#gc-방식" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>Java7 : Parallel GC<li>Java8 : Parallel GC<li>Java9 : G1(proPosed)<li>Java10 : G1<li>Java15 : ZGC(proPosed)</ul><h3 id="1-serial-gc"><span class="mr-2">1. Serial GC</span><a href="#1-serial-gc" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>JDK 5,6 에서 쓰이던 방식으로 Major GC, Minor GC 모두 싱글스레드로 실행되어 Stop-The-World가 다른 GC에 비하여 오래걸린다.<br /> 절대 사용하면 안되는 GC로 설명되어 있으며 MSC 알고리즘을 사용한다.</p><h3 id="2-parallel-gcthroughput-collector"><span class="mr-2">2. Parallel GC(Throughput Collector)</span><a href="#2-parallel-gcthroughput-collector" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><strong>Serial GC와 동일하나 Young Gen을 멀티스레드를 통해 병렬 처리한다.</strong></p><p>compaction 단계 이전에 summary라는 단계를 가지며, 해당 작업에서는 이전 GC 이후의 메모리를 인덱싱하는 작업을 수행하고 compact 작업을 수행한다.<br /> 공간에 대한 인덱싱 작업때문에 약간의 메모리를 더 소모할 수 있다.</p><p>업그레이드 방식으로 <strong>Parallel old GC</strong>가 있다. 이는 Old영역에서 발생하는 FullGC도 병렬로 처리한다.</p><h3 id="3-cmsconcurrent-mark--sweep-gc"><span class="mr-2">3. CMS(Concurrent Mark &amp; Sweep) GC</span><a href="#3-cmsconcurrent-mark--sweep-gc" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Full GC의 수행시간을 최소한으로 줄이는데 초점을 맞춘 GC이다. 즉 Stop-The-World의 시간을 최소화한다. 그렇기에 GC대상을 정밀하게 파악한다.</p><p>기존 Parallel GC 방식은 Full GC를 수행할때마다 Compaction 작업을 하여 시간을 많이 소요하였지만, 수행된 이후에는 메모리를 연속적으로 저장할 수 있어 메모리를 더 빠르게 할당할 수 있다.</p><p><strong>CMS는 Compaction작업을 수행하지 않기 때문에</strong> 속도가 빠르지만 메모리 단편화로 인해 <strong>Concurrent mode failure</strong>가 발생할 수 있고, 이 경우 Compaction 작업을 수행한다.<br /> 다만, Compaction 과정이 Parallel GC보다 오래걸릴 수 있다. 그리고 CPU리소스가 부족해지거나 메모리 단편화로 인해 메모리 공간이 부족해지면 Serial GC방식의 Full GC가 발생 한다.</p><p>그러면 CMS는 어떤식으로 GC대상을 파악할까?</p><ul><li>Initial Mark : 현재 살아남은 객체를 탐색하는데, GC ROOT에서 참조하는 객체들만 우선 탐색하기 때문에 STW발생 시간이 적다.<li>Concurrent Mark : 위 단계에서 탐색한 객체들이 참조하고 있는 객체를 찾아가며, GC대상인지 확인한다.(STW 발생 x)<li>ReMark : Concurrent Mark 과정 중 새로 생성된 객체나, 참조가 끊기는 등 변경된 객체가 있는지 다시 한번 점검한다.(STW 발생 - 멀티스레드로 인해 시간이 짧다.)<li>Concurrent Sweep : Remark 단계까지 검증이 완료된 GC대상 객체를 해제한다.(STW x)</ul><h3 id="4-g1-gcgarbage-first-gc"><span class="mr-2">4. G1 GC(Garbage First GC)</span><a href="#4-g1-gcgarbage-first-gc" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>G1 GC는 기존 메모리 구조에서 좋은 성능을 내기 힘들어서 개선하고자 등장했다. 힙 메모리 영역 전체를 Region이라는 논리적인 단위로 나눠서 관리한다. Region은 특정 역할(Eden, Suvivor, Old 등)을 동적으로 부여한다.</p><p>CMS와 달리 Compaction 단계를 진행하고 메모리 단편화 문제를 없앴다. STW 시간을 예측할 수 있다는 것이 G1 GC가 가진 큰 장점 중 하나다.</p><p><img data-src="/assets/img/interview/g1GC.png" alt="error" data-proofer-ignore></p><p>이렇게 Region 단위로 나뉘는데, 2048개의 Region으로 Heap을 나눌 수 있다.</p><p>각 Region은 1MB ~ 32MB의 크기를 지정할 수 있다.</p><p>여기서 <strong>Humonogous, Avliable, Unused</strong>영역은 처음보는데 이를 정리해야 한다.</p><ul><li>Humonogous : Region 크기의 50%를 초과하는 객체가 저장되는 공간이다. 이 공간에서는 GC가 효율적으로 일어나지 않는다.<li>Avaliable/Unused : 아직 사용되지 않은 비어있는 공간의 Region이다.</ul><p>G1 GC에서는 <strong>Young GC</strong>를 수행할 때는 STW가 발생하고, STW시간을 줄이기 위해 멀티스레드로 GC를 진행한다.</p><p>Young GC는 Region 중 GC대상 객체가 가장 많은 Region(Eden or Survivor역할)에서 수행 되며, 이 Region에서 살아남은 객체를 다른 Region(Suvivor 역할)으로 옮긴 후, 비워진 Region을 사용 가능한 Region으로 돌리는 형태로 작동한다.</p><p>Old GC에서는 CMS처럼 백그라운드 쓰레드로 이 영역들을 정리한다.<br /> Heap 메모리에 객체가 살아 있는지 동시적이고 전역적인 마킹을 수행하고, 어떤 영역의 메모리가 가장 많이 비어있는지 확인하여 메모리를 회수 한다. 그렇기 때문에 Garbage First라는 이름을 갖고 있는 것이다. G1에 의해서 교체를 해야하는 공간은 배출(evacuation)에 의해 GC를 시작한다.</p><p>배출은 Region 내의 unreachable object만 삭제하는 것이 아니고, Reachable object는 다른 Old영역Region으로 이동시키고 해당 Region 전체를 클리어한다. 다른 Region으로 옮기는 과정에서 Compacting을 하여 메모리 단편화가 생기지 않는다.</p><h3 id="5-zgc"><span class="mr-2">5. ZGC</span><a href="#5-zgc" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>jdk 15버전이상에서 사용되는 GC종류로, 조금 더 큰 메모리(8MB ~ 16TB)에서 효율적으로 GC하기 위한 알고리즘이다. 주된 목적은 STW시간을 줄이기 위해 Marking 시간에서만 STW를 진행하도록 하고 있다.</p><p><img data-src="/assets/img/interview/zgc.png" alt="error" data-proofer-ignore></p><p>G1GC와 유사한 구조를 가지고 있는데, ZGC는 <strong>Colored pointers</strong>와 <strong>Load barriers</strong>라는 2가지 주요 알고리즘을 가지고 있다.</p><ul><li>Colored Pointers <img data-src="/assets/img/interview/coloredPointer.png" alt="error" data-proofer-ignore></ul><p>객체를 가리키는 변수의 포인터에서 64bit를 활용해서 Marking을 한다.</p><p>Finalizable : finalizer을 통해서만 참조되는 Object의 Garbage Remapped: 재배치 여부를 판단하는 Mark Marked 1/0 : Live Object</p><p>그렇기에 ZGC는 64비트 운영체제에서만 사용이 가능하다.</p><ul><li>Load barriers<br /> 위의 비트를 이용해서 G1GC와 다르게 메모리 재배치 과정에서 STW를 발생시키지 않는다. 그리고 비트를 이용해 참조 값과 mark 상태를 업데이트 한다.</ul><p>마킹 과정은 내가 이해를 못해서.. 정리하기 어려우므로 다른 글을 읽는것을 추천한다.</p><ol><li><a href="https://kchanguk.tistory.com/174">https://kchanguk.tistory.com/174</a><li><a href="https://huisam.tistory.com/entry/jvmgc">https://huisam.tistory.com/entry/jvmgc</a></ol><h2 id="reference"><span class="mr-2">Reference</span><a href="#reference" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li><a href="https://1-7171771.tistory.com/140">https://1-7171771.tistory.com/140</a> Java8버전 이후 GC참조<li><a href="https://parksb.github.io/article/2.html">https://parksb.github.io/article/2.html</a> GC 디테일<li><a href="https://d2.naver.com/helloworld/1329">https://d2.naver.com/helloworld/1329</a> Naver D2<li><a href="https://code-factory.tistory.com/48">https://code-factory.tistory.com/48</a> Metaspace 정보 참조</ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/interview/'>Interview</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/java/" class="post-tag no-text-decoration" >Java</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=면접준비 - Java GC(Garbage Collection) 상세설명 - 민석강&amp;url=https://kkminseok.github.io/posts/1001TIL2/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=면접준비 - Java GC(Garbage Collection) 상세설명 - 민석강&amp;u=https://kkminseok.github.io/posts/1001TIL2/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https://kkminseok.github.io/posts/1001TIL2/&amp;text=면접준비 - Java GC(Garbage Collection) 상세설명 - 민석강" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/2023-03-06-dnd/">DND 8기 활동 후기</a><li><a href="/posts/2024-03-31-fastapi/">fastapi Swagger Response 분리하기</a><li><a href="/posts/2023-05-19-think01/">5월19일시점 개발하면서 고민한 것들 + 도커관련 이슈</a><li><a href="/posts/2023-05-02-Modern-Java-In-action/">2번 읽는 Modern Java In Action - Chapter06 스트림으로 데이터 수집</a><li><a href="/posts/2023-03-18-Modern-Java-In-Action/">2번 읽는 Modern Java In Action - Chapter01 기초</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/leetcode/">leetcode</a> <a class="post-tag" href="/tags/programmers/">Programmers</a> <a class="post-tag" href="/tags/baekjoon/">Baekjoon</a> <a class="post-tag" href="/tags/algorithmstudy/">AlgorithmStudy</a> <a class="post-tag" href="/tags/top100like/">Top100Like</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/fastapi/">FastAPI</a> <a class="post-tag" href="/tags/economy/">Economy</a> <a class="post-tag" href="/tags/dp/">DP</a> <a class="post-tag" href="/tags/top100interview/">Top100Interview</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/2022-12-08-JavaVersion10/"><div class="card-body"> <em class="timeago small" data-ts="1670439720" > 2022-12-08 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Java 10버전은 뭐가 달라졌나</h3><div class="text-muted small"><p> 개요 2018년 3월 20일에 출시된 자바 10버전은 뭐가 달라졌을까? 현재 19버전까지 나왔는데, 좋은 글을 발견하여 이 글을 읽어가면서 예제를 작성하고 학습할 예정이다. ✏️ Local-variable Type inference(“var”) 10버전에서부터 로컬변수에 var를 사용하여 선언할 수 있다. 1 2 3 4 5 6 7 8 9 ...</p></div></div></a></div><div class="card"> <a href="/posts/2022-12-11-JavaVersion11/"><div class="card-body"> <em class="timeago small" data-ts="1670778120" > 2022-12-12 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Java 11버전은 뭐가 달라졌나</h3><div class="text-muted small"><p> 개요 자바 11버전부터는 LTS(Long-Term Support)개념이 들어간다. 일반적인 소프트웨어는 새로운 버전이 출시될 때마다 이전 버전에 대한 업데이트를 중지하는데, LTS는 긴 기간 동안 지속적인 지원을 받을 수 있기 때문에, 기업이나 조직 등에서 사용하여 안정성을 어느정도 보장받을 수 있다. ✏️1. Local-Variable Synt...</p></div></div></a></div><div class="card"> <a href="/posts/2022-12-14-JavaVersion12/"><div class="card-body"> <em class="timeago small" data-ts="1670961720" > 2022-12-14 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Java 12버전은 뭐가 달라졌나</h3><div class="text-muted small"><p> 개요 자바12는 이전 버전에 비해 크게 바뀐 것은 없다. ✏️ 1. New String and Files methods String.indent() 이 함수는 메소드안에 있는 인자만큼 문자열을 들여쓰기 해준다. 여러줄에 걸쳐서 들여쓰기를 해야하는 경우 이 함수는 이를 감지하여 적용 시켜준다. 1 2 3 4 5 6 7 8 9 @Test @Di...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/1001TIL/" class="btn btn-outline-primary" prompt="Older"><p>면접준비 - Java 동등성, 동일성</p></a> <a href="/posts/banksalad02/" class="btn btn-outline-primary" prompt="Newer"><p>라이브코테 준비 - 연습문제2</p></a></div><script type="text/javascript"> $(function () { const origin = "https://giscus.app"; const iframe = "iframe.giscus-frame"; const lightTheme = "light"; const darkTheme = "dark_dimmed"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } let giscusAttributes = { "src": "https://giscus.app/client.js", "data-repo": "kkminseok/kkminseok.github.io", "data-repo-id": "MDEwOlJlcG9zaXRvcnkzNDUwNzI2OTM=", "data-category": "Announcements", "data-category-id": "DIC_kwDOFJFkNc4CO5-J", "data-mapping": "pathname", "data-reactions-enabled": "1", "data-emit-metadata": "0", "data-theme": initTheme, "data-input-position": "bottom", "data-lang": "en", "crossorigin": "anonymous", "async": "" }; let giscusScript = document.createElement("script"); Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value)); document.getElementById("tail-wrapper").appendChild(giscusScript); addEventListener("message", (event) => { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; const theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); const message = { setConfig: { theme: theme } }; const giscus = document.querySelector(iframe).contentWindow; giscus.postMessage({ giscus: message }, origin); } }); }); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://twitter.com/none">kang minseok</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/leetcode/">leetcode</a> <a class="post-tag" href="/tags/programmers/">Programmers</a> <a class="post-tag" href="/tags/baekjoon/">Baekjoon</a> <a class="post-tag" href="/tags/algorithmstudy/">AlgorithmStudy</a> <a class="post-tag" href="/tags/top100like/">Top100Like</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/fastapi/">FastAPI</a> <a class="post-tag" href="/tags/economy/">Economy</a> <a class="post-tag" href="/tags/dp/">DP</a> <a class="post-tag" href="/tags/top100interview/">Top100Interview</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> $(function() { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/ko.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-KMXXJ0D586"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-KMXXJ0D586'); }); </script>
