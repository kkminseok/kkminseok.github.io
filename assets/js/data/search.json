[ { "title": "fastapi Swagger Response 분리하기", "url": "/posts/2024-03-31-fastapi/", "categories": "openAPI", "tags": "openAPI", "date": "2024-03-31 01:02:00 +0900", "snippet": "개요fastapi 를 사용하고 있는데, fastapi 공식문서를 따라가면서 swagger문서를 작성하다보니 불편함을 느꼈다.그것은 바로@router.get(&quot;/ingredient&quot;, responses={ status.HTTP_200_OK: { &quot;description&quot;: &quot;재료 조회 성공&quot;, &quot;content&quot;: { &quot;application/json&quot;: { &quot;example&quot;: { &quot;code&quot;: 200, &quot;message&quot;: &quot;Success&quot;, &quot;data&quot;: [ { &quot;ingredient_name&quot;: &quot;당근&quot;, &quot;ingredient_url&quot;: &quot;https://default.image&quot; }, { &quot;ingredient_name&quot;: &quot;토마토&quot;, &quot;ingredient_url&quot;: &quot;https://default.image&quot; }, { &quot;ingredient_name&quot;: &quot;치즈&quot;, &quot;ingredient_url&quot;: &quot;https://default.image&quot; } ] } } } }, status.HTTP_401_UNAUTHORIZED: {&quot;description&quot;: &quot;토큰 에러&quot;, &quot;content&quot;: { &quot;application/json&quot;: { &quot;example&quot;: { &quot;code&quot;: 401, &quot;message&quot;: &quot;Parsing Error token&quot;, &quot;data&quot;: None } } } } } )async def search_ingredient_history( db: Session = Depends(get_db), user: Optional[UserResponseByToken] = Depends(get_current_user_authorizer())): return StandardizedResponse(code=200, data=await user_service.search_ingredient_history(db, user))이런 코드들이 Controller에 너무 많이 있었다.뭐가 불편한가?service를 호출하는 코드는 return StandardizedResponse(code=200, data=await user_service.search_ingredient_history(db, user))로 단 한 줄인데 swagger를 작성하는 코드는 약 40줄에 달한다.배보다 배꼽이 더 큰 상황인데, 이런 코드들이 점점 많아지니까 스웨거를 자세히 작성하는데에 불편함도 느끼고 함수를 찾아가는데에도 번거로움을 느꼈다. 무엇보다 정리되지 않은 느낌이 싫었다.해결방법분리하기 위해서는 2가지 방법이 있었다. 직접 .yml파일을 작성하고, 해당 파일을 명시하는 방법 함수형태로 호출각각 장단점이 있는데, .yml파일을 작성하면 간결하게 읽을 수 있겠지만 모델이 변경하는 등의 수정작업이 있으면 .yml파일도 같이 수정해줘야한다.함수호출형태는 수정작업이 이루어져도 모델을 참조하고 있기에 관리가 용이하지만 파일이 늘어난다는 단점이 있다.나는 관리포인트를 최소화하고 싶어서 함수호출형태로 변경하였다.사전준비@router.post( &quot;/verification&quot;, description=&quot;사용자 토큰 검증 api&quot;, status_code=status.HTTP_200_OK, response_description=&quot;유저의 email과 이름 정보&quot;, responses=verification_user_response())## 분리된 파일def verification_user_response(): return { status.HTTP_200_OK: { &quot;description&quot;: &quot;Success&quot;, &quot;content&quot;: { &quot;application/json&quot;: MediaType( example=Example({ &quot;code&quot;: 200, &quot;message&quot;: &quot;Success&quot;, &quot;data&quot;: { &quot;name&quot;: &quot;username&quot;, &quot;email&quot;: &quot;test@naver.com&quot;, &quot;access_token&quot;: &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuaWNrbmFtZSI6IkppaG8gSmFuZyIsImV4cCI6MTcxMjIyODAzM30.RUl1PC3VuuQuldnl0IZMg4YEgSq-P1oZmKDrnjzt-uZ&quot; } }) ) } }, status.HTTP_401_UNAUTHORIZED: { &quot;description&quot;: &quot;Unauthorized&quot;, &quot;content&quot;:{ &quot;application/json&quot;: MediaType( example=Example({ &quot;code&quot;: 401, &quot;message&quot;: &quot;Parsing Error token&quot;, &quot;data&quot;: None }) ) } } }이렇게 작성해주면 된다.이게 가능한 이유는 @router에 response가 스키마를 구성할때 데이터 타입은 dictionary로 데이터를 받고 있기에 위와같은 구조가 가능한 것이다.이렇게 한결 깔끔하게 문서관리를 할 수 있게 되었다.끝" }, { "title": "google Bard API 사용해보기", "url": "/posts/2023-09-29-bardTest/", "categories": "openAPI", "tags": "openAPI", "date": "2023-09-29 01:02:00 +0900", "snippet": "개요현재 사이드프로젝트의 주제를 새롭게 정하여 진행하고 있는데 OpenAI를 이용한 서비스를 구현할까 생각하고 있다.GPT도 있고 Bard도 있는데, GPT는 무료크레딧을 주고 정확한 정보를 제공하지만 정보가 2021년도에 막혀있다는 단점이 있어서 Bard를 사용해볼까 테스트를 진행하였다.오랜만에 기술블로그에 글 쓸겸해서..이런 openAI코드들이 그렇듯, 대부분 python으로 제공되므로 python을 사용해서 테스트해볼 것이다.영어문서가 잘 나와있지만 그것도 보기 귀찮은 어느 사람들을 위해 글을 쓴다.코드import requestsfrom bardapi.constants import SESSION_HEADERSfrom bardapi import Bardfrom markdown import markdowntoken = &quot;&quot;session = requests.Session()session.headers = SESSION_HEADERSsession.cookies.set(&quot;__Secure-1PSID&quot;, token)session.cookies.set(&quot;__Secure-1PSIDTS&quot;, &quot;custom value&quot;)session.cookies.set(&quot;__Secure-1PSIDCC&quot;, &quot;custom value&quot;)bard = Bard(token=token, session=session)response = bard.get_answer(&quot;깃허브 id가 kkminseok인 사람의 깃허브 프로필 주소를 알려줘&quot;)response_content = response[&#39;content&#39;]response_image = response[&#39;links&#39;]filtered_links = [link for link in response_image if &quot;https://lh3.googleusercontent.com/&quot; in link or &quot;http://t0.gstatic.com/&quot; in link]print(markdown(response_content))print(filtered_links)코드를 보면 cookie를 가지고 짬뽕을 하는걸 알 수 있다.https://bard.google.com/chat에 들어가서 개발자도구 -&amp;gt; 애플리케이션 -&amp;gt; 쿠키에 들어가면 해당값들을 볼 수 있다.__Secure-1PSID, __Secure-1PSIDTS, __Secure-1PSIDCC값들을 맞게 설정해주고 나머지는 알아서 작성하면된다.위 코드에서 filtered_links가 있는데, stackoverflow에서 이미지 링크를 응답으로 받았을때 그걸 검출위한 코드로 제시하고 있어서 써봤다. 근데 잘 되지는 않는다. 연구가 필요한 부분..markdown 라이브러리르 사용한 것은, 기본적으로 응답이 markdown문법으로 내려온다.대략**개요***어떤 글*이런식으로 응답이 내려와서 웹에 해당 응답을 줘야한다면 markdown이 아닌, 웹이 알 수 있는 html로 변환해서 내려줘야할 것이다.저렇게 markdown()으로 감싸면 html로 감싸서 응답을 줄 수 있으므로 참고하면 될 것 같다.결과" }, { "title": "aws를 이용해서 음원 스트리밍 파일 서버(?) 구축하기", "url": "/posts/2023-07-08-AwsElasticTrasCoder/", "categories": "Java, Spring", "tags": "Troubleshooting", "date": "2023-07-08 01:02:00 +0900", "snippet": "📖 개요내가 하고 있는 프로젝트중 하나인, bpm을 측정해서 해당 bpm에 맞는 음원을 반환하는 서비스는 기존에 다음과 같은 로직으로 되어있었다.s3에 파일업로드 -&amp;gt; 직접 접근할 수 있는 url을 안드로이드에 반환 -&amp;gt; 안드로이드에서 캐시작업 + 해당 음원을 다운로드 -&amp;gt; 음원 재생여기서 문제는 2가지 있었다. 캐시작업캐시 작업을 할 때 안드로이드에서 리소스 부담이 크다는 것이다. 음원이 하나당 10MB정도인데, 100곡이면 1GB라는점 그리고 캐시작업으로 인해 코드가 더럽다고 한다. 음원재생이것도 가장 큰 문제인데, 음원을 다운로드하고 재생하는 방식이다보니 다음 곡 재생이 4~5초 걸린다고 하는 것이다.4~5초가 크지는 않지만 이게 반복된다면 사용자 입장에서 굉장히 불편할거라 생각했다.그래서 우리는 스트리밍방식을 선택하기로 하였다.📖 선행지식 및 flow선행지식에 대해 많이 적지는 않겠지만 hls라는 프로토콜을 사용해서 스트리밍 방식을 구현한다.인터넷에 찾아보면 비디오 파일을 스트리밍방식으로 구현한 예제는 많이 찾아볼 수 있지만, mp3파일을 스트리밍방식으로 구현한 예제는 찾기 어려웠다.그래서 비디오 파일을 스트리밍방식으로 구현한 예제를 토대로 작성하였다.플로우는 다음과 같다.aws Lambda에서 s3에 파일 업로드를 감지 -&amp;gt; 파일 업로드 되면 mp3파일인 경우 Elastic TransCoder를 통하여 m3u8파일로 변환 -&amp;gt; 이에 직접 접근 가능한 url을 클라이언트에 제공그러면 먼저 aws Lambda를 작성해야한다.Aws Lambda작성Lambda를 통해 s3에 파일이 업로드되는 것을 감지하고, 해당 파일을 m3u8파일로 변환한다.# Pythonimport boto3def lambda_handler(event, context): # AWS Elastic Transcoder 인스턴스 생성 transcoder = boto3.client(&#39;elastictranscoder&#39;, region_name=&#39;us-east-1&#39;) # 변환 작업에 사용할 S3 버킷 이름 설정 input_bucket = &#39;버킷 이름&#39; output_bucket = &#39;버킷 이름&#39; # Lambda 이벤트에서 S3 버킷 이름과 파일 키 추출 bucket = event[&#39;Records&#39;][0][&#39;s3&#39;][&#39;bucket&#39;][&#39;name&#39;] key = event[&#39;Records&#39;][0][&#39;s3&#39;][&#39;object&#39;][&#39;key&#39;] # 버킷명 출력 print(&quot;bucket:&quot;, bucket) # s3에 업로드된 파일명 출력 print(&quot;key:&quot;, key) # 필자의 경우 album이미지가 들어오는 경우 따로 저장해줘서 이는 걸러줌. print(&quot;key find test :&quot;, key.find(&quot;album&quot;)) if key.find(&quot;album&quot;) != -1 : return # 이 밑은 출력파일 경로 본인이 알아서 설정. key = key.replace(&quot;+&quot;,&quot; &quot;).replace(&quot;.mp3&quot;, &quot;&quot;) keyList = key.split(&quot;/&quot;) outputFolder = keyList[1] + &quot;/&quot; + keyList[-1] print(outputFolder) #여기까지 # Elastic Transcoder 작업 설정 job_settings = { &#39;PipelineId&#39;: &#39;Elastic TransCoder 파이프라인 ID&#39;, &#39;Input&#39;: { &#39;Key&#39;: key, &#39;FrameRate&#39;: &#39;auto&#39;, &#39;Resolution&#39;: &#39;auto&#39;, &#39;AspectRatio&#39;: &#39;auto&#39;, &#39;Interlaced&#39;: &#39;auto&#39;, &#39;Container&#39;: &#39;auto&#39; }, &#39;Output&#39;: { # 출력 파일명 &#39;Key&#39;: &quot;output/&quot; + outputFolder +&quot;/Hls&quot;, # 비디오 파일 프리셋 아이디명인데, 밑의 ID는 Hls Audio 160k이다. &#39;PresetId&#39;: &#39;1351620000001-200060&#39;, &#39;SegmentDuration&#39;: &#39;10&#39;, &#39;ThumbnailPattern&#39;: &#39;&#39;, &#39;Rotate&#39;: &#39;0&#39; } } # Elastic Transcoder 작업 시작 transcoder.create_job( PipelineId=job_settings[&#39;PipelineId&#39;], Input=job_settings[&#39;Input&#39;], Output=job_settings[&#39;Output&#39;] ) return { &#39;statusCode&#39;: 200, &#39;body&#39;: &#39;Elastic Transcoder job created&#39; }한글로 적은 부분은 본인이 알아서 적어야하는 부분이다.Elastic TransCoder 파이프라인 ID를 알려면 AWS Elastic TransCoder로 접근해서 파이프라인을 생성해야한다.만드는 방식은 크게 어렵지 않으며, 성공적으로 만들면 해당 파이프라인의 ID가 생성된다.이는 파이프라인을 선택하면 돋보기 모양이 생기는데 거기 안으로 들어가면 볼 수 있다.해당 ID를 입력해주면 된다.이렇게 하면 s3에 api콜을 통해서 파일을 업로드하던, 직접 업로드하면 람다가 작동해서 성공적으로 m3u8파일로 변환된다.이를 테스트하는 방법은 HLSPlayer를 다운받아서 해당 url에 직접 접근하였을때 음원이 재생되면 된다.겪은 문제?위처럼 깔끔하게 되지는 않을 것이다.중간에 IAM 역할이 없다고 오류가 나온적도 있으며, 코드상의 문제가 생긴적도 있었다.이는 전부 AWS CloudWatch에서 로그를 분석하거나, AWS Elastic Coder의 JOB에서 로그를 볼 수 있다. AWS Elastic Coder 로그 접근 AWS CloudWatch로 접근해서 보는 로그 분석큰 어려움이 있다면 댓글을 달아주세요." }, { "title": "경험으로 알아보는 Spring Filter를 사용하는 이유", "url": "/posts/2023-05-21-filter01/", "categories": "Java, Spring", "tags": "Troubleshooting", "date": "2023-05-21 01:02:00 +0900", "snippet": "🔅 문제상황안드로이드 개발자와 얘기를 하다가 response데이터들을 하나의 response객체에 담아서 보내기로 하였다.기존에는{ &quot;questionBoardDto&quot;: { ... 필드값들 ... }}이런식으로 값을 줬다면{ &quot;response&quot; :{ ... 필드값들 ... }}즉, 모든 dto를 response라는 객체로 바꾸고 그 안에 값을 담아서 보내야했다.모든 DTO에 어노테이션을 달아서 해결할 수는 있지만, 이미 사이즈가 어느정도 커졌고 좀 더 편한 방법이 없을까 했다.🤔 Interceptor vs Filter인터셉터로 구현할까 해봤다.하지만 필터와 달리 인터셉터는 request 및 response 조작이 불가능하다.필터의 동작방식은 모두가 알테니 설명하지는 않겠다. 컨트롤러에 요청이 도달하기 전, 도달하고 클라이언트에게 응답을 보낼때의 request, response 조작이 가능하다.나는 클라이언트에게 모든 요청에 대해서 response body에 담겨진 Json값을 response라는 객체에 담아서 보내야했기에 response 조작이 필요했다.그래서 하나의 필터를 만들었다.참고글은 이글이다.@Slf4jpublic class JsonFilter extends OncePerRequestFilter { @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { //전처리 ContentCachingResponseWrapper responseWrapper = new ContentCachingResponseWrapper((HttpServletResponse) response); filterChain.doFilter(request, responseWrapper); //후처리 responseWrapper.setCharacterEncoding(&quot;UTF-8&quot;); byte[] responseArray = responseWrapper.getContentAsByteArray(); String responseStr = new String(responseArray, responseWrapper.getCharacterEncoding()); ObjectMapper objectMapper = new ObjectMapper(); JsonNode jsonNode = objectMapper.readTree(responseStr); ObjectNode dataNode = objectMapper.createObjectNode(); dataNode.set(&quot;response&quot;, jsonNode); String modifiedJson = objectMapper.writeValueAsString(dataNode); //한글이 포함되어 있어서 사이즈를 재계산해줘야함. byte[] utf8Bytes = modifiedJson.getBytes(StandardCharsets.UTF_8); int length = utf8Bytes.length; response.setContentType(responseWrapper.getContentType()); response.setContentLength(length); response.getOutputStream().write(modifiedJson.getBytes()); }}지금은 결과물이지만 조금의 고생이 있었다. response에 한글이 내려올 경우 깨지는 경우가 있어서 UTF-8로 변환후 값을 재구성해줘야했다. 이는 그렇게 어렵지 않았다. swagger-ui와 같이 쓸 경우🤔 Swagger-ui와 같이 쓸 경우이게 왜 문제일까?저 위의 코드는 무조건 JSON값이 들어온다고 가정하고 값을 파싱해서 response객체에 담아서 보내고 있다.Swagger에 접근할 경우 응답으로 줘야할건 JSON이 아니라 Html이다.그래서 JSON파싱을 못하기에 에러가 발생했다.자, 그럼 WebConfig에서 swagger에 대한 url을 무시하면 되지 않느냐?가 생각났다.😕 되지 않는 무시 @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http.csrf() .disable() .authorizeHttpRequests((auth) -&amp;gt; auth .requestMatchers(&quot;/swagger-ui/**&quot;, &quot;/v3/**&quot;).permitAll() .requestMatchers(&quot;/api/users/signup&quot;, &quot;/api/users/verification&quot;).permitAll() .anyRequest().authenticated()) .requestCache().disable() .securityContext().disable() .sessionManagement().disable() .headers().frameOptions().disable() .and() .formLogin() .disable() .exceptionHandling().authenticationEntryPoint(new HttpStatusEntryPoint(HttpStatus.UNAUTHORIZED)) .exceptionHandling().authenticationEntryPoint(customAuthenticationEntryPoint) .and() .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class) .addFilterBefore(jsonFilter, FilterSecurityInterceptor.class);이런식으로 구성했었다.보면은 requestMatcher에서 스웨거에 대한 url은 모두 요청을 허용하도록 하였다. 즉, 내 의도는 jsonFilter를 거치지 않아서 response를 그대로 다음 Filter에 넘겨주길 바랬다.하지만..계속 필터를 탔다.왜 그럴까? 왜 그럴까? 계속 생각하다가 구글링 하면서 어느정도 해답을 알았다.👍 해결방법이 글을 보면서 어느정도 해소가 되었다.즉, 위의 코드에서 JsonFilter는 컴포넌트 스캔으로 스프링 컨택스트에서 관리하는데, 스프링 시큐리티에서 아는 Filter와 다른 Filter로 스프링 시큐리티에서 해당 필터를 무시하라고 해도 무시가 되지 않았던 것이다.그래서 addFilterBefore메서드가 호출될 때 그냥 호출되어버리는 것이다.이를 new연산자를 통해서 객체로 직접 넘기면 해결이 된다.... .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class) .addFilterBefore(new JsonFilter(), FilterSecurityInterceptor.class);이런식으로 하면 Spring 컨텍스트와 관계가 없는 객체가 되기 때문에 Spring Security가 해당 객체를 필터로 간주하고 필터체인에 추가하게 되는 것이다.그리고 혹시 몰라서 설정값을 바꿔줬다.@Beanpublic WebSecurityCustomizer webSecurityCustomizer() { return (web) -&amp;gt; web.ignoring().requestMatchers(&quot;/swagger-ui/**&quot;, &quot;/v3/**&quot;);}이런식으로 아예 시큐리티 필터체인을 거치지 않도록 설정하였다.✏️ 결론스프링에는 여러가지 필터가 있고, 설정을 어떻게 하느냐에 따라 동작방식이 달라진다.나의 문제는 어떻게보면 당연히 빈으로 관리하면 편할거라 생각하고 필터조차 @Component로 달아서 관리하도록 하였는데, 내 생각과는 다르게 동작이 되어서 문제가 발생했던 것 같다.그리고 필터에 대한 이해도도 좀 더 높아야겠다고 생각하였고, 직접 HttpServletResponse객체를 조작하면서 필터를 왜 사용하는가에 대해 알 수 있었다." }, { "title": "5월19일시점 개발하면서 고민한 것들 + 도커관련 이슈", "url": "/posts/2023-05-19-think01/", "categories": "Java, Spring", "tags": "Troubleshooting", "date": "2023-05-18 01:02:00 +0900", "snippet": "🤔 개요프로젝트를 진행하면서 정말로 고민할 것들이 많아졌다.지라의 티켓들인데 이걸보면 최근 고민이 진짜 많다.😂 1. 토큰 만료시의 처리내가 하고 있는 프로젝트는 refreshToken을 사용하지 않는다. AccessToken 하나만으로 고민을 해야하는데, 프로젝트 기간이 길어지면서 토큰 만료시간이 다 된 계정들이 몇 개 있었다.이에 맞게 후처리를 해줘야하는데..일단 토큰이 만료되면{ &quot;errors&quot;: { &quot;timestamp&quot;: &quot;2023-05-19T00:36:31.8402904&quot;, &quot;status&quot;: 401, &quot;error&quot;: &quot;UNAUTHORIZED&quot;, &quot;code&quot;: &quot;UNAUTHORIZED_USER&quot;, &quot;message&quot;: &quot;Unauthorized user. Please check your token.&quot; }}이런 JSON이 클라이언트에 반환된다. 문제가 있다.내가 옛날에 작성한 코드 https://kkminseok.github.io/posts/2023-03-11-SpringSecurityError/ 때문에 토큰에 문제가 생기면 무조건 401를 반환했는데, 토큰이 만료되었을때는 -1의 Status를 주고 싶었다.문제는 Filter에서 token검증을 하는데, 거기서 에러를 받고, 커스텀해서 -1의 상태를 가지는 ResponseEntity객체를 주기가 불가능했다.그래서 생각한건 Jwt관련 Controller를 하나 만들어서 거기서 서비스를 호출하고 에러를 @ControllerAdvice를 통해 전역으로 잡을까?토큰하나때문에 컨트롤러 만드는것도 고민해야할 문제이고, 제대로 되지 않는다.사실 이 부분은 계속해서 고민중이다.😂 2. 클라이언트에 데이터를 어떻게 줘야할까?나는 안드로이드 개발자와 협업하고 있다.안드로이드 개발자와 이야기를 하다가 문제가 생겼다.기존에는 데이터를 이런식으로 주고 있었다.{ &quot;questionBoardResponseList&quot;: [ { &quot;id&quot;: 18, &quot;slug&quot;: &quot;hi&quot;, &quot;content&quot;: &quot;hello&quot;, &quot;createdAt&quot;: &quot;2023-05-18T23:27:45.437317+09:00&quot;, &quot;updatedAt&quot;: ... } ...}근데 안드로이드 개발자는 결국 ‘questionBoardResponseList’를 key로 가지며 데이터를 파싱해야했고, ‘questionBoardResponseList’가 아닌 ‘questionBoardResponse’, ‘profileResponse’등 여러개들을 이름에 맞게 코드를 하나하나 다 작성해야했다.그래서 처음 나온 의견은 아예 객체이름을빼자였다.{ [ { &quot;id&quot;: 18, &quot;slug&quot;: &quot;hi&quot;, &quot;content&quot;: &quot;hello&quot;, &quot;createdAt&quot;: &quot;2023-05-18T23:27:45.437317+09:00&quot;, &quot;updatedAt&quot;: ... } ... ]}이런식으로.. 근데 문제는 딱 보이게도 배열은 배열로 받아야하고, 필드는 필드로 받아야한다. 그런 불편함이 생겨 우리 프로젝트에서는 객체 담아서 보내는게 맞다.고 결론이 내려졌다.하나의 객체에 담겨서 보내주면 안드로이드에서 알아서 파싱해서 해결할 수 있다고 하길래 데이터를 data라는 객체에 담아 보내기로 했다.{ &quot;data&quot;:{ &quot;questionBoardResponseList&quot;: [ { &quot;id&quot;: 18, &quot;slug&quot;: &quot;hi&quot;, &quot;content&quot;: &quot;hello&quot;, &quot;createdAt&quot;: &quot;2023-05-18T23:27:45.437317+09:00&quot;, &quot;updatedAt&quot;: ... } ... }}이렇게 담아 보냈지만, 결국 파싱이 제대로 되지 않아서 해결되지 않았고 기존 방식대로 ‘questionBoardResponseList’ 키값을 그대로 파싱하기로 하였다.근데 서버쪽에서 해결해줄 수 있는 더 좋은 방법이 있지 않을까? 고민하게 되었다. 안드로이드개발자와 협업하다보니 이런것을 고민하게 되었다.😂 3. DELETE Http Method는 꼭 데이터를 반환해야하나?프로젝트를 하다가 다른 백엔드 개발자분께서 짜신 코드를 봤다.간단하게 게시글을 좋아요, 좋아요 취소에 대한 API였다.@DeleteMapping(&quot;/{studioId}/scrap&quot;)public void deleteScrap( @PathVariable Long studioId, @AuthenticationPrincipal User user) { scrapService.deleteScrap(studioId, user);}근데 나는 다른 방식으로 짰다.@PostMapping(&quot;/{questionBoardArticleId}/unfavorite&quot;)public QuestionBoardResponse.SingleQuestionBoard unfavoriteQuestionBoardArticle( @AuthenticationPrincipal User user, @PathVariable Long questionBoardArticleId) { log.info(&quot;question board favorite input : {}&quot;, questionBoardArticleId); return QuestionBoardResponse.SingleQuestionBoard.builder().questionBoardResponse(questionBoardService.unfavoriteQuestionBoardArticle(user, questionBoardArticleId)).build();}둘 다 같은 기능(좋아요, 좋아요 취소)이지만 짠 방식이 다르다. 나는 @PostMapping을 사용하였다. 나는 객체를 반환한다.그래서 고민하게되었다. 나는 왜 @PostMapping을 사용했을까? @DeleteMapping이 맞나?내 생각은 객체가 삭제되는건 아니고, 객체의 상태를 변경시키는거라고 생각해서 @PostMapping을 달았고, 객체가 삭제되는게 아니기 때문에 객체를 반환했다.그리고 생각했다. 요즘 Web Client기술은 객체의 상태를 추적해서 이에 맞게 계속 페이지를 렌더해주는걸로 알고 있다.그래서 객체를 넘기면 반환된 객체의 상태가 계속 추적되어서 페이지뷰가 바뀐다.근데 안드로이드에서는 그런 추적장치가 있느냐고 물어봤을때 잘 모르는걸로 봐서는 굳이 객체를 넘기지 않아도 되겠지만.. 그래도 객체가 삭제되는건 아니기에 객체의 상태를 개발자도 추적하기 위해서 넘기는게 맞지 않을까 라는 고민을 했다.😂 4. Docker 이미지 관련 이슈기존 CI/CD는 도커를 이용해서 이미지를 받아오고, 이를 컨테이너에 올리는 작업을 했는데CI/CD과정속에서 계속 fail떴다.왜지?잘만되다가처음에는 port가 겹쳐서 뜨나했다. 근데 이미 blue-green으로 배포하고 있기에 포트가 겹칠일이 없었다.혹시 몰라서 인스턴스도 껐다켜보고 도커자체도 껐다가 켜보고 컨테이너도 다 내렸다가 올려보고 했다.그래도 해결되지 않았다.근데.. chatGPT선생님이 도커 용량이 꽉찼을 수도 있다하면서sudo docker system df이 명령어를 알려줬다.이 명령어는 도커 용량을 확인할 수 있는데TYPE TOTAL ACTIVE SIZE RECLAIMABLEImages 19 1 1.493GB 1.426GB (95%)Containers 1 1 32.77kB 0B (0%)Local Volumes 0 0 0B 0BBuild Cache 7 0 131.7MB 131.7MB지금은 어느정도 삭제한 상태지만 95%의 용량을 차지하고 있었고, 용량이 꽉차서 이미지를 받아오지 못하고, 그 과정속에서 CI/CD가 fail이 떠서 코드가 정상적으로 반영되지 않았던 것이다.sudo docker images이 명령어를 통해서 현재 저장된 도커 이미지들을 볼 수 있는데..REPOSITORY TAG IMAGE ID CREATED SIZEteambpm2023/dnd-bpm main 3e0c053b8888 About an hour ago 538MBteambpm2023/dnd-bpm &amp;lt;none&amp;gt; f4cf0812eeb0 2 hours ago 538MBteambpm2023/dnd-bpm &amp;lt;none&amp;gt; 7233b8ffa465 3 hours ago 538MBteambpm2023/dnd-bpm &amp;lt;none&amp;gt; 56e470449cf8 2 days ago 538MBteambpm2023/dnd-bpm &amp;lt;none&amp;gt; 333eccb86ff5 5 days ago 538MBteambpm2023/dnd-bpm &amp;lt;none&amp;gt; deda5288ced4 5 days ago 538MBteambpm2023/dnd-bpm &amp;lt;none&amp;gt; 1aa6ad95bcb0 10 days ago 538MBteambpm2023/dnd-bpm &amp;lt;none&amp;gt; 301b225bbd26 11 days ago 538MBteambpm2023/dnd-bpm &amp;lt;none&amp;gt; c65082157308 11 days ago 538MBteambpm2023/dnd-bpm &amp;lt;none&amp;gt; c189e6ca21c9 13 days ago 538MBteambpm2023/dnd-bpm &amp;lt;none&amp;gt; 8fadb576b375 2 weeks ago 538MBteambpm2023/dnd-bpm &amp;lt;none&amp;gt; 743ff80c1df1 2 weeks ago 537MBteambpm2023/dnd-bpm &amp;lt;none&amp;gt; a1e19a5e3094 2 weeks ago 537MBteambpm2023/dnd-bpm &amp;lt;none&amp;gt; 0dfd80b93183 3 weeks ago 537MBweb-green_nginx latest ba4e904a4efc 2 months ago 23.5MBweb-blue_nginx latest f56711d22b3e 2 months ago 23.5MBubuntu_nginx latest 65dcf19360e9 2 months ago 23.5MBteambpm2023/dnd-bpm &amp;lt;none&amp;gt; 186805a54fe0 2 months ago 537MBnginx 1.22.1-alpine 652309d09131 3 months ago 23.5MB정말 별의별게 많다.임시 방편으로sudo docker image rm 이미지명를 통해 이미지를 삭제해줄 수 있었다.이게 중요한게 아니고, 결국 매번 이를 체크해서 지워줄 수는 없는 노릇이니 CI/CD를 구축할때 기존 이미지를 지워주고 이미지를 받아야겠더라.이를 티켓을 끊어서 곧 해결하고 배포할 예정이다.추가이는 간단하게 해결할 수 있다.배포파일에다가#최근 받은 이미지를 삭제할 변수 설정LATEST_IMAGE=$(sudo docker images --format &quot;&quot; --quiet | head -n 1)#확인용 출력echo &quot;LATEST_IMAGE value is: $LATEST_IMAGE&quot;#이미지 삭제sudo docker image rm $LATEST_IMAGE이렇게 작성하면된다.주의할 점은 이미지가 이미 컨테이너로 띄워져있으면 삭제가 안 되기 때문에 컨테이너가 종료되고 나서 이미지를 삭제해야한다는 것이다." }, { "title": "2번 읽는 Modern Java In Action - Chapter05 스트림활용(2)", "url": "/posts/2023-04-25-Modern-Java-In-action/", "categories": "Java, Modern Java In Action", "tags": "Modern Java In Action", "date": "2023-04-25 01:02:00 +0900", "snippet": "🔅 개요저번 내용이 너무 길어질 것 같아서 따로 작성하게 되었다.🔅 리듀싱리듀싱 연산은 모든 스트림 요소를 처리해서 값으로 도출하는 것이라고 한다.예시를 보는게 빠른 것 같다.다음은 모든 요소에 대해 값을 더해서 그 결과를 반환하는 테스트이다.@Test@DisplayName(&quot;reduce 튜토리얼&quot;)void testReduce(){ List&amp;lt;Integer&amp;gt; numbers = Arrays.asList(1,2,3,4,5); Integer sum = numbers.stream().reduce(0, (a, b) -&amp;gt; a + b); //간단버전 //Integer sum = numbers.stream().reduce(0,Integer::sum); //1 + 2 + 3 + 4 + 5 System.out.println(sum);}이처럼 reduce는 2 가지 인수를 가진다. 초기값 두 요소를 조합해서 새로운 값을 만드는 BinaryOperator&amp;lt;T&amp;gt; 이다.reduce에는 초기값 없는 경우도 오버로드 되어있다.//초기값 없는 경우Optional&amp;lt;Integer&amp;gt; result = numbers.stream().reduce(Integer::sum);//Optional[15]System.out.println(result);스트림에 아무 요소가 없는 경우가 있을 수 있으므로 Optional을 반환하게 된다.최댓값 최솟값reduce를 사용하면 최댓값, 최솟값을 찾을 수 있다.인자로는 위에서 말한 두 요소를 조합해서 새로운 값을 만드는 BinaryOperator&amp;lt;T&amp;gt;형태의 값을 넣으면 된다.@Test@DisplayName(&quot;reduce max min&quot;)void testReduceMaxMin(){ Optional&amp;lt;Integer&amp;gt; max = numbers.stream().reduce(Integer::max); Assertions.assertEquals(max.get(), 5); Optional&amp;lt;Integer&amp;gt; min = numbers.stream().reduce(Integer::min); Assertions.assertEquals(min.get(), 1); Optional&amp;lt;Integer&amp;gt; min2 = numbers.stream().reduce((x, y) -&amp;gt; x &amp;lt; y ? x : y); Assertions.assertEquals(min2.get(), 1);}이런식으로 넘기면 된다.🔅 숫자형 스트림int calories = menu.stream() .map(Dish::getCalories) .reduce(0,Integer::sum);이런 코드가 있는데, 위에는 박싱 비용이 숨겨져 있다. 내부적으로 합계를 계산하기 전에 Integer를 기본형(int)으로 언박싱해야 한다.그리고, reduce연산 말고 sum()하나로 합계를 구할 수 있다면 더 편할 것 같다.int calories = menu.stream() .map(Dish::getCalories) .sum()하지만 이는 불가능하다. map()의 반환형이 Stream&amp;lt;T&amp;gt;이기 때문에 해당 인터페이스가 sum을 가질 수 없기 때문이다.이는 비효율적인데, 스트림 API 숫자 스트림을 효율적으로 처리할 수 있도록 기본형 특화 스트림을 제공한다.기본형 특화 스트림자바8에서는 스트림 API는 박싱 비용을 피할 수 있도록 IntStream, DoubleStream, LongStream을 제공한다.위의 스트림들은 각각 숫자 스트림의 합계를 계산하는 sum, 최댓값을 구하는 max와 같은 연산 수행 메서드도 제공한다.@Test@DisplayName(&quot;숫자 스트림 매핑&quot;)void testMapToInt(){ int calories = menu.stream() // Stream&amp;lt;Dish&amp;gt; .mapToInt(Dish::getCalories) // IntStream으로 반환 .sum(); System.out.println(calories);}위의 mapToInt는 IntStream을 반환한다. 이 인터페이스가 제공하는 sum을 통하여 합계를 계산할 수 있게 되었다.참고로 스트림이 비어있다면 sum은 기본값 0을 반환한다. 외에도 max, min, average 등 다양한 유틸리티 메서드도 지원한다.객체 스트림으로 복원IntStream을 그냥 Stream을 바꿀 수 있을까에 대한 내용이다.간단하게 boxed라는 메서드를 사용하면 된다.@Test@DisplayName(&quot;boxed 메서드&quot;)void testBoxed(){ IntStream intStream = menu.stream() .mapToInt(Dish::getCalories); Stream&amp;lt;Integer&amp;gt; boxed = intStream.boxed();}기본값들기본형 특화 스트림은 max메서드도 제공하는데, 스트림이 비어있는 경우 이를 어떻게 판단할까?IntStream기준으로 이를 담기 위한 OptionalInt라는 자료형을 제공한다.@Test@DisplayName(&quot;OptionalInt&quot;)void testOptionalInt(){ OptionalInt maxCalories = menu.stream() .mapToInt(Dish::getCalories) .max(); System.out.println(maxCalories.orElse(1));}OptionalInt자료형을 통해 최댓값이 없는 상황에 사용할 기본값을 명시적으로 정의가 가능하다. 사실 왜 Optional을 사용하지 않았을까 생각하였는데, 가독성면에서 좀 더 특화된 OptionalInt를 사용하는게 낫겠다 생각하였다.숫자 범위특정 범위의 숫자를 이용해야 하는 상황이 있는데, 이를 지원한다.range와 rangeClosed라는 두 가지 정적 메서드가 있는데, 첫 번째 인수로는 시작값을 두 번째 인수로는 종료값을 갖는다.range는 시작값과 종료값이 결과에 포함되지 않고, rangeClosed는 포함된다.@Test@DisplayName(&quot;숫자범위&quot;)void testRange() { IntStream evenNumbers = IntStream.rangeClosed(1, 100) .filter(n -&amp;gt; n % 2 == 0); IntStream evenNumbers2 = IntStream.range(1, 100) .filter(n -&amp;gt; n % 2 == 0); Assertions.assertEquals(evenNumbers.count(), 50); Assertions.assertEquals(evenNumbers2.count(), 49);}🔅 스트림 만들기다양한 방식으로 스트림을 만들 수 있다고 한다.//값으로 스트림 만들기@Test@DisplayName(&quot;값으로 스트림 만들기&quot;)void testStreamByValue(){ Stream&amp;lt;String&amp;gt; stream = Stream.of(&quot;Modern&quot;, &quot;Java&quot;, &quot;In&quot;, &quot;Action&quot;); stream.map(String::toUpperCase) .forEach(System.out::println);}//널값을 가지는 스트림 만들기Stream&amp;lt;String&amp;gt; homeValueStream = Stream.ofNullable(System.getProperty(&quot;home&quot;));자고로 System.getProperty()는 key값으로 들어온 인자에 해당하는 값이 없으면 null을 반환한다. 이를 넣을 수 있다. Java 9부터다.//배열로 스트림 만들기@Test@DisplayName(&quot;배열로 스트림 만들기&quot;)void testArrayStream(){ int[] numbers = {2,3,5,7,11,13}; int sum = Arrays.stream(numbers).sum(); System.out.println(&quot;sum : &quot; + sum);}//무한스트림 만들기 iterate활용@Test@DisplayName(&quot;무한 스트림&quot;)void testInfiniteStream(){ //iterate활용 Stream.iterate(0, n -&amp;gt; n +2) .limit(10) .forEach(System.out::println); //0 2 4 6 8 10 ...18}iterate()메서드는 첫 번째 인자로는 초기값을 가지고, 두 번째 인자로는 람다(UnaryOperator&amp;lt;T&amp;gt;)를 가져 새로운 값을 끊임없이 생산한다고 한다. 이러한 스트림을 무한 스트림이라하며 동일하게 언바운드 스트림이라고 한다.보통 연속된 일련 값을 만들때는 iterate()를 사용한다고 한다.//무한 스트림 만들기 generate 활용@Test@DisplayName(&quot;generate활용&quot;)void testGenerateStream(){ //generate활용 Stream.generate(Math::random) .limit(5) .forEach(System.out::println);}generate()는 앞에서 설명한 iterate()와 다르게 계산을 하지 않는다.이 두 메서드의 차이점은 책예제로는 피보나치를 구현하면 알 수 있다고 한다.//iterate로 피보나치 구현Stream.iterate(new int[]{0,1},t -&amp;gt; new int[]{t[1], t[0] + t[1]} ) .limit(20) .forEach(t -&amp;gt; System.out.println(&quot;(&quot; + t[0] + &quot;,&quot; + t[1] + &quot;)&quot;));//generate로 구현IntSupplier fib = new IntSupplier() { private int previous = 0; private int current = 1; @Override public int getAsInt() { int oldPrevious = this.previous; int nextValue = this.previous + this.current; this.previous = this.current; this.current = nextValue; return oldPrevious; }};IntStream.generate(fib) .limit(10) .forEach(System.out::println);generate의 인자는 상태를 가질 수 있다.위 코드를 보면 IntSupplier의 상태를 갱신하고 있다. 즉, getAsInt()를 호출하면서 자신의 상태를 바꾸며 값을 생산하고 있다. 반면 iterate는 값은 새로 생성하지만 기존 상태를 바꾸지 않으려는 불변 상태를 유지하려고 한다.근데 병렬처리에 있어서는 불변함을 고수해야한다는 것을 강조하는데, generate는 getAsInt()를 람다로 표현하지 않으면 개발자가 커스텀하여, 불변함을 유지할 수 없다. 때문에 사용하는데 주의가 더 필요한 것은 사실인 것 같다." }, { "title": "2번 읽는 Modern Java In Action - Chapter05 스트림활용(1)", "url": "/posts/2023-04-17-Modern-Java-In-action/", "categories": "Java, Modern Java In Action", "tags": "Modern Java In Action", "date": "2023-04-17 01:02:00 +0900", "snippet": "🔅 개요스트림 API가 지원하는 다양한 연산들을 다뤄본다고 한다.참고로 여기서 나오는 menu리스트들은@BeforeEachvoid init() { menu = Arrays.asList( new Dish(&quot;chicken&quot;, false, 200, Dish.Type.MEAT), new Dish(&quot;pork Chop&quot;, false, 400, Dish.Type.FISH), new Dish(&quot;pork Loin&quot;, false, 230, Dish.Type.FISH), new Dish(&quot;salad&quot;, true, 199, Dish.Type.OTHER) );}이렇게 구현되어있다.🔅 필터링 filter메서드는 프레디케이트를 인수로 받아서 해당 프레디케이트와 일치하는 모든 요소를 포함하는 스트림을 반환한다.@Test@DisplayName(&quot;프리디게이트로 필터링&quot;)void testPredicateFilter(){ List&amp;lt;Dish&amp;gt; vegetarianMenu = menu.stream() .filter(Dish::isVegetarian) .collect(Collectors.toList()); //salad vegetarianMenu.stream().forEach(System.out::println);} distinct()를 통한 중복제거도 가능하다.@Test@DisplayName(&quot;프리디게이트로 필터링 - 중복제거&quot;)void testPredicateDistinctFilter() { List&amp;lt;Integer&amp;gt; numbers = Arrays.asList(1, 2, 1, 3, 3, 2, 4); //중복제거 //2, 4 numbers.stream() .filter(i -&amp;gt; i % 2 == 0) .distinct() .collect(Collectors.toList()) .forEach(System.out::println);}🔅 스트림 슬라이싱만약 칼로리순으로 정렬된 경우이고, 320칼로리 이하의 요리를 선택해야한다면 어떻게 할 수 있을까List&amp;lt;Dish&amp;gt; sortedMenu = Arrays.asList( new Dish(&quot;fruit&quot;, true, 120, Dish.Type.OTHER), new Dish(&quot;prwans&quot;, false, 300, Dish.Type.FISH), new Dish(&quot;rice&quot;, false, 350, Dish.Type.OTHER), new Dish(&quot;chicken&quot;, false, 400, Dish.Type.MEAT), new Dish(&quot;french fries&quot;, true, 530, Dish.Type.OTHER) );sortedMenu.stream() .filter(dish -&amp;gt; dish.getCalories() &amp;lt; 320) .collect(Collectors.toList());이런식으로 할 수 있지만, 정렬이 되었음에도 불구하고 4번째인 400칼로리도 filter가 적용될 것이고 5번째인 800칼로리도 마찬가지로 돌것이다. 그렇게 무의미하게 필터가 계속 작용될 것이다.Java9버전에서는 taskWhile()를 통해 정렬된 값에 대한 필터를 적용하여 범위를 벗어난값이 나타나면 연산을 종료시킬 수 있다.List&amp;lt;Dish&amp;gt; result = sortedMenu.stream() .takeWhile(dish -&amp;gt; dish.getCalories() &amp;lt; 320) .collect(Collectors.toList());//fruit, prawnsresult.stream().forEach(System.out::println);이런식으로 해결할 수 있다.반대로 320칼로 이상의 요소를 선택하려면 어떻게 해야할까?List&amp;lt;Dish&amp;gt; result = sortedMenu.stream() .dropWhile(dish -&amp;gt; dish.getCalories() &amp;lt; 320) .collect(Collectors.toList());//rice, chicken, french friesresult.stream().forEach(System.out::println);dropWhile은 프레디케이트가 처음으로 거짓이 되는 지점까지 발견된 요소를 버린다. 그리고 거짓이 되면 그 지점에서 작업을 중단하고 남은 모든 요소를 반환한다.limit(n)를 이용해 스트림 최대 요소 n개를 반환할 수 있다.@Test@DisplayName(&quot;limit를 이용한 테스트&quot;)void testLimit(){ List&amp;lt;Dish&amp;gt; sortedMenu = Arrays.asList( new Dish(&quot;fruit&quot;, true, 120, Dish.Type.OTHER), new Dish(&quot;prwans&quot;, false, 500, Dish.Type.FISH), new Dish(&quot;rice&quot;, false, 350, Dish.Type.OTHER), new Dish(&quot;chicken&quot;, false, 400, Dish.Type.MEAT), new Dish(&quot;french fries&quot;, true, 530, Dish.Type.OTHER) ); List&amp;lt;Dish&amp;gt; dishes = sortedMenu.stream() .filter(dish -&amp;gt; dish.getCalories() &amp;gt; 300) .limit(3) .collect(Collectors.toList()); // prwans // rice // chicken dishes.stream().forEach(System.out::println);}skip(n)을 통하여 스트림 요소 n개를 건너 뛸 수 있다.@BeforeEachvoid init() { menu = Arrays.asList( new Dish(&quot;chicken&quot;, false, 200, Dish.Type.MEAT), new Dish(&quot;pork Chop&quot;, false, 400, Dish.Type.FISH), new Dish(&quot;pork Loin&quot;, false, 230, Dish.Type.FISH), new Dish(&quot;salad&quot;, true, 199, Dish.Type.OTHER) );}@Test@DisplayName(&quot;skip을 이용한 테스트&quot;)void testSkip(){ List&amp;lt;Dish&amp;gt; dishes = menu.stream() .filter(d -&amp;gt; d.getCalories() &amp;lt; 300) .skip(2) .collect(Collectors.toList()); //salad dishes.stream().forEach(System.out::println);}🔅 매핑특정객체의 특정 데이터를 선택하는 작업이 필요할 때도 있을 것이다. 이는 map과 flatMap메서드가 제공한다.@Test@DisplayName(&quot;map 테스트&quot;)void testMap(){ List&amp;lt;String&amp;gt; dishNames = menu.stream() .map(Dish::getName) .collect(Collectors.toList()); // chicken // pork Chop // pork Loin // salad dishNames.stream().forEach(System.out::println);}Dish::getName은 문자열을 반환하므로 map 메서드의 출력 스트림은 **Stream** 형식을 갖는다.만약 각 요리명의 길이를 알고 싶으면 어떻게 할까? map을 중첩해서 사용하면 된다.@Test@DisplayName(&quot;map 중첩 테스트&quot;)void testMapDuplicate(){ List&amp;lt;Integer&amp;gt; dishNameLengths = menu.stream() .map(Dish::getName) .map(String::length) .collect(Collectors.toList()); //7 9 9 5 dishNameLengths.stream().forEach(System.out::println);}🔅 스트림 평면화책에서 flatMap은 배열을 스트림이 아니라 스트림의 콘텐츠로 매핑한다는데, 이해가 잘 되지 않는다.만약 [“Hello”, “World”]를 [“H”,”e”,”l”,”l”,”o”,”W”,”o”,”r”,”l”,”d”]로 쪼개고 싶다고 하자.그러면List&amp;lt;String&amp;gt; words = Arrays.asList(&quot;Hello&quot;, &quot;World&quot;); //평면화 전List&amp;lt;String[]&amp;gt; mapResult = words.stream() .map(word -&amp;gt; word.split(&quot;&quot;)) .collect(Collectors.toList());결과는 [[“H”,”e”,”l”,”l”,”o”],[“W”,”o”,”r”,”l”,”d”]] 로 나올 것이다.우리가 원하는 건 2개의 배열에 결과를 담는게 아니다.flatMap은 이러한 작업을 도와주는데, 스트림을 1차원 평면화 시킨다고 보면된다.@Test@DisplayName(&quot;스트림 평면화&quot;)void testMapDistinct(){List&amp;lt;String&amp;gt; words = Arrays.asList(&quot;Hello&quot;, &quot;World&quot;);List&amp;lt;String&amp;gt; result = words.stream() .map(word -&amp;gt; word.split(&quot;&quot;)) .flatMap(Arrays::stream) // 배열을 스트림으로 변환 .collect(Collectors.toList());result.stream().forEach(System.out::println);}🔅 검색과 매칭검색하는데 용이한 메서드들을 제공한다는 것이다.anyMatch프레디케이트가 주어진 스트림에서 적어도 한 요소와 일치하는지 확인할 때 사용한다.@Test@DisplayName(&quot;anyMatch 테스트&quot;)void testAnyMatch(){ if(menu.stream().anyMatch(Dish::isVegetarian)){ System.out.println(&quot;is vegetarian&quot;); }}allMatch스트림의 모든 요소가 주어진 프레디케이트와 일치하는지를 검사한다.@Test@DisplayName(&quot;allMatch 테스트&quot;)void testAllMatch(){ if(menu.stream().allMatch(dish -&amp;gt; dish.getCalories() &amp;lt; 1000)){ System.out.println(&quot;모든 음식의 칼로리가 1000보다 적습니다.&quot;); }}noneMatch스트림의 모든 요소가 주어진 프레디케이트와 일치하지 않는지를 검사한다.@Test@DisplayName(&quot;noneMatch 테스트&quot;)void testNoneMatch(){ if(menu.stream().noneMatch(dish -&amp;gt; dish.getCalories() &amp;gt; 1000)){ System.out.println(&quot;모든 음식의 칼로리가 1000을 초과하지 않습니다.&quot;); }}findAny스트림에서 임의의 요소를 반환한다. 예제에서는 자료구조의 양이 적어서 매 번 임의의 값이 나오지는 않는다.@Test@DisplayName(&quot;findAny 테스트&quot;)void testFindAny(){ Optional&amp;lt;Dish&amp;gt; dish = menu.stream() .filter(Dish::isVegetarian) .findAny(); //Optional[salad] System.out.println(dish);} Optional에 관한 내용은 10챕터에 자세히 나온다니, 생략하도록 하겠다. 간단히 null을 처리하기 위해 등장한 클래스다.findFirst스트림에서 첫 번째 요소를 찾기위해 사용한다.@Test@DisplayName(&quot;findFirst 테스트&quot;)void testFindFirst(){ List&amp;lt;Integer&amp;gt; numbers = Arrays.asList(1,2,3,4,5); numbers.stream() .map(n -&amp;gt; n * n) .filter(n -&amp;gt; n % 3 == 0) .findFirst() //9출력 .ifPresent(i -&amp;gt; System.out.println(i));} 병렬 실행에서는 첫 번째 요소를 반환하는 findFirst를 제대로 이용하기 어렵다. 때문에 findAny를 사용하는게 좋다.내용이 길어서 2개로 나눠서 작성하게 되었다." }, { "title": "2번 읽는 Modern Java In Action - Chapter04 스트림", "url": "/posts/2023-04-13-Modern-Java-In-action/", "categories": "Java, Modern Java In Action", "tags": "Modern Java In Action", "date": "2023-04-14 00:02:00 +0900", "snippet": "🔅 스트림기존 자바7코드에서는 저칼로리의 요리명을 반환하고, 칼로리를 기준으로 요리를 정렬하려면 어떤식으로 코드를 작성했는가//Dish.javapublic class Dish { private String name; private int calories; public Dish(String name, int calories){ this.name = name; this.calories = calories; } public String getName() { return name; } public int getCalories() { return calories; }}//Test Code@Testvoid 스트림이전(){ List&amp;lt;Dish&amp;gt; menu = Arrays.asList( new Dish(&quot;chicken&quot;,200), new Dish(&quot;pork Chop&quot;,400), new Dish(&quot;pork Loin&quot;,230), new Dish(&quot;salad&quot;, 199) ); //1. 저칼로리를 뽑아냄 List&amp;lt;Dish&amp;gt; lowCaloricDishes = new ArrayList&amp;lt;&amp;gt;(); for(Dish dish: menu){ if(dish.getCalories() &amp;lt; 250){ lowCaloricDishes.add(dish); } } Assertions.assertEquals(lowCaloricDishes.size(), 3); //2. 정렬(익명클래스 사용) Collections.sort(lowCaloricDishes, new Comparator&amp;lt;Dish&amp;gt;() { @Override public int compare(Dish o1, Dish o2) { return Integer.compare(o1.getCalories(), o2.getCalories()); } }); //3. 이름으로 리스트에 넣음. List&amp;lt;String&amp;gt; lowCaloricDishesName = new ArrayList&amp;lt;&amp;gt;(); for(Dish dish: lowCaloricDishes){ lowCaloricDishesName.add(dish.getName()); } lowCaloricDishesName.forEach(food-&amp;gt; System.out.println(food));}lowCaloricDishes라는 사실상 결과값에 포함되지 않는 가비지 변수를 사용했다.자바8에서 제공하는 코드를 사용하면 위와같은 중간변수하는 것들은 전부 라이브러리내에서 처리하게 된다.//java8 코드@Testvoid 스트림사용(){ List&amp;lt;Dish&amp;gt; menu = Arrays.asList( new Dish(&quot;chicken&quot;,200), new Dish(&quot;pork Chop&quot;,400), new Dish(&quot;pork Loin&quot;,230), new Dish(&quot;salad&quot;, 199) ); List&amp;lt;String&amp;gt; lowCaloricDishesName = menu.stream() .filter(d -&amp;gt; d.getCalories() &amp;lt; 250) .sorted(Comparator.comparing(Dish::getCalories)) .map(Dish::getName) .collect(Collectors.toList()); //병렬로 실행 List&amp;lt;String&amp;gt; ParallelLowCaloricDishesName = menu.parallelStream() .filter(d -&amp;gt; d.getCalories() &amp;lt; 250) .sorted(Comparator.comparing(Dish::getCalories)) .map(Dish::getName) .collect(Collectors.toList()); lowCaloricDishesName.forEach(food-&amp;gt; System.out.println(food)); ParallelLowCaloricDishesName.forEach(food-&amp;gt; System.out.println(food));}코드 수를 줄여 가독성을 높이고, 불필요한 변수를 선언할 필요가 사라졌다.병렬처리에 대해서는 7장에서 배운다고 하니 넘어가도록 하겠다.이점 선언형 코드로 구현이 가능하다. if문을 사용하여 어떻게 동작을 구현할지 고민을 할 필요 없이 정해진 연산들을 호출하여 ‘저칼로리의 요리만 선택하라’ 라는 동작의 수행을 지정할 수 있다. filter, sorted, map .. 같은 여러 연산들을 연결하여 파이프라인으로 만들어서 처리가 가능한데, 이를 통해 가독성과 명확성이 유지된다. 병렬화를 통해 대규모 데이터처리에 능하게 대처가 가능하다.정의스트림이란 데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소라고 책에서 정의하고 있다. 연속된 요소: 기존 컬렉션과 마찬가지로 특정 요소 형식으로 이루어진 연속된 값의 집합이라고 한다. 컬렉션의 초점은 자료구조(LinkedList, ArrayList을 사용할 것인지)에 초점이 맞춰져있고, 스트림은 filter, sorted처럼 계산에 초점이 맞춰져있다. 소스: 컬렉션, 배열, I/O자원 등의 데이터 제공 소스로부터 데이터를 소비한다. 데이터 처리 연산: 앞에서 말한 filter, map, reduce같이 데이터를 조작할 수 있게 도와주는 연산들을 말한다. 이는 순차적, 병렬적으로 실행이 가능하다. 특징 파이프라이닝: 스트림 연산끼리 연결해서 파이프라인을 구성할 수 있다. 이 덕분에 게으름, 쇼트서킷같은 최적화를 얻을 수 있다. 내부 반복: 반복자를 명시하는 컬렉션과 달리 스트림은 내부 반복을 지원한다. @Testvoid stream_tutorial_test(){ List&amp;lt;String&amp;gt; threeHighCaloricDishNames = menu.stream() // 스트림 얻기 .filter(dish -&amp;gt; dish.getCalories() &amp;gt; 250) // 고칼로리 요리 필터링 .map(Dish::getName) // 요리명 추출 .limit(3) // 선착순 세 개만 선택 .collect(Collectors.toList()); // 결과를 다른 리스트로 저장 threeHighCaloricDishNames.forEach(dishName -&amp;gt; System.out.println(dishName));} 데이터 소스: 요리(리스트) 코드상에서는 menu가 되겠다. 연속된 요소를 스트림에 제공하고 있다. 데이터 처리 연산: filter, map, limit, collect이다. collect를 제외한 모든 연산은 서로 파이프 라인을 제공하고 있다.🔅 스트림과 컬렉션 차이책에서는 DVD에 대한 예시를 들고 있다. DVD에 어떤 영화가 저장되어 있다. DVD안에는 바이트나 프레임으로 이루어진 어떠한 요소들이 있을 것이다. 즉, DVD에 전체 자료구조가 저장되어 있으므로 컬렉션이다.DVD와 달리 인터넷 스트리밍의 경우 사용자가 시청하는 부분의 몇 프레임을 미리 내려받고, 이를 재생한다.DVD를 실행했을때는 사용자가 이를 다운받을 수 있는 충분한 메모리가 없을 수도 있고, 모든 요소를 다운로드 받은 후에 재생할 수 있다는 단점이 있다. 하지만 스트리밍 서비스는 그런게 없다.즉, 컬렉션과 스트림의 차이는 데이터를 언제계산하느냐에 따라 다르다. 컬렉션은 자료구조가 포함하는 모든 값을 메모리에 저장하는 자료구조다. 그러므로 컬렉션은 모든 요소들이 컬렉션에 추가되고나서 계산되어야 한다.반면 스트림은 이론적으로는 요청할 때만 요소를 계산하는 자료구조이다. 때문에 스트림의 예제로 유명한 무제한 소수가 만들어질 수 있다는 것이다.그리고, 스트림은 한 번만 탐색할 수 있다. 즉, 한 번 탐색된 스트림의 요소는 소비된다.@Testvoid 일회성스트림테스트(){ List&amp;lt;String&amp;gt; title = Arrays.asList(&quot;Java8&quot;, &quot;In&quot;, &quot;Action&quot;); Stream&amp;lt;String&amp;gt; s = title.stream(); s.forEach(System.out::println); s.forEach(System.out::println); // error}--결과Java8InActionstream has already been operated upon or closedjava.lang.IllegalStateException: stream has already been operated upon or closed at java.util.stream.AbstractPipeline.sourceStageSpliterator(AbstractPipeline.java:279) at java.util.stream.ReferencePipeline$Head.forEach(ReferencePipeline.java:647) at com.example.modernjavainaction.Chapter04.StreamTest.일회성스트림테스트(StreamTest.java:91) ...이렇듯 스트림은 단 한 번만 소비할 수 있다는 것이다.스트림과 컬렉션의 또 다른 차이는 반복의 차이가 있다.컬렉션 인터페이스는 사용자가 직접 요소를 반복 해야하는데(for-each구문 등) 이를 외부 반복이라고 한다.스트림 라이브러리는 반복을 알아서 처리하고 결과 스트림값을 어딘가에 저장해주는 내부 반복을 사용한다.@Testvoid 스트림과컬렉션_반복차이(){ //컬렉션 for-each List&amp;lt;String&amp;gt; names = new ArrayList&amp;lt;&amp;gt;(); for(Dish dish: menu){ names.add(dish.getName()); } names.stream().forEach(System.out::println); //컬렉션 내부적으로 숨겨졌던 반복자를 사용한 외부 반복 List&amp;lt;String&amp;gt; namesIter = new ArrayList&amp;lt;&amp;gt;(); Iterator&amp;lt;Dish&amp;gt; iterator = menu.iterator(); while(iterator.hasNext()){ Dish dish = iterator.next(); namesIter.add(dish.getName()); } System.out.println(&quot;-------컬렉션 iterator 반복-------&quot;); namesIter.stream().forEach(System.out::println); //스트림 내부 반복 List&amp;lt;String&amp;gt; namesStream = menu.stream() .map(Dish::getName) .collect(Collectors.toList()); System.out.println(&quot;-------스트림 내부 반복-------&quot;); namesStream.stream().forEach(System.out::println);}내부반복 즉, 스트림을 사용하면 여러 조건이 붙을경우 순서를 적절히 제어하여 최적화하기가 더 쉬워진다. 또한 병렬적으로 수행이 가능하도록 만들 수 있고 어느정도 스트림에서 병렬성 관리를 해준다. 외부 반복을 사용하면 병렬성을 스스로 관리해야하는데, 이는 동시성문제를 synchronized와 같은 관리를 통해 개발자 스스로 제어해야한다는 뜻이다.🔅 스트림 연산 특징스트림 연산은 크게 두 그룹으로 나눌 수 있다. 중간 연산 최종 연산중간 연산중간 연산은 filter,map등 과 과 같이 스트림을 연결할 수 있는 연산들을 말한다.중간 연산의 중요한 특징은 스트림 파이프라인에 실행하기 전까지 아무 연산도 수행하지 않는다고 한다.(lazy)이를 추적하기 위한 코드는 다음과 같다.@Testvoid 중간연산(){ List&amp;lt;String&amp;gt; names = menu.stream() .filter(dish -&amp;gt; { System.out.println(&quot;filtering &quot; + dish.getName()); return dish.getCalories() &amp;gt; 100; }) .map(dish -&amp;gt; { System.out.println(&quot;mapping &quot; + dish.getName()); return dish.getName(); }) .limit(3) .collect(Collectors.toList());; System.out.println(names);}// 결과filtering chickenmapping chickenfiltering pork Chopmapping pork Chopfiltering pork Loinmapping pork Loin[chicken, pork Chop, pork Loin]스트림의 lazy한 특성 덕에 몇 가지 최적화 효과를 얻었다.사실상 menu에 있는 4가지 요소 전부 칼로리가 100을 넘지만, 처음 3개만 선택되었다.이는 limit연산 그리고 쇼트서킷이라고 불리는 기법 덕이다.그리고, filter와 map은 다른 연산이지만 한 과정으로 병합 되었는데, 이를 루프 퓨전이라고 한다.최종 연산최종 연산은 스트림 파이프라인에서 결과를 도출한다. 보통 이 연산을 통해 List, Integer, void 등과 같은 스트림 이외의 결과가 반환된다.🔅 정리 스트림은 소스에서 추출된 연속 요소이고, 데이터 처리 연산을 지원한다. 스트림은 내부 반복을 지원한다. 스트림은 중간 연산과 최종 연산으로 나눌 수 있다. 스트림 요소는 게으르게(lazy)하게 계산된다." }, { "title": "2번 읽는 Modern Java In Action - Chapter03 람다 표현식", "url": "/posts/2023-04-05-Modern-Java-In-action/", "categories": "Java, Modern Java In Action", "tags": "Modern Java In Action", "date": "2023-04-06 00:02:00 +0900", "snippet": "3장은 람다에 대한 내용이다.전에 동작 파라미터화를 통해 재사용성을 늘릴 수 있었고, 익명 클래스를 통해 로직을 더 줄일 수 있었다.하지만 코드 자체가 깔끔하지 않았고, 이를 해결하기 위한 자바8에서 새로나온 람다에 대해서 학습한다.🔅 람다의 특징 익명: 보통의 메서드와 달리 이름이 없어서 익명의 특성을 가진다. 함수: 특정 클래스에 종속되지 않아서 함수라고 한다. 전달: 람다 표현식을 메서드 인수로 전달하거나 변수로 저장이 가능하다. 간결성: 익명클래스처럼 너무 많은 코드를 작성하지 않아도 된다.자바의 기본 문법은 다음과 같다.(parameters) -&amp;gt; expression(parameters) -&amp;gt; { statements; }람다는 함수형 인터페이스를 통해 인자를 넘길 수 있다. 함수형 인터페이스는 단 하나의 추상 메서드를 가지는 인터페이스인데, 람다의 표현식으로 함수형 인터페이스의 추상 메서드 구현을 직접 전달할 수 있어서 전체 표현식을 함수형 인터페이스의 인스턴스로 취급이 가능하다고 한다.밑에는 람다와 익명 클래스, 람다표현식을 함수 파라미터에 전달해서 표현하는 코드이다.@Testvoid 람다_튜토리얼(){ //람다 Runnable r1 = () -&amp;gt; System.out.println(&quot;람다 튜토리얼&quot;); //익명 클래스 Runnable r2 = new Runnable() { @Override public void run() { System.out.println(&quot;익명 클래스&quot;); } }; process(r1); process(r2); process(() -&amp;gt; System.out.println(&quot;람다 표현식 전달.&quot;));}private void process(Runnable r){ r.run();}🔅 함수 디스크립터람다의 표현식은 파라미터와 리턴을 가질 수 있는데, 리턴을 가질 수도 있고 안 가질수도 있고 조합에 따라 다양한 람다 표현식들이 생겨날 것이다.다양한 람다 표현식을 구별하기 위해서는 시그니처가 필요한데, 람다 표현식의 시그니처를 서술하는 메서드를 함수 디스크립터라고 부른다.예를 들어 Runnable 인터페이스의 유일한 추상 메서드 run메서드는 인수와 반환값이 void로 없으므로 Runnable인터페이스는 인수와 반환값이 없는 시그니처로 말할 수 있다.이러한 시그니처에 따라 자바에서 제공하는 여러 함수형 인터페이스들이 있는데, 이에 대한 설명은 여기에 정리해놨기에 시간 여건상 중복 내용은 따로 추가로 적지 않도록 하겠습니다.위에서 제공하는 함수형 인터페이스들은 제네릭 파라미터를 사용하기에 참조형만 사용할 수 있다.참조형을 기본형으로 변환하는것을 언박싱 하는데, 이를 자동으로 이루어지게 오토박싱기능도 제공하므로 프로그래머는 편리하게 코드를 작성할 수 있다.근데 오토박싱 기능을 사용하면 변환과정에서 비용을 소모하게 되는데, 자바8에서 제공하는 함수형 인터페이스를 통해 오토박싱 동작을 피할 수 있도록 한다.@Testvoid 오토박싱_x(){ IntPredicate evenNumbers = (int i) -&amp;gt; i % 2 == 0; //박싱 x Assertions.assertEquals(evenNumbers.test(1000), true); Predicate&amp;lt;Integer&amp;gt; oddNumbers = (Integer i) -&amp;gt; i%2 != 0; //박싱 o Assertions.assertEquals(oddNumbers.test(1000), false);}@FunctionalInterfaceinterface IntPredicate{ boolean test(int t);}사실 특별한건 없고 함수형 인터페이스의 인자를 제너릭 파라미터가 아닌, 기본형으로 받도록 바꿨을 뿐이다. 이를통해 int형이 들어오면 박싱하지 않도록 할 뿐이다.보통 특별한 인자를 받는 경우 함수형 인터페이스 앞에 DoublePredicate 와 같이 자료형을 앞에 붙인다.이외에도 여러 함수형인터페이스를 커스텀해서 만들 수 있다.🔅 형식 검사, 형식 추론, 제약람다가 어떤 방식으로 실행되는지, 어떻게 컴파일러는 이를 인식하는지 알 필요가 있다.책에서는List&amp;lt;Apple&amp;gt; apples = filter(inventory, (Apple apple) -&amp;gt; apple.getWeight() &amp;gt; 150);이라는 코드를 가지고 설명하고 있으므로, 내 생각을 덧붙여서 정리하겠다. filter메서드의 선언을 확인한다. filter메서드의 두 번째 파라미터를 보고, 개발자는 함수형 인터페이스중 맞는 것(Predicate)을 찾아 그 형식을 기대하도록 설계한다. Predicate&amp;lt;Apple&amp;gt;는 test라는 한 개의 추상 메서드를 가지고 반환형은 boolean이므로 이 메서드를 사용할때 이러한 요구사항을 만족해야한다.위의 식은 해당 요구사항을 만족하므로 유효한 코드이다.Comparator&amp;lt;Apple&amp;gt; c1 = (Apple a1, Apple a2) -&amp;gt; a1.getWeight().compareTo(a2.getWeight());ToIntBiFunction&amp;lt;Apple,Apple&amp;gt; c2 = (Apple a1, Apple a2) -&amp;gt; a1.getWeight().compareTo(a2.getWeight());위 코드는 하나의 람다 표현식을 다양한 함수형 인터페이스로 받을 수 있다.이는 &amp;lt;&amp;gt;라는 컨텍스트를 통해 제너릭 형식을 추론할 수 있게 한다.즉, 람다는 할당문 콘텍스트, 메서드 호출 콘텍스트(파라미터, 반환값), 형변환 콘텍스트 등으로 람다 표현식의 형식을 추론할 수 있다.자바 컴파일러는 위의 방식으로 함수 디스크럽터를 추론할 수 있는데, 이는 즉 람다의 시그니처도 추론할 수 있다는 것이다.그렇기에 문법에서 생략할 수 있는 부분이 생긴다.위의 코드에서List&amp;lt;Apple&amp;gt; apples = filter(inventory, apple -&amp;gt; apple.getWeight() &amp;gt; 150);//또는Comparator&amp;lt;Apple&amp;gt; c1 = (a1, a2) -&amp;gt; a1.getWeight().compareTo(a2.getWeight());이런식으로 생략이 가능하고 때에 따라서는 가독성을 향상시킬 수도 있다.지금까지 사용한 람다는 모두 인수를 자신의 바디 안에서만 사용했는데, 외부 변수를 가져다 쓸 수도 있다.이를 람다 캡쳐링이라고 부르기도 한다.@Testvoid 람다캡쳐링(){ int pointNumber = 1553; Runnable r = () -&amp;gt; System.out.println(pointNumber); r.run();}이런식으로 외부 변수인 pointNumber를 인자로 넘겨서 사용할 수 있다.하지만 제약이 있다. 넘기는 변수는 final로 선언되어 있거나 final처럼 사용되어야 한다. 즉, 한 번만 할당되어야 한다. 재할당하니 컴파일 오류를 나타내는 것을 볼 수 있다.왜 이런 제약이 있냐면, 정말 간단하게 말하면 pointNumber가 1553값일때 람다식을 실행하려고 하는데, 밑에서 10000으로 재할당하는 경우가 생겨버려, 예기치 못한 에러를 발생시킬 수 있기 때문이다. 즉, 람다식 내부에서 사용하려는 지역변수 복사본이 재할당 되는 경우가 생겨버리므로 이를 막기 위해 컴파일 에러를 발생시킨다는 것이다.🔅 메서드 참조메서드 참조를 사용하면 메서드 정의를 활용해서 람다처럼 전달할 수 있다고 한다.@Testvoid 메서드참조(){ List&amp;lt;Apple&amp;gt; inventory = Arrays.asList( new Apple(200, Color.RED), new Apple(190, Color.GREEN), new Apple(180, Color.RED) ); //참조 사용 inventory.sort(Comparator.comparing(Apple::getWeight)); inventory.forEach(apple -&amp;gt; System.out.println(apple.getWeight()));}이처럼 Apple::getWeight라는 문법이 메서드 참조이다.람다에게 메서드를 어떻게 호출하는지에 명시하는 것이 아닌, 메서드에 직접 참조하는 것이 가독성을 높일 때가 있다.위의 식은 (Apple a) -&amp;gt; a.getWeight()를 축약한 것이다.위와 비슷하게 객체를 메서드 참조를 통해 생성할 수도 있다.@Testvoid 생성자참조() { //기본 생성자 //Supplier&amp;lt;Apple&amp;gt; c1 = () -&amp;gt; new Apple(); Supplier&amp;lt;Apple&amp;gt; c1 = Apple::new; Apple a1 = c1.get(); // weight가 있는 생성자 // Function&amp;lt;Integer, Apple&amp;gt; c2 = (weight) -&amp;gt; new Apple(weight); Function&amp;lt;Integer, Apple&amp;gt; c2 = Apple::new; Apple a2 = c2.apply(150); //생성자 1개일때 List&amp;lt;Integer&amp;gt; weights = Arrays.asList(7, 3, 4, 10); List&amp;lt;Apple&amp;gt; apples = mapByNewRef(weights, Apple::new); Assertions.assertEquals(apples.size(),4); //생성자 2개일때 BiFunction&amp;lt;Integer, Color, Apple&amp;gt; c3 = Apple::new; Apple a3 = c3.apply(150, Color.GREEN);}책에서는 여러 함수형 인터페이스를 조합해서 사용하는 방법도 알려주고 있다.예를들어, Comparator 인터페이스에는 reversed()와 같이 역정렬도 가능하고, thenComparing()같은 메소드를 통해 어떠한 처리 이후의 비교처리를 할 수 있게 한다.inventory.sort(comparing(Apple::getWeight)) .reversed() //무게를 내림차순 정렬 .thenComparing(Apple::getCountry); //두 사과의 무게가 같으면 국가별 정렬또한 Predicate인터페이스는 negate, and, or 세가지 메서드를 통해 사용자 요청을 조합할 수 있게 한다.//빨간색이면서 150g이상의 사과 또는 녹색인 사과추출Predicate&amp;lt;Apple&amp;gt; redAndHeavyAppleOrGreen = redApple.and(apple -&amp;gt; apple.getWeight() &amp;gt; 150) .or(apple -&amp;gt; Color.GREEN.equals(a.getColor()));이런식으로 활용이 가능하다.이 외에도 Function을 이용한 조합도 있다.public class Letter { public static String addHeader(String text){ return &quot;From minseok, java, kotlin&quot; + text; } public static String addFooter(String text){ return text + &quot;Kind regards&quot;; } public static String checkSpelling(String text){ return text.replaceAll(&quot;labda&quot;, &quot;lambda&quot;); }}@Testvoid Function_letter_test(){ Function&amp;lt;String, String&amp;gt; addHeader = Letter::addHeader; Function&amp;lt;String, String&amp;gt; transformationPipeline = addHeader.andThen(Letter::checkSpelling) .andThen(Letter::addFooter); System.out.println(transformationPipeline.apply(&quot;안녕하세요.&quot;));}//결과: From minseok, java, kotlin안녕하세요.Kind regards이는 모두 java.util에 있으며 해당 인터페이스를 까보면서 제공되는 메서드를 확인할 수도 있다." }, { "title": "2번 읽는 Modern Java In Action - Chapter02 동적 파라미터화 코드 전달하기", "url": "/posts/2023-03-27-Modern-Java-In-action/", "categories": "Java, Modern Java In Action", "tags": "Modern Java In Action", "date": "2023-03-27 01:02:00 +0900", "snippet": "동적 파라미터화란 말 그대로 메소드의 파라미터를 동적으로 정해줘서 넘겨주는 것을 말한다.그래서 자주 바뀌는 요구사항에 효과적으로 대응이 가능하다고 한다.🔅 예제책에서는 사과 파는것에 대한 예제를 들고 있다.만약 빨간사과, 녹색 사과가 있고 녹색사과만 필터링하고 싶으면 어떻게 할까?@Testvoid 녹색사과만필터(){ List&amp;lt;Apple&amp;gt; inventory = new ArrayList&amp;lt;Apple&amp;gt;(); inventory.add(new Apple(Color.GREEN)); inventory.add(new Apple(Color.RED)); inventory.add(new Apple(Color.GREEN)); inventory.add(new Apple(Color.RED)); List&amp;lt;Apple&amp;gt; greenApples = filterGreenApples(inventory); assertEquals(greenApples.size(), 2);}private List&amp;lt;Apple&amp;gt; filterGreenApples(List&amp;lt;Apple&amp;gt; inventory){ List&amp;lt;Apple&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(); for(Apple apple: inventory){ if(Color.GREEN.equals(apple.getColor())){ result.add(apple); } } return result;}이런식으로 코드를 작성할 수 있다. 만약에 요구사항이 바뀌어서 GREEN이 아니고 빨간(RED)를 필터하려면 어떻게 할까?if문만 바꾸고 나머지 로직은 동일한 filterRedApples()메서드를 추가할 수 있을 것이다. 하지만 점점 요구사항이 바뀌면 바뀔수록 이는 반복되는 코드가 너무 많아질 것이다.아니면 비교할 색을 받는 파라미터를 하나 늘려서 유연하게 대처할 수 있을 것이다.@Testvoid 좀더유연하게필터(){ List&amp;lt;Apple&amp;gt; inventory = new ArrayList&amp;lt;Apple&amp;gt;(); inventory.add(new Apple(Color.GREEN)); inventory.add(new Apple(Color.RED)); inventory.add(new Apple(Color.GREEN)); inventory.add(new Apple(Color.RED)); //파라미터 하나 늘었음. List&amp;lt;Apple&amp;gt; greenApples = filterApplesByColor(inventory, Color.RED); assertEquals(greenApples.size(), 2);}//파라미터 하나 늘었음.private List&amp;lt;Apple&amp;gt; filterApplesByColor(List&amp;lt;Apple&amp;gt; inventory, Color color){ List&amp;lt;Apple&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(); for(Apple apple: inventory){ if(color.equals(apple.getColor())){ result.add(apple); } } return result;}좋은 코드처럼 보인다. 하지만 색 말고 무게가 150그램 이상인 사과를 거르고 싶다라는 조건이 생긴다면 어떻게 할까?비슷하게 코드를 작성하는 방법이 있다.@Testvoid 무게필터(){ List&amp;lt;Apple&amp;gt; inventory = new ArrayList&amp;lt;Apple&amp;gt;(); inventory.add(new Apple(130)); inventory.add(new Apple(170)); inventory.add(new Apple(160)); inventory.add(new Apple(150)); List&amp;lt;Apple&amp;gt; greenApples = filterApplesByWeight(inventory, 150); assertEquals(greenApples.size(), 2);}private List&amp;lt;Apple&amp;gt; filterApplesByWeight(List&amp;lt;Apple&amp;gt; inventory, int weight){ List&amp;lt;Apple&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(); for(Apple apple: inventory){ if(apple.getWeight() &amp;gt; weight){ result.add(apple); } } return result;}하지만 결국 색 필터 관련 함수와 대부분 중복이 된다는 단점이 있다.책에서는 flag인자로 하나 더 둬서 true인 경우는 색 필터를 진행하고 false인 경우 무게 필터를 적용하는 코드를 작성했는데, 별로 좋은 코드가 아니므로 시간이 아까워 작성하지 않겠다.결국 이러한 메서드를 늘려나가는 방식은 한계가 있다는 점을 알려주고 있다.🔅 동작 파라미터화선택 조건을 결정하는 인터페이스를 하나 둬보자.보통 참 또는 거짓을 반환하는 함수를 predicate라고 한다.public interface ApplePredicate { boolean test(Apple apple);}이 인터페이스를 구현한 색 필터 클래스, 무게 필터 클래스를 작성할 수 있다.public class AppleGreenColorPredicate implements ApplePredicate{ @Override public boolean test(Apple apple) { return Color.GREEN.equals(apple.getColor()); }}public class AppleHeavyWeightPredicate implements ApplePredicate{ @Override public boolean test(Apple apple) { return apple.getWeight() &amp;gt; 150; }}테스트코드는 다음처럼 작성할 수 있다. @Testvoid 동작파라미터화(){ List&amp;lt;Apple&amp;gt; inventory = new ArrayList&amp;lt;Apple&amp;gt;(); inventory.add(new Apple(130, Color.GREEN)); inventory.add(new Apple(170, Color.RED)); inventory.add(new Apple(160, Color.RED)); inventory.add(new Apple(150, Color.RED)); List&amp;lt;Apple&amp;gt; greenApples = filterApples(inventory, new AppleGreenColorPredicate()); assertEquals(greenApples.size(),1);}private List&amp;lt;Apple&amp;gt; filterApples(List&amp;lt;Apple&amp;gt; inventory, ApplePredicate p){ List&amp;lt;Apple&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(); for(Apple apple: inventory){ if(p.test(apple)){ result.add(apple); } } return result;}분류하는 함수의 파라미터를 보면 ApplePredicate 객체 형태의 인자를 받는다. 그리고 실제 호출할때는 우리가 원하는 필터 클래스, 즉 상속받은 클래스를 넣어서 다양한 기능을 수행할 수 있게 한다. 이를 동작 파라미터화라고 한다.이를 통해 반복되는 로직과 각 요소에 적용할 동작, 즉 색이나 무게에 따라 필터를 적용하는것의 코드를 분리할 수 있다.즉, 적절한 객체를 전달하기만하면 filterApples내부에서 이를 확인하여 동작을 결정한다는 것이다.물론 여기에도 불편한 점이 있다. 두 개를 섞어서 쓰고 싶거나, 결국 새로운 클래스를 매 번 생성하고 상속받아야한다는 점이다.그래도 코드를 분리하고 필요에 따라서 원하는 객체를 인자로 넘겨 필터를 진행할 수 있다는건 알아둬야할 점이라고 생각한다.🔅 익명 클래스의 사용위에서 말한 불편한 점을 해결하기 위해서 익명 클래스를 사용할 수 있다.익명클래스의 장점으로는 선언과 동시에 인스턴스화를 할 수 있기에 따로 클래스파일을 만들 필요가 없다.만약, 빨간색사과만 필터하고 싶다면@Testvoid 익명클래스의_사용(){ List&amp;lt;Apple&amp;gt; inventory = new ArrayList&amp;lt;Apple&amp;gt;(); inventory.add(new Apple(130, Color.GREEN)); inventory.add(new Apple(170, Color.RED)); inventory.add(new Apple(160, Color.RED)); inventory.add(new Apple(150, Color.RED)); List&amp;lt;Apple&amp;gt; redApples = filterApples(inventory, new ApplePredicate() { @Override public boolean test(Apple apple) { return Color.RED.equals(apple.getColor()); } }); assertEquals(redApples.size(), 3);}이런식으로 익명 클래스를 통해 작성할 수 있다.하지만 익명클래스도 결국 코드 수가 길어지게 하는 원인이 되고, 프로그래머들에게 익숙하지 않다고 한다.책에서는 많은 프로그래머들이 곤경에 빠지는 고전 자바문제를 출제하였는데, 코드는 다음과 같다.class MeaningOfThis{ public final int value = 4; public void doIt(){ int value = 6; Runnable r = new Runnable() { public final int value = 5; @Override public void run() { int value = 10; System.out.println(this.value); } }; r.run(); }}@Testvoid 고전자바문제(){ MeaningOfThis m = new MeaningOfThis(); m.doIt();}이것의 답은 5이다. run()에서 말하는 this는 Runnable을 참조하기 때문이다.참고로, this를 안 쓰면 지역변수가 출력된다.class MeaningOfThis{ public final int value = 4; public void doIt(){ int value = 6; //4 System.out.println(this.value); //6 System.out.println(value); Runnable r = new Runnable() { public final int value = 5; @Override public void run() { int value = 10; //5 System.out.println(this.value); //10 System.out.println(value); } }; r.run(); }}즉, 이는 코드의 장황함을 가지는 코드이다. 장황한 코드는 알아보기 어렵고 유지보수하는데도 시간이 오래걸리기에 개발자들의 사랑을 받지 못한다. 그러므로 익명 클래스도 만족스러운 방법은 아니다. 결국 과정은 생략하였지만 결국 객체를 생성하고 동작을 정의한다는 점은 바뀌지 않기 때문이다.결국 람다를 이용해서 간단하게 적용할 수 있는데,@Testvoid 람다맛보기예제(){ List&amp;lt;Apple&amp;gt; inventory = new ArrayList&amp;lt;Apple&amp;gt;(); inventory.add(new Apple(130, Color.GREEN)); inventory.add(new Apple(170, Color.RED)); inventory.add(new Apple(160, Color.RED)); inventory.add(new Apple(150, Color.RED)); List&amp;lt;Apple&amp;gt; redApples = filterApples(inventory, (Apple apple) -&amp;gt; Color.RED.equals(apple.getColor())); assertEquals(redApples.size(),3);}책을 읽고, 다시 복습하며 코드를 짜지만 정말 간단하다고 느낀다.3장은 람다에 대한 얘기를 한다." }, { "title": "2번 읽는 Modern Java In Action - Chapter01 기초", "url": "/posts/2023-03-18-Modern-Java-In-Action/", "categories": "Java, Modern Java In Action", "tags": "Modern Java In Action", "date": "2023-03-18 01:02:00 +0900", "snippet": "개요이 책을 사게 된 계기는 원래 읽던 책인 effective Java를 읽다가 내용이 머릿속에 잘 안들어왔고, 자바의 대한 이해가 좀 더 필요하다고 느껴서 주변에 물어봐서 effective java 보다 잘 읽히는 책인 Modern Java In Action을 구매하게 되었다.1장이라 코드보다는 설명이 많다.Java8에서는 Stream API를 통해서 멀티코어 환경에서 좀 더 안정적, 간결하게 짤 수 있음을 말한다. 그 이유는 메서드에 코드를 전달하는 람다, 메서드 참조를 통해 불필요한 로직 중복을 줄일 수 있으며, 스트림 라이브러리가 최적의 저수준 실행방법을 선택하여 멀티코어 환경에서도 비용이 비싼 synchronized를 사용하지 않게 할 수 있다.즉, 앞으로 Java8에서 제공하는 세 가지 프로그래밍 개념을 통해 멀티코어 병렬성이 강화된 내용을 설명한다.📜 스트림 처리스트림은 한 번에 한 개씩 만들어지는 연속적인 데이터 항목들의 모임이다.프로그램은 입력 스트림에서 한 개씩 데이터를 읽어 들이며 마찬가지로 한 개씩 출력 스트림으로 데이터를 기록한다.cat file1 file2 | tr &quot;[A-Z]&quot; &quot;[a-z]&quot; | sort | tail -3 이라는 파이프( )로 구성한 유닉스 명령어가 있다. 이는 일반적으로 병렬적으로 실행된다. 즉, cat명령어가 끝나지 않아도, sort를 처리할 수도 있다.어떤식으로 병렬적으로 해결할까? 사실 파이프는 앞에서 처리한 데이터들을 input으로 받아서 처리해야한다. 이게 어떻게 병렬적이란 것인가?에 대해 생각해봤다.이는 각 명령어를 수행하는 자식 프로세스가 생기며(병렬성) 결국 앞에서 수행한 명령어를 input으로 받아서 작업을 처리하며 넘긴다.참고: https://hwan-shell.tistory.com/324Java8에는 위와 비슷한 개념의 Stream API를 통해 스레드라는 복잡한 작업을 사용하지 않으면서 병렬성을 얻을 수 있게 되었다. 개인 의견: 추가적으로 항상 병렬 스트림을 이용하였다고 하여, 항상 성능을 높일 수 있는건 아니다. 기본적으로 병렬스트림은 스레드를 여러개 생성해서 동작하기때문에 그 비용이 만만치 않기 때문이다. 즉, 대용량 데이터에서 병렬 스트림을 적용하는것을 고려할만하다.📜 동작 파라미터화로 메서드에 코드 전달만약 어떤 나라에서 다른 나라로 돈을 보낼때 ID값을 이런식으로 구성한다고 하자2023CADKRW12345연도/전송할 나라/받은 나라/id위의 유닉스 예제에서 sort에 연도별로 정렬해야할 때도 있고, 전송할 나라로 정렬해야할 때도 있고, 받은 나라로 정렬해야할 때가 있다고 하면 sort명령어에 인자를 넘겨줘야한다.Java8 전에는 Comparator객체를 만들어서 커스텀된 정렬 메서드를 넘겨주는 방법이 있지만, 코드가 복잡하고 결국 구현해야할 각각의 메서드들도 로직적으로 공통사항이 생겨 중복 코드가 생길 수 밖에 없다.Java8부터는 메서드를 다른 메서드의 인수로 넘겨주는 기능을 제공한다고 한다. 궁금하지만 곧 2장에서 나온다니, 일단 넘어가고 내가 따로 학습해야할 내용은 그때 추가하겠다.📜 병렬성과 공유 가변 데이터세 번째는 스트림을 통해 병렬성을 얻는 대신에 항상 안전하게 코드를 실행할 수 있도록 공유된 가변 데이터에 접근하지 않아야 한다.즉, 공유된 변수나 객체가 있으면 병렬성에 문제가 생길 수 있다. 병렬성을 통해 명령을 수행하는 여러 프로세스가 생겨날텐데, 여러 프로세스에서 공유된 변수를 동시에 바꾸려하면 어떻게 될까?먼저 synchronized 키워드를 통해 해결할 수는 있겠다. 하지만 이러면 병렬성의 이점이 사라진다. 결국 순차적으로 코드가 실행되어야하고 대기하는 프로세스도 많아져서 성능상의 이슈가 있을 수 있다. 개인 의견: 기본적으로 자바에서 제공하는 ConcurrentHashMap같이 안전한 자료구조를 제공하는 방법이 생각난다. 책에서 향후 또 다룰 것 같다.📜 메서드 참조메서드 참조란 개념은 자바8에서 새로 생긴 기능이다. 기존에는 어떠한 필터작업을 할 때 객체를 생성해서 메서드에 넘기는 방식으로 작업을 하였다.@Testvoid 자바8이전작업처리(){ File[] hiddenFiles = new File(&quot;.&quot;).listFiles(new FileFilter() { @Override public boolean accept(File pathname) { return pathname.isHidden(); } });}숨김파일을 찾는 코드인데, 코드 수도 너무 길고 굳이 FileFilter를 인스턴스화해서 해결한다.자바8 이후에는 간단하게 코드를 짤 수 있다. @Test void 자바8이후작업처리(){ File[] Java8HiddenFiles = new File(&quot;.&quot;).listFiles(File::isHidden); }::라는 메서드 참조를 이용하여 간단하게 작성이 가능하다. 내부동작은 3장에 나온다하니 일단은 넘어가기로 했다. 메서드 참조는 객체를 생성하지 않고 런타임 시에 메서드를 참조하여 호출할 수 있는 기능이다. 이후 책에는 람다와 스트림 자바8에 추가된 기능에 대한 간단한 예제에 대한 내용이 나오지만, 어차피 점차 자세히 다뤄지고 있으므로 시간이 아까워서 여기서 정리하지 않을 것이다." }, { "title": "blue-green 배포 적용하기", "url": "/posts/2023-03-15-blue-green-deploy/", "categories": "Java, Spring", "tags": "blue-green-deploy", "date": "2023-03-15 01:02:00 +0900", "snippet": "☑️ 왜 필요했나?기존 배포방식은 다음과 같았다.GitAction을 사용했다.name: Deploy to EC2on: push: branches: - mainpermissions: contents: readjobs: build: runs-on: ubuntu-latest steps: - name: checkout uses: actions/checkout@v3 # JDK Setting - name: Set up JDK 17 uses: actions/setup-java@v3 with: java-version: &#39;17&#39; distribution: &#39;temurin&#39; # Gradle Caching - name: Cache Gradle packages uses: actions/cache@v3 with: path: | ~/.gradle/caches ~/.gradle/wrapper key: $-gradle-$ restore-keys: $-gradle- - name: Grant execute permission for gradlew run: chmod +x gradlew # Create application-prod.properties - name: Create application-prod.properties run: | cd ./src/main/resources touch ./application-prod.properties echo &quot;$PROPERTIES_PROD&quot; &amp;gt; ./application-prod.properties env: PROPERTIES_PROD: $ # Gradle Build - name: Build with Gradle run: ./gradlew build -x test # Image Tagging with Docker Meta - name: Docker meta id: docker_meta uses: crazy-max/ghaction-docker-meta@v1 with: images: teambpm2023/dnd-bpm - name: Set up Docker Buildx uses: docker/setup-buildx-action@v1 # DockerHub Login - name: Login to DockerHub uses: docker/login-action@v1 with: username: $ password: $ - name: Docker build &amp;amp; push uses: docker/build-push-action@v2 with: context: . file: ./Dockerfile platforms: linux/amd64 push: true tags: $ labels: $ - name: create remote directory uses: appleboy/ssh-action@master with: host: $ username: ubuntu key: $ script: mkdir -p /home/ubuntu/srv/ubuntu - name: copy source via ssh key uses: burnett01/rsync-deployments@4.1 with: switches: -avzr --delete remote_path: /home/ubuntu/srv/ubuntu/ remote_host: $ remote_user: ubuntu remote_key: $ - name: executing remote ssh commands using password uses: appleboy/ssh-action@master with: host: $ username: ubuntu key: $ script: | cd /home/ubuntu/srv/ubuntu sh ./config/scripts/docker-install.sh sudo docker stop $(sudo docker ps -a -q) sudo docker rm $(sudo docker ps -a -q) sudo docker rmi $(sudo docker images -q) sudo docker-compose -f docker-compose.yml pull sudo docker-compose -f docker-compose.yml up --build -dGitAction을 통해 빌드를한 파일을 DockerHub에 올리고, 운영서버에서 명령어로 DockerHub에 올린 빌드된 파일들을 받아서 서버를 띄우고 있었다.근데, 결국 운영서버에서 빌드하고 다시 띄우는데 시간이 걸렸고 안드로이드 개발자들한테 수정사항이 생기면“배포 지금 다 했고, 운영서버 뜰 때까지 좀 기다리셔야해요.” 라고 말하는 버릇이 생겼다.그래서 무중단 배포에 관심이 생겼고 적용해야겠다고 생각했다.😕 왜 블루-그린 배포를 선택했는가?블루-그린 배포 방식 말고도 카나리 배포, 롤링 배포가 있다.그 둘을 적용하지 않고 블루-그린을 배포한 이유는 다음과 같았다.카나리 배포를 선택하지 않은 이유 카나리 배포 방식의 장점인 조금씩 배포해가며, 위험을 빠르게 감지할 필요가 없다고 생각했다. 카나리 배포 방식의 인프라 구성방식이 복잡하다고 하여, 이는 주어진 일정내에 빠르게 적용할 수 없다고 생각했다.롤링 배포를 선택하지 않은 이유 롤링 배포 방식의 단점중 하나인 데이터 일관성 문제가 생길 수 있다는 것에 끌리지 않았다.🔅 해결 과정로드 밸런서를 두지 않았다.앱 자체가 서비스를 안 했기에 로드밸런서로 트래픽 관리를 할 필요가 없다고 생각했다. 실제 앱이 출시되고, 트래픽을 감당할 수 없는 상황에 로드 밸런서를 놓을 생각이다.Flow내가 생각한 플로우는 기존 코드는 최대한 덜 건드리고 적용하고 싶었기에 다음과 같이 생각했다. port를 다르게 설정한 docker-compose파일을 blue용, green용으로 둔다. greenversion: &#39;3&#39;services: web-green: container_name: web-green image: teambpm2023/dnd-bpm:main expose: - &quot;8082&quot; ports: - &quot;8082:8080&quot; blueversion: &#39;3&#39;services: web-blue: container_name: web-blue image: teambpm2023/dnd-bpm:main expose: - &quot;8081&quot; ports: - &quot;8081:8080&quot; 배포스크립트를 짜는데, 이 compose파일들에 저장된 정보들을 이용해서 DockerHub에서 이미지를 가져오고 빌드시킨다. 기존에 존재했던 서버(green이나 blue)와 반대 서버를 띄워서 2포트를 사용하고 있게 한다.(8081, 8082포트) nginx 설정을 건드려서 green이나 blue의 설정파일을 가리키게 만든다.(포트 변경) 서버가 가리키는 포트가 변경되었으면, 기존 떠있던 green이나 blue의 컨테이너를 종료시킨다.이를 그림으로 잘 표현한것은 https://jay-ji.tistory.com/m/99 이 블로그이고, 실제로 여기있는 코드들을 잘 적용해서 사용하고 있다.그러므로 잘 이해가 안된다면 참고하시길 바랍니다.nginx blue버전의 설정은 다음과 같이 구성했다.events {}http{ upstream web-blue { server localhost:8081; } server { listen 80; location / { proxy_pass http://web-blue; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $host; proxy_set_header X-Forwarded-Host $server_name; proxy_set_header X-Real-IP $remote_addr; proxy_redirect off; } }}nginx green버전의 설정이다.events {}http{ upstream web-green{ server localhost:8082; } server { listen 80; location / { proxy_pass http://web-green; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $host; proxy_set_header X-Forwarded-Host $server_name; proxy_set_header X-Real-IP $remote_addr; proxy_redirect off; proxy_buffer_size 128k; proxy_buffers 4 256k; proxy_busy_buffers_size 256k; } }}그리고, 배포 스크립트는 다음과 같이 작성했다.EC2환경에서 실행되는거라 sudo코드를 이용해서 작성했다.#!/bin/bash# Blue 를 기준으로 현재 떠있는 컨테이너를 체크한다.EXIST_BLUE=$(sudo docker-compose -p web-blue -f docker-compose-blue.yml ps | grep Up)echo &quot;EXIST_BLUE value is: $EXIST_BLUE&quot;if [ -z &quot;$EXIST_BLUE&quot; ]; then echo &quot;blue up&quot; sudo docker-compose -f docker-compose-blue.yml pull sudo docker-compose -p web-blue -f docker-compose-blue.yml up --build -d BEFORE_COMPOSE_COLOR=&quot;green&quot; AFTER_COMPOSE_COLOR=&quot;blue&quot;else echo &quot;green up&quot; sudo docker-compose -f docker-compose-green.yml pull sudo docker-compose -p web-green -f docker-compose-green.yml up --build -d BEFORE_COMPOSE_COLOR=&quot;blue&quot; AFTER_COMPOSE_COLOR=&quot;green&quot;fisleep 10# 새로운 컨테이너가 제대로 떴는지 확인EXIST_AFTER=$(sudo docker-compose -p web-${AFTER_COMPOSE_COLOR} -f docker-compose-${AFTER_COMPOSE_COLOR}.yml ps | grep Up)if [ -n &quot;$EXIST_AFTER&quot; ]; then # nginx.config를 컨테이너에 맞게 변경해주고 reload 한다 -&amp;gt; 필요없을듯? sudo cp ./config/nginx/nginx.${AFTER_COMPOSE_COLOR}.conf /etc/nginx/nginx.conf sudo nginx -s reload # 이전 컨테이너 종료 sudo docker-compose -p web-${BEFORE_COMPOSE_COLOR} -f docker-compose-${BEFORE_COMPOSE_COLOR}.yml down echo &quot;$BEFORE_COMPOSE_COLOR down&quot;fi그리고 기존 gitAction에서 배포방식의 스크립트도 변경해줘야했다. 배포되고 deploy.sh파일을 실행하게끔 말이다.그러므로 chmod를 통해 권한을 주고 실행시킨다.~~~script: | cd /home/ubuntu/srv/ubuntu sh ./config/scripts/docker-install.sh - sudo docker stop $(sudo docker ps -a -q) - sudo docker rm $(sudo docker ps -a -q) - sudo docker rmi $(sudo docker images -q) - sudo docker-compose -f docker-compose.yml pull - sudo docker-compose -f docker-compose.yml up --build -d + sh chmod +x ./deploy.sh + sh ./deploy.sh🤔 어려웠던 점, 아쉬운 점어려웠던 점으로는 환경부분이 컸다.내 노트북은 mac이고, 데스크탑은 window11 운영체제를 가지고 있어서 로컬에서 테스트하기 좀 어려웠다.왜냐하면 Dockerhub에 올라간 파일은 arm/64운영체제에서 돌아가게끔 되어있었기 때문이다.. 운영환경인 ubuntu와 셋 다 운영체제가 달라서 도커허브에 이미지를 올리거나 받아오는 작업을 운영환경속에서 확인해야했다.그 외에는 어려웠던건 없었다.아쉬웠던 점으로는 nginx추가 설정에 있다.일단 지금 운영환경에 nginx가 무조건 떠 있는걸 가정하고 배포를 진행하였는데, 이에 대한 체크도 스크립트에서 작성이 필요하다고 느꼈다.이는 추후 작업할 것이다.😀 배운 점확실히 직접 구성해보니, 왜 필요하고 왜 이런 배포방식을 구성했는지에 대해 깊게 생각하는 계기가 되었다.그리고, 기존 배포방식에서 많은 코드를 건들지 않도록 바꾸니 어떻게 하면 배포방식들을 내 프로젝트에 자연스럽게 스며들게 할 지 고민할 수도 있었다.blue-green 배포 쉬운데?" }, { "title": "SpringSecurity - jwt인증 실패했을때 커스텀 에러 넘기기", "url": "/posts/2023-03-11-SpringSecurityError/", "categories": "Java, Spring", "tags": "SpringSecurity", "date": "2023-03-11 01:02:00 +0900", "snippet": "☑️ 개요해당 기능을 작성하는 이유가 있다.기존 프로젝트 코드에서는 인증절차 실패할 경우 무조건 401 Unauthorized Status를 반환하고 있었다.그 코드는 다음과 같으며, @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http.csrf() .disable() .authorizeHttpRequests((auth) -&amp;gt; auth .requestMatchers(&quot;/swagger-ui/**&quot;, &quot;/v3/**&quot;).permitAll() .requestMatchers(&quot;/api/users/signup&quot;, &quot;/api/users/verification&quot;).permitAll() .anyRequest().authenticated()) .requestCache().disable() .securityContext().disable() .sessionManagement().disable() .headers().frameOptions().disable() .and() .formLogin() .disable() //밑의 이 부분 .exceptionHandling().authenticationEntryPoint(new HttpStatusEntryPoint(HttpStatus.UNAUTHORIZED)) .and() .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class); return http.build(); }postman으로 요청을 보내서 인증에 실패할 경우 밑의 사진처럼 뜬다.이것은 문제는 Response Status만 알고, 어디서 어떻게 에러가 터졌는지 몰라서 같이 협업하는 안드로이드 개발자가 매우 답답함을 느꼈다.처음에는 401 에러가 뜰때마다 토큰의 문제라고 생각 안 하고 로그를 확인하였으며 매우 많은 시간을 보냈다.일단 다른 일들이 급하여 이 부분 수정을 미루고 있었는데, 시간이 생겨서 우선순위 큐에 첫 번째에 있는 놈처럼 바로 처리하기로 했다.☑️ 수정위 코드에서.exceptionHandling().authenticationEntryPoint(new HttpStatusEntryPoint(HttpStatus.UNAUTHORIZED))이 부분을 커스텀하면 되는데, HttpStatusEntryPoint는 AuthenticationEntryPoint라는 인터페이스의 구현체이다.즉, AuthenticationEntryPoint를 구현한 클래스를 갈아끼우면 된다.나는 CustomAuthenticationEntryPoint라는 클래스를 만들어서 위의 인터페이스를 구현할 것이다.@Component@Slf4jpublic class CustomAuthenticationEntryPoint implements AuthenticationEntryPoint { @Override public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException { //... }}commence라는 메소드를 구현하게 되어있고, 이 메소드를 통해 인증에 실패했을때의 처리를 진행할 수 있다.내가 반환할 에러 객체는 다음과 같이 구성되어있다.public class ErrorResponse { private final LocalDateTime timestamp = LocalDateTime.now(); private final int status; private final String error; private final String code; private final String message; public ErrorResponse(Error error){ this.status = error.getStatus().value(); this.error = error.getStatus().name(); this.code = error.name(); this.message = error.getMessage(); }}즉, 여기에 있는 값을 인증에 실패했을때 내려줄 것이며 이는 대략적으로{ &quot;timestamp&quot;: &quot;2023-03-11T20:23:42.663273&quot;, &quot;status&quot;: 409, &quot;error&quot;: &quot;CONFLICT&quot;, &quot;code&quot;: &quot;USER_ALREADY_EXITS&quot;, &quot;message&quot;: &quot;user already exits&quot;}이런것처럼 구성을 가질 것이다. 에러발생시간, Http 상태코드, Http 상태메시지, 커스텀한 에러 코드, 커스텀한 에러 내용 이라는 값을 가진다.이제 이를 반환해보겠다.☑️ CustomAuthenticationEntryPoint 작성response의 값들을 수정하여 내려줄때의 상태를 커스텀해줄 수 있다.// CustomAuthenticationEntryPoint.java@Overridepublic void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException { log.error(&quot;UnAuthentication!!! message : &quot; + authException.getMessage()); response.setContentType(MediaType.APPLICATION_JSON_VALUE); response.setStatus(HttpStatus.UNAUTHORIZED.value()); //..}여기까지는 쉽다. 먼저, 배포서버에서 로그를 볼 수 있게 로그를 찍고 우리는 Json형태의 값을 내려주며 401 상태코드를 내려줄거라는 코드이다. 참고로 setStatus안에 들어오는 상태값들은 응답본문을 가지는 어떠한 코드도 들어올 수 있다.이제 ErrorResponse의 객체를 응답본문에 담아서 넘겨줘야한다.@Overridepublic void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException { log.error(&quot;UnAuthentication!!! message : &quot; + authException.getMessage()); response.setContentType(MediaType.APPLICATION_JSON_VALUE); response.setStatus(HttpStatus.UNAUTHORIZED.value()); // 추가된 부분 ErrorResponse errorResponse = new ErrorResponse(Error.UNAUTHORIZED_USER); String responseBody = objectMapper.writeValueAsString(errorResponse); try (OutputStream os = response.getOutputStream()) { os.write(responseBody.getBytes(StandardCharsets.UTF_8)); os.flush(); }}@Getterpublic enum Error { UNAUTHORIZED_USER(&quot;Unauthorized user. Please check your token.&quot;, HttpStatus.UNAUTHORIZED), ...}내가 작성한 커스텀 에러 객체를 생성하고 이를 직렬화하는 코드이다. 제가 커스텀한 에러 객체들이 필요하다면 요청하시면 드리겠습니다.아무튼 위의 내용을 직렬화를 하여, 응답본문에 작성한다.objectMapper는 어딨냐? 라고 말할 수 있는데, 이는 내가 따로 싱글톤으로 구현했다.싱글톤으로 만들어서 딱 한번만 해당 객체를 생성하도록 하여 객체 생성 리소스를 줄이기 위함이다.그래서 싱글톤 + 전체적인 코드는 다음과 같다.@Component@Slf4jpublic class CustomAuthenticationEntryPoint implements AuthenticationEntryPoint { private final ObjectMapper objectMapper; public CustomAuthenticationEntryPoint(){ this.objectMapper = new ObjectMapper() //timestamp 직렬화를 위해 필요한 코드 .registerModule(new JavaTimeModule()) .disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS); } @Override public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException { log.error(&quot;UnAuthentication!!! message : &quot; + authException.getMessage()); response.setContentType(MediaType.APPLICATION_JSON_VALUE); response.setStatus(HttpStatus.UNAUTHORIZED.value()); ErrorResponse errorResponse = new ErrorResponse(Error.UNAUTHORIZED_USER); String responseBody = objectMapper.writeValueAsString(errorResponse); try (OutputStream os = response.getOutputStream()) { os.write(responseBody.getBytes(StandardCharsets.UTF_8)); os.flush(); } }}여기서 절대 놓치지 말아야할 한 가지가 있는데,this.objectMapper = new ObjectMapper() //timestamp 직렬화를 위해 필요한 코드 .registerModule(new JavaTimeModule()) .disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);이 코드이다.기존 ObjectMapper는 java.util.Date와 java.util.Calendar를 통해 시간에 대해 직렬화를 수행하는데, Java8부터 나온 LocalDate 시리즈들을 인식하지 못한다.그래서 registerModule(new JavaTimeModule()) 코드를 통해 모듈을 추가 등록하면서 LocalDate 시리즈들도 직렬화 할 수 있게 한다.그러면 ObjectMapper가 JavaTimeModule 모듈에 있는 직렬화 방식을 사용할까? 기존 제공하던 java.util.Date나 java.utilCalendar를 통해 직렬화를 할까?.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)를 통해 기본적으로 제공하는 직렬화 방식을 막는다. 이 코드를 넣지 않는다면 예기치 못한 방식으로 직렬화 할 것이다. disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)를 추가하지 않았을 때 disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)를 추가했을 때☑️ 등록사실 저기까지 구현한다해서 제대로 동작하지 않는다.왜냐하면 커스텀한 이 객체를 등록하지 않았기 때문이다.이제 다시 Config관련 코드로 가서 해당 객체를 끼워넣어주자.@Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http.csrf() ... .exceptionHandling().authenticationEntryPoint(customAuthenticationEntryPoint) ... return http.build(); }자 이제 이러면 성공적으로 작동한다.여기서 인터페이스 장점도 볼 수 있다. 구현체만 갈아끼우면 얼마든지 여러 코드를 커스텀할 수 있다는 것이다." }, { "title": "DND 8기 활동 후기", "url": "/posts/2023-03-06-dnd/", "categories": "", "tags": "", "date": "2023-03-06 01:02:00 +0900", "snippet": "개요2023년 03월 04일부로 DND활동이 끝이 났다.https://www.dnd.ac/1월초부터 8주간 진행되었고, 결론적으로 참여하길 잘했다고 생각이 들었다.운영진분 께서 백엔드 개발자 직군 기준 20:1의 경쟁률을 가지고 있었는데, 이를 뚫고 둘어간거라 하시더라.경과팀은 디자이너 2명, 안드로이드 or 웹 프론트 개발자 2명, 백엔드 개발자 2명 총 6명이 한 팀을 이뤄서 진행하게 된다.먼저 기획부터 설계까지 모두 회의와 협업을 통해 도출해야한다.8주라는 시간안에 기획, 설계, 개발까지 하는데에는 정말 많은 시간이 필요했다. figma툴을 이용한 기획, 디자인나는 직장을 다니면서 했기에, 거의 퇴근해서는 1~2시까지 개발을 진행했던 것 같다.근데 워낙 좋은 동료들을 둬서 개발하는 것이 너무 재밌었다.내가 느낀 이 활동의 가장 큰 장점은 열정있는 동료들을 만났다는 것이다.동료들과 내가 욕심이 많아서 이것저것 기능을 추가하고 버릴건 버려도 너무 많았다.그래서 시간내에 기능을 구현하느라 너무 바빴다. 많은 기능들과 화면을 만들었지만, 동료들과 내가 만족하지 못했다.결국 나는 동료들과 함께 6월까지 우리가 만족할만한 기능을 모두 구현할때까지 달리기로 했다.정말 멋있다.아이디어도 정말 마음에 들어서 안드로이드 개발자와 나는 거의 밤을 지새워서 이 앱에 대해서 얘기한 적도 있다.발표 전 날에는 아침 8시까지 같이 논의하면서 개발을 진행하였고, 적어도 보여줄 정도까지는 만들었다.결론나는 이 활동을 적극 추천한다.그리고 본인이 쌓아올린것들이 있다면 경쟁률은 크게 의미가 없다.내 모든것을 보여주고 싶어서 서류를 정말 진정성있게 지원서를 작성하였고, 그 진정성이 닿았나 보다.진행을 하면서 느낀것은 대략 이것들이다. 다른 사람들의 발표를 보면서 기술스택에 대해 생각하게 되었다. 거의 7할은 spring boot + docker + aws 조합인데, nextJs를 쓴 팀이 눈에 와 닿았다. 자바 + 스프링이 전부였던 나에게 코틀린 + 스프링이라는 관심이 생겼다. 우리팀 안드로이드 개발자들은 전부 코틀린을 사용하는데, 원만한 협업과 평소 관심이 있던점을 통해 아마 코프링으로 기술을 바꾸지 않을까 싶다. 아예 노베이스는 힘들 것 같다고 생각했다. 기능을 구현하기 위해 달려야할 일정 자체는 짧은 편이다. 본인이 기술에 대한 베이스가 크지 않다면 해당 언어와 프레임워크에 대해 미리미리 공부해둬야할 것이다.이번 협업을 통해, 의사소통을 하기 위해서 무엇이 중요할까 생각하게 되었다. 긍정적인 사고와 때로는 비판적인 사고가 중요하다. 긍정적인 사고는 팀원들과 내가 다양한 의견을 낼 수 있는 환경을 마련하더라. 뭐든 안 된다하면 그 누가 의견을 자유롭게 낼까? 라는 생각을 했다. 그렇지만 너무 무리하게 긍정적인 사고를 가질 필요는 없다. 팀에게 기대를 크게 하지 말자. 팀에게 기대하는 순간 기대치를 두고 사람을 바라보기에, 실망할 일도 생긴다. 팀의 일이 곧 나의 일이다. 기대하면 팀에서 불화가 나올 수 있다고 생각한다. 위의 방식을 통해 서로가 하고싶은게 있고, 프러덕트에 대한 애정이 생겨 더 열심히 제작하게 되는 것 같다.다시 한 번 나는 이 활동 적극 추천한다.나는 운이 좋게도 모든 팀원들을 너무 잘 만났다.나는 이제 8기 활동을 마무리하였는데, 운영진분들이 너무 고생하시기도 했고 요즘 개발자들은 어떤 기술에 관심이 많은지 옆에서 보고 싶어서 개발 운영진으로 지원하게 되었다.이것도 운이 좋게도 앞으로 운영진으로 dnd에 활동할 수 있게 되었다. dnd 서버를 보면서 어떤식으로 지원자를 관리하고 있는지 지원자들이 협업할 때 어떤 문제들이 발생하고 같이 고민하며 해결할 지 지원자들을 보고 내가 어떤 방식으로 성장할 지 dnd활동에 내가 어떠한 점을 기여할 지가 기대된다.글을 쓰려니 내 모든 생각들을 담지 못해서 아쉽다." }, { "title": "Trouble Shooting - Docker 빌드할때 운영체제를 꼼꼼히 봐야한다.", "url": "/posts/2023-02-26-dockerError/", "categories": "Error, AWS", "tags": "interview", "date": "2023-02-27 01:02:00 +0900", "snippet": "✏️ 개요지금 하고 있는 사이드 프로젝트에서 문제가 생겼다.기존에 Git Action을 통해 CI/CD를 구축하였다. flow는 다음과 같다. 프로젝트를 빌드한다. 도커 허브에 프로젝트 빌드를 push한다. 서버가 떠 있는 aws EC2에서 도커허브에 있는 빌드된 파일을 pull을 통해 받아오고, 서버를 띄운다.나는 도커에 대해 많이 알지 못하므로, 팀원에게 CI/CD구축을 맡겼다.왜냐하면, EC2 + docker + RDS + S3등을 연동해야했기에, docker라는 것 때문에 이를 유기적으로 연결할 생각을 무서워서 못했기 때문이다.결과적으로, 이번 문제를 팀원과 같이 해결하면서 docker에 대한 이해도가 어느정도 늘었다고 생각한다.✏️ 문제문제는 빌드 파일을 pull로 가져오는건 되는데, 서버가 뜨지 않는다는 것이다.jolly_montalcini라는 랜덤으로 설정된 컨테이너는 내가 수동으로 서버를 띄워본 빌드파일이다.수동으로 서버를 띄웠을때 잘 되고, 왜 도커 허브에서 받은 파일로 서버를 띄우면 안되는 것인가?처음에는 gitAction에서 err라는 문구를 출력하길래 이걸 뜯어봐야한다고 생각했다.근데, 이 문구는 Action이 성공했을때도 떴기에 일단 다른 부분을 체크하기로 했다.✏️ 로그확인그 다음 든 생각은 로그를 보자. 찾아보니 docker-comose로 띄운 컨테이너를 다음 명령어를 통해 로그를 확인할 수 있다고 했다.sudo docker-compose logs 컨테이너이름//sudo docker-compose logs web그렇게 이 명령어를 통해 확인해보니이 에러는 빌드한 이미지와 서버의 운영체제가 다를때 뜨는 에러라고 한다. 참고알고보니, 팀원은 M1맥북으로 자바 파일 이미지를 최초에 빌드했고, 이를 계속 EC2 ubuntu 환경인 AMDx86에서 arm에서 빌드한 파일을 빌드하고 서버를 띄우려고 하니, 에러가 발생하는 것이다.즉, 윈도우에서 최초 이미지를 빌드하던가 해야하는데.. 도커허브에 일단 들어가 보았다.보아하니, main은 AMD64로 계속 허브에 올라오고 있었고, latest는 9일 전 그러니까 최초에 올라오고 그 이후에는 푸시되고 있지 않았다.gitAction은 자동으로 latest를 배포하고 있었다.그렇기에 Ec2에는 latest가 계속 배포되고 있었고, 이를 main으로 바꾸면 해결될 거라 생각했다.이는 간단하다.기존 docker-compose.yml 파일은 이렇게 되어있었다.version: &#39;3&#39;services: web: container_name: web image: teambpm2023/dnd-bpm expose: - &quot;8080&quot; ports: - &quot;8080:8080&quot; nginx: depends_on: - web restart: always build: dockerfile: Dockerfile context: ./config/nginx ports: - &quot;80:80&quot;여기서 image: teambpm2023/dnd-bpm 이 부분을 image: teambpm2023/dnd-bpm:main 으로 바꾸면 된다.그리고 GitAction을 다시 돌리면..서버가 자동으로 잘 뜨게 된다.도커에 대해 조금 더 알게되긴 하였고, 더 공부하고 싶은 생각이 들었다." }, { "title": "Java Lombok @Get 직접 구현해보면서 프로세서 분석하기.", "url": "/posts/2023-01-31-Annotation_AD/", "categories": "Interview", "tags": "interview", "date": "2023-01-31 01:02:00 +0900", "snippet": "롬복을 만들어보면서 어노테이션이 어떻게? 동작하는지 알아보자.참고자료: https://catch-me-java.tistory.com/49 =&amp;gt; 원론적인 부분https://catsbi.oopy.io/78cee801-bb9c-44af-ad1f-dffc5a541101 다른 API를 이용하여 아예 클래스를 컴파일단계에서 새로 만드는 방법을 제시 기존에 있는것을 수정이 불가능함🔅 환경구성 Intellij: 2021.2.1 Language: Java 8 ProjectName: customLombok 구현내용: @Get(getter)&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.7.8&amp;lt;/version&amp;gt; &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;groupId&amp;gt;me.kms&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;customLombok&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;name&amp;gt;customLombok&amp;lt;/name&amp;gt; &amp;lt;description&amp;gt;customLombok&amp;lt;/description&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt; &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt; &amp;lt;maven.compiler.source&amp;gt;1.8&amp;lt;/maven.compiler.source&amp;gt; &amp;lt;maven.compiler.target&amp;gt;1.8&amp;lt;/maven.compiler.target&amp;gt; &amp;lt;auto-service.version&amp;gt;1.0-rc4&amp;lt;/auto-service.version&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.google.auto.service&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;auto-service&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${auto-service.version}&amp;lt;/version&amp;gt; &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.github.olivergondza&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;maven-jdk-tools-wrapper&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;0.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;build&amp;gt; &amp;lt;plugins&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;/plugin&amp;gt; &amp;lt;/plugins&amp;gt; &amp;lt;/build&amp;gt;&amp;lt;/project&amp;gt; 스프링 부트 3버전은 Java17버전부터 지원하므로 그 아래 단계를 선택🔅1. Annotation Get1.1 @Get 코드package mylombok;import java.lang.annotation.*;/** * @Target의 ElementType.TYPE에 의해 클래스/인터페이스/열거/레코드 타입에 어노테이션을 붙일 수 있게 되었다. * @Get의 기본방식은 컴파일 이후에는 쓰이지 않게 구성되어 있으므로, RentetionPolicy를 SOURCE로 해둬서 컴파일 이전까지 쓰이게 한다. * * @author kms * */@Documented@Target(ElementType.TYPE)@Retention(RetentionPolicy.SOURCE)public @interface Get {}1.2 Get 어노테이션 프로세스@SupportedAnnotationTypes(&quot;me.kms.anno.Get&quot;)@AutoService(Processor.class)public class GetProcessor extends AbstractProcessor { @Override public SourceVersion getSupportedSourceVersion(){ return SourceVersion.RELEASE_8; } @Override public boolean process(Set&amp;lt;? extends TypeElement&amp;gt; annotations, RoundEnvironment roundEnv) { //logic return true; }}@SupportedAnnotationTypes 인자로 들어온 값의 경로를 찾고 해당 어노테이션의 값을 사용하여, 어떠한 처리를 할 수 있게 도와준다. 이는 Processor라는 인터페이스에 정의된 getSupportedAnnotationTypes라는 메서드를 통해 인자로 들어온 어노테이션의 이름을 반환하여 작업을 할 수 있게 도와준다. 우리가 extends한 AbstractProcessor 클래스는 위의 Processor를 구현한 구현체이며, 우리가 필요한것들만 오버라이드 해서 사용할 것이다. Annotation Processor를 지원하는 어노테이션 인터페이스를 나타내는 어노테이션임을 뜻한다. Annotation Processor란 어노테이션을 처리하는 일종의 프로그램이다. 이를통해 Annotation Processor는 특정 어노테이션 인터페이스를 사용하는 클래스를 검색하여 처리할 수 있게 된다.즉, 코드에서는 mylombok패키지에 있는 Get어노테이션을 처리하도록 도와주는 소스이다.@SupportedSourceVersion(SourceVersion.RELEASE_8) 밑의 getSupportedSourceVersion()로 대체가 가능하다. 특정 버전에서의 자바에서만 사용가능하도록 지정할 수가 있다. 위의 예시는 자바8버전에서만 사용가능하다고 명시한 예시다. 여러 버전을 지정하고 싶다면 @SupportedSourceVersion(value = {RELEASE_8,RELEASE_11,RELEASE_14})이런식으로 사용이 가능하다. @AutoService(Processor.class)원래는 resources / META-INF /javax.annotation.processing.Processor파일에 다음과 같은 내용을 써주고 컴파일 해야한다.me.kms.anno.GetProcessor이렇게 작성하고 mvn clean install을 수행하면 에러가 발생하는데, 메이븐이 소스 컴파일 하는 시점에 프로세서가 동작하려고 하니, 아직 컴파일 되지 않은 소스를 읽으려 하면서 에러가 나오는 것이다.그래서 위의 문구를 주석처리하고, 다시 컴파일 하면 된다.그리고 다시 주석을 풀고, mvn install을 수행하면 된다.이런 일련의 과정이 귀찮기에 @AutoService어노테이션을 사용하면 위의 문제를 해결해줄 수 있다. 컴파일 시점에 어노테이션 프로세서를 활용해서 파일을 자동으로 생성해주는 것이다.이제 process()에 로직을 구성해줘야한다.1.3 init() 구현 private ProcessingEnvironment processingEnvironment; private Trees trees; private TreeMaker treeMaker; private Names names; private Context context; @Override public synchronized void init(ProcessingEnvironment processingEnv) { JavacProcessingEnvironment javacProcessingEnvironment = (JavacProcessingEnvironment) processingEnv; super.init(processingEnv); this.processingEnvironment = processingEnv; this.trees = Trees.instance(processingEnv); this.context = javacProcessingEnvironment.getContext(); this.treeMaker = TreeMaker.instance(context); this.names = Names.instance(context); }process()를 구현하기 전에 필요한 정보들을 설정해야한다. 그에 대한 정보를 맞춰주는 메서드다.JavacProcessingEnvironment javacProcessingEnvironment = (JavacProcessingEnvironment) processingEnv;이 부분 코드 때문에 에러가 발생한다.이러한 에러로, https://github.com/mplushnikov/lombok-intellij-plugin/issues/988를 참고하여 해결하면 된다. javacProcessingEnvironment.getContext()에서 반환하는 컨택스트는 컴파일러 정보, 등을 반환하고 또한 해당 컨택스트를 통해 메서드나 클래스, 어노테이션 프로세서를 만들 수 있게 도와주는 정보를 제공한다.다른 변수들은 밑에서 어떻게 쓰이는지 확인하면서 찾아가보는게 낫겠다 생각했다.1.4 process() 구현for (final Element element : roundEnv.getElementsAnnotatedWith(Get.class)) { System.out.println(&quot;element:&quot; + element); if(element.getKind() != ElementKind.CLASS){ processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, &quot;@Get annotation cant be used on&quot; + element.getSimpleName()); }else{ processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, &quot;@Get annotation Processing &quot; + element.getSimpleName()); final TreePath path = trees.getPath(element); scanner.scan(path, path.getCompilationUnit()); } }이 코드는 어렵지는 않다. 저 for문은 프로젝트 내에 있는 모든 파일의 클래스를 검사해 Get어노테이션이 붙어 있는것만 가져오는 문장이다.이렇듯 다른 패키지나 다른 곳에 클래스가 있어도컴파일할 때 @Get어노테이션이 있으면 가져온다.가져오고 나서는 element.getKind() != ElementKind.CLASS라는 문구를 통해 해당 어노테이션이 클래스타입에 붙어있는지 확인하고 맞다면 else문을, 아니면 if문을 진행하여 에러를 발생시키고 끝내버린다.내가 InterfaceLombok이라는 인터페이스를 만들고, @Get 어노테이션을 달았다면 컴파일할 때 에러가 뜰 것이다.final TreePath path = trees.getPath(element);TreePath란 자바 프로그램에서 사용되는 코드, 메서드, 클래스, 변수등을 하나의 트리형태의 자료구조로 관리하는 클래스이다.그래서 getPath()메소드를 통해 개발자가 원하는 특정 노드의 경로를 찾을 수 있다.이를 출력하려면 getPathCoponent()메서드를 통해 호출 할 수 있다.//..위에 for문으로 @Get이 달린 모든 요소들을 element에 넣고 있다.final TreePath path = trees.getPath(element);System.out.println(path.getCompilationUnit());//scanner.scan(path, path.getCompilationUnit());실제로 이를 호출해보면@Get어노테이션이 달린 파일의 소스코드를 모두 가지고 있음을 알 수 있다. 여담으로 컴파일러가 생성자가 없는 경우에는 기본 생성자도 알아서 만들어주고, 한글 문자가 유니코드로 변환됨을 알 수 있다.scanner.scan(path, path.getCompilationUnit());scanner는 위에서 변수로 작성되어있는데, 어떻게 작성되어있는지 보겠다.TreePathScanner&amp;lt;Object, CompilationUnitTree&amp;gt; scanner = new TreePathScanner&amp;lt;Object, CompilationUnitTree&amp;gt;(){ @Override public Trees visitClass(ClassTree classTree, CompilationUnitTree unitTree){ JCTree.JCCompilationUnit compilationUnit = (JCTree.JCCompilationUnit) unitTree; // .java 파일인지 확인후 accept 를 통해 treeTransLator, 작성 메소드 생성 if (compilationUnit.sourcefile.getKind() == JavaFileObject.Kind.SOURCE){ compilationUnit.accept(new TreeTranslator() { @Override public void visitClassDef(JCTree.JCClassDecl jcClassDecl) { super.visitClassDef(jcClassDecl); // Class 내부에 정의된 모든 member 를 싹다 가져옴. List&amp;lt;JCTree&amp;gt; members = jcClassDecl.getMembers(); // Syntax tree 에서 모든 member 변수 get for(JCTree member : members){ if (member instanceof JCTree.JCVariableDecl){ // member 변수에 대한 getter 메서드 생성 List&amp;lt;JCTree.JCMethodDecl&amp;gt; getters = createGetter((JCTree.JCVariableDecl) member); for(JCTree.JCMethodDecl getter : getters){ jcClassDecl.defs = jcClassDecl.defs.prepend(getter); } } } } }); } return trees; } };이 코드를 하나씩 까볼 필요가 있다.TreePathScanner&amp;lt;Object, CompilationUnitTree&amp;gt;이 클래스는 자바 컴파일러API가 제공하는 클래스로, 자바 소스 트리 구조를 순회하면서 개발자의 명령어를 수행할 수 있는 트리구조이다.각 요소에 대해서, 첫 번째 자료형은 해당 클래스의 리턴타입을 말하고, 두 번째 자료형은 트리의 루트 요소 타입을 말한다.즉, 이 클래스는 Object형을 반환할 것이고, 트리의 루트 요소 타입은 ComilationUnitTree타입이 될 것이다.그리고 이는 visitClass()를 오버라이드 하게 되어있는데 이는scanner.scan(path, path.getCompilationUnit());이 소스에서 호출하고 있다.디버그를 찍어보면scan()메소드의 accept()라는 메서드가 있는데, 이 부분을 들어가게 되면오버라이드한 visitClass()를 호출하게 되어있다.public Trees visitClass(ClassTree classTree, CompilationUnitTree unitTree)에서 그러면 classTree는 무엇이고, unitTree는 무엇인가classTree는 패키지, 임포트 문을 제외한 자바 소스코드 그 자체이고, unitTree는 패키지, 임포트문을 포함한 자바 소스 코드이다.//classTree@Get()public class Test { public Test() { super(); }}//unitTreepackage me.kms.animal;import me.kms.anno.Get;@Get()public class Test { public Test() { super(); }}그 밑은 자바 코드인지 확인하고 맞다면 TreeTranslator클래스를 만들어서 특정 행동을 수행하게 된다.// java파일인지 확인if (compilationUnit.sourcefile.getKind() == JavaFileObject.Kind.SOURCE){ compilationUnit.accept(new TreeTranslator() { @Override public void visitClassDef(JCTree.JCClassDecl jcClassDecl) { super.visitClassDef(jcClassDecl); // Class 내부에 정의된 모든 member 를 싹다 가져옴. List&amp;lt;JCTree&amp;gt; members = jcClassDecl.getMembers(); // Syntax tree 에서 모든 member 변수 get for(JCTree member : members){ if (member instanceof JCTree.JCVariableDecl){ // member 변수에 대한 getter 메서드 생성 List&amp;lt;JCTree.JCMethodDecl&amp;gt; getters = createGetter((JCTree.JCVariableDecl) member); for(JCTree.JCMethodDecl getter : getters){ jcClassDecl.defs = jcClassDecl.defs.prepend(getter); } } } } }); }즉, 우리는 다시 visitClassDef()가 언제 호출되는지, 호출 내용에 대해 알 필요가 있다. 먼저, compilationUnit.accept로 들어갈 필요가 있다.public void accept(JCTree.Visitor var1) { var1.visitTopLevel(this);}이렇게 구현되어있으며, 이를 또 타고 들어가면translate() 함수는public &amp;lt;T extends JCTree&amp;gt; List&amp;lt;T&amp;gt; translate(List&amp;lt;T&amp;gt; var1) { if (var1 == null) { return null; } else { for(List var2 = var1; var2.nonEmpty(); var2 = var2.tail) { var2.head = this.translate((JCTree)var2.head); } return var1; } }이렇게 구현되어있다. var는 import문과 소스코드를 나눈 스트링을 리스트로 가지고 있다.//var1[0]import me.kms.anno.Get;//var1[1]@Get()public class Test { public Test() { super(); }}그래서 실질적으로 var1을 돌면서 this.translate((JCTree)var2.head)이 문장을 수행해준다.여기서 head란 인덱스로 봐도 무방하다. tail은 끝의 인덱스를 지칭한다.그래서 this.translate()도 봐야하는데,public &amp;lt;T extends JCTree&amp;gt; T translate(T var1) { if (var1 == null) { return null; } else { var1.accept(this); JCTree var2 = this.result; this.result = null; return var2; }}이렇게 구현이 되어있다.내부는 좀 더 복잡하지만, 간단하게 import로 선언된 경로를 하나하나 파싱해가면서 찾아가는 역할을한다. me.kms.anno.Get으로 되어있다면 me를 들리고 그다음 kms를 들리고 .. 이런 작업을 진행한다.그래서 import문을 이렇게 찾아가고 위의 코드에서 var1[1]인 소스코드 부분도 accept()함수를 호출하게 처리하게 된다.이는 좀 더 다르게 동작하는데, 그 이유는 둘의 자료형이 다르기 때문이다.그래서 var1[1]은 JCClassDecl의 accept()를 호출하게 되는데 다음과 같이 구현되어있다.public void accept(JCTree.Visitor var1) { var1.visitClassDef(this);}여기서 우리가 오버라이드해준 vistiClassDef()가 호출이 되는 것이다.그럼 다시 돌아가야한다.그래서 일단 오버라이드한 함수 인자로 임포트문을 제외한 소스코드가 있다고 인지하고 시작하자.public void visitClassDef(JCTree.JCClassDecl jcClassDecl) { super.visitClassDef(jcClassDecl); // Class 내부에 정의된 모든 member 를 싹다 가져옴. List&amp;lt;JCTree&amp;gt; members = jcClassDecl.getMembers(); // Syntax tree 에서 모든 member 변수 get for(JCTree member : members){ if (member instanceof JCTree.JCVariableDecl){ // member 변수에 대한 getter 메서드 생성 List&amp;lt;JCTree.JCMethodDecl&amp;gt; getters = createGetter((JCTree.JCVariableDecl) member); for(JCTree.JCMethodDecl getter : getters){ jcClassDecl.defs = jcClassDecl.defs.prepend(getter); } } }}내부 구현을 보자super.visitClassDef()는 다음과 같이 구현되어 있다.public void visitClassDef(JCClassDecl var1) { //어노테이션 정보를 가지고 있다. var1.mods = (JCModifiers)this.translate((JCTree)var1.mods); //없음 var1.typarams = this.translateTypeParams(var1.typarams); //없음 var1.extending = (JCExpression)this.translate((JCTree)var1.extending); //없음 var1.implementing = this.translate(var1.implementing); //함수에 관한 정보 var1.defs = this.translate(var1.defs); this.result = var1;}인자로 넘어온 값들을 가지고 초기화를 수행한다.기존에는 빈 클래스를 예시르 들었지만, 이해를 돕기 위해 이번에는 멤버변수를 3개 가지고 있는 클래스를 가지고 디버그를 할 것이다. List&amp;lt;JCTree&amp;gt; members = jcClassDecl.getMembers();이 구문은 간단하게 구현되어있다.public List&amp;lt;JCTree&amp;gt; getMembers() { return this.defs;}이렇게 간단하게 구현되어, 멤버 변수, 멤버 함수를 반환한다.그 후, 멤버 변수면 해당 멤버 변수를 가지고 Getter를 만들게 되는데, 이 부분은 개발자가 직접 작성해주어야한다.public List&amp;lt;JCTree.JCMethodDecl&amp;gt; createGetter(JCTree.JCVariableDecl var){ // 필드 이름 변수에 앞문자 대문자로 변경 해주기 String str = var.name.toString(); String upperVar = str.substring(0,1).toUpperCase()+str.substring(1,var.name.length()); return List.of( /** * treeMaker.Modifiers -&amp;gt; syntax tree node 에 접근하여 수정및 삽입하는 역할 * @Parm : treeMaker.Modifiers flag 1-&amp;gt; public , 2-&amp;gt; private, 0-&amp;gt; default * @Parm : methodName &amp;amp; Type, return 정의 */ treeMaker.MethodDef( treeMaker.Modifiers(1), // public names.fromString(&quot;get&quot;.concat(upperVar)), // 메서드 명 (JCTree.JCExpression) var.getType(), // return type List.nil(), List.nil(), List.nil(), // 식생성 this.a = a; treeMaker.Block(1, List.of(treeMaker.Return((treeMaker.Ident(var.getName()))))), null)); }대부분의 내용은 주석을 보면 이해가 되지만 treeMaker.Block() 메서드 생성 부분은 짚고 넘어갈만하다.이 함수는 함수 블럭을 만드는 함수로, 첫 번째 인자값은 접근 지정자이다. 1은 public을 의미한다. 두 번째 인자값은 리스트를 주어야하고, 블록 한 줄을 작성할 수 있게 한다. 저 구문에서는 리턴 값에 쓸 문자열을 지정해준것이다.결국,public { return age;}이런 구문이 만들어질 것이다.그래서 결국, treeMaker에서 제공하는 MethodDef()메서드를 통해public int getAge() public { return age;}를 반환하게 된다.이렇게 모든 멤버변수를 돌면서 getter를 만들고, 이를 JCTree에 넣어준다.그렇게 트리로 만들어진 코드는 컴파일 되어서 클래스 파일로 만들어진다.다음엔 이 방식으로 Getter를 만들어보겠다." }, { "title": "Java Annotation 쓰는이유 중 하나", "url": "/posts/2023-01-26-Annotation_Ad01/", "categories": "Interview", "tags": "interview", "date": "2023-01-26 01:02:00 +0900", "snippet": "Annotation📃배경어노테이션의 의미는 ‘주석’이다. 주석은 코드로만 알기 힘든 내용이나 코드로 설명하기 어려운 디테일한 부분을 설명하기 위해 추가하기도 한다.어노테이션은 그렇기에 소스코드 안에 다른 프로그램을 위한 정보를 미리 약속된 형식으로 포함시키기 위해 작성한다.기존의 자바 웹 어플리케이션은 구성과 설정값들을 외부 XML설정 파일에 명시하여 프로그래밍 되었다. 외부에서 변경될 수 있는 값을 관리하기에 재컴파일 없이 쉽게 변경사항을 적용할 수 있었지만, 프로그램의 규모가 커질수록 설정을 다 적어줘야했고, 프로그램을 작성할때 마다 많은 설정을 작성해야했기에 문제점이 있었다. 이를 해결하기 위해 고안된 문법이 어노테이션이다. 어노테이션은 런타임 또는 컴파일에 어노테이션은 해석될 수 있다. 어노테이션은 보통 문서화, 컴파일러 체크, 코드 분석을 위한 용도로 사용되는데 본질적인 목적은 소스 코드에 메타데이터를 표현하는 것이다.소스 코드에 메타데이터를 표현하다는 것은 정보에 대한 정보를 표시한다는 의미인데..@Override라는 어노테이션은 보통 많이 접해봤으니까 이를 통해 설명을 하자면 @Override 어노테이션의 기능은 뒤에서도 설명하겠지만 명시적으로 이 함수가 오버라이딩 됨을 알려주고 오버라이딩을 하지 않으면 빨간 밑줄이 생기면서 컴파일러에서 경고를 해준다. 이것은 ‘이 함수는 오버라이딩 해야해!’라는 정보를 포함하고 있기에 함수(정보)에 대한 정보를 표시한다는 것이다.// Annotation을 사용한방식@Servicepublic class MyService { // ...}//xml을 사용한 방식&amp;lt;bean id=&quot;myService&quot; class=&quot;com.example.MyService&quot;&amp;gt; &amp;lt;!-- ... --&amp;gt;&amp;lt;/bean&amp;gt;📃종류어노테이션은 Java에 기본적으로 내장되어 있는 것들도 있는데, 이를 Built-in-Annotation이라고 한다. 주로 컴파일러를 위한 것으로 컴파일러에 유용한 정보를 준다.대표적으로Built-in-Annotation@Override위에서 설명했지만 컴파일러에게 현재 메소드가 수퍼클래스의 메소드를 오버라이드한 메소드라는 것을 명시한다.이를 통해 메소드 이름 오타나 오버라이딩을 하지 않으면 컴파일러가 잡아준다.@Deprecated차후 버전에 지원되지 않을 수 있기 때문에 더 이상 사용되지 말아야 할 메소드를 말한다.예로는 최근 스프링에서 웹설정을 위한 어댑터에 @Deprecated가 달리게 되었다.@Deprecatedpublic abstract class WebSecurityConfigurerAdapter implements WebSecurityConfigurer&amp;lt;WebSecurity&amp;gt; { ...}@SupreesWarning프로그래머의 의도를 컴파일러에게 전달하여 경고를 제거한다.회사에서 쓴걸 본 적이 있는데 이걸 지우면 노란줄(warning)이 뜨던것이 이 어노테이션을 달면 사라지는것을 알 수 있었다.@SafeVarargs@SupressWarning과 비슷한데, 변수나 타입에 대한 경고성도 무시한다는 의미다.@FunctionalInterface컴파일러에게 해당 인터페이스가 함수형 인터페이스라는 것을 알린다. @Override와 비슷하게 프로그래머가 실수를 하는것을 미연에 방지한다. 자바의 람다식은 함수형 인터페이스로만 접근이 가능하기 때문이다.@NativeJava 8버전 이후의 새로운 어노테이션이다.이는 필드에만 적용할 수 있고 native code영역과 관련이 있다는것을 명시적으로 알려준다.public final class Integer { @Native public static final int MIN_VALUE = 0x80000000; // omitted}네이티브 영역은 외부 언어로 작성된 파일을 저장하는 메모리 영역인데 보통 C언어로 작성되어 있기에 이를 명시하는 의미로 쓰인다. Native 메서드에서 참조되는 상수 앞에 붙인다고 한다.Meta-Annotation어노테이션에 사용되는 어노테이션으로 해당 어노테이션의 동작대상을 결정한다. 주로 새로운 어노테이션을 정의할 때 사용한다.@Target어노테이션이 적용가능한 대상을 지정하는데 사용한다. {}를 통해 열거할 수도 있다. 패키지, 어노테이션, 멤버 변수 등에 따라 지정할 수 있다.@Retention어노테이션이 유지되는 기간을 지정한다. 세 가지 유지정책(retention policy)를 사용할 수 있다.SOURCE : 소스코드(.java)까지 남아있는다.CLASS : 클래스 파일(.class)까지만 남아있는다. = 바이트 코드RUNTIME : 런타임까지만 남아있는다.이렇게만 설명하면 이해가 되지 않는다.주의!! 레퍼런스가 있긴하지만 제 생각을 곁든 개인적인 견해입니다.먼저 JVM이 동작하는 방식을 알아야할 필요가 있다. compile load.java -&amp;gt; .class -&amp;gt; classLoader in JVM이렇게 되기에 SOURCE는 .java시점에 살아있고, CLASS는 .class시점에 살아있을것이고 실제 프로그램이 구동되면서는 런타임이 된것이므로 RUNTIME에 살아있을 것이다.대표적으로 롬복의 @Getter는 정책이 SOURCE로 되어있는데 컴파일될 때 메서드들의 get()함수를 바이트코드로 생성해 컴파일을 시켜버리고 사라지게 되는것이다.@NonNull의 정책은 CLASS인데 동작방식은 이게 붙어있는데 null을 넣게되면 노란색 경고로 프로그래머에게 알려주는 동작을 한다.Maven/Gradle로 다운받은 라이브러리와 같이 jar파일에는 소스가 포함되어 있지 않기에 SOURCE정책을 사용하는데에 한계가 있다. 이미 컴파일된 파일이기에 어노테이션 정보가 남아있지 않기 때문이다. 그렇기에 .class만 남아있는 라이브러리 경우에 대하여 타입체커, IDE부가기능 등을 사용할 수 있으려면 CLASS에 대한 정책이 필요하게 되는 것이다.RUNTIME정책에 대해서는 자바의 Reflection API등을 통하여 런타임에 어노테이션 정보를 알 수 있다는 의미이다. @Controller, @Service와 같이 스프링이 올라오는 런타임 시점에 스캔이 컴포넌트 스캔이 가능해야하기에 RUNTIME정책을 필요로 한다.@Documented어노테이션에 대한 정보가 javadoc로 작성한 문서에 포함되도록 할 때 사용하는 어노테이션이다.@Inherited어노테이션이 자손 클래스에도 상속되도록 하는 어노테이션이다. 즉, 조상 클래스에 붙이면 자손 클래스도 이 어노테이션이 붙은것과 같이 인식된다.📃 커스텀 어노테이션 만들기커스텀을 해주기 전에 어느상황에서 쓰일 수 있는지 알아야한다.나는 스프링 시큐리티에서 제공하는 기능들을 사용했을때,@GetMappingpublic UserResponse currentUser(@AuthenticationPrincipal UserAuth userAuth) { return userService.getCurrentUser(userAuth);}라는 코드를 테스트하고 싶었다. 하지만 테스트 코드에서는 @AuthenticationPrincipal로 들어와야하는 인자처리를 어떻게 할까?크게 2가지 방법이 있지만 커스텀하기 쉬워서 대표적으로 쓰이는 방법 한가지를 쓰겠다.User객체는 Id, email,username의 필드를 가진다고 친다.먼저 이를 해결하기 위해서는 유저정보를 스프링 시큐리티 컨텍스트에 넣고 이를 테스트할때 꺼내서 쓰거나 그래야할 것이다.이 과정을 테스트 코드 거치기 전에 해줘야할 것인데 어떻게 해줄까?가장 원론적인 방법은 다음과 같다.UserAuth userAuth = UserAuth.builder() .username(&quot;kms&quot;) .email(&quot;test@gmail.com&quot;) .build();Authentication auth = new UsernamePasswordAuthenticationToken(userAuth, &quot;&quot;, null);SecurityContextHolder.getContext().setAuthentication(auth);이런식으로 UserAuth 인스턴스를 만들어서 시큐리티 인증정보 컨택스트에 넣어주면 된다.이 방식은 매 테스트코드마다 넣는것도 번거롭고, 필요한곳에만 가져다 쓰기에도 불편하다.테스트코드위에 어노테이션을 달고, 그 부분에만 설정값을 컨택스트에 넣고 쓰면 좋을것 같다.스프링 시큐리티에서는 WithSecurityContextFactory라는 인터페이스를 제공한다.이 인터페이스를 사용하면 사용자 인증정보를 컨택스트에 넣을 수 있게 강제하는 인터페이스로, 어노테이션 타입과 하나의 메소드를 가진다. 그 메소드는 컨택스트 객체를 생성해야만 한다.public interface WithSecurityContextFactory&amp;lt;A extends Annotation&amp;gt; { SecurityContext createSecurityContext(A annotation);}구현해야할 인자로 어노테이션 타입이 들어와야한다. 해당 어노테이션을 가지고 스프링 시큐리티 컨택스트에 유저정보 값을 넣어줄 것이다.그러면 해당 어노테이션을 만들어야한다.@Retention(RetentionPolicy.RUNTIME)@WithSecurityContext(factory = WithAuthUserSecurityContextFactory.class)public @interface WithAuthUser { long id() default 1L; String email() default &quot;test@gmail.com&quot;; String username() default &quot;kms&quot;;} 커스텀 어노테이션을 만들기 위해서는 @interface를 붙여야한다. @Retention()을 통해 해당 어노테이션이 런타임때까지 남아있어야한다고 한다. @WithSecurityContext()라는 어노테이션은 우리가 만들 WithSecurityContextFactory구현체 클래스 정보를 넣으면 된다. 즉, WithAuthUserSecurityContextFactory는 WithSecurityContextFactory를 구현한 구현체이다.이제 구현체를 만들어보겠다.public class WithAuthUserSecurityContextFactory implements WithSecurityContextFactory&amp;lt;WithAuthUser&amp;gt; { @Override public SecurityContext createSecurityContext(WithAuthUser annotation) { Long id = annotation.id(); String email = annotation.email(); String username = annotation.username(); UserAuth userAuth = UserAuth.builder() .email(email) .username(username) .id(id) .build(); Authentication authentication = new UsernamePasswordAuthenticationToken(userAuth,&quot;&quot;,null); SecurityContext context = SecurityContextHolder.getContext(); context.setAuthentication(authentication); return context; }}인터페이스에서 어노테이션 타입을 받았으므로 우리가 만든 어노테이션을 인자로 넣어주고, 어노테이션에서 값을 꺼내서 컨택스트에 넣는 클래스로 볼 수 있다.정리하자면 WithSecurityContextFactory는 스프링 시큐리티에서 제공하는 컨택스트에 유저정보를 넣고, 그 컨택스트를 반환하는 메소드를 구현하는 메소드를 강제하는 인터페이스이다.이를 구현한 것이 WithAuthUserSecurityContextFactory이고 어노테이션을 인자로 받게 되어있고, 그 어노테이션은 개발자가 만든 커스텀 어노테이션이 되겠다.그럼 어떤 방식으로 이 컨택스트를 테스트때마다 가져다 쓴다는 것인가?그러면 @WithSecurityContext(factory = WithAuthUserSecurityContextFactory.class)의 의미는 무엇일까?@WithSecurityContext()라는 어노테이션은 다음과 같이 구현되어 있다.@Target({ElementType.ANNOTATION_TYPE})@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface WithSecurityContext { Class&amp;lt;? extends WithSecurityContextFactory&amp;lt;? extends Annotation&amp;gt;&amp;gt; factory(); TestExecutionEvent setupBefore() default TestExecutionEvent.TEST_METHOD;}위에서부터 해석을 하자면 @Target({ElementType.ANNOTATION_TYPE}): 어노테이션에 붙을 수 있다. @Retention(RetentionPolicy.RUNTIME): 런타임때까지 살아있다. 이를 통해 Refelction을 사용할 수 있다. @Inherited: 상속을 가능하게 한다. @Documented: 문서화가 되어있다. factory()메서드는 구현된 WithSecurityContextFactory를 리턴하도록 되어있다. setupBefore()는 기본값으로 TestExecutionEvent.TEST_METHOD를 가지도록 되어있다. 이 뜻은 테스트 메서드가 수행되기 전에 어노테이션을 실행한다는 뜻이다.즉, 테스트 메서드가 실행되기 전에 factory()메서드에 반환된 컨택스트의 설정 및 초기화를 실행하고 해당 설정값을 가지고 테스트 메서드의 인증 과정을 수행한다.📃 해석아무런 정보가 없는데 해석을 어떻게 한 것인가? 사실 어노테이션의 내부 메서드 구현방식은 보기는 굉장히 까다롭다 IDE에서도 타고갈 수도 없기에 이를 해석하기 위해서는..공식문서롤 보거나 여러 커뮤니티를 돌아다니면서 알아보거나 직접 여러 상황을 테스트코드를 작성해서 유추하거나 하는 등의 방법밖에 없다고 나는 알고 있다.더 찾아봐도, 코드 단에서 내부 구현방식을 정확히 알기 위해서는 본인이 직접 유추하는 수 밖에 없다는 말이다.왜 그런식으로 만들었을까? chatGPT의 말을 요약하자면 다음과 같이 정리할 수 있다.우리가 인터페이스를 사용하는 이유와 비슷한데, 내부 구현은 외부 사용자에게 보여주지 않도로 함으로써, 캡슐화와 추상화를 보장하고 사용자 입장에서는 내부 구현방식을 몰라도 사용만 할 수 있게 만든다.사실 Reflection을 통해서 어노테이션 속성값들을 찾고 그 내부구현을 유추할 수 있기도 한다." }, { "title": "Java Reflection 정리", "url": "/posts/2023-01-19-Reflection/", "categories": "Interview", "tags": "interview", "date": "2023-01-19 02:02:00 +0900", "snippet": "Java Reflection✏️ 개요 Java 1.1버전에서 나온 Reflection은 런타임때 클래스나 객체를 생성, 호출하여 동적으로 객체를 다루는 기술을 말한다.✏️ 나오게 된 배경Java 프레임워크나 라이브러리 개발시 클래스의 메타데이터를 조작하는데 기능을 제공하기 위해 고안되었다.즉, 프레임워크에서 제공하는 API를 이용하여 클래스를 호출하고 생성하는 방식이 아닌, 클래스의 이름을 이용하여 동적으로 클래스를 생성하고 호출할 수 있도록 하여 프레임워크의 사용성을 높이게 한다.✏️ 동적으로 생성시의 이점Reflection을 이용해 객체를 동적으로 다루는 것은 어떤 이점이 있나 유연성: 코드 내에서 클래스나 객체를 생성하거나 호출하는 방법을 동적으로 바꿔 유연성을 갖게 한다.public class MyClass { public void testFunction(){ System.out.println(&quot;hello function&quot;); }}@Testvoid Reflection_유연성테스트() throws Exception { //경로명을 적어줘야한다. String className = &quot;MyClass&quot;; Class&amp;lt;?&amp;gt; clazz = Class.forName(className); Object obj = clazz.getDeclaredConstructor().newInstance(); Method method = clazz.getMethod(&quot;testFunction&quot;); method.invoke(obj);}대표적으로 Spring FrameWork에서 의존성 주입으로 자주 쓰이는 @Autowired를 처리하는 부분은 Reflection을 사용하고 있다.이는 AutowiredAnnotationBeanPostProcessor라는 클래스로 다음과 같이 구현되어 있다.protected boolean checkAutowiredAnnotation(AnnotatedElement ae) { Autowired autowired = ae.getAnnotation(Autowired.class); if (autowired != null) { if (Modifier.isStatic(ae.getModifiers())) { throw new IllegalStateException(&quot;Autowired annotation is not supported on static fields&quot;); } return true; } else { return false; }}@Autowired를 탐색할때 java.lang.reflect.Field, java.lang.reflect.Constructor 클래스를 이용해서 클래스를 사용하고, 해당 필드나 생성자에 값을 주입할 때도 Reflection을 사용한다.간단하게 인스턴스를 생성해서 해당 인스턴스 필드값을 바꾸는 예제를 보겠다.public class MyClass { private String name; public MyClass(String name){ this.name = name; } public MyClass() { } public void testFunction(){ System.out.println(&quot;hello function&quot;); } public String getName() { return name; }} private 이라는 필드에 접근하여 해당 값을 바꿔줄 것이다. @Test void Reflection_Field_search() throws Exception{ MyClass clazz = new MyClass(); // clazz.getField(&quot;name&quot;); -&amp;gt; public만 접근가능 Field name = clazz.getClass().getDeclaredField(&quot;name&quot;); name.setAccessible(true); name.set(clazz,&quot;kang min seok&quot;); System.out.println(clazz.getName()); } getField()는 public 필드에만 접근이 가능하다. 때문에 Field.setAccessible(true)를 통해 접근제어자를 풀어줘야한다.성공적으로 값이 바뀌였다.이를 활용해서 @Autowired기능을 구현해보았다.public class MyClass { private String name; @Autowired private int age; @Autowired private OtherClass otherClass;}public class OtherClass {}@Testvoid Reflection_AutowiredTest() throws Exception{ MyClass bean = new MyClass(); Field[] fields = bean.getClass().getDeclaredFields(); for(Field field: fields){ System.out.println(field.getType()); if(field.isAnnotationPresent(Autowired.class)){ Object dependency = applicationContext.getBean(field.getType()); field.setAccessible(true); field.set(bean,dependency); } } //return bean;}간단하게 짰지만,이런식으로 @Autowired가 붙은 모든 필드를 탐색하고 의존성 주입을 넣고 해당 빈을 반환해줄 수 있다.✏️ 다른 예시다른 예시로, Java Reflection을 통해 ORM을 구현할 수 있다. ORM은 데이터베이스 테이블과 객체를 매핑하는 기술로, 객체의 필드와 데이터베이스 컬럼을 자동으로 매핑할 수 있다.@Entity@Builderpublic class User { @Id private int id; private String name; private int age; //getter, setter 생략}public class SimpleORM { public static void insert(Connection conn, Object object) throws SQLException, IllegalAccessException { Class&amp;lt;?&amp;gt; clazz = object.getClass(); String tableName = clazz.getSimpleName(); StringBuilder columns = new StringBuilder(); StringBuilder values = new StringBuilder(); for (Field field : clazz.getDeclaredFields()) { field.setAccessible(true); columns.append(field.getName()).append(&quot;, &quot;); values.append(&quot;&#39;&quot;).append(field.get(object)).append(&quot;&#39;, &quot;); } String sql = &quot;INSERT INTO &quot; + tableName + &quot;(&quot; + columns.substring(0, columns.length() - 2) + &quot;) VALUES(&quot; + values.substring(0, values.length() - 2) + &quot;)&quot;; PreparedStatement stmt = conn.prepareStatement(sql); stmt.execute(); }}이 코드는 만약 SimpleORM.insert(user)라는 코드를 실행하였을때, user에 있는 필드값들을 쿼리에 순차적으로 넣어서 테이블에 저장이 되는 코드이다.✏️ 보안적 이슈?보면 private에도 접근이 가능하고, 다른사람이 만든 클래스에 무작위로 접근해서 값을 바꿀 수도 있을 것 같다.보안적 이슈가 생길 것 같아서 이를 해결할 수 있는 방법들을 찾아보았다. Security Manager: Java에서는 보안 관리자를 사용하여 클래스나 메소드에 대한 접근 권한을 제어할 수 있다. Input Validation: 특정 클래스에 대한 Reflection을 허용하는 경우 입력값을 적절하게 검증한다. 잘못된 입력값으로 인해 발생할 수 있는 취약점을 방지할 수 있다.//Security Managerimport java.lang.reflect.ReflectPermission;public class MySecurityManager extends SecurityManager { @Override public void checkPermission(Permission perm) { if (perm instanceof ReflectPermission) { if (perm.getName().startsWith(&quot;suppressAccessChecks&quot;)) { if (!perm.getName().startsWith(&quot;suppressAccessChecks-com.mypackage&quot;)) { super.checkPermission(perm); } } else { super.checkPermission(perm); } } }}//main FunctionMySecurityManager securityManager = new MySecurityManager();System.setSecurityManager(securityManager);이 코드는 com.mypackage패키지에 포함된 클래스만 Reflection을 허용하고, 그 외는 금지시키는 코드이다.인자로 들어오는 perm의 속성이 com.mypackage로 시작하는지 확인하고 맞다면 권한 체크를 하지 않고 넘어가고, 아니면 SecurityManage에 정의된 메서드를 호출하여 권한 체크를 한다.//Input ValidationString className = &quot;com.example.MyClass&quot;;if(!className.startsWith(&quot;com.example&quot;)) { throw new IllegalArgumentException(&quot;Invalid class name&quot;);}Class&amp;lt;?&amp;gt; clazz = Class.forName(className);Object obj = clazz.newInstance();Method method = clazz.getMethod(&quot;performFunction&quot;);method.invoke(obj);이렇게 입력값을 검증하여 체크하는 방식도 있다. 이 방식을 사용하여 메서드 인자도 검증하여 SQL Injection, XSS등의 취약점을 방지하는데 도움이 될 수 있다니 알아두자.🙌결론Java Reflection은 런타임때 클래스, 인터페이스, 필드, 메서드 등을 동적으로 조작하여 코드의 유연함과 코드를 분리하여 유지보수성과 재사용성이 높아지게 하는 기능이다." }, { "title": "Java Google Convention 규칙 정리", "url": "/posts/2023-01-19-javaconvention/", "categories": "Interview", "tags": "interview", "date": "2023-01-19 01:02:00 +0900", "snippet": "Java 컨벤션 규칙✏️ 개요https://google.github.io/styleguide/javaguide.html에서 제공하는 문서 번역✏️ 1. Introduction class라는 용어는 일반적인 클래스, enum, interface 또는 @interface을 포함한다. member라는 용어는 중첩 클래스, 필드, 메소드, 생성자를 포함한다. 즉, 클래스의 초기화 코드와 주석 제외한 것들을 의미한다. ‘주석’이라는 용어는 항상 구현 주석을 의미한다. 보통 javadoc라고 한다.✏️ 2. Source file basics2.1 File name 소스 파일은 최상위 클래스의 대소문자를 구분하는 이름과 .java확장자로 구분된다.2.2 File encoding: UTF-8 파일 인코딩은 UTF-8로 설정한다.2.3 Special characters2.3.1 Whitespace characters줄 끝을 나타내는 문자(\\n, 등)을 제외하고, 띄어쓰기(0x20)는 소스파일에서 어떤 곳에서도 나타나는 유일한 공백 문자이다. 탭 문자는 들여쓰기로 사용되지 않는다. 즉, 코드의 들여쓰기는 스페이스 문자나 스페이스 문자 여러개를 사용해야한다는 뜻이다. 그 이유는 탭 문자를 사용할 경우 들여쓰기가 일관적이지 않을 수 있기 때문이다. if (x &amp;gt; 0) { // 탭 문자가 사용된 들여쓰기 System.out.println(&quot;x is positive.&quot;);} else { // 스페이스 문자가 사용된 들여쓰기 System.out.println(&quot;x is non-positive.&quot;);}2.3.2 Special escape sequences\\b,\\t,\\n,\\f,\\r,.. 등과 같은 특수한 이스케이프 시퀸스는 이대로 사용되어야지, 유니코드나 8진수로 표현하면 안된다.//correctString s = &quot;This is a string with a newline.\\n&quot;;char c = &#39;\\n&#39;;//wrongString s = &quot;This is a string with a newline.\\u000a&quot;;char c = &#39;\\u000a&#39;;✏️ 3. Source file structure소스파일은 다음의 순서로 구성된다. 라이선스, 저작권 정보(있다면) 패키지 선언 임포트 선언 정확히 한 개의 최상위 클래스각 세션 사이는 하나의 라인으로 분리할 것. 1) 라이선스, 저작권 정보: 해당 정보는 파일 바로 아래에 적으면 된다. 2) 패키지 선언: 줄 바꿈이 되지 않고, 열 제한은 100은 패키지 선언에 적용되지 않는다. 3) 임포트 선언 *를 사용한 와일드카드 임포트나 static을 사용한 임포트를 사용하지 않는다. 그 이유는 해당 심볼이 어디서 가져와진건지 이해하기 어려울 수도 있고, 여러 모듈에서 동일한 심볼을 호출할 경우 충돌이 발생할 수 있다. 여러 심볼을 임포트할 때 여러줄로 나누어 가져오거나, 줄 바꿈을 해서 가져오면 안된다. 100자를 초과하더라도 한 줄로 가져와야 한다. //이러면 안 됨.import java.util.List, java.util.ArrayList, java.util.Map, java.util.HashMap; static이든 non-static이든 import문은 한 줄에 하나씩 작성한다. import mypackage.MyClass;import mypackage.MyInterface;import java.util.List;import java.util.ArrayList;import java.util.Map;import java.util.HashMap;import com.example.util.StringUtils;import org.example.data.DataModel; static import할 때 중첩 클래스를 임포트하지 않도록 권고한다. 4) 한 개의 최상위 클래스가 소스파일에 존재해야한다. 메소드나 멤버변수 등이 추가될 때는 어떠한 논리로 의해 순서가 정해져있으며, 잘 설명할 수 있기만 하면된다.즉, 습관적으로 멤버변수나 메소드를 바로 밑에 추가하는 방식을 하는게 아니다. ✏️ 4. Formatting4.1 Brace if,else,for,do,while 등을 사용할 때, 내용이 비어있거나 단일 표현식이라해도 Braces를 사용해야 한다. Nonempty blocks {뒤에는 줄바꿈이 있어야한다. } 전에는 줄바꿈이 있어야한다. 몇 가지 예외가 있는데, }뒤에 ;가 나오는 경우나 else if문, else문 등의 경우가 있다. return () -&amp;gt; { while (condition()) { method(); }};return new MyClass() { @Override public void method() { if (condition()) { try { something(); } catch (ProblemException e) { recover(); } } else if (otherCondition()) { somethingElse(); } else { lastThing(); } { int x = foo(); frob(x); } }}; Empty blocks: {}이 구문 쓰일 수 있다. 하지만, multi-block statement에서는 불가능하다.예를 들어서// 가능void doNothing() {}// 가능void doNothingElse() {}// 불가능try { doSomething();} catch (Exception e) {}4.2 Block Indentation block안에 코딩을 할때는 2칸을 띄어라. block이 끝나면 이 전 idenet를 따르라는 의미도 포함.4.3 One statement per line 각각의 표현식은 한 줄로 작성한다.4.4 Column limit: 100 Java 코드는 줄마다 100자의 character 제한이 있다. 예외1: javadoc의 긴 URL 등을 참조하는 경우 예외2: 제일 첫 상단의 package구문이나 import구문 예외3: 매우긴 식별자(대부분 써드파티 라이브러리나 API를 말하는 듯. 통상적으로는 길게 작성하는건 안됨.) customer_order_transaction_history와 같은 DB에 접근할 때 등 4.5 Line-wrappingLine-wrapping이란, 한 줄을 합법적(?)으로 코드가 여러줄로 분할시키는 일련의 작업을 말한다.이 작업을 통해 코드 가독성을 높이고, 더 이해하기 쉽게 만든다. 줄바꿈에 대한 정확한 가이드라인은 없지만, 어떠한 패턴이 있다고 한다. 함수나 지역변수로 추출하는 방식은 굳이 Line-wrapping을 사용하게 안할 수도 있다. 일반적으로 열 제한에 걸리는 경우 사용하지만, 굳이 걸리지 않더라도 개발자의 재량에 따라 사용할 수 있다.Where to break 라인을 나누는 곳은 대입 연산자 이외의 연산자 앞에서 나누는 것을 권장한다고 한다.int result = number1 + number2 + number3;float sum = float1 + float2; 대입 연산자 앞 또는 뒤에 라인을 나누는것도 가능은 하다. 메소드나 생성자에 구문 다음에 나오는 (는 같은 줄에 작성해야 한다.//wrongpublic void doSomething() { // code here}//correctpublic void doSomething() { // code here} 람다식에 나오는 화살표는 바로 라인을 분리할 수 없도록 해야한다. 단, 다음에 나오는 구문이 한 줄인 경우는 가능하다.MyLambda&amp;lt;String, Long, Object&amp;gt; lambda = (String label, Long value, Object obj) -&amp;gt; { ... };Predicate&amp;lt;String&amp;gt; predicate = str -&amp;gt; longExpressionInvolving(str); 줄바꿈을 수행할 때 첫 줄은 원래 줄의 +4 이상 들여쓰기를 해야한다.4.6 WhitespaceVertical Whitespace가독성을 위해 공백을 추가하는 것이다.class MyClass { public void myMethod() { // code here }}보다는class MyClass { public void myMethod() { // code here }}이런식으로 각 메서드 사이나, 생성자와 멤버변수 사이 등 집어 넣을 수 있다.Horizontal whitespace if, for, catch 등의 구문에서 (를 분리하여 작성하도록 한다.if(x&amp;gt;0)//보다는if (x &amp;gt; 0)//를 사용하자고 한다. else, catch와 같은 예약어는 }를 분리하여 작성하도록 권장하고 있다.}else} else &amp;lt;T extends Foo &amp;amp; Bar&amp;gt;처럼 &amp;amp;로 두 타입을 이을때도 분리하여 사용하도록 권장하고 있다. catch (FooException | BarException)처럼 |(파이프라인)연산자를 사용할 경우에도 분리하도록 권장하고 있다. foreach() 구문의 :연산자를 사용할 때에도 -&amp;gt;를 이용한 람다식에서도 ex) (String str) -&amp;gt; str.length() 분리하도록 권장하고 있다.단, ::같은 메서드 참조나 .을 이용한 메서드 접근자는 제한다. :, ,, ; 혹은 ) 다음에는 공백을 두지 않도록 한다. (사이는 공백을 두는것을 권장) 배열같은 요소를 초기화할때는 이 두 용법 전부 허용한다.new int[] {5, 6}new int[] { 5, 6 }Horizontal alignment: never required수평정렬 하지마.private int x; // 허용하지만 나중에 수정할 가능성이 크다.private String str; 4.7 Grouping parentheses: recommendedif (x &amp;gt; 0 &amp;amp;&amp;amp; x &amp;lt; 10)처럼 어떠한 연산을 위해 괄호를 통해 그룹으로 묶어버리는것을 말한다. 이를 적극 활용하라는 이야기.4.8 Specific constructsEnum classes보통 ,뒤에 줄바꿈을 해주는데 특별한 경우는 추가적인 공백을 넣어줄 수 있다.private enum Answer { YES { @Override public String toString() { return &quot;yes&quot;; } }, NO, MAYBE}나는 이렇게 쓰는 경우가 있는지 잘 모르겠으니, 알아서 그렇구나 하고 넘어가자.그리고 enum에 함수가 없거나 추가적인 언급이 없는 경우 배열처럼 쓸 수 있다.private enum Suit { CLUBS, HEARTS, SPADES, DIAMONDS }Variable declarationsint a, b; //(x)int a;int b; 즉, 선언은 한 변수당 한 줄에 쓰자고 권장한다. for문에서 선언되는 경우는 제외 지역변수는 습관적으로 맨 상단에 선언하는 경우가 있는데, 이 보다는 범위를 최소화하기 위해 실질적으로 쓰이는 곳 주변에 적절히 선언하는 것이 좋다. 초기화의 경우는 선언과 같이 해주거나, 선언 직후 해주는 편이 좋다.Arraynew int[] { new int[] { 0, 1, 2, 3 0,} 1, 2,new int[] { 3, 0, 1, } 2, 3} new int[] {0, 1, 2, 3}다 된다. C스타일로 쓰지마라. String[] args지, String args[]가 아니다.Switch statements Switch구문의 indent 는 최소 +2로 한다. fall-through을 의도적으로 발생시키면 주석을 달아 놓는다.switch (input) { case 1: case 2: prepareOneOrTwo(); // fall through // 일부러 case1을 통과한 이유를 적으면 된다. case 3: handleOneTwoOrThree(); break; default: handleLargeNumber(input);} 추가적인 구문이 없다해도 default는 적어준다. 단 enum클래스를 사용하는 경우 생략할 수 도 있다.Annotations 만약 자료형 어노테이션을 사용하면 특정 자료형 앞에 나와야 한다.final @Nullable String name; 만약 클래스에 붙는 어노테이션을 사용할 경우 각 어노테이션은 하나에 한 줄을 사용한다.@Deprecated@CheckReturnValuepublic final class Frozzler { ... } 메소드나 생성자에 붙는 어노테이션도 위와 동일하다. 필드형 어노테이션도 위와 동일하지만, 여러개의 어노테이션이 붙는 경우에는 같은 라인에 쓸 수도 있다.@Partial @Mock DataLoader loader;Comments/* * 만약 이렇게 새 줄이 시작 되면 &#39;*&#39;을 처음 넣어주면 좋다. * This is // And so /* Or you can * okay. // is this. * even do this. */ */다 된다.Modifiers다음과 같은 순서로 선언문을 작성하면 된다.public protected private abstract default static final transient volatile synchronized native strictfpNumeric LiteralsLong타입을 사용하여 변수를 초기화 해주는 경우 l을 쓰지말자. 1과 혼동한다. 즉, 3000L처럼 L을 사용하자.✏️ 5. Naming5.1 Rules common to all identifiersGoogle Style에서는 특별한 접두사나 접미사가 불필요하다. name_, mName, s_name, kName과 같은거 필요 없다.5.2 Rules by identifier type package 이름은 소문자와 숫자만을 사용하여 작성한다. Class의 이름은 카멜규칙을 적용한다. 첫 글자는 대문자를 사용한다. Test 클래스의 이름은 끝에 Test를 붙인다. Method의 이름은 카멜규칙을 사용하지만, 클래스와 다르게 첫 글자는 소문자로 쓴다. Constant의 이름은 스네이크규칙을 적용한다. 모두 대문자를 쓴다. // Constantsstatic final int NUMBER = 5;static final ImmutableList&amp;lt;String&amp;gt; NAMES = ImmutableList.of(&quot;Ed&quot;, &quot;Ann&quot;);static final Map&amp;lt;String, Integer&amp;gt; AGES = ImmutableMap.of(&quot;Ed&quot;, 35, &quot;Ann&quot;, 32);static final Joiner COMMA_JOINER = Joiner.on(&#39;,&#39;); // because Joiner is immutablestatic final SomeMutableType[] EMPTY_ARRAY = {}; Non-Constant의 이름은 카멜규칙을 적용한다. 첫 글자만 소문자를 사용한다. Parameter의 이름도 위와 동일하다. Local variable도 동일하다. Type varaible은 하나의 문자인 경우 T, E, X2처럼 대문자를 사용하고 문자 뒤에 숫자가 나온다. 그렇지 않은 경우 Class의 규칙을 적용한다. 그리고 뒤에 T를 붙인다. ex) RequestT … 5.3 Camel case: defined눈으로 확인하라✏️ 6. Programming Practies6.1 @Override: always used @Override 무조건 써라. 단 한 가지의 예외가 있다. 만약 부모의 함수가 @Deprecated에 의해 생략될 수 있는 경우에만6.2 Caught exceptions: not ignored 예외를 잡았을때 해당 예외를 무시하지말라. 예시로 아무런 조치를 취하지 않는다면 주석을 달아놓은 코드 try { int i = Integer.parseInt(response); return handleNumericResponse(i);} catch (NumberFormatException ok) { // it&#39;s not numeric; that&#39;s fine, just continue}return handleTextResponse(response);예외를 잡았다면 어떤 조치를 취해야한다.e.printStatckTrace()같은 코드를 넣으면서 자신의 Custom Error를 발생시키는것도 방법이다.6.3 Static members: qualified using class 만약 정적 멤버(static member)를 사용할 때 해당 멤버를 소유하는 클래스를 참조하도로 권고한다.Foo aFoo = ...;Foo.aStaticMethod(); // goodaFoo.aStaticMethod(); // bad 인스턴스를 만들어서 사용하는 방법somethingThatYieldsAFoo().aStaticMethod(); // very bad 어떤 함수가 반환하는 객체의 메서드를 호출하는 방법6.4 Finalizers: not used finalizer를 사용하지마. 자바18에서부터 얘를 없앨 준비를 하고 있다. 해당 메서드는 객체의 리소스를 해제시키는 등의 처리를 할 수 있는데, 보통 가비지 컬렉터가 실행될 때 사용된다. 즉, 프로그래머가 해당 메서드를 사용하면 가비지컬렉터의 효율성이 저하될 수 있으며, 안정성 또한 저하될 수 있다. 🔅 Reference ChatGPT https://google.github.io/styleguide/javaguide.html" }, { "title": "my-Repository-Traffic프로젝트 이슈 - Python third-party mocking하기", "url": "/posts/2023-01-08-toyissue01/", "categories": "Toy, my-Repository-Traffic", "tags": "Spring", "date": "2023-01-08 01:02:00 +0900", "snippet": " my-Repository-Traffic 저장소😂 개요프로젝트는 github API를 다른 Third-party를 이용해서 호출하고 있었다.유닛 테스트를 위해 테스트코드를 짜려다보니.. Third-party API들은 어떻게 모킹하지?의문이 들었다.chatGPT에게 물어봐서 해결하긴 했지만 그 과정을 적고 이해하기 위해 블로그에 적는다.🔅 환경def get_all_repositories_cloner(repositories: github.PaginatedList.PaginatedList) -&amp;gt; dict: cloner_counts = {} for repository in repositories: clone_traffic = get_repository_clone_traffic(repository) unique_cloner = clone_traffic[&#39;uniques&#39;] if unique_cloner == 0: continue cloner_counts[repository.full_name] = unique_cloner return cloner_countsdef get_repository_clone_traffic(repository: github.Repository.Repository) -&amp;gt; dict: return repository.get_clones_traffic()이 코드를 테스트해야한다.get_all_repositories_cloner() 파라미터를 보면 github.PaginatedList.PaginatedList라는 타입을 받는데, 이는 pygithub라는 써드파티에서 제공하는 자료형이다.for문을 도는 부분이 있는데, 이 코드가 돌 수 있게 적절히 모킹해줘야한다.또한 cloner_counts[repository.full_name]에 repository.full_name에 접근할 수 있도록 모킹해줘야한다.그렇기에 repositories라는 인자를 모킹해줘야하고, get_repository_clone_traffic() 모킹, for문을 돌 수 있게 해야하고, .연산자를 사용하기 위한 객체로 만들어야한다.😊 방법@pytest_asyncio.fixtureasync def repositories() -&amp;gt; github.PaginatedList.PaginatedList: class Repository: def __init__(self, full_name): self.full_name = full_name mock_paginated_list = MagicMock(spec=github.PaginatedList.PaginatedList) mock_paginated_list.__iter__.return_value = iter([ Repository(full_name=&quot;kkminseok.repo1&quot;), Repository(full_name=&quot;kkminseok.repo2&quot;), Repository(full_name=&quot;kkminseok.repo3&quot;), ]) return mock_paginated_list먼저, PaginatedList 자료형으로 반환해야하고, .연산자를 사용하기 위해 클래스로 만들어서 리턴하도록 하였다.그리고, for문을 돌기 위해서 __iter__를 모킹하였고, MagicMock을 통해 자료형을 지정하였다.실제 테스트 코드에서는def test_get_all_repositories_cloner(repositories: github.PaginatedList.PaginatedList, mocker: MockerFixture): mocker.patch(&quot;git_utils.get_repository_clone_traffic&quot;, return_value={&quot;uniques&quot;: 100}) result = get_all_repositories_cloner(repositories) assert len(result) == 3 assert result[&#39;kkminseok.repo1&#39;] == 100 assert result[&#39;kkminseok.repo2&#39;] == 100 assert result[&#39;kkminseok.repo3&#39;] == 100이렇게 호출해주면 된다.막상 짜고나니 별 거 아닌데.. 은근 모킹하는데 오래 걸렸다." }, { "title": "Java 8버전은 뭐가 달라졌나 상세파악", "url": "/posts/2022-12-30-Java8Version/", "categories": "Java, CS", "tags": "Java", "date": "2022-12-30 01:02:00 +0900", "snippet": "🔅 Java82014년 3월 18일에 출시된 Java버전이다. 크게 다음과 같은 변화가 있었다. Functional Interfaces 와 Lambda표현식 추가 forEach()메소드 추가. Interface에 Default Static Method 추가 Stream API 추가 새로운 날짜/시간 API 추가 Collection API 향상 동시성 관련 API 향상 Java IO 향상 여러 API 개선 Optional Class 추가✏️ 1. Functional interface, Lambda 추가Functional interface Functional Interface: 1개의 추상 메소드를 갖고 있는 인터페이스. Single Abstract Method라고도 한다.왜 함수형 인터페이스는 추상 메서드를 1개만 가져야할까? 이는 인터페이스의 메소드가 단 하나의 기능을 제공해야하기 때문이다.그래서 혹여나 개발자가 2개의 추상 메서드를 적용시킬 수 있으므로 @FunctionalInterface라는 어노테이션을 인터페이스 위에 붙여서 컴파일러에게 검증을 요청하고, 컴파일 에러를 발생시킨다. 즉, @Override와 비슷하게 개발자의 실수와 협업시의 소통의 목적이 비슷한 것이다.그리고 이를 사용하는 이유는 자바8에 추가된 Lambda식이 함수형 인터페이스로만 접근이 가능하기 때문이다.이는 자바에서 함수형 개발 패러다임을 지원하기 시작하면서 인터페이스의 어떤 로직을 값으로 쓰기 위함이다.public interface FunctionalInterfaceClass { public abstract void outputText(String text);}@Testvoid java8FunctionalTest(){ FunctionalInterfaceClass func = text -&amp;gt; { System.out.println(text); }; //output: java8 버전의 람다와 함수형 인터페이스 테스트 func.outputText(&quot;java8 버전의 람다와 함수형 인터페이스 테스트 &quot;);}위는 람다식의 구현예제이고, 익명 클래스로 구현도 가능하다.@Testvoid java8FunctionalTestAnonymousfunction(){ FunctionalInterfaceClass func = new FunctionalInterfaceClass() { @Override public void outputText(String text) { System.out.println(text); } }; func.outputText(&quot;java8 버전의 람다와 함수형 인터페이스 테스트 &quot;); FunctionalInterfaceClass func2 = new FunctionalInterfaceClass() { @Override public void outputText(String text) { System.out.println(text.toUpperCase()); } }; func2.outputText(&quot;java8 버전의 람다와 함수형 인터페이스 테스트 &quot;);}//output//java8 버전의 람다와 함수형 인터페이스 테스트 //JAVA8 버전의 람다와 함수형 인터페이스 테스트 확실히 람다식을 썼을때와 비교해서는 익명 클래스는 보기 복잡함과 간결함이 부족하다.Lambda람다를 정리는 이 글의 목적이 아니므로 간단히 설명하고 넘어가야한다. 람다 표현식: 익명 함수로, 이름이 없고 식별자만 있는 함수이다. 일반적으로 다른 함수의 매개변수로 정의되는 곳에서 정확하게 정의된다.기본적인 구조는 다음과 같다.(parameters) -&amp;gt; expression간단하게 이러한 예제로 덧셈 예제가 있는데 위의 구조를 사용하면(int x, int y) -&amp;gt; x+y로 표현할 수 있다. 이 함수의 이름은 없고 식별자만 있다는것이다.람다를 사용하기 위해서 함수형 인터페이스를 하나 만든다.@FunctionalInterfacepublic interface LambdaSumInterface { public abstract int sum(int x, int y);}그리고 위에서 정의한 구조 그대로 사용하면 된다.@Testvoid lambdaSumTest(){ LambdaSumInterface result = (int x,int y) -&amp;gt; x+y; //10 result.sum(5,5);}간단하고 자주 쓰이는 함수형 인터페이스들은 매 번 선언하기가 귀찮을 것이다 그래서 자바에서 기본적으로 제공하는 함수형 인터페이스들이 있다. Runnable: 인자를 받지 않고 리턴값도 없는 인터페이스@Testvoid runAbleTest(){ Runnable consoleOutPut = () -&amp;gt; System.out.println(&quot;인자도 없고 리턴도 없다.&quot;); //run()을 통해 호출 가능. //output: 인자도 없고 리턴도 없다. consoleOutPut.run();} Supplier: 인자를 받지 않고 T 타입의 객체를 리턴한다.@Testvoid supplierTest(){ Supplier&amp;lt;String&amp;gt; consoleOutput = () -&amp;gt; &quot;abcdefg&quot;; //get()으로 리턴값을 받아올 수 있다. String output = consoleOutput.get(); //2차 작업 대문자로 변환 System.out.println(output.toUpperCase());} Consumer: T타입의 객체를 인자로 받고 리턴은 없다.@Testvoid consumerTest(){ Consumer&amp;lt;String&amp;gt; myBlogURL = username -&amp;gt; System.out.println(&quot;https://&quot; + username + &quot;/github.io&quot;); //output: https://kkminseok/github.io myBlogURL.accept(&quot;kkminseok&quot;);} Function: Function&amp;lt;T, R&amp;gt;은 T타입의 인자를 받고, R타입의 객체를 리턴@Testvoid functionTest(){ Function&amp;lt;String,String&amp;gt; myBlogURL = username -&amp;gt; &quot;https://&quot; + username + &quot;/github.io&quot;; String url = myBlogURL.apply(&quot;kkminseok&quot;); //output: https://kkminseok/github.io System.out.println(url);} Predicate: Predicate&amp;lt;T&amp;gt;은 T타입의 인자를 받고, boolean을 리턴@Testvoid predicateTest(){ Predicate&amp;lt;String&amp;gt; isMyBlogURL = url -&amp;gt; url.equals(&quot;https://kkminseok/github.io&quot;); boolean result = isMyBlogURL.test(&quot;https://kkminseok/github.io&quot;); //true System.out.println(result);}좀 더 복잡한 기능들도 존재하고 정리하자니 이글이 너무 무거워질까봐 궁금하면 찾아보자.일단 이제부터 이 함수형 인터페이스에 기반하여 여러 기능들이 생겨났으니 한 번 보자.✏️ 2. foreach() 메소드 추가foreach() 메소드는 List, Map과 같은 여러 자료구조를 순회하면서 개발자가 지정한 작업을 수행하게 도와준다.foreach()는 위에서 설명한 Consumer을 인자로 넘기고 이 함수형 인터페이스의 메소드를 적용한다.Java8 버전 이전에는 배열을 Iterator를 통해 순회하여 작업을 한다면 다음과 같이 작업했다.//java8이전@Testvoid foreachTestBeforeJava8(){ List&amp;lt;String&amp;gt; subList = new ArrayList&amp;lt;String&amp;gt;(); subList.add(&quot;Carrot&quot;); subList.add(&quot;Potato&quot;); subList.add(&quot;Cauliflower&quot;); subList.add(&quot;LadyFinger&quot;); subList.add(&quot;Tomato&quot;); Iterator&amp;lt;String&amp;gt; it = subList.iterator(); while(it.hasNext()){ System.out.println(it.next()); }}Iterator를 변수로 선언하며, 끝을 돌 때까지 작업을 해줬다.이제 foreach()를 통해 람다식으로 간단하게 표현이 가능해졌다.@Testvoid foreachTest(){ List&amp;lt;String&amp;gt; subList = new ArrayList&amp;lt;String&amp;gt;(); subList.add(&quot;Carrot&quot;); subList.add(&quot;Potato&quot;); subList.add(&quot;Cauliflower&quot;); subList.add(&quot;LadyFinger&quot;); subList.add(&quot;Tomato&quot;); subList.forEach(sub -&amp;gt; System.out.println(sub));}참고로 람다표현식을 사용하지 않고 구현할려면 다음과 같이 할 수도 있다.//subList.forEach(sub -&amp;gt; System.out.println(sub)); 대신에subList.forEach(new Consumer&amp;lt;String&amp;gt;() { @Override public void accept(String s) { System.out.println(s); }});default void forEach(Consumer&amp;lt;? super T&amp;gt; action) { Objects.requireNonNull(action); for (T t : this) { action.accept(t); }}foreach()는 내부적으로 위와같이 구현되어 있다. 인자의 널값을 체크하고 for문을 통해 순회한다. T타입으로 들어온 인자를 accept()메서드를 통해 소비하고 리턴값은 반환하지 않는다.foreach()의 장점 일단 for문이나 Iterator보다 짧고 간결하다. 그래서 가독성이 좋아졌다. 그래서 코드 오류의 위험성이 적어졌다.foreach()의 단점 순서 제어가 힘들다. 인덱스 접근이 어렵기 떄문이다. 당연하겠지만 컬렉션 요소를 추가하거나 삭제의 기능이 없다.✏️ 3. Interface에 Default Static Method 추가Interface는 원래 함수를 구현하지 못하게 되어있다.하지만, Java8에서는 default 또는 static이라는 키워드를 메소드 앞에 붙여서 사용하면 인터페이스에서도 함수를 구현할 수 있게 한다.//인터페이스public interface DefaultMethodTestInterface { default void printThisInterface(){ System.out.println(&quot;DefaultMethodTestInterface입니다.&quot;); } static void printTest(){ System.out.println(&quot;testestsetst&quot;); }}//구현클래스public class DefaultMethodTestImpl implements DefaultMethodTestInterface{}//Test@Testvoid defaultMethodInInterface(){ DefaultMethodTestImpl interface1 = new DefaultMethodTestImpl(); interface1.printThisInterface(); //interface에서 직접호출 DefaultMethodTestInterface.printTest();}다중상속처럼 구현해본다면?Java는 Diamond-Problem 때문에 다중상속을 지원하지 않는다. 인터페이스는 다중상속이 가능하다. 왜냐하면 모두 Override라는 강제성을 띄기 때문에 문제가 발생하지 않기 때문이다.하지만 위처럼 Default Method Interface를 이용하면 문제가 발생할 수도 있겠다.//인터페이스 1@FunctionalInterfacepublic interface Interface1 { void method1(String str); default void log(String str){ System.out.println(&quot;I1 logging::&quot;+str); } static void print(String str){ System.out.println(&quot;Printing &quot;+str); }}//인터페이스 2@FunctionalInterfacepublic interface Interface2 { void method2(); default void log(String str){ System.out.println(&quot;I2 logging::&quot;+str); }}다중상속을 하면 log()가 겹치게 될 것이다.public class MultiImplementClass implements Interface1,Interface2{ @Override public void method1(String str) { } @Override public void method2() { } @Override public void log(String str) { System.out.println(&quot;MultiImplementClass logging::&quot;+str); Interface1.print(&quot;abc&quot;); }}직접 해보면 알겠지만 컴파일러가 log()의 구현을 강제한다.그래서 Interface1의 log()와 Interface2의 log()의 구현이 의미가 없게 되는 것이다.✏️ 4. Stream API 추가 Java Stream API for Bulk Data Operations on Collectionsjava.util.stream클래스가 추가되었다. 컬렉션을 대상으로 필터링, 데이터변환 등의 작업을 쉽게 해주는 역할을 한다.이 작업은 병렬, 순차적으로 수행이 가능하고 특히 대용량의 데이터를 정제하는데에 탁월하다고 한다.이건 너무 양이 방대하므로 따로 주제를 잡고 해야할 것 같다. 간단한 예제만 적겠다.@Testvoid streamTest(){ List&amp;lt;Integer&amp;gt; myList = new ArrayList&amp;lt;&amp;gt;(); for(int i=0; i&amp;lt;10000; i++) myList.add(i); Stream&amp;lt;Integer&amp;gt; sequentialStream = myList.stream().sequential(); Stream&amp;lt;Integer&amp;gt; parallelStream = myList.stream().parallel(); long startTime = System.currentTimeMillis(); Stream&amp;lt;Integer&amp;gt; integerStream = parallelStream.filter(p -&amp;gt; p &amp;gt; 5000); integerStream.forEach(i -&amp;gt; System.out.println(i)); long endTime = System.currentTimeMillis(); long duration1 = endTime - startTime; startTime = System.currentTimeMillis(); Stream&amp;lt;Integer&amp;gt; integerStream1 = sequentialStream.filter(p -&amp;gt; p &amp;gt; 5000); integerStream1.forEach(i -&amp;gt; System.out.println(i)); endTime = System.currentTimeMillis(); long duration2 = endTime - startTime; System.out.println(&quot;parallel test took &quot; + duration1 + &quot; milliseconds&quot;); System.out.println(&quot;sequential test took &quot; + duration2 + &quot; milliseconds&quot;);}병렬처리와 순차처리의 시간을 재고 결과를 내는 테스트인데나는 당연히 병렬처리가 빠를거라 생각했다.하지만꽤나 유의미하게 차이가 났고, 이를 찾아보니 쓰레드 생성비용에 따른 시간지연이 이만큼 컸던것이다.그리고 동시성 문제도 생각했어야 했다.데이터가 큰 경우는 물론 병렬처리가 더 빨랐다.(위의 리스트에 100만까지 넣은 경우)아무튼 Stream API는 간단하게 짚고 넘어가겠다.✏️ 5. 새로운 날짜/시간 API 추가 Java Date Time APIJava8 이전에는 java.util.Date 클래스를 이용해서 시간과 날짜를 표현했다.근데 이 클래스는 자바 컬렉션 프레임워크나 시간과 관련된 일부 기능을 제공하지 않고, 시간 요소를 출력하려면 서브 클래스를 작성해서 사용해야 했다. 그래서 불편했다. 이 클래스는 자바 개발 초기때 추가되어서 많은 기능이 낙후되어있었다.Java8에서는 java.time패키지를 통해 날짜를 좀 더 표현하기 쉽게 하였다.이는 또 따로 다루는게 나을정도로 방대하므로 이정도로 알아가는게 좋을 것 같다.✏️ 6. Collection API 향상 Collection API improvements먼저, 컬렉션은 Java 1.2버전에 처음 등장했다.위에서 컬렉션에 대한 foreach()메서드랑 Stream API를 살펴봤다. Map에는 replaceAll(), compute(), merge() 등이 추가되었다. HashMap클래스의 충돌문제 알고리즘을 개선하였다. Collection의 기본 메서드 removeif(Predicate filter)를 통해 조건에 맞게 요소를 삭제할 수 있게 하였다. Collection의 spliterator()메서드를 통해 순차적 또는 병렬로 요소를 순회할 수 있는 Spliterator인스턴스를 반환한다.등등이 있다.✏️ 7. 동시성 관련 API 향상 Concurrency API Changes/Enhancements동시성 관련 API의 성능이 향상 되었다는데, 실 프로그램에 사용한 경험이 없어 적기만 하겠다. ConcurrentHashMap의 메소드 들의 성능이 향상되었다고 한다. newWorkStealingPool()이라는 메서드가 향상 되었다. 시스템의 전체 프로세스 수만큼 스레드를 생성하고 관리하는 스레드풀을 만드는 작업을 처리하는 메소드라고 한다. 그리고, 작업큐에 작업이 없을 경우 다른 쓰레드의 작업을 도와준다고 함. ✏️ 8. Java IO 향상 Java IO Improvements파일입출력 기능을 향상시키는 메서드들이 등장했다. Files.list(Path dir): lazily populated Stream을 반환하고, 디렉터리 안의 각각의 항목들을 가져온다. lazily populated Stream이란 스트림이 바로 채워지지 않고 요소가 필요할 때 그 값을 생성하여 성능을 개선시키는 방법이다.@Testvoid fileListTest(){ Path dir = Paths.get(&quot;/&quot;); try (Stream&amp;lt;Path&amp;gt; stream = Files.list(dir)) { stream.forEach(System.out::println); } catch (IOException e) { e.printStackTrace(); }} Files.lines(Path path): 모든 라인을 읽고 스트림으로 반환한다.//test//1//2//3//4//5//6@Testvoid fileLinesTest() throws IOException { Path file = Paths.get(&quot;test.txt&quot;); Stream&amp;lt;String&amp;gt; lines = Files.lines(file); lines.forEach(System.out::println);}✏️ 9. 여러 API 개선 Miscellaneous Java 8 Core API improvements ThreadLocal클래스의 정적 메소드인 withInitial은 supplier라는 인자를 통해 인스턴스를 쉽게 생성할 수 있게 되었다. Comparator 인터페이스의 정렬, 역정렬 같은 기본 메서드와 정적 메소드가 추가되었다. min(),max(),sum() 메서드들은 래퍼 클래스로 감싸게 되었다. logicalAnd(),logicalOr(),logicalXor() 메서드는 Boolean 래퍼클래스로 감싸게 되었다.등등, 여러가지 생겼는데 과유불급✏️ 10. Optional Class 추가NullPointerException을 다루기 쉽게 만드는 Optional 클래스가 추가되었다.이 클래스를 통해 객체가 비어있는지, 존재하는지 확인할 수 있어서 여러 에러를 피할 수 있게 되었다.@Testvoid OptionalTest(){ // Creating an Optional object from a non-null value Optional&amp;lt;String&amp;gt; optional1 = Optional.of(&quot;value&quot;); // Creating an Optional object from a null value Optional&amp;lt;String&amp;gt; optional2 = Optional.ofNullable(null); // Creating an empty Optional object Optional&amp;lt;String&amp;gt; optional3 = Optional.empty(); // Check if an Optional object has a value if (optional1.isPresent()) { System.out.println(&quot;optional1 has a value: &quot; + optional1.get()); } // Get the value of an Optional object, or a default value if it is empty String value1 = optional1.orElse(&quot;default value&quot;); String value2 = optional2.orElse(&quot;default value&quot;); System.out.println(&quot;value1:&quot; + value1); System.out.println(&quot;value2:&quot; + value2); // Use the value of an Optional object if it is present, or throw an exception if it is empty try { String value3 = optional1.orElseThrow(IllegalStateException::new); } catch (IllegalStateException e) { System.out.println(&quot;optional1 is empty&quot;); } try { String value4 = optional2.orElseThrow(IllegalStateException::new); } catch (IllegalStateException e) { System.out.println(&quot;optional2 is empty&quot;); } // Use the value of an Optional object if it is present, or execute a function if it is empty String value5 = optional1.orElseGet(() -&amp;gt; &quot;default value from function&quot;); String value6 = optional2.orElseGet(() -&amp;gt; &quot;default value from function&quot;); System.out.println(&quot;value5: &quot; + value5); System.out.println(&quot;value6: &quot; + value6);}결론Java8은 우리가 주로 사용하는 Optional, Stream API, 람다식, 함수형 인터페이스가 나왔다.함수형 인터페이스를 통해 파생되는 기능들이 많이 생겼다고 보면 된다." }, { "title": "real-world프로젝트 이슈 - @AuthenticationPrincipal 테스트코드 작성하기", "url": "/posts/2022-12-27-realworld-trouble/", "categories": "Toy, real-world-spring", "tags": "Spring", "date": "2022-12-27 01:02:00 +0900", "snippet": " real-world project 구현 과정 카테고리 보기개요real-world프로젝트를 진행하다보니 회원유저, 비회원유저 식별 필터를 제작하였다.본 서비스를 제작하는데에는 여러 예제코드들이 있어서 큰 어려움이 없었다.@AuthenticationPrincipal어노테이션을 붙여서 본 서비스를 제작하고 실제 잘 통신하는걸 확인하였다.@GetMappingpublic UserResponse currentUser(@AuthenticationPrincipal UserAuth userAuth) { return userService.getCurrentUser(userAuth);}문제는.. 이거 단위 테스트 어떻게 작성하지? 였다.그냥 일단 작성해보았다.UserResponse userResponse = UserResponse.builder() .username(userAuth.getUsername()) .email(userAuth.getEmail()) .image(userAuth.getImage()) .bio(userAuth.getBio()).build(); when(userService.getCurrentUser(any(UserAuth.class))).thenReturn(userResponse); mockMvc.perform(get(&quot;/api/user&quot;) .with(csrf()) ).andExpect(status().isOk()) .andExpect(jsonPath(&quot;$.user.email&quot;, Matchers.equalTo(userResponse.getEmail())))당연히 될리가 없다.그러면 직접 SecurityContext에 인증정보를 넣어줘야 한다.UserAuth userAuth = UserAuth.builder() .username(&quot;kms&quot;) .email(&quot;test@gmail.com&quot;) .build();Authentication auth = new UsernamePasswordAuthenticationToken(userAuth, &quot;&quot;, null);SecurityContextHolder.getContext().setAuthentication(auth);내 코드기준 SecurityContext에 인증정보를 넣는 방법은 다음과 같았다. 테스트 코드내에 삽입해주었다.성공하였다.하지만 저 코드를 매 번 삽입해줘야하나?아니면 @BeforeEach로 테스트 수행마다 넣어줘야할까? 인증이 필요없는 메소드에도 적용이 될 것이고, 알 수 없는 에러를 발생시킬 수 있다.공식문서에서는 이를 테스트하기 위한 방법 여러방법 중 하나로 @WithSecurityContext를 제공하여 인증정보를 커스텀할 수 있게 도와준다고 한다.나는 이 방법을 토대로 해결하였으나 궁금해서 나머지도 찾아보았다.위처럼 SecurityContextHolder객체에 직접 넣어주는것과 @WithMockUser를 사용하는 것이 있다.다음은 @WithMockUser는 정말 간단한 유저인증 정보를 컨텍스트에 넣을 수 있다.@WithMockUser(username = &quot;kms&quot;)이러한 내용을 테스트메소드위에 달아서 사용할 수는 있으나, 이 프로젝트와 같이 인증정보를 객체로 넣은 경우에는 커스텀이 불가능하다.무슨 말이냐하면Authentication auth = new UsernamePasswordAuthenticationToken(userAuth, &quot;&quot;, null);SecurityContextHolder.getContext().setAuthentication(auth);처럼 userAuth라는 인스턴스를 인증객체로 생성해서 컨텍스트에 세팅하는데 @WithMockUser는 이처럼 인스턴스 자체를 컨텍스트에 넣는게 불가능 하다는 것이다. 즉 @WithMockUser(userAuth= 어떤 객체)같은 코드는 불가능 하다.참고로 @WithUserDetails어노테이션도 있는데, 이는 UserDetailsService라는 인터페이스를 구현한 메서드로 컨텍스트에 인증정보를 넣었을 때 사용이 가능하다.위 프로젝트는 UserDetailsService를 구현하긴 하지만 이 인터페이스의 메소드인 loadUserByUsername()의 반환값으로 컨텍스트에 인증정보를 넣지 않는다.@WithMockUser보다는 커스텀하는데에는 가능성이 있음을 보였다.하지만 이 또한 유연하게 대처가 불가능하다. 테스트코드를 위해 기존 로직을 손대야함의 불편함이 생겨 서로에게 의존적이게 되기 때문이다.즉, 테스트코드는 인증에 대해서 실제 서비스 코드와 완벽히 분리되어야 한다.그래서 결국 적절한 값으로 커스텀마이징 해주려면 새로운 인증 테스트 방식이 필요하다.✔ @WithSecurityContext이 방식을 통해서 테스트 코드를 좀 더 유연하게 작성이 가능해진다.먼저, 자신이 설정하고 싶은 이름으로 어노테이션을 작성해야한다.@Retention(RetentionPolicy.RUNTIME)@WithSecurityContext(factory = WithAuthUserSecurityContextFactory.class)public @interface WithAuthUser { long id() default 1L; String email() default &quot;test@gmail.com&quot;; String username() default &quot;kms&quot;;}프로젝트에서 인증을 하기 위한 최소한 조건인 컬럼들을 넣어두었다. id, email, username이다.그리고 이를 관리하는 클래스를 만들어 준다.public class WithAuthUserSecurityContextFactory implements WithSecurityContextFactory&amp;lt;WithAuthUser&amp;gt; { @Override public SecurityContext createSecurityContext(WithAuthUser annotation) { Long id = annotation.id(); String email = annotation.email(); String username = annotation.username(); UserAuth userAuth = UserAuth.builder() .email(email) .username(username) .id(id) .build(); Authentication authentication = new UsernamePasswordAuthenticationToken(userAuth,&quot;&quot;,null); SecurityContext context = SecurityContextHolder.getContext(); context.setAuthentication(authentication); return context; }}공식 문서에 의하면 @WithSecurityContext(factory = WithAuthUserSecurityContextFactory.class)이 구분은 다음과 같은 의미를 담고 있다고 한다. SecurityContextRepository라는 인증정보 컨텍스트를 관리하는 인터페이스에다가 테스트용 인증정보를 생성할 의도가 있음을 알린다. 이 의미를 보고 SecurityContextRepository는 컨텍스트를 생성할 때 WithSecurityContextFactory의 구현체인 WithAuthUser (위 코드 기준)어노테이션에 지정된 속성 값들로 인증정보를 생성하고 컨텍스트에 담는다.그래서 위 코드를 보면 커스텀 어노테이션을 구현체로 설정하고 어노테이션에 지정된 값들을 뽑아내, UserAuth객체를 만들고 이를 컨텍스트에 넣어주는 코드임을 알 수 있다.이러한 결과로 WithSecurityContextTestExecutionListener라는 스프링 시큐리티에서 테스트 수행시 인증정보를 생성할 수 있게 해주는 실행 리스너가 SecurityContext에 우리가 커스텀한 값으로 채워질 수 있게 한다.공식문서에서는 추가로 UserDetailsService을 의존성 주입을 통해 가져다 쓸 수 있다고 하지만 이 프로젝트에서는 쓰이지 않았으므로 알아두고 넘어갔다.결국 테스트코드는 다음과 같이 작성하면 된다.@WithAuthUser(email = &quot;test@gmail.com&quot;,username = &quot;kms&quot;,id = 1L)@Test@DisplayName(&quot;현재유저 찾기 컨트롤러 테스트&quot;)void currentUserSuccess() throws Exception { UserResponse userResponse = UserResponse.builder() .username(&quot;kms&quot;) .email(&quot;test@gmail.com&quot;) .build(); when(userService.getCurrentUser(any(UserAuth.class))).thenReturn(userResponse); mockMvc.perform(get(&quot;/api/user&quot;) ).andExpect(status().isOk()) .andExpect(jsonPath(&quot;$.user.email&quot;, Matchers.equalTo(userResponse.getEmail()))) .andExpect(jsonPath(&quot;$.user.bio&quot;, Matchers.equalTo(userResponse.getBio()))) .andExpect(jsonPath(&quot;$.user.username&quot;, Matchers.equalTo(userResponse.getUsername()))) .andExpect(jsonPath(&quot;$.user.image&quot;, Matchers.equalTo(userResponse.getImage())));}커스텀 어노테이션의 속성값을 따로 지정해줄 수 있다는 사실.성공이다.복기하자면, 커스텀 어노테이션에 인증에 필요한 값들을 넣고 SecurityContextRepository 인터페이스에 커스텀 어노테이션을 구현체로 넣어 구현한 클래스에서, SecurityContext에 인증정보를 객체의 형태로 넣을 수 있게 되었다." }, { "title": "Java,OS- 동시성 정리", "url": "/posts/2022-12-25TIL/", "categories": "Interview", "tags": "interview", "date": "2022-12-25 01:02:00 +0900", "snippet": "🔅 동시성 개요앞에서 프로세스끼리 데이터를 공유하려면 share-memory기법이나 message passing기법을 사용하였다.공유된 데이터를 사용하려면 항상 동시성을 생각해야하는데, 데이터 불일치라는 문제가 생길 수 있기 때문이다.그래서 프로세스나 쓰레드의 실행 순서를 보장해주는 등의 작업을 해줘야한다.🔑 입출금 예제간단한 예제로는 입출금 예제가 있다.import org.junit.jupiter.api.Test;import java.util.ArrayList;import java.util.List;import java.util.concurrent.*;public class TestClass { private Account account = new Account(100000); @Test void accountExample() throws InterruptedException, ExecutionException { ExecutorService executor = Executors.newFixedThreadPool(100); //virtual Thread 아직 intellij에서 지원안함. (preview) //ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor(); List&amp;lt;Task&amp;gt; tasks = new ArrayList&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; 100; i++) { tasks.add(new Task((int)((Math.random()*3) + 1) * 1000, account)); } long time = System.currentTimeMillis(); List&amp;lt;Future&amp;lt;Integer&amp;gt;&amp;gt; futures = executor.invokeAll(tasks); long sum = 0; for (Future&amp;lt;Integer&amp;gt; future : futures) { sum += future.get(); } time = System.currentTimeMillis() - time; System.out.println(&quot;sum = &quot; + sum + &quot;; time = &quot; + time + &quot; ms&quot;); executor.shutdown(); }}class Account{ private int balance; public Account(int balance){ this.balance = balance; } public void withDraw(int money) throws InterruptedException { if(balance &amp;gt;= money){ Thread thread = Thread.currentThread(); thread.sleep(1000); this.balance -= money; System.out.printf( &quot;WithDraw Function Thread %s - Task %d finished.%n&quot;, thread.getName(), getBalance()); } } public int getBalance(){ return this.balance; }}class Task implements Callable&amp;lt;Integer&amp;gt; { private final int money; private final Account account; public Task(int money, Account account){ this.money = money; this.account = account; } @Override public Integer call() throws Exception { System.out.printf( &quot;Thread %s - Task %d waiting...%n&quot;, Thread.currentThread().getName(), money); try { account.withDraw(money); } catch (InterruptedException e) { System.out.printf( &quot;Thread %s - Task %d canceled.%n&quot;, Thread.currentThread().getName(), money); return -1; } System.out.printf( &quot;Thread %s - Task %d finished.%n&quot;, Thread.currentThread().getName(), account.getBalance()); return ThreadLocalRandom.current().nextInt(100); }}결과개발자의 의도와도 다르다. 예측도 거의 불가능. 디버그도 어렵다. 저 코드에서 thread.sleep(1000)를 지우면 개발자가 원하는대로 돌아가기는 한다. 연산이 간단하기에 추적이나 디버그하는데 시간이 크게 소요되지 않지만 프로그램이 커지면 커질수록 디버그와 추적하기는 어려워진다.때문에 동시성을 계속 고려하면서 프로그래밍을 짜거나 논리적 흐름을 구성하는게 정말 중요하다.MOV EAX, balance ; EAX 레지스터에 balance 값 로드SUB EAX, money ; EAX에서 money를 뺀 결과를 EAX에 저장MOV balance, EAX ; balance에 EAX의 값 대입 x86아키텍처의 어셈블리어 코드즉, 자원을 공유하는 부분에서 스케줄러나 인터럽트를 통해 레지스터가 saved되거나 restored되면 문제가 발생할 확률이 생기는 것이다.위는 쓰레드 2개를 나타낸것이지만, 실제 코드에서는 쓰레드 100개가 동시에 같은 자원을 할당받는다. 그렇기에 결과적으로 -98000같은 숫자가 나오는 것이다.🔑 Race Condition여러 개의 쓰레드나 프로세스가 공유 자원을 할당받으려하고 할당받아서, 그 수행의 결과값이 매 번 달라 예상치 못한 결과가 나오는 경우.🔑 해결법 (Critical Section Problem)어떤 코드영역이 각각의 프로세스나 쓰레드마다 같은 데이터를 갱신하거나 접근하는 영역을 Critical Section(임계영역)이라고 부른다.이럴경우 race Condition이 발생할 수 있고, 이를 해결하기 위한 방법들이 Critical Section Problem이라고 한다.이 문제를 풀기 위해서는 개념적으로 3가지 요구되는 것들이 있다. Mutual Exclusion(상호배제): 어떤 프로세스가 임계영역에서 작업을 수행중일 때는 다른 프로세스는 접근할 수 없다는 것을 보장.하지만 상호배제를 적용하면 deadlock과 starvation이라는 문제가 발생한다. Progress(avoid deadlock): 쓰레드가 자원에 접근할 수 있는 상태를 일컫는 말. 임계 영역에 쓰레드가 있는 경우 Progress가 있다고 할 수 있고, 임계 영역에 쓰레드가 없는 경우 Progress가 없다고 한다. 그래서 임계영역에 있는 쓰레드는 자원에 접근이 가능하지만, 임계영역에 없는 쓰레드는 자원에 접근이 불가능하다는 것. 그래서 임계영역에 들어갈 쓰레드를 결정해줘야한다. Bounded waiting(avoid starvation): 기아를 방지하기 위해서 한 번 임계구역에 들어간 프로세스나 쓰레드는 다음번 임계구역에 들어갈 때 제한을 두어야 한다.이 3가지를 모두 만족하면 임계구역 문제를 해결하였다고 할 수 있지만, 현실적으로 3가지를 모두 만족하기란 쉽지가 않다.이러한 임계영역에 동시접근을 해결하기 위해서는 공유자원에 접근 하였을 때 인터럽트자체를 방지하여 컨택스트 스위치가 발생하지 않도록 만들 수 있지만, 멀티프로세서 환경에서는 모든 코어에 대해 인터럽트를 막으면 효율성이 떨어지므로 사용하지 않는다. Mutex Locks Semaphore Monitor LivenessLiveness는 다른 방법의 단점을 극복하고 Mutual Exclusion + Progress까지 수행. 나머지는 Mutual Exclusion까지만🔑 Mutex Locks mutex: mutual exclusion임계역역에 들어갈 때 Lock이라는 것을 걸고, 나올 때 Lock을 풀어서 상호배제를 보장하는 방법. 즉, 프로세스나 쓰레드는 Lock라는 것을 획득하고 임계영역에 들어가야한다. 단순한 방법개념적으로 이런식으로 구현이 가능하다.//locking = acquirelock.lock();try { // critical section of code goes here} finally { //unlocking = release lock.unlock();}try { lock.lock(); account.withDraw(money);} catch (InterruptedException e) { System.out.printf( &quot;Thread %s - Task %d canceled.%n&quot;, Thread.currentThread().getName(), money); return -1;}finally { lock.unlock();}결과 단점 Busy waiting: 내부적으로 다른프로세스들이 lock이 풀려있는지 while(true)를 통해 계속 질의하여 의미없이 CPU가 계속 돌아가고 있는 문제. public class MyClass { private boolean locked = false; public void doSomething() { while (locked) { // busy waiting loop 다른 프로세스, 쓰레드는 계속 여기 걸려있음. } locked = true; try { // critical section of code goes here } finally { locked = false; } }} Spinlock: 위의 Busy waiting이 생기면 while문 끝으로 갔다가 다시 올라가고 하는 형태가 마치 spin의 형태라서 지어진 이름. Busy waiting이 멀티 프로세스환경에서 마냥 나쁜게 아니다. 왜냐하면 context switch가 일어나지 않기에 그 시간을 절약할 수 있다는 것 즉, ready-Queue에서 대기했다가 가는것이 아니고 프로세스가 계속 Running상태에서 공유자원이 해제되면 들어갈 수 있기 때문이다.🔑 Semaphores 알고리즘 개념도 전체 구성도mutex-lock 경우는 임계구역에 하나의 프로세스나 쓰레드만 접근이 가능했지만, 세마포어는 접근가능한 쓰레드나 프로세스의 개수를 정해놓으면 접근할 때마다 count변수를 빼고 임계구역을 벗어날때마다 count변수를 증가시켜 자원에 접근가능한 쓰레드 수를 제한할 수 있다. 그러다가 count변수가 0이 되면 모든 리소스가 할당된 것이므로 다른 쓰레드는 접근이 불가능하게 막는다.count를 빼는 행위를 wait()한다고 하고, count를 더하는 행위를 signal()이라고 한다.(세마포어에서 사용하는 용어) Binary Semaphore자원에 접근 가능한 쓰레드 수를 0 ~ 1로 제한하는 것. mutex-lock처럼 동작한다. Counting Semaphore자원에 접근 가능한 쓰레드 수를 2이상으로 제한하는 것이다.S1을 수행하는 프로세스를 P1, S2를 수행하는 프로세스를 P2라 하자. 그리고 count변수를 0으로 초기화되어있다고 한다.만약 쓰레드간 순서를 제어하고 싶다면 위처럼 구현하면 된다.P1이 자원을 반납하면 count가 1증가하여 사용할 수 있게 되는데, 이로인해서 P2는 S1이 끝날때까지 접근이 불가능한 것이다.세마포어도 busy waiting의 문제가 있는데, 멀티프로세서 환경에서는 spinlock으로 사용해도 되지만, 그렇지 않은 경우 이를 해결해야한다.그래서 세마포어를 통해 자원에 접근을 할 수 없다면 자기 자체를 중지하고 waiting queue로 보내고 다른 프로세스가 signal()을 호출하면 waiting quque에 있던 프로세스를 ready queue로 보내는 전략이 있다.class Account{ private Semaphore semaphoreForWithdraw; private int balance; public Account(int balance){ this.balance = balance; semaphoreForWithdraw = new Semaphore(1); } public void withDraw(int money) throws InterruptedException { if(balance &amp;gt;= money){ Thread thread = Thread.currentThread(); semaphoreForWithdraw.acquire(); this.balance -= money; System.out.printf( &quot;WithDraw Function Thread %s - Task %d finished.%n&quot;, thread.getName(), getBalance()); semaphoreForWithdraw.release(); } } public int getBalance(){ return this.balance; }}출금하는 부분은 쓰레드 1개만 들어와야하므로 위의 세마포어를 이용해 동기화문제를 해결할 수 있다.위의 결과에서 WithDraw ~ 출력부분을 보면 순차적으로 잘 빼고 있음을 볼 수 있다.그리고 접근 가능한 쓰레드 수를 1이 아닌 2로 지정하면 동기화문제가 해결되지 않는것을 볼 수 있다.결국 적절한 세마포어 수와, 내부적 알고리즘을 얼마나 Atomic하게 짰냐에 따라 다르다.🔑 Monitors세마포어는 잘 쓰면 효율적이고 편리하게 동기화 문제를 해결할 수 있지만 가장 적절한 접근 가능한 쓰레드 수를 지정하는 일은 매우 어렵다.그리고 세마포어는 timing error라는 문제가 발생할 수 있는데, 적절한 곳에 wait()나 signal()을 안 써주는 경우 코드를 짜다보니 wait()을 생략하거나 두 번 호출된 경우 등 예측할 수 없는 문제가 발생할 수 있는 문제다. 즉, 해당 함수를 호출하는 순서가 중요해진다는 것이다.여기서 상대적으로 간단한 동기화 도구인 monitor가 등장했다.monitor typemonitor type은 상호배제를 제공하는 일종의 데이터 타입이라고 생각하면 된다.이 데이터 타입 안에 있는 구문들은 모두 동기화를 보장할 수 있도록 하는 것이다. Java에서는 synchronized키워드가 있다. public synchronized void withDraw(int money) throws InterruptedException { if(balance &amp;gt;= money){ Thread thread = Thread.currentThread(); this.balance -= money; System.out.printf( &quot;WithDraw Function Thread %s - Task %d finished.%n&quot;, thread.getName(), getBalance()); }synchronized 키워드만 추가해주면 해당 블럭들은 전부 임계구역이 된다.하나가 끝날 때까지 다른 스레드들은 접근을 못한다.if(balance &amp;gt;= money){ Thread thread = Thread.currentThread(); synchronized (Account.class){ this.balance -= money; } System.out.printf( &quot;WithDraw Function Thread %s - Task %d finished.%n&quot;, thread.getName(), getBalance());}이런식으로 block을 지정해서 동기화문제를 해결할 수도 있다.mutexlock과의 차이점은 권한 제어 여부에 있다.monitors는 스레드가 순차적으로 실행되기 위함의 목적이 있고, mutexlock은 스레드가 자원에 접근할 수 있는 권한을 제어하기 위함에 목적이 있다.🔑정리동기화를 해결하기 위해 3가지 기법이 있다. mutex lock: 임계구역에 락이라는걸 걸어서 상호배제를 보장하는방법 Semaphores: 임계구역에 접근이 가능한 쓰레드 수를 제한해서 상호배제를 보장하는 방법 Monitors: 임계구역에 접근할 수 있는 쓰레드의 순서를 제어하는 방법." }, { "title": "가상 면접 사례로 배우는 대규모 시스템 설계 기초 8장 - URL 단축기 설계", "url": "/posts/2022-12-16-interViewBook08/", "categories": "Book, 가상 면접 사례로 배우는 대규모 시스템 설계 기초", "tags": "book, interview", "date": "2022-12-16 01:02:00 +0900", "snippet": " 가상 면접 사례로 배우는 대규모 시스템 설계 기초 책 정리 글입니다.개요URL 단축기는 말그대로 URL을 줄이는 모듈을 말한다.✏️ 1단계 문제 이해 및 설계 범위 확정여태까지 그래왔듯 질문을 통해 요구사항을 명확히 해야한다. 트래픽의 규모는? (예제에서는 매일 1억개의 단축url생성) url의 길이는? (예제에서는 최대한 줄이도록) url문자제한은? (예제에서는 0~9숫자, a~Z, A-Z 알파벳) url을 시스템에서 지우거나 갱신 가능? (예제에서는 불가능)고로 이 시스템의 기본 기능은 다음과 같다고 한다. URL단축: 주어진 긴 URL을 훨씬 짧게 줄인다. URL 리다이렉션: 축약된 URL로 HTTP 요청이 오면 원래 URL로 안내 높은 가용성과 규모 확장성, 그리고 장애 감내가 요구개략적 추정 쓰기 연산: 매일 1억개 단축URL 생성 초당 쓰기 연산: 1억/24/3600 = 1160 읽기 연산: 여기서는 읽기와 쓰기 비율이 10:1로 가정. 그러므로 1160 * 10 = 11,600 URL 단축 서비스를 10년 운영한다하면 1억 * 365 * 10 = 3650억URL을 저장할 레코드가 필요. 축약 전 URL의 평균 길이는 100이라 가정. 따라서 10년 운영에 필요한 데이터 저장 용량은 3650억 * 100 = 36.5TB✏️ 2단계 개략적 설계안 제시 및 동의 구하기API 엔드포인트API 엔드포인트로 서버와 통신할 것이기에, REST 스타일로 설계를 한다.POST /api/v1/data/shorten //책에는 이렇게 되어있는데, Restful하게 짜려면 명사를 사용하는게 좋다 그래서 나는POST /api/v1/short-url 로 하겠다.인자: {longUrl: longURLString}반환: 단축URLURL 리디리렉션용 엔드포인트: 단축 URL에 대해서 요청이 오면 원래 URL로 보내주기 위한 용도의 엔드포인트이다.GET /api/v1/shortUrl //책에는 이렇게 써져있지만 나는GET /api/v1/short-url //로해서 POST와 동일하게 하였다.반환: HTTP 리다이렉션 목적지가 될 원래 URL즉,이런식으로 요청의 흐름이 이루어질 것이다.301 응답과 302응답의 차이점에 대해 간단히 짚고 넘어가야된다. 301 응답(Permanently Moved): 브라우저가 응답을 캐시해서 추후 같은 단축URL에 요청을 보낼 필요가 있고 요청이 도착하면 브라우저는 캐시된 원래URL로 보내버린다. 302 응답(Found): 클라이언트의 요청은 언제나 단축URL 서버에 먼저 보내진 후에 원래 URL로 리다이렉션 된다.첫 번째 요청만 단축URL 서버로 전송되기 때문에 서버 부하를 줄이기엔 301이 낫다.그러나 트래픽 분석이 중요할때는 302를 써서 클릭 발생률, 발생 위치 등을 추적하는 것도 좋다.URL 단축이런식으로 원본URL이 어떠한 해시함수에 들어가면 단축URL로 바뀐다고 생각하자. 요구사항은 다음과 같다. 입력으로 주어지는 긴 URL이 다른값이면 해시 값도 달라야 한다. 계산된 URL은 다시 원본 URL로 복원될 수 있어야 한다.✏️ 3단계 상세 설계데이터모델&amp;lt;단축URL,원본URL&amp;gt;을 쌍으로 가지는 해시테이블을 만들 수도 있겠지만, 메모리는 유한하고 비싸기에 이러한 쌍을 RDB에 저장하는 편이 좋을거라 생각이 든다. url--------PK id shorUrl longUrl을 컬럼으로 가지는 테이블을 만든다.해시 함수원래 URL을 단축URL로 만드는 해시 함수를 만들어야 한다.해시 값 길이단축URL은 0~9, a-z, A-Z까지의 문자들로 구성된다. 따라서 사용할 수 있는 문자의 개수는 10 + 26 + 26 = 62개이다. 이 시스템은 10년간 운영될 3650억개의 URL을 중복없이 담아야하므로, $ 62^n &amp;gt;= 3650억 $을 넘는 n을 구해야한다.이러한 n은 7이고 이는 3.5조개의 URL을 만들 수 있다. 따라서 단축URL의 길이는 7이다.함수 구현에 쓰일 기술로는 해시 후 충돌 해소 방법과 base-62 변환법이 있다.해시 후 충돌해소긴 URL을 줄이려면, 원래 URL을 7글자 문자열로 줄이는 해시 함수가 필요하다. CRC32, MD5, SHA-1과 같이 잘 알려진 해시 함수를 이용하는것도 방법이다.해시함수 | 해시 결과CRC32 | 5cb54054MD5 | 5a62509a84df9ee03fe1230b9df8b84eSHA-1 | 0eeae7916c06853901d9ccbefbfcaf4de57ed85b문제는 CRC32가 계산한 가장 짧은 해시조차도 단축URL의 길이인 7글자를 넘겨버린다.이 문제를 해결할 첫 번째 방법은 7글자까지 그냥 잘라버리는 것이다.이렇게 구현할 경우 해시 결과가 서로 충돌할 확률이 높아진다. 실제 충돌을 하면 충돌을 해소할 때까지 사전에 정한 문자열을 해시값에 덧붙이는 방법이 있다.하지만 이렇게 하면 단축URL을 생성할 때 한 번 이상 데이터베이스에 질의해야하므로 오버헤드의 부담이 생긴다. 앞에서 배운 블룸 필터를 통해 공간 효율성을 증대시킬 수는 있지만 충돌을 피하기는 쉽지 않다는 것이다.base-62 변환진법 변환(base conversion)은 단축URL을 구성할 때 흔히 사용되는 접근법이다. 이 기법은 수의 표현 방식이 다른 두 시스템이 같은 수를 공유하여야 하는 경우에 유용하다. 62진법을 사용하는 이유는 이 예시에서 한 글자에 들어올 수 있는 문자의 경우의 수가 62이기 때문이다.base-62 변환 예제이다. $ 11527_{10} $을 62진수로 변환해 보는 예제다. 여기서 62진법은 이런식으로 구성되어 있다.0 ~ 9 : 0 ~ 9a ~ z: 10 ~ 35A ~ Z: 36 ~ 61따라서 62진법에서 ‘a’는 $ 10{10} $이고, ‘Z’는 $ 61{10} $ 이다.이러한 방식으로 $ 11157{10} $의 62진법 변환은 $ 2TX{62} $가 될 것이다.두 접근법을 비교해 보겠다. 해시 후 충돌 해소 전략 base-62 변환 단축URL길이가 고정 단축URL길이가 가변, ID값이 커지면 같이 커진다. 유일성이 필요한 ID 생성기가 필요 없음. 유일성 보장 ID가 필요함. 해시 중복 방지 충돌이 가능해서 해소 전략필요 ID가 유일하면 충돌이 불가능 ID로부터 도출해내는 방식이 아니라 다음에 쓸 URL을 알아내는것이 불가능 다음에쓸 단축URL을 알아낼 수 있어서 보안상의 문제가 있을 수 있다. URL 단축기 상세 설계62진법 변환을 기준으로 설명 되어 있다.처리 로직은 간단하다. 입력으로 긴 원본URL을 받는다 | | | | 입력된 URL이 DB에 있나? ┌----------------------┐ yes | | no | | | | DB에서 찾은 단축URL 변환 새로운 ID 생성 | | | | 생성된 ID를 단축URL로 변환 | | ID, 단축 URL, 원래URL을 DB에 저장ID생성기는 7장에서 구현하는 방법을 이야기 했다.참고URL 리다이렉션 상세 설계 사용자가 단축 URL을 클릭한다. 로드 밸런서가 해당 클릭으로 발생한 요청을 웹 서버에 전달한다. 단축URL이 이미 캐시에 있는 경우 원래 URL을 꺼내 반환한다. 단축URL이 캐시에 없는 경우 데이터베이스에서 꺼낸다. 만약 데이터가 없으면 사용자가 잘못된 단축URL을 입력한 것이다. 데이터베이스에서 꺼낸 URL을 캐시에 넣은 후 사용자에게 반환한다.🤔 정리단축URL이라는 시스템디자인을 이 책을 읽어보면서 처음 해보았다.그렇게 어렵다고 느끼지는 않았고, 구현과정을 다시 되짚어볼 필요가 있음을 느꼈다.API 설계, 데이터 모델 설계, 해시 함수 설계, URL 단축 및 리다이렉션 절차를 설계하였다.추가적으로 고려해볼만한건 다음과 같은게 있다. 처리율 제한 장치: 엄청난 양의 URL 단축 요청이 밀려 들어오면 시스템이 무력화 될 수도 있다. 처리율 제한 장치를 둬서 요청을 어느정도 걸러낼 수 있을 것이다. 본 설계는 무상태(stateless) 웹 계층을 가지고 있으므로 자유롭게 웹 서버를 증설하거나 삭제할 수 있다. 데이터베이스 규모 확장: 데이터베이스 다중화하거나 샤딩하여 규모 확장성을 달성할 수 있다. 데이터 분석 솔루션: 데이터를 통해 링크를 얼마나 많은 사용자가 클릭했는지, 언제 주로 클릭했는지 등 중요한 정보를 알아낼 수 있을 것이다. 가용성, 데이터 일관성, 안정성 적용에 대한 논의" }, { "title": "SpringMVC - MockMvc, @WebMvcTest코드까보기", "url": "/posts/2022-12-15-Spring_WebMVCTest/", "categories": "Java, Spring", "tags": "Java", "date": "2022-12-15 02:02:00 +0900", "snippet": " real-world project 구현 과정 카테고리 보기개요테스트 코드를 짜면서 어쩌다보니 쓰고 있는 이 클래스, 어노테이션들 정리할 필요를 느꼈다.😎 MockMvc, @WebMvcTest@WebMvcTest어노테이션을 알기 전 MockMvc에 대해 알고 있어야한다. @WebMvcTest 문서를 보면 MockMvc에 대한 언급이 나오기 때문이다.@WebMvcTest(controllers = UsersController.class)class UsersControllerTest { void signup(UserSignupRequest userSignupRequest) throws Exception { @Autowired MockMvc mockMvc; ... //when , then mockMvc.perform(post(&quot;/api/users&quot;) .contentType(MediaType.APPLICATION_JSON) .content(objectMapper.writeValueAsString(userSignupRequest)) .with(csrf()) ) ... } ...}이런식으로 사용하고 있는 mockMvcmockMvc는 컨트롤러에 가짜 HTTP요청을 보낸다.Spring은 DispatcherServlet이라는 실제 웹 요청을 처리하는 서블릿을 가지고 있는데 mockMvc는 DispatcherServlet을 모방하여 요청을 보낸다.이러한 가짜 서블릿을 통해 실제 웹 서버가 뜨지 않고도 컨트롤러에 요청을 보낼 수 있어서 테스트가 가능하다.단점으로는 실제 웹 서버와 다르게 동작할 수 있어서 정확한 테스트가 어려울 수도 있다는 것이다.죽 mockMvc는 컨트롤러와 관련된 정보를 가지고 가짜 HTTP 요청 생성을 한다. 가짜 HTTP 요청을 컨트롤러에 전달한다. 이 요청은 DispatcherServlet을 모방한 방식대로 처리됨. 요청한 컨트롤러를 찾고, 요청을 전달한다. 컨트롤러의 응답을 검증한다. 이는 .andExpect()같은 함수를 통해 검증이 가능하다.그러면 MockMvc는 어떻게 가짜 servlet을 만들 수 있는걸까?그러면 다시 @WebMvcTest에 대해 간단히 언급해야한다.이는 @SpringBootApplication가 자동설정을 도와주듯 해당 어노테이션도 테스트에 필요한 설정들을 자동화해준다고 현재는 이해하자.아무튼 @WebMvcTest 코드를 보면@Bean@ConditionalOnMissingBeanpublic MockMvc mockMvc(MockMvcBuilder builder) { return builder.build();} @ConditionalOnMissingBean는 이미 등록된 빈이 없을때 새로 만들어준다는 코드라는 코드가 있다. 빈으로 등록하는 코드이다. 파라미터로 들어온 builder에는 웹 컨텍스트의 정보가 들어있다고 알고 있자.아무튼 MockMvc 빈을 생성할 때 빌더패턴을 통해 빌드를 하게 되는 것 같다. 그래서 해당 코드로 또 들어가보면@Override@SuppressWarnings(&quot;rawtypes&quot;)public final MockMvc build() { WebApplicationContext wac = initWebAppContext(); ServletContext servletContext = wac.getServletContext(); MockServletConfig mockServletConfig = new MockServletConfig(servletContext); for (MockMvcConfigurer configurer : this.configurers) { RequestPostProcessor processor = configurer.beforeMockMvcCreated(this, wac); if (processor != null) { if (this.defaultRequestBuilder == null) { this.defaultRequestBuilder = MockMvcRequestBuilders.get(&quot;/&quot;); } if (this.defaultRequestBuilder instanceof ConfigurableSmartRequestBuilder) { ((ConfigurableSmartRequestBuilder) this.defaultRequestBuilder).with(processor); } } } Filter[] filterArray = this.filters.toArray(new Filter[0]); return super.createMockMvc(filterArray, mockServletConfig, wac, this.defaultRequestBuilder, this.defaultResponseCharacterEncoding, this.globalResultMatchers, this.globalResultHandlers, this.dispatcherServletCustomizers);}요약하자면 테스트용 서블릿 컨텍스트가 있는데, 이에 저장된 필터, 설정들을 실제 서블릿 컨텍스트에 넣는다.그리고 createMockMvc()을 리턴하기에 이 코드도 까봐야한다.protected final MockMvc createMockMvc(Filter[] filters, MockServletConfig servletConfig, WebApplicationContext webAppContext, @Nullable RequestBuilder defaultRequestBuilder, List&amp;lt;ResultMatcher&amp;gt; globalResultMatchers, List&amp;lt;ResultHandler&amp;gt; globalResultHandlers, @Nullable List&amp;lt;DispatcherServletCustomizer&amp;gt; dispatcherServletCustomizers) { TestDispatcherServlet dispatcherServlet = new TestDispatcherServlet(webAppContext); ... try { dispatcherServlet.init(servletConfig); } catch (ServletException ex) { // should never happen.. throw new MockMvcBuildException(&quot;Failed to initialize TestDispatcherServlet&quot;, ex); } MockMvc mockMvc = new MockMvc(dispatcherServlet, filters); mockMvc.setDefaultRequest(defaultRequestBuilder); mockMvc.setGlobalResultMatchers(globalResultMatchers); mockMvc.setGlobalResultHandlers(globalResultHandlers); return mockMvc;}보아하니, 테스트용 DispatcherServlet을 만들고 MockMvc객체를 생성할 때 넣는다.new MockMvc(dispatcherServlet, filters)을 보면MockMvc(TestDispatcherServlet servlet, Filter... filters) { Assert.notNull(servlet, &quot;DispatcherServlet is required&quot;); Assert.notNull(filters, &quot;Filters cannot be null&quot;); Assert.noNullElements(filters, &quot;Filters cannot contain null values&quot;); this.servlet = servlet; this.filters = filters; this.servletContext = servlet.getServletContext();}이렇게 되어있다. 즉, MockMvc는 빈에 등록되어있고, 테스트용 DispatcherServlet과 설정값들을 가지고 있다.그러면 실제 MockMvc인스턴스의 함수를 호출하는 곳을 보자.mockMvc.perform(post(&quot;/api/users&quot;) .contentType(MediaType.APPLICATION_JSON) .content(objectMapper.writeValueAsString(userSignupRequest)) .with(csrf()) ) .andExpect(MockMvcResultMatchers.status().isOk())이렇게 구현해놨는데, .perform()은 어떻게 수행되는걸까??public ResultActions perform(RequestBuilder requestBuilder) throws Exception { ... //1. 테스트용 HttpServletRequest 객체에 값을 넣음. MockHttpServletRequest request = requestBuilder.buildRequest(this.servletContext); //2. 비동기 서블릿 컨텍스트 호출 =&amp;gt; null AsyncContext asyncContext = request.getAsyncContext(); MockHttpServletResponse mockResponse; HttpServletResponse servletResponse; if (asyncContext != null) { ... } //3. null이므로 새로운 테스트용 HttpServletResponse 객체를 만듦. 이때는 빈 값이다. status도 200이고 response의 내용물은 비어있다. else { mockResponse = new MockHttpServletResponse(); servletResponse = mockResponse; } //4. 인풋 헤더를 검증하는 부분같은데 잘 이해 못했습니다. if (requestBuilder instanceof SmartRequestBuilder) { request = ((SmartRequestBuilder) requestBuilder).postProcessRequest(request); } //5. mvcResult는 mockRequest,와 mockResponse를 가지고 있다. MvcResult mvcResult = new DefaultMvcResult(request, mockResponse); //6. 리퀘스트 속성에 이값을 키-값 형태로 넣는다. request.setAttribute(MVC_RESULT_ATTRIBUTE, mvcResult); ... //7. 테스트용 필터를 생성하는데, 이 값에는 기본 필터들과 사용자가 정의한 필터(Jwt 관련)가 들어있다. 또한 인자로 들어간 테스트용 서블릿객체도 들어가 있다. MockFilterChain filterChain = new MockFilterChain(this.servlet, this.filters); //8. 실질적으로 요청을 보내는 부분이다. 들어온 필터를 도는데 결국 마지막에 들어간 서블릿객체의 service()도 호출하여 실질적으로 가짜HTTP요청이 MockMvc가 만든 서블릿객체에 들어간다. filterChain.doFilter(request, servletResponse); ... //9. 결국 요청에 대한 응답을 받는다. applyDefaultResultActions(mvcResult); RequestContextHolder.setRequestAttributes(previousAttributes); //10. andExpect()처럼 후처리. return new ResultActions() { @Override public ResultActions andExpect(ResultMatcher matcher) throws Exception { matcher.match(mvcResult); return this; } @Override public ResultActions andDo(ResultHandler handler) throws Exception { handler.handle(mvcResult); return this; } @Override public MvcResult andReturn() { return mvcResult; } }; }참고로파라미터로 들어온 requestBuilder는 이런식으로 저장되어있다.쓰다말다 쓰다말다해서 내용이 좀 난잡하다. 참고만 해야할것 같다." }, { "title": "가상 면접 사례로 배우는 대규모 시스템 설계 기초 7장 - 분산 시스템을 위한 유일 ID 생성기 설계", "url": "/posts/2022-12-15-interviewBook07/", "categories": "Book, 가상 면접 사례로 배우는 대규모 시스템 설계 기초", "tags": "book, interview", "date": "2022-12-15 01:02:00 +0900", "snippet": "개요auto_increment속성이 설정된 관계형 데이터베이스의 기본 키를 쓰는 방법이 있겠다. 하지만 분산환경에서 데이터베이스 서버 한 대로는 이 요청을 감당할 수 없을 것이고, 여러 데이터베이스를 쓰는 경우 서버들이 중복된 값을 반환하면 안되기에 이를 관리해줘야할텐데 이 때문에 지연시간을 낮추기가 어려울 것이다.✏️ 1단계 문제 이해 및 설계 범위 확정어떤 문제를 풀던 적절한 질문을 통해 모호함을 없애 설계 하며 풀어가야 한다. ID는 어떤 특성을 가지는가? 유일해야하나? ID는 숫자로 구성되어 있는가? ID는 최대 몇 비트로 표현되어야하는가? ID가 꼭 1씩 증가해야하는가? 초당 몇 개의 ID를 만들 수 있는가? 시스템 규모가 얼마나 되는가?✏️ 2단계 개략적 설계안 제시 및 동의 구하기분산 시스템에서 유일성이 보장되는 ID를 만드는 방법은 여러 가지다. 다중 마스터 복제(multi-master replication) UUID(Universally Unique Identifier) 티켓 서버(ticket server) 트위터 스노플레이크(twitter snowflake) 접근법각각의 동작 원리와 장단점을 살펴봐야 한다.다중 마스터 복제이 접근법은 데이터베이스의 auto_increment기능을 활용하는 것이다. 하지만 다음 ID를 구할 때 1씩 증가하는것이 아닌 서버의 대수 k만큼 증가시키는 것이다.서버가 3개라면 서버1은 1,4,7 …이렇게 증가하고 서버2는 2,5,8,… 이런식으로 증가할 것이다.이렇게 하면 규모 확장성 문제를 어느정도 해결할 수 있다. 데이터베이스 수를 늘리면 초당 생산 가능 ID수도 늘릴 수 있기 때문이다. 하지만 서버가 추가되면 이 id들이 고유할까? 단점이 존재한다. 여러 데이터 센터에 걸쳐 규모를 늘리기 어렵다. ID 유일성이 보장되겠지만 그 값이 시간 흐름에 맞추어 커지도록 보장할 수는 없다. 서버를 추가하거나 삭제할 때도 잘 동작하도록 만들기가 어렵다.UUIDUUID는 컴퓨터 시스템에 저장되는 정보를 유일하게 식별하기 위한 128비트짜리의 수다. UUID 값은 충돌 가능성이 극히 낮다. 위키피디아를 인용하면 &quot;중복UUID가 1개 생길확률을 50%로 끌어 올리려면 초당 10억 개의 UUID를 100년 동안 계속해서 만들어야 한다.&quot;고 한다.UUID는 09c93e62-50c4-487q-bfz8n-e05g4687bfs3같은 형태를 띈다.이 구조에서 웹 서버는 별도의 ID 생성기를 사용해 독립적인 ID를 만들어낸다.장점 UUID만드는것이 단순하다. 서버간 조율이 불필요해서 동기화 이슈도 없다. 각 서버가 독립적으로 자기가 쓸 ID를 만드는것이기에 규모 확장이 쉽다.단점 ID가 128비트로 길다. ID를 시간순으로 정렬이 불가능하다. ID에 숫자가 아닌 값이 포함될 수 있다.티켓 서버간단하다. auto_increment 기능을 갖춘 데이터베이스 서버, 즉 티켓 서버를 중앙 집중형으로 하나만 사용하는 것이다. 즉, 고유한 ID를 반환하는 서버 한 대를 둬서 동기화 이슈를 없애는 것이다.장점 유일성이 보장되는 오직 숫자로만 구성된 ID를 만들 수 있다. 구현하기 쉽다.단점 티켓 서버가 SPOF(Single-Point-Of-Failure)가 된다. 이 서버에 장애가 발생하면 해당 서버를 이용하는 모든 시스템에 영향을 준다. 이 이슈를 피하려면 티켓 서버를 여러대 둬야하는데, 이러면 동기화 문제를 피할 수 없다.트위터 스노플레이크 접근법트위터 스노플레이크를 통해서 문제의 요구사항을 만족시킬 수 있다. 기본 개념은 생성해야 하는 ID의 구조를 여러 공간으로 분할하는 것이다. 사인(sign) 비트: 1비트를 할당한다. 개발자가 필요하면 쓰는 공간이다. 음수와 양수를 구분하는데 쓰일 수도 있고 다른 의미로 쓸 수도 있다. 타임스탬프(timestamp): 41비트를 할당한다. Unix-time이후로 몇 밀리초가 경과했는지를 나타내는 값이다. 데이터센터 ID: 5비트를 할당한다. 따라서 $ 2^5 $ 개의 데이터센터를 지원할 수 있다. 서버 ID: 5비트를 할당한다. 따라서 데이터센터당 $ 2^5 $개의 서버를 사용할 수 있다. 일련번호: 12비트를 할당한다. 각 서버에서는 ID를 생성할 때마다 일련번호를 1씩 증가시킨다. 이 값은 1밀리초가 경과할 때마다 0으로 초기화된다.✏️ 3단계 상세설계일단 위 방식에서 데이터센터ID와 서버 ID는 시스템이 시작될 때 결정되며, 일반적으로 시스템 운영중에는 바뀌지 않는다. 이 두 값을 잘못 변경하게 되면 ID 충돌이 날 수 있으니 신중해야 한다.타임스탬프나 일련번호는 ID 생성기가 돌고 있는 중에 만들어지는 값이다.타임스탬프타임스탬프는 시간이 흐름에 따라 점점 큰 값을 가져서 정렬이 가능해진다. 이러한 방식으로 UTC 시각을 추출할 수 있다.중간에 이해 안되는게 있을 것같다.트위터 기원 시각(epoch)을 더함이라는 것인데, 트위터 스노플레이크 접근법은 무조건 Unix-time(1970년 1월1일)을 기원 시각으로 보지 않는다. 책의 예제에서는 Nov 04, 2010, 01:42:54 UTC에 해당하는 값인 1288834974657를 사용한다. 그렇기에 1970년에서 해당 값을 더해서 기원시각을 맞춰주는 것이다.실제 위 그림의 $ 1586451091225 - 297616116568$ 을 한다면 기원시각인 $ 1288834974657 $이 될 것이다.또한 이 기술에서 타임스탬프는 41비트로 표현이 가능하므로 최대 $ 2^41 - 1 $만큼 표현이 가능할 것이다. 이는 약 69년에 해당한다. 만약 69년에 근접한다면 기원시각을 현재로 맞추거나, ID 체계를 다른 것으로 이전해야 한다.일련번호일련번호는 12비트로, $ 2^12 $개의 값을 가질 수 있다.🤔 정리분산환경에서 고유한 ID를 만드는 방법을 알아봤다.그나마 트위터 스노우 플레이크를 제외한 다른 방법들은 장단점이 명확하고 구현이 간단하여 이 챕터에서 어려운 점은 없었다. 다중 마스터 복제: 단순하게 서버의 갯수만큼 Id값을 증가시키는 것이다. 하지만 서버가 삭제되거나 추가될 때 취약하다는 단점이 있다. UUID: 128비트를 가져 중복 확률이 줄지만 고유한 값을 128비트보다 적게 만들 수 있었다. 티켓 서버: 고유한 ID를 반환하는 중앙집중형 서버를 하나 뒀다. 하지만 이 서버가 장애가 난다면 어떻게 해결할 것인가에 대한 의문이 있었다. 트위터 스노우 플레이크: 모든 요구사항을 만족하며 분산환경에서 규모확장도 가능하다." }, { "title": "Java 12버전은 뭐가 달라졌나", "url": "/posts/2022-12-14-JavaVersion12/", "categories": "Java, CS", "tags": "Java", "date": "2022-12-14 05:02:00 +0900", "snippet": "개요자바12는 이전 버전에 비해 크게 바뀐 것은 없다.✏️ 1. New String and Files methodsString.indent()이 함수는 메소드안에 있는 인자만큼 문자열을 들여쓰기 해준다.여러줄에 걸쳐서 들여쓰기를 해야하는 경우 이 함수는 이를 감지하여 적용 시켜준다.@Test@DisplayName(&quot;String.indent() test&quot;)void indentTest(){ String s = &quot;hello my name is kms&quot;; System.out.println(s); System.out.println(s.indent(4)); s = &quot;hello \\n my \\n name \\n is \\n kms&quot;; System.out.println(s.indent(4));}String.transform()이 함수는 인자로 들어온 함수를 문자열에 적용한다.@Test@DisplayName(&quot;String.transform() test&quot;)void transformTest(){ String name=&quot;kms&quot;.transform(String::toUpperCase); Integer i = &quot;0727&quot;.transform(Integer::valueOf); System.out.println(name); System.out.println(i);}근데 위의 소스는@Test@DisplayName(&quot;String.transform() test&quot;)void transformTest(){ String name=&quot;kms&quot;.toUpperCase(); Integer i = Integer.valueOf(&quot;0727&quot;); System.out.println(name); System.out.println(i);}로도 쓸 수 있는데 transform()함수가 무슨 장점이 있는걸까?transform()함수에 들어온 인자값은 런타임에 동적으로 작동한다.이러한 점때문에 프로그램의 유연성을 높일 수 있고, 다양한 용도로 사용할 수 있게 한다.반면에 밑의 소스 경우는 문자열 변환이 컴파일 시에 고정이 된다는 것이다.Files.mismatch()이름에서도 알 수 있다싶이 두 파일을 비교하여 파일의 내용이 같으면 -1을 리턴하고, 다르면 다른 부분의 위치를 반환한다. 그리고 만약 비교 도중에 한 파일이 먼저 EOF에 도달해버리면 해당 파일 내용의 길이를 리턴한다.@Test@DisplayName(&quot;String.mismatch() test&quot;)void fileMismatchTest() throws IOException { //hihihihihi? Path path1 = Path.of(&quot;test1.txt&quot;); Path path2 = Path.of(&quot;test1.txt&quot;); // hihihihihi? Path path3 = Path.of(&quot;test_success.txt&quot;); // hihihihihi Path path4 = Path.of(&quot;test_fail.txt&quot;); // hihihihihi?hihihihihi? Path path5 = Path.of(&quot;test_long.txt&quot;); //파일명, 파일 내용 같을 때 System.out.println(Files.mismatch(path1,path2)); //파일 내용만 같을 때 System.out.println(Files.mismatch(path1,path3)); //내용이 다를 때 System.out.println(Files.mismatch(path1,path4)); //한 파일이 먼저 끝나는 경우 System.out.println(Files.mismatch(path1,path5));}✏️ 2. The Teeing Collector어떤 경우에는 하나의 스트림을 두 개의 스트림으로 쪼개고 싶고, 어떤 경우에는 두 개의 스트림을 하나의 스트림으로 합치고 싶을 때가 있다.밑의 예제는 랜덤한 정수를 가지는 1개의 스트림의 요소중 최댓값과 최솟값을 빼려는 예제다.@Test@DisplayName(&quot;The Teeing Collector test&quot;)void TeeingCollectorTest(){ Stream&amp;lt;Integer&amp;gt; numbers = new Random().ints(100).boxed(); int min = numbers.collect(Collectors.minBy(Integer::compareTo)).orElseThrow(); int max = numbers.collect(Collectors.maxBy(Integer::compareTo)).orElseThrow(); long range = (long) max - min; System.out.println(range);}하지만 실행해보면이러한 예외가 발생한다.왜냐하면 스트림은 일회성이기 때문에 재사용할 수 없기 때문이다. 한 번 최종처리까지 간 스트림은 닫히게 되고 이는 재사용 할 수 없다.그러면 어떻게 해결해야할까?가장 먼저 생각이 드는 방법은 스트림이 닫히기 전에 한 번에 처리하는 것이다.int[] result = numbers.collect( () -&amp;gt; new int[] {Integer.MAX_VALUE, Integer.MIN_VALUE}, (minMax,i) -&amp;gt; { if (i &amp;lt; minMax[0]) minMax[0] = i; if (i &amp;gt; minMax[1]) minMax[1] = i; }, (minMax1, minMax2) -&amp;gt; { if (minMax2[0] &amp;lt; minMax1[0]) minMax1[0] = minMax2[0]; if (minMax2[1] &amp;gt; minMax1[1]) minMax1[1] = minMax2[1]; });long range = (long) result[1] - result[0];System.out.println(range);가독성도 떨어지고 복잡해보인다.여기서 Java12에서 추가된 Teeing Collector를 사용하면 두 개의 Collector를 조합해서 하나의 Collector로 만들어버릴 수 있다.long range = numbers.collect( Collectors.teeing( Collectors.minBy(Integer::compareTo), Collectors.maxBy(Integer::compareTo), (min,max) -&amp;gt; (long) max.orElseThrow() - min.orElseThrow() ));System.out.println(range);가독성은 좋아지고 복잡성은 떨어졌다.이러한 방식이 가능한 이유는 하나의 스트림을 두 개의 다운 스트림(DownStream)으로 쪼개 연산을 수행하고 마지막에 합치는 과정을 거치기 때문이다. tee는 관이나 파이프를 다른 관이나 파이프로 연결하는 것을 의미한다. 그래서 TeeingCollector는 두 개의 Collector를 하나의 Collector로 만들거나 하나의 Collector를 두 개의 Collector로 이어버린다.이러한 유래에서 오지 않을까 한다.✏️ 3. Support for Compact Number FormattingJava12에서는 Compact number formatting이라는 것을 제공하는데, 이건 사람들이 읽기 쉬운 표현으로 숫자를 변환해준다.@Testvoid compactNumberFormattingTest(){ NumberFormat nfShort = NumberFormat.getCompactNumberInstance(Locale.US,NumberFormat.Style.SHORT); NumberFormat nfLong = NumberFormat.getCompactNumberInstance(Locale.US,NumberFormat.Style.LONG); System.out.println(&quot; 1,000 short -&amp;gt; &quot; + nfShort.format(1_000)); System.out.println(&quot; 456,789 short -&amp;gt; &quot; + nfShort.format(456_789)); System.out.println(&quot; 2,000,000 short -&amp;gt; &quot; + nfShort.format(2_000_000)); System.out.println(&quot;3,456,789,000 short -&amp;gt; &quot; + nfShort.format(3_456_789_000L)); System.out.println(&quot;34,456,789,000 short -&amp;gt; &quot; + nfShort.format(34_456_789_000L)); System.out.println(); System.out.println(&quot; 1,000 long -&amp;gt; &quot; + nfLong.format(1_000)); System.out.println(&quot; 456,789 long -&amp;gt; &quot; + nfLong.format(456_789)); System.out.println(&quot; 2,000,000 long -&amp;gt; &quot; + nfLong.format(2_000_000)); System.out.println(&quot;3,456,789,000 long -&amp;gt; &quot; + nfLong.format(3_456_789_000L));}참고로 Locale.KOREA로 바꾸면 1,000 short -&amp;gt; 1천 456,789 short -&amp;gt; 46만 2,000,000 short -&amp;gt; 200만3,456,789,000 short -&amp;gt; 35억34,456,789,000 short -&amp;gt; 345억이런 결과가 나타난다.✏️ 4. Performance Improvements" }, { "title": "Process 정리", "url": "/posts/2022-12-14-TIL/", "categories": "Interview", "tags": "interview", "date": "2022-12-14 02:02:00 +0900", "snippet": " 오타, 지적 환영입니다. ✏️CS스터디 저장소프로세스(Process)쉽게 말하면 실행중인 프로그램이다.디스크에 있는 프로그램이 메모리에 로드되면 프로세스가 된다.여기서 말하는 프로그램이란 .exe파일 같이 아직 실행되지 않은 명령어 집합체를 말한다.1. 프로세스 문맥(Process Context) 여러 프로세스가 타이머 인터럽트에 의해 짧은 시간동안 CPU를 점유하며 서로 제어권을 넘겨주는 시분할 시스템 환경에 의해 나타남. 서로 제어권을 넘길때 어디까지 명령을 수행했는지, 상태에 대한 정보를 나타낼 필요가 있었음.프로세스가 어떤 상태에서 수행되고 있는지 정확히 규명하기 위해 필요한 정보들.프로세스 문맥은 하드웨어 문맥, 프로세스의 주소공간, 커널상의 문맥으로 나뉨. 하드웨어 문맥: PC(Program Counter)와 각종 레지스터에 저장하고 있는 값들. Program Counter는 다음에 실행될 명령어의 주소를 가지고 있는 레지스터. 인텔에서는 IP(Instruction Pointer)로도 불림. 프로세스 주소공간: 코드, 데이터, 스택, 힙으로 구성된 프로세스만의 독자적 주소 공간.코드는 프로그램의 코드가, 데이터는 전역변수 같은 데이터가, 스택에는 함수나 지역변수가 저장되어 있다. 커널상의 문맥: PCB(Process Control Block), Kernel Stack(커널상의 주소)를 말한다.PCB는 밑에서 설명, Kernel Stack이란 간단하게 프로세스 자체에서 처리할 수 없는것들은 운영체제 부탁하는데 이를 시스템 콜이라고 부른다. 시스템 콜이 발생하면 PC는 커널의 Code를 가리키고 커널의 함수를 호출한다. 이때 각 프로세스마다 호출하는 Code를 관리하기 위해서 Kernel Stack을 갖게 됨. 따라서 해당 프로세스의 커널 스택의 값이 뭔지 필요하게 됨.2. 프로세스의 상태PCB를 알기 전에 프로세스 상태에 대해 알고 있어야한다.Five-State Process Model보통 우리는 이 모델을 가지고 설명을 많이한다.시분할 시스템 환경에서 프로세스의 상태는 New, Ready, Running, Waiting, Terminated로 구분이 가능하다. New: 프로세스가 처음 생성된 단계, 메모리 할당 및 PCB와 스택 메모리 할당 및 초기화 등의 작업. Ready: 프로세스가 CPU에 할당되기를 기다리는 상태. Running: 프로세스가 할당되어 CPU를 잡고 명령을 수행중인 상태 Waiting: 프로세스가 어떠한 이벤트가 발생하기를 기다리는 상태 Terminated: 프로세스가 실행을 마치고 완전히 제거되진 않은 상태.State Transitions Dispatcher란 OS 프로그램의 일부로, 실행중인 프로그램을 중단하고 다른 프로그램을 실행시키도록 하는 프로그램이다. New -&amp;gt; ReadyOS가 Ready 단계로 넘어가길 허락(Admit)해야 넘어갈 수 있다.이러한 이유로 메모리 자원 문제 및 CPU 문제가 있기 때문이다. Ready -&amp;gt; RunningDispatcher가 대기하고 있는 프로그램 중 적절한 프로그램을 골라 Running 상태로 옮김. Running -&amp;gt; terminatedOS는 프로그램이 종료하게 되면 exit상태를 거쳐 terminated로 옮김. Running -&amp;gt; Ready프로그램의 할당 시간이 길어지면 timeout이 걸려(interrupt) Ready상태로 돌아간다. Running -&amp;gt; Blocked프로그램 실행중 I/O Request, 시스템콜 등 작업을 요청하면 Blocked상태로 변경하여 대기한다. Blocked -&amp;gt; Ready기다리던 이벤트가 발생하면 Running이 아닌 Ready상태로 간다.중기 스케줄러로 인해 Seven-State Process Model이라는것도 생겨났으니 참고하면 된다.3. PCB(Process Control Block)커널 Data영역에 있는 프로세스에 관한 정보들 OS가 관리하는 정보: (1) 및 스케줄링 및 우선순위에 대한 정보를 가지고 있다.Pointer: 프로세스를 큐에서 관리하기에 이를 나타내기 위한 포인터Process state: 위에서 말한 Ready, Running 등 프로세스 상태Process number(PID): 프로세스를 구별하기 위한 숫자.PCB들은 메모리에 존재하고 상태에 따라 Ready Queue, Event Queue에서 관리 된다. Ready Queue Ready 상태에 있는 프로세스만 모아둔 큐를 말한다.- **Scheduler**가 Ready큐에서 최우선순위 프로세스를 선택.- 선택된 프로세스를 **Dispatch**해서 CPU가 실행한다.(Running) Blocked(Waiting or Event) Queue - 대기큐 Blocked상태에 있는 프로세스만 모아둔 큐- 각각의 `Device driver`에 존재하는 큐- 키보드, 디스크, 네트워크, 세마포어, 등에 대기큐가 존재한다.- 예를 들어 I/O함수 등을 호출하면 Blocked 상태가 되며 PCB를 해당 장치의 대기큐로 이동시킴.- 이벤트가 발생하면 Device driver내의 함수는 대기큐에서 해당 PCB를 찾고 대기큐에서 제거 후 Ready Queue로 넘김.(Ready) CPU 수행 관련 하드웨어 값: (2)에 해당. 해당 프로세스가 어떤 값을 가지고 있었는지에 대한 정보ProgramCounter: 다음에 실행될 명령어의 위치를 가리키는 레지스터Registers: 프로세스 실행 중 사용된 레즈스터 값들 (Accumulator, Index register…) 메모리 관련: (3)에 해당. Code, Data, Stack의 위치 정보. 프로세스가 물리적으로 어디에 있는지 나타내는 위치정보. 파일 관련: (4)에 해당. 어떤 파일을 열어놨는지 등에 대한 정보참고로 Blocked에 있는 프로세스를 찾을때 포트번호로 구별하여 PCB를 찾는다.4. Context Switch멀티 프로세스 환경에서 프로세스가 실행되다가 인터럽트가 발생해서 CPU를 한 프로세스에서 다른 프로세스로 넘겨주는 과정운영체제는 CPU를 내어주는 A프로세스의 상태를 A프로세스의 PCB에 저장하고, CPU를 새롭게 얻는 B프로세스의 상태를 B프로세스의 PCB에서 읽어온다. CPU입장에서는 Context는 PCB이고, 이가 바뀌는것이 Context Switch다. 이는 OS 스케줄러에서 수행한다.인터럽트나 시스템콜이 발생한다해서 반드시 Context Switch가 발생하는것은 아니다. Context Switch가 발생하지 않는 경우프로세스A -&amp;gt; interrupt or system call -&amp;gt; kernelMode -&amp;gt; 프로세스A : Context Switch 없음. Context Switch가 발생하는 경우프로세스A -&amp;gt; interrupt or I/O system call -&amp;gt; kernelMode -&amp;gt; Context Switch -&amp;gt; 프로세스B Context Switch시 Cache memory flush라는 프로세스가 바뀔때 Cache를 초기화 시켜 오버헤드가 큼. 단점으로 캐시 히트가 줄어들고 초반 프로세스 작업 속도가 느려질 수 있다. 또한 Context Switch을 하는동안 CPU는 아무일을 하지 않는 시간이 발생하는데 이를 오버헤드라고 부름.5. Process Management시스템이 부팅된 후 최초 프로세스는 운영체제가 직접 생성, 그 이후로는 프로세스를 복제하여 생성하게 된다.프로세스를 복제한 프로세스를 부모 프로세스 새롭게 생성된 프로세스를 자식 프로세스라고 한다.각 프로세스는 PID로 구별되고, 자원은 운영체제로부터 할당받거나 부모와 공유한다.fork()fork()라는 시스템콜은 새로운 프로세스를 생성한다.fork()를 통해 자식은 부모의 pid를 제외하고 그대로 복사한다. fork()함수의 리턴값은 부모는 0보다 큰 수, 자식은 0을 갖는다.#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;static void ssu_charatatime(char *str) { char *ptr; int print_char; setbuf(stdout, NULL); for (ptr = str; (print_char = *ptr++) != 0;) { putc(print_char, stdout); usleep(10); }}int main(int argc, char *argv[], char *envpp[]) { pid_t pid; if ((pid = fork()) == 0) { ssu_charatatime(&quot;output from child\\n&quot;); } else if (pid &amp;gt; 0) { ssu_charatatime(&quot;output from parent\\n&quot;); } exit(0);}결과6. Process Cooperating프로세스는 동작 방식에 따라 2가지 방식으로 나뉜다. 먼저 독립적 프로세스(Independent Process)는 각자 주소 공간을 가지면서 수행되고 원칙적으로는 하나의 프로세스가 다른 프로세스의 수행에 영향을 미치지는 않는다.협력 프로세스(Cooperating Process)는 IPC(InterProcess Communication)이라는 프로세스 협력 메커니즘을 통해 하나의 프로세스가 다른 프로세스 수행에 영향을 미칠 수 있다.IPC에는 크게 두 모델이 있다.공유 메모리(Shared Memory)서로 다픈 프로세스 간에 일부 주소 공간을 공유.위의 그림처럼 같은 공간을 사용하므로 일관성 문제가 생길 수 있다.장점으로는 커널을 거치지 않기에 빠르다.커널은 또 정리하는 편이 좋지만 여기서는 간단하게 fork()라는 함수를 실행하면 OS자체에서 내부적으로 이 코드를 실행하기 위해 로직을 돌텐데 이때 도는 로직들은 커널공간에서 돈다고 생각하면 된다.메시지 패싱(Message Passing)커널을 통해 메시지를 주고 받는다. Context Switch가 발생하기에 속도가 느리지만, 커널이 기본 기능을 제공하기에 구현이 쉽고, 일관성 문제를 해결하기 쉽다. 기본적으로 Send/Receive 동작을 통해 교환한다.1) Direct Communication통신하는 프로세스의 이름을 명시적으로 표시해야한다.때문에 서로 이름만 알면 된다. 이는 단점이 될 수도 있는데, 만약 프로세스의 이름을 변경해야한다면 연결되어 있는 모든 Send/Receive 프로세스를 바꿔줘야한다.2) Indirect Dommunicationmailbox를 통해 메시지를 전달한다.이 mailbox는 고유의 ID를 가지고 있고, 이 ID를 통해 연결된 프로세스들이 통신을 할 수 있다. Blocking send : 수신자(프로세스 or mailbox)가 메시지를 받을 때까지 발신자는 block 된다. Non-blocking send : 발신자가 메시지를 보내고 작업을 계속한다. Blocking receive : 수신자가 메시지를 받을 때까지 block 된다. Non-blocking receive : 수신자는 유효한 메시지 또는 null 메시지를 받는다.프로세스끼리 통신할 때 파이프(Pipe)방식으로도 통신한다. 이는 단방향만 가능해서 양방향으로 통신하려면 두 개의 파이프가 필요하다.이 파이프는 Anonymous 파이프와 named 파이프로 구분되는데 전자는 부모-자식 또는 공통의 부모를 갖는 프로세스끼리 통신이 가능하다. 후자는 그런 관계 없이 사용할 수 있다.Reference https://velog.io/@zooneon/OS-Process-State#-dispatcher 프로세스 상태모델 https://ws-pace.tistory.com/20 PCB 등 https://rebro.kr/172 Context Switch https://bubble-dev.tistory.com/entry/CC-fork2 fork()" }, { "title": "가상 면접 사례로 배우는 대규모 시스템 설계 기초 6장 - 키-값 저장소 설계", "url": "/posts/2022-12-14-interviewBook06/", "categories": "Book, 가상 면접 사례로 배우는 대규모 시스템 설계 기초", "tags": "book, interview", "date": "2022-12-14 01:02:00 +0900", "snippet": " 가상 면접 사례로 배우는 대규모 시스템 설계 기초 책 정리 글입니다.개요키-값 저장소는 키-값 데이터베이스라고도 불리는 비 관계형 데이터베이스다. 여기에 저장되는 값은 이를 식별할 수 있는 고유한 키를 가져야하고, 이러한 연결 관계를 키-값 쌍(pair)이라고 한다. put(key,value): 키-값 쌍을 저장소에 저장한다. get(key): 인자로 주어진 키에 달린 값을 꺼낸다.✏️ 문제 이해 및 설계 범위 확정다음 특성을 갖는 키-값 저장소를 설계해본다고 한다. 키-값 쌍의 크기는 10KB 이하이다. 큰 데이터를 저장할 수 있어야 한다. 높은 가용성을 제공. 시스템은 설사 장애가 있더라도 빨리 응답해야한다. 높은 규모 확장성을 제공. 트래픽 양에 따라 자동적으로 서버 증설/삭제 이루어져야한다. 데이터 일관성 수준은 조정이 가능해야 한다. 응답 지연시간이 짧아야 한다.✏️ 단일 서버 키-값 저장소한 대 서버만 사용하는 키-값 저장소를 설계하는 것은 쉽다.키-값 쌍 전부 메모리에 해시 테이블로 저장해버려 빠른 접근속도를 보장하게 하지만 모든 데이터를 메모리 안에 두는게 사실상 불가능하다. 이를 해결하기 위해서는 데이터 압축(compression)이나 자주 쓰이는 데이터만 메모리에 두고 나머지는 디스크에 저장하는 방법이 있다.결국 개선의 일종이고 단 한 대로 모든 데이터를 저장하는 것은 벅찰 때가 있다. 그래서 분산 키-값 저장소를 만들 필요가 있다.✏️ 분산 키-값 저장소분산 해시 테이블이라고도 불리는 분산 키-값 저장소는 키-값 쌍을 여러 서버에 분산 시키는 방식이다.분산 시스템을 설계할 때에는 CAP정리(Consistency, Availability, Partition Tolerance theorem)을 이해하고 있어야 한다.CAP 정리데이터 일관성(C), 가용성(A), 파티션 감내(P)라는 세 가지 요구사항을 동시에 만족하는 분산 시스템을 설계하는 것은 불가능하다는 정리다. 데이터 일관성: 분산 시스템에 접속하는 모든 클라이언트는 어떤 노드에 접속했느냐에 관계없이 언제나 같은 데이터를 봐야한다. 가용성: 분산 시스템에 접속하는 클라이언트는 일부 노드가 장애를 발생하더라도 항상 응답을 받아야 한다. 파티션 감내: 파티션은 두 노드 사이에 통신 장애가 발생했음을 의미하는데, 이러한 파티션이 생기더라도 시스템은 계속 동작하여야 한다는 뜻이다.CAP 정리는 이들 가운데 어떤 두 가지를 충족하려면 나머지 하나는 희생되어여 한다는 뜻이다.위 그림에서 일관성과 가용성을 가져가고 파티션감내를 희생한 CA시스템은 실세계에 존재하지 않는다고 한다. 왜냐하면 네트워크 장애는 피할 수 없는 일로 여겨져 파티션 감내를 할 수 있도록 분산 시스템은 설계되어야 하기 때문이다.위의 설계 예시를 들려면 먼저 이상적인 상태를 봐야한다.분산 시스템에서 데이터는 여러 노드에 복제되어 보관된다. 위 그림에서 n1, n2, n3는 노드이고, 모두 원본 데이터를 완벽히 복제한 상태이다. 이상적인 환경이라면 네트워크가 파티션이 일어나지 않을 환경이다. 이런 경우 데이터 일관성과 가용성도 만족된다.실세계의 분산 시스템하지만 분산 시스템은 파티션 문제를 피할 수 없다. 그리고 파티션 문제가 발생하면 우리는 일관성과 가용성 사이에서 하나를 선택해야 한다. n3가 고장난 상태. n1, n2과 통신 불가능일관성을 선택한다면 데이터 불일치 문제를 피하기 위해 n1,n2에 쓰기 연산을 중단시켜야하는데, 그렇게 하면 가용성이 깨진다. 은행 시스템처럼 어느 서버에 들어가든 계좌의 같은 정보를 조회해야하는 곳은 일관성을 양보하지 못한다. 하지만 쓰기 연산을 중단하여 최신 계좌를 반환하지 못하는데, 어쩔 수 없이 파티션 문제를 해결할 때까지 오류를 반환하는 수 밖에 없다.가용성을 선택한다면 설사 낡은 데이터를 반환할 위험이 있더라도 계속해서 읽기 연산을 허용해야 한다. n1, n2는 계속 쓰기를 허용할 것이고, 파티션 문제가 해결 된 뒤에 새 데이터를 n3에 전송할 것이다.시스템 컴포넌트키-값 저장소 구현에 사용될 핵심 컴포넌트 및 기술들이라고 한다. 데이터 파티션 데이터 다중화(replication) 일관성(consistency) 일관성 불일치 해소(inconsistency resolution) 장애 처리 시스템 아키텍처 다이어그램 쓰기 경로 읽기 경로데이터 파티션대규모 애플리케이션의 경우 전체 데이터를 한 대 서버에 욱여 넣는것은 불가능하다. 그렇기에 데이터를 작은 파티션들로 분할하여 여러 대의 서버에 저장하는게 좋다.데이터를 파티션으로 나눌때 고려해야할 사항들이 있다. 데이터를 여러 서버에 고르게 분산할 수 있는가 노드가 추가되거나 삭제될 때 데이터의 이동을 최소화할 수 있는가저번 포스팅(5장)에서 안정 해시에 대해 이야기했고, 이 기술이 이런 문제를 푸는데 적합한 기술이다.데이터 다중화높은 가용성과 안정성을 확보하기 위해 데이터를 N개 서버에 비동기적으로 다중화할 방법이 필요하다.위에서 말한 안정 해시 기준으로 key0이 들어온다치고 그 지점으로부터 시계방향으로 순회하면서 N개의 노드를 거치면서 데이터 사본을 저장하는 것이다. N이 3개이면 key0은 s1, s2, s3에 저장된다.하지만, 가상 노드를 사용하면 가상 노드도 순회하면서 복사본을 저장하고 카운터를 올려주므로 실제 물리적 서버는 1군데만 거칠 수 있다.(s1이라는 서버를 가기 전에 s1을 가리키는 가상 노드 3개를 이미 거친 경우)이런 경우를 대비하기 위해 같은 물리 서버를 중복 선택하지 않도록 해야한다.같은 데이터 센터에 속한 노드들은 정전, 네트워크 이슈, 자연재해 등의 문제를 동시에 겪을 수 있으므로 데이터 사본들을 다른 센터의 서버에 보관하고, 센터의 네트워크 품질을 높이는 방법도 고려해봐야 한다.데이터 일관성정족수 합의(Quorum Consensus)프로토콜을 사용하면 읽기/쓰기 연산 모두에 일관성을 보장할 수 있다. N: 사본 개수 W: 쓰기 연산에 대한 정족수. 쓰기 연산이 성공한 것으로 간주되려면 적어도 W개의 서버로부터 쓰기 연산이 성공했다는 응답을 받아야한다. R: 읽기 연산에 대한 정족수. 읽기 연산이 성공한 것으로 간주되려면 적어도 W개의 서버로부터 읽기 연산이 성공했다는 응답을 받아야한다. N=3인 경우W=1의 의미는 쓰기 연산이 성공했다고 판단하기 위해서는 중재자는 최소 한 대(1)의 서버에서 쓰기 성공 응답을 받아야 한다는 뜻이다.위 예제에서 만약 s1에서 쓰기 연산에 성공했다고 응답을 받으면 s0, s2는 응답을 기다릴 필요가 없는 것이다.중재자는 클라이언트와 노드 사이에서 proxy역할을 한다.W, R, N의 값을 정하는 것은 응답 지연과 데이터 일관성 사이의 타협점을 찾는 과정이다. W=1 또는 R=1이면 중재자는 한 군데에서만 응답을 받으면 되니 응답속도가 빠를 것이다. W나 R의 값이 1보다 크면 응답속도는 느릴테지만 데이터 일관성의 수준은 향상될 것이다.W+R &amp;gt; N인 경우에는 강한 일관성이 보장된다. 저 식을 만족하기 위해서는 적어도 하나의 노드는 쓰기와 읽기 둘 다 응답을 했기 때문이다.그렇기에 W, R을 적절한 값으로 정해야한다. 밑은 예시라고 한다. W=N, R=1: 빠른 읽기에 최적화된 시스템 R=N, W=1: 빠른 쓰기에 최적화된 시스템 W+R &amp;gt; N: 강한 일관성이 보장 W+R &amp;lt;= N: 강한 일관성이 보장되지 않음.일관성 모델일관성 모델은 데이터 일관성의 수준을 결정한다. 강한 일관성: 모든 읽기 연산은 가장 최근에 갱신된 결과를 반환한다. 약한 일관성: 읽기 연산은 가장 최근에 갱신된 결과를 받지 못할 수도 있다. 최종 일관성: 약한 일관성의 한 형태로, 갱신 결과가 결국 모든 사본에 반영(동기화) 되는 모델이다.강한 일관성을 달성하려면, 모든 사본에 쓰기 연산의 결과가 반영되기 전까지 해당 데이터에 대한 읽기/쓰기를 금지하는 것이다. 이 방법은 고가용성 시스템에 적합하지 않은데, 새로운 요청의 처리가 중단되기 때문이다.카산드라, 다이나모 같은 저장소는 최종 일관성 모델을 채택하고 있다. 이 경우 쓰기 연산이 병렬적으로 발생하면 시스템에 저장된 값의 일관성이 깨질 수 있는데, 이 문제는 클라이언트가 해결해야 한다고 한다. 일관성이 깨진 데이터를 읽지 않도록 하는 방법 중 데이터 버저닝이라는 것이 있다.비 일관성 해소 기법: 데이터 버저닝 데이터를 변경할 때마다 해당 데이터의 새로운 버전을 만드는 것을 의미한다.다음과 같은 상황에서 데이터 일관성이 깨지게 될 것이다. 어떤 데이터의 사본이 노드n1, n2에 저장되어 있다.만약 서버1과 서버2에서 노드n1, n2에 저장된 값을 동시에 수정하려고 한다면 충돌이 일어날 것이다.n1에 저장된 값의 버전을 v1이라하고, n2에 저장된 값의 버전을 v2라하자.이렇게 v1과 v2 사이의 충돌을 발견하고 자동으로 해결해 낼 버저닝 시스템이 필요한데 벡터 시계(vector clock)은 이러한 문제를 푸는데 보편적으로 사용되는 기술이다.벡터 시계벡터 시계는 [서버, 버전]의 순서쌍을 데이터에 매단 것이다.D([S1,v1],[S2,v2]…[Sn,vn])처럼 표현한다고 가정하고 D는 데이터, $ S_i $는 서버, $ v_i $는 버전이다.만일 데이터 D를 $ S_i $에 기록하면 아래 작업 가운데 하나를 수행해야 한다. [Si, vi]가 있으면 $ v_i $을 증가시킨다. 그렇지 않으면 [Si, 1]을 만든다. 충돌 났을때 벡터 시계가 처리하는 방법벡터 시계를 사용하면 어떤 버전 X가 버전 Y의 이전 버전인지 쉽게 판단할 수 있다. 버전 Y에 포함된 모든 구성요소의 값이 X에 포함된 모든 구성요소의 값보다 같거나 큰지만 보면 된다.D([s0,1],[s1,1])은 D([s0,1],[s1,2])의 이전 버전이다. 따라서 두 데이터 사이에 충돌은 없다.어떤 버전 X와 Y 사이에 충돌이 있는지 확인하려면 버전 Y에 포함된 모든 구성요소의 값이 X에 포함된 모든 구성요소의 값보다 작은지 보면 된다.(Y가 최신화 데이터라는 기준)D([s0,1],[s1,2])와 D([s0,2],[s1,1])은 서로 충돌한다.벡터 시계를 사용해 충돌을 감지하고 해소하는 방법에는 두 가지 단점이 있다. 충돌 감지 및 해소 로직이 클라이언트에 들어가, 클라이언트 구현이 복잡해짐. [서버:버전]의 순서쌍 개수가 굉장히 빨리 늘어난다는 점.이 문제를 해결하기 위해서는 어떤 임계치를 설정하고 임계치 이상으로 길어지면 오래된 순서쌍을 제거하도록 해야하는데, 이렇게 하면 버전 간 선후 관계를 정확하게 결정할 수 없기에 효율성이 낮아진다.하지만 다이나모 데이터베이스에 관계된 문헌에 따르면 아마존은 실제 서비스에서 그런 문제가 벌어지는 것을 발견한 적이 없다고 한다.장애 처리장애를 처리하기 위해서는 우선 장애 감지(failure detection) 기법들과 장애 해소(failure resolution)전략들을 볼 필요가 있다.장애 감지분산 시스템에서 한 대 서버(B) “A서버가 죽었습니다.” 라고해서 서버A를 바로 장애처리를 하지 않는다. 보통 두 대 이상의 서버가 똑같이 “A서버가 죽었습니다.”라고 해야 장애가 발생했다고 간주하게 된다.이는 모든 노드 사이에 멀티캐스팅(multicasting) 채널을 구축하는 것이고, 장애를 감지하기 가장 손쉬운 방법이다. 하지만 이 방법은 노드 수가 많아지면 점점 비효율적으로 동작할 것이다.가십 프로토콜(gossip protocol)가 같이 분산형 장애 감지 솔루션을 채택하는 편이 보다 효율적이다.가십 프로토콜의 동작원리는 다음과 같다. 각 노드는 멤버십 목록을 유지한다. 멤버십 목록에는 각 멤버 ID와 그 박동 카운터 쌍의 목록이다. 각 노드는 주기적으로 자신의 박동 카운터를 증가시킨다. 각 노드는 무작위로 선정된 노드들에게 주기적으로 자기의 박동 카운터 목록을 보낸다. 박동 카운터 목록을 받은 노드는 멤버십 목록을 최신값으로 갱신한다. 어떤 멤버의 박동 카운터 값이 지정된 시간 동안 갱신되지 않으면 해당 멤버는 장애상태인 것으로 간주한다.위의 예시는 다음과 같이 동작한다. 노드 s0은 노드s2(멤버ID=2)의 박동 카운터가 오랫동안 증가되지 않은것을 발견한다. 노드s0은 노드s2를 포함하는 박동 카운터 목록을 무작위로 선택된 다른 노드들에게 전달한다. 노드s2의 박동 카운터가 오랫동안 증가되지 않았음을 발견한 모든 노드들은 해당 노드를 장애 노드로 표시한다.일시적 장애 처리가십 프로토콜로 장애를 감지하면 가용성을 보장하기 위해 필요한 조치를 취해야 한다.위에서 설명한 정족수 합의의 느슨한 정족수 접근법을 통해 가용성을 올릴 수 있다. 엄격한 정족수 접근법을 쓰면 데이터 읽기와 쓰기 연산을 금지해야하기에 가용성이 떨어지기 때문이다.네트워크나 서버 문제로 장애 상태인 서버로 가는 요청들은 다른 서버들이 임시로 맡아 처리한다. 그동안 발생한 변경사항은 해당 서버가 복구되었을 때 일괄 반영하여 데이터 일관성을 보존한다. 이를 위해 임시로 쓰기 연산을 처리한 서버에는 그에 관한 단서(hint)를 남겨둔다. 이러한 방식을 단서 후 임시 위탁(hinted handoff)기법이라 부른다.이러한 상태에서 노드s2에 대한 읽기 쓰기 연산은 일시적으로 s3가 처리할 것이다. s2가 복구되면 s3은 갱신된 데이터를 s2로 인계할 것이다.영구 장애 처리위의 임시 위탁 기법은 일시적 장애 처리를 위함이고, 영구 장애 처리를 위해서는 반-엔트로피(anti-entropy)프로토콜을 사용해야 한다. 이 프로토콜은 사본들을 비교하여 최신 버전으로 갱신하는 과정을 포함한다. 또한 일관성이 망가진 데이터를 탐색하고 전송 데이터의 양을 줄이기 위해 머클(Merkle)트리를 사용한다.밑은 키 공간 1부터 12까지일 때 머클 트리를 만드는 예제이다.1단계: 키 공간을 버킷(bucket)으로 나눈다. (예제에서는 4개)2단계: 각각의 키에 균등 분포 해시를 적용하여 해시값을 계산3단계: 버킷별로 해시값을 계산하여 노드를 생성 및 버킷에 연결4단계: 자식 노드의 레이블로부터 새로운 해시를 계산하여 이진트리를 상향식으로 구상해 나간다.이를 위에서 부터 역추적하며 비교하여 동기화하는 버킷을 찾아나가 동기화한다.위의 기술들을 고려한 아키텍처는 다음과 같을 수 있다.쓰기 경로 카산드라 구조 참조 쓰기 요청이 커밋 로그에 기록 데이터가 메모리 캐시에 기록 메모리 캐시가 가득차거나 사전에 정의된 임계치에 도달하면 데이터는 디스크에 있는 SSTable에 기록.SSTable: Sorted-String Table의 약자로 &amp;lt;키,값&amp;gt;의 순서쌍을 정렬된 리스트 형태로 관리하는 테이블읽기 경로 메모리 캐시에 데이터가 있는 경우메모리 캐시에 데이터가 있는 경우에는 바로 데이터를 클라이언트에 반환하면 된다. 데이터가 메모리 캐시에 없는 경우SSTable에서 찾는 키가 있는지 알아야하는데, 이러 문제를 푸는데는 블룸 필터(Bloom filter)가 흔히 사용된다. 데이터가 메모리가 없으면 블룸 필터를 검사한다. 블룸 필터를 통해 어떤 SSTable에 키가 보관되어 있는지 알아낸다. SSTable에서 해당 데이터를 가져온다. 해당 데이터를 클라이언트에 반환한다.🤔 정리생각이상으로 정리해야할게 많았다.분산 키-값 저장소를 구현할 때에는 CAP정리에 의해 파티션 감내 부분은 계속해서 신경 써야했다. 거기서 일관성을 고려하느냐 가용성을 고려하느냐의 차이가 있었다.안정 해시를 통해 데이터를 파티션 단위로 나눠 여러 대의 서버에 저장했고 데이터 다중화도 어느정도 해결할 수 있었다.다중화된 데이터들의 일관성을 유지하기 위해 N,W,R을 가지는 정족수 합의라는 프로토콜을 이용하였고, 사실상 최종 일관성 모델을 일관성 모델로 채택하여 비일관성 문제를 해결하기로 하였다.비일관성 해소 기법으로 데이터 버저닝이라는 것이 있었고, 벡터 시계라는 기술에 따라 데이터 충돌에 대해 감지하고 처리하였다.장애처리를 위해서 먼저 장애를 감지하여야했다. 장애 감지를 위해 모든 노드 사이에 채널을 구축하는 방법이 있었지만 분산 시스템에서는 비효율적으로 작동하였고 가십 프로토콜을 통해 각 노드들의 박동 카운터를 서로 주고받아 헬스 체크를 하였다.장애를 발견한 뒤, 단서 후 임시 위탁 기법을 통해 임시로 다른 서버가 요청을 받았는데 이는 일시적으로 장애를 해결하기 위한 기법이고 영구적인 장애를 처리하는데에는 반-엔트로피프로토콜과 머클트리를 이용하여 해결하였다." }, { "title": "가상 면접 사례로 배우는 대규모 시스템 설계 기초 5장 - 안정 해시 설계", "url": "/posts/2022-12-13-InterviewBook05/", "categories": "Book, 가상 면접 사례로 배우는 대규모 시스템 설계 기초", "tags": "book, interview", "date": "2022-12-13 01:02:00 +0900", "snippet": " 가상 면접 사례로 배우는 대규모 시스템 설계 기초 책 정리 글입니다.개요요청 또는 데이터를 서버에 균등하게 나누는 것이 중요하다. 안정 해시는 이 목표를 달성하기 위해 보편적으로 사용하는 기술이다.✏️ 해시 키 재비치(rehash) 문제보편적으로 해시 함수는 다음과 같이 사용한다.serverIndex = hash(key) % N(서버의 개수)만약 서버의 개수4 라고 하면 키 해시값 해시 % 4 key0 5 1 key1 6 2 key2 7 3 key3 8 0 그러면 서버 입장에서는 hash(key0) % 4 =1이면, 클라이언트는 캐시에 보관된 데이터를 가져오기 위해 서버 1에 접속해야한다.위와 같은 방법은 서버 풀(pool)의 크기가 고정되어 있을 때, 데이터 분포가 균등할 때 잘 작동한다. 하지만 서버가 삭제가 되거나 추가되면 어떻게 될까?예로 서버1이 장애를 일으켜 동작이 중지되었다면 서버 풀의 크기는 3이 될 것이고, 그에따른 해시 값의 나머지 연산들은 바뀔 것이다. 키 해시값 해시 % 3 key0 5 2 key1 6 0 key2 7 1 key3 8 2 서버가 하나 줄음에 따라 해시의 나머지값들이 기존 값과 동일한 것이 단 하나도 없다. 이러면 1번 서버가 죽으면 모든 캐시 클라이언트가 데이터가 없는 서버에 접근하게 된다는 것이다. 그 결과로 대규모 캐시 미스(cache miss)가 발생할 것이다. 안정 해시는 이 문제를 효과적으로 해결하는 기술이다.✏️ 안정 해시해시 테이블 크기가 조정될 때 오직 k/n개의 키만 재배치하는 해시 기술 k는 키의 개수, n은 슬롯(slot)의 개수이다.해시 공간과 해시 링해시 함수f는 SHA-1을 사용한다고 가정하면 해시를 통해 나온 값의 범위는 0부터 $ 2^{160} -1$ 까지라고 알려져 있다.x0을 0, xn은 $ 2^{160} -1 $ 라고 하면이러한 길이를 가지는 공간을 가질 것이다. 사이사이 공간들은 x1,x2,x3…라고 가정한다. 이 공간을 해시 공간(hash space)이라고 한다.그리고 이를 양쪽을 접어 구부리면이러한 그림의 형태인 해시 링(hash ring)이라고 한다.해시 서버이를 해시 함수 f를 통해서 서버IP나 이름을 이 링 위의 어떤 위치에 대응시킬 수 있다. 만약 4개의 서버가 있다고 하고 서버를 배치한다고 하면이런식으로 배치할 수 있다.해시 키여기서 사용된 해시 함수f는 나머지 연산을 하지 않고 있음을 알고 있어야한다. 때문에 해시 키는 링 위의 어느 지점에 배치할 수 있다.서버 조회어떠한 키가 저장되는 서버는, 해당 키가 시계 방향으로 링을 탐색했을때 조우하는 첫 번째 서버다. 때문에 위 그림에서 key0은 server0에 저장되고 key1는 server1에 저장되는 식이다.서버 추가만약 서버가 추가되더라도 키 가운데 일부만 재배치하면 된다.server4가 추가되자 key0은 server0에 저장되는것이 아닌 server4에 저장될 것이다.그림이 너무 당연해서 뭐가 바뀐건지 헷갈릴 수 있는데, 나머지연산으로 재배치했던 해시함수는 모든 키의 저장 위치가 바뀔 수 있었는데 이 방식은 서버가 추가되어도 모든 키에 영향을 미치는게 아니라는 것이다.서버 제거마찬가지로 서버가 하나 제거 되었을때 그 서버가 저장하고 있던 키들만 재배치 해주면 될 것이다.기본 구현법의 두 가지 문제기본 절차는 다음과 같다. 서버와 키를 균등 분포(uniform distribution) 해시 함수를 사용해 해시 링에 배치한다. 키의 위치에서 링을 시계 방향으로 탐색하다 만나는 최초의 서버가 키가 저장될 서버다.생각해보면 첫 번째 조건이 굉장히 이상적이라고 볼 수 있다. 당장 위의 예제만 봐도 서버 하나가 지워지거나 추가될 때마다 균등성이 깨져버린다.또 다른 문제는 키가 하나의 서버에 몰려서 저장될 가능성이 높아서 균등성 문제가 생긴다는 것이다. s1,s3는 아무 키도 저장되어있지 않은데 s2에 대부분의 키가 저장되어있는걸 볼 수 있다.이를 해결하기 위해서 가상 노드(virtual node) 또는 복제(replica)라 불리는 기법이 생겼다.가상 노드가상 노드는 실제 노드 또는 서버를 가리키는 노드다.결과적으로 이 노드들을 링위에 많이 넣어버려서 해시 링에 균등성을 주는 것이다.동작 방식 서버0과 서버1이 있다. (더 추가 가능) 서버0과, 서버1은 N개의 가상 노드를 가진다.(여기서 N은 3이라 가정) s0_0, s0_1, s0_2는 서버0의 가상노드들이고, s1_0, s1_1, s1_2는 서버 1의 가상노드들이다. 서버0과 서버1은 이 노드들의 경계들(파티션)을 관리하게 된다.이제 새로운 키가 서버에 저장되어야 한다고 하면, 키의 위치가 임의적으로 정해지고 링을 탐색하면서 가장 가까운 서버에 저장될 것이다.k0이라고 불리는 키가 s1.1에 저장되는데 s1.1은 가상노드이고 실제 가리키는 건 서버1이므로 서버1에 저장될 것이다.이렇듯, 가상 노드를 늘리면 키의 분포는 점점 균등해지지만 저장할 공간이 더 필요해진다는 트레이드 오프가 있다.때문에 적절히 노드 개수를 조절해야한다.🤔 정리안정 해시가 나오게 된 배경은 보편적으로 사용하는 해시 함수의 경우 서버가 삭제나 추가 되었을 때 키가 재분배 되느라 없는 캐시에 접근하여 캐시 미스가 발생하는 확률을 줄이고 키가 최대한 덜 재분배되고 균등하게 맞추는 목표에 있다.안정 해시의 이점은 다음과 같다. 서버가 추가되거나 삭제될 때 재배치 되는 키의 수가 최소화된다. 데이터가 보다 균등하게 분포되어 수평적 규모 확장이라는 목표에 달성하기 쉬워졌다. 핫스팟(hotspot) 키 문제를 줄인다. 특정 샤드(shard)에 접근이 지나치게 빈번하거나 등의 문제를 말한다. 안정 해시는 데이터를 좀 더 균등하게 분배하므로 이런 문제가 생길 가능성을 줄여준다.안정 해시는 실제로 널리 쓰이는 기술이고, 네트워크 부하 분산기, CDN, 디스코드 채팅 어플리케이션, 아파치 카산드라 클라스터에서의 데이터 파티셔닝, 아마존 다이나모 데이터베이스의 파티셔닝 관련 컴포넌트에서 쓰인다." }, { "title": "Java 11버전은 뭐가 달라졌나", "url": "/posts/2022-12-11-JavaVersion11/", "categories": "Java, CS", "tags": "Java", "date": "2022-12-12 02:02:00 +0900", "snippet": "개요자바 11버전부터는 LTS(Long-Term Support)개념이 들어간다.일반적인 소프트웨어는 새로운 버전이 출시될 때마다 이전 버전에 대한 업데이트를 중지하는데, LTS는 긴 기간 동안 지속적인 지원을 받을 수 있기 때문에, 기업이나 조직 등에서 사용하여 안정성을 어느정도 보장받을 수 있다.✏️1. Local-Variable Syntax for Lambda ParametersJava10에서 var에 대해 알아봤다.Java11에서는 람다식에 var를 생략할 수 있게 하였다.일반적으로 람다식에는 매개변수 타입을 명시해야하는데, Java11에서는 매개변수 타입을 생략할 수 있게 해준다는 것이다.//기존 사용방식var arrInteger = new Integer[]{5, 9, 3, 6, 2, 4, 8, 7, 1, null};//기본 명시적 타입long cnt = Arrays.stream(arrInteger).filter( (Integer x) -&amp;gt; (x != null &amp;amp;&amp;amp; x &amp;gt; 5)).count();System.out.println(cnt);//var를 쓴 명시적 타입cnt = Arrays.stream(arrInteger).filter( (var x) -&amp;gt; (x!= null &amp;amp;&amp;amp; x&amp;gt; 5)).count();System.out.println(cnt);이렇듯 매개변수 타입명을 적어줬는데 타입을 생략할 수 있게 한다는 것이다.//기본 암묵적 타입cnt = Arrays.stream(arrInteger).filter( x -&amp;gt; (x != null &amp;amp;&amp;amp; x &amp;gt; 5)).count();System.out.println(cnt);자바 컴파일러가 자동으로 타입을 추론한다. 이를 통해 코드를 짧게 쓸 수 있다.var를 명시적으로 쓰는 경우에는 validation을 위해 쓰는 경우가 있다.var arrInteger = new Integer[]{5, 9, 3, 6, 2, 4, 8, 7, 1, null};//var에 어노테이션을 추가 Null이면 에러try { cnt = Arrays.stream(arrInteger).filter( (@Nonnull var x) -&amp;gt; (x &amp;gt; 5)).count(); System.out.println(cnt);}catch (NullPointerException e){ System.out.println(e);}//var에 어노테이션을 추가 Null허용 null인경우 10으로 초기화해서 count값을 증가cnt = Arrays.stream(arrInteger).filter( (@Nullable var x) -&amp;gt; { if(x == null) x = 10; return x &amp;gt; 5; }).count();System.out.println(cnt);}이 경우 위의 결과는 에러가 발생할 것이고, 밑에는 5가 나올 것이다. 위의 모든 코드를 돌렸을때두 가지를 혼용하지 말라고 한다. 타입을 모두 생략하거나 타입을 모두 적거나 모든 타입에대해 var를 쓰거나 하라고 한다.✏️2. HTTP Client (Standard)Java11버전 이전에는 HTTP통신을 하려면 많은 양의 코드를 요구하였다.Java11에서는 새로운 HttpClient클래스가 생겨났고, 이 클래스가 제공하는 API들이 코드를 효율적으로 짤 수 있게 도와주었다.@Test@DisplayName(&quot;자바 11버전 이전 포스트 요청&quot;)void HttpClientBefore() throws IOException { URL urlObj = new URL(&quot;http://localhost:8080/api/test&quot;); HttpURLConnection con = (HttpURLConnection) urlObj.openConnection(); con.setRequestMethod(&quot;POST&quot;); con.setRequestProperty(&quot;Content-Type&quot;, &quot;application/json&quot;); // Send data con.setDoOutput(true); String data = &quot;test&quot;; try (OutputStream os = con.getOutputStream()) { byte[] input = data.getBytes(StandardCharsets.UTF_8); os.write(input, 0, input.length); } // Handle HTTP errors if (con.getResponseCode() != 200) { con.disconnect(); throw new IOException(&quot;HTTP response status: &quot; + con.getResponseCode()); }else { // Read response String body; try (InputStreamReader isr = new InputStreamReader(con.getInputStream()); BufferedReader br = new BufferedReader(isr)) { body = br.lines().collect(Collectors.joining(&quot;n&quot;)); } System.out.println(&quot;Body: &quot; + body); con.disconnect(); }}이 코드를 실행 시키기 위해서 SpringMVC를 추가하고 Controller를 추가하였다.컨트롤어에는 요청 바디에 있는 값을 그대로 돌려주는 역할을 한다. 즉, body에 test를 포함해 Post요청을 하였으므로 test가 반환되어야 할 것이다.코드가 정말 긴데, Java 11버전부터 새로운 HttpClient클래스가 생겼다.이를 통해 이전 버전에 비해 매우 짧고 효율적은 코드를 작성할 수 있게 되었다.@Test@DisplayName(&quot;자바 11이후 포스트 요청&quot;)void HttpClientNew() throws IOException, InterruptedException { URL url = new URL(&quot;http://localhost:8080/api/test&quot;); HttpClient client = HttpClient.newHttpClient(); String data = &quot;test&quot;; HttpRequest request = HttpRequest.newBuilder() .uri(URI.create(String.valueOf(url))) .header(&quot;Content-Type&quot;, &quot;application/json&quot;) .POST(HttpRequest.BodyPublishers.ofString(data)) .build(); HttpResponse&amp;lt;String&amp;gt; response = client.send(request, HttpResponse.BodyHandlers.ofString()); if (response.statusCode() != 200) { throw new IOException(&quot;HTTP response status: &quot; + response.statusCode()); } System.out.println(&quot;Body: &quot;+response.body());}새로생긴 HttpClient클래스는 매우 다양한 기능을 수행한다고 한다. 위 코드에서 BodyPublisher.ofString()을 통해 문자열을 보냈는데, BodyPublisher클래스에 있는 ofByteArray(),ofByteArrays(),ofFile() 등을 통해 여러 데이터를 보낼 수 있다. 마찬가지로 응답에 있는 BodyHandlers도 ofString()을 통해 응답을 문자열로 받을 수 있지만 파일, 배열 등으로도 받을 수 있다. HttpClient는 HTTP/2.0을 지원하기 시작. HttpClient는 비동기적 요청도 지원한다.@Test@DisplayName(&quot;자바 11 비동기 post요청&quot;)void AsyncPostTest() throws MalformedURLException, ExecutionException, InterruptedException { URL url = new URL(&quot;http://localhost:8080/api/test&quot;); HttpClient client = HttpClient.newHttpClient(); String data = &quot;kms async test&quot;; HttpRequest request = HttpRequest.newBuilder() .uri(URI.create(String.valueOf(url))) .header(&quot;Content-Type&quot;, &quot;application/json&quot;) .POST(HttpRequest.BodyPublishers.ofString(data)) .build(); //요청이 비동기적이라 결과를 받아, 저장할 곳이 필요함. CompletableFuture클래스를 이용. //사실상 요청이 완료될때까지 프로그램을 대기시키기에 비동기라 할 수 없겠지만 출력물으 보여주기 위해 어쩔 수 없음. 실제 업무에서는 이렇게 쓰지 말 것. CompletableFuture&amp;lt;HttpResponse&amp;lt;String&amp;gt;&amp;gt; responseFuture = client.sendAsync(request, HttpResponse.BodyHandlers.ofString()); HttpResponse&amp;lt;String&amp;gt; response = responseFuture.get(); System.out.println(response.body());}✏️3. New Collection.toArray() Method기존 Collection 인터페이스는 두 가지의 toArray()라는 컬렉션을 배열로 바꾸는 함수를 제공했다.List&amp;lt;String&amp;gt; list = List.of(&quot;kms&quot;,&quot;test&quot;,&quot;java11&quot;);Object[] strings1 = list.toArray();String[] strings2 = list.toArray(new String[list.size()]);String[] strings3 = list.toArray(new String[0]);인자를 받지 않는 toArray()의 경우 리턴값이 Object형이다. 이는 Type erasure라는 현상 때문인데, Type erasure란 자바에서 리스트를 생성할때 제너릭을 사용하면 컴파일시점에 타입이 결정이 된다. 근데 컴파일러가 코드를 컴파일하면서 제너릭의 타입 정보는 사라지게 되는데, 이렇게 컴파일 시점에 타입 정보가 사라지는 현상을 Type erasure라고 한다. 따라서 리스트의 타입 정보는 런타임때에 알 수 없어서 오브젝트 형으로 반환되는 것이다.즉, List&amp;lt;String&amp;gt; list는 컴파일때 타입 소거로 인해 단순히 List가 되어버리기에 list.toArray()는 Object형으로 반환해야 한다.두 번째 toArray() 메서드는 매개변수로 배열을 지정할 수 있는 오버로드 된 메서드이다. 이 메서드는 매개변수로 지정한 배열의 타입을 요청하게 된다. 만약 지정한 배열의 크기가 리스트의 요소 개수보다 적다면, 새로운 배열을 생성하여 리스트의 요소를 복사한 후 리턴하고,지정한 배열의 크기가 리스트의 요소 개수보다 크거나 같다면, 지정한 배열에 리스트의 요소를 복사한 후 리턴한다.Java 11에서는 새로운 방식으로 쓸 수 있게 되었는데,String[] strings = list.toArray(String[]::new);이 방식을 사용하면 Collection 클래스가 절달된 배열 생성자의 참조를 사용하여 필요한 크기의 배열을 만들 수 있게 된다.그런데 이 기능은 잘 사용되지 않는다. 그 이유는 컬렉션 인터페이스에만 구현되어 있기 때문이다.이 코드의 구현방식을 보면 빈 배열을 만들고, 기존 toArray()를 호출하는 방식으로 되어 있다.default &amp;lt;T&amp;gt; T[] toArray(IntFunction&amp;lt;T[]&amp;gt; generator) { return toArray(generator.apply(0));}문제는 이 메소드를 오버라이드 하지 않는 컬렉션 구현체가 많다는 것이다.✏️4. New String MethodsJava 11버전에서 String클래스에 함수들이 추가적으로 생겼다.String.strip(), stripLeading(), stripTailing()예시를 보는게 빠르다.// 문자열 앞 뒤 공백 제거 함수 strip()String stripTest = &quot; 1 2 3 4 5 6 &quot;;System.out.println(stripTest.strip() + &quot;7&quot;);//문자열 앞 공백 제거 함수 stripLeading()System.out.println(stripTest.stripLeading() +&quot;7&quot;);//문자열 뒤 공백 제거 함수 stripTailing()System.out.println(stripTest.stripTrailing() + &quot;7&quot;);// trim() vs strip()String trimTest = &quot;\\u2003\\u2003\\u2003\\u2003\\u2003kms&quot;;System.out.println(trimTest);System.out.println(trimTest.trim());System.out.println(trimTest.strip());기존 trim()와 뭐가 다른걸까? trim(): 이 함수는 ‘\\u0020’이하의 공백들만 제거한다. strip(): 유니코드의 공백들을 제거한다. 유니코드에는 ‘\\u0020’ 이하의 공백문자 뿐만아니라 다양한 공백문자가 있다. 그 중 하나가 위와 같은 ‘\\u2003’같은 것들이다.String.isBlank()이 함수는 각 요소들이 Character.isWhitespace()가 true이면 true를 리턴한다. Character.isWhitespace()함수는 공백 문자인지 여부를 판단하는 함수라서 문자열에 속해있느 모든 문자가 공백인지를 확인하여 공백이면 true를 리턴한다는 것이다.//String.isBlank()String isBlankTest = &quot; &quot;;//TrueSystem.out.println(isBlankTest.isBlank());String.repeat()이 함수는 주어진 String을 연속적으로 나열하는 기능을 한다.//String.repeat()//hi?hi?hi?hi?hi?hi?hi?hi?hi?hi?System.out.println(&quot;hi?&quot;.repeat(10));String.lines()이 함수는 line을 기준으로 String을 분리하는 기능을 한다. 리턴형은 Stream이다.//String.lines()Stream&amp;lt;String&amp;gt; lines = &quot;foo\\nbar\\nbaz&quot;.lines();lines.forEachOrdered(System.out::println);✏️5. Files.readString() und writeString()Java 6 이후로 텍스트 파일을 읽고 쓰는 것이 더욱 간편해졌다.Java 6에서는 파일을 읽기 위해 FileInputStream을 열고, InputStreamReader와 BufferedReader를 사용해야 했고, 텍스트 파일의 각 줄을 StringBuilder로 읽은 다음, finally를 통해 reader와 stream을 닫아야 했다.Java 7에서는 Files.newBufferedWriter()와 Files.newBufferedReader()를 사용하면 finally구문이 없어도 reader와 stream을 닫을 수 있어서 더 간편하게 구현이 가능해졌다.@Test@DisplayName(&quot;자바7 파일 입출력&quot;)void Java7FileWriteRead() throws IOException{ //write Path path = Paths.get(&quot;./samplejava7.txt&quot;); String text=&quot;java 7 file test&quot;; try(BufferedWriter writer = Files.newBufferedWriter(path,StandardCharsets.UTF_8)){ writer.write(text); } //read StringBuilder sb = new StringBuilder(); try(BufferedReader reader = Files.newBufferedReader(path,StandardCharsets.UTF_8)){ String line; while((line = reader.readLine()) != null){ sb.append(line).append(&#39;\\n&#39;); } } System.out.println(sb.toString());}Java11은 더욱 간편하게 표현이 가능해졌다.@Test@DisplayName(&quot;자바11 파일 입출력&quot;)void Java11FileWriteRead() throws IOException{ //write Path path = Paths.get(&quot;./samplejava11.txt&quot;); String text=&quot;java 11 file test&quot;; Files.writeString(path,text,StandardCharsets.UTF_8); //read String reader = Files.readString(path,StandardCharsets.UTF_8); System.out.println(reader.toString());}✏️6. Path.of()이전에 Path객체를 생성하려면 Paths.get()을 사용했는데, 이는 getter처럼 보여서 혼동이 있었다고 한다.그래서 Path.of로 바꾸고 기능은 동일하게 바꾸었다.실제로 Paths.get()메소드의 구현 방식을 보면 Path.of()를 호출하게 되어있다.public static Path get(String first, String... more) { return Path.of(first, more);}즉, 혼동을 줄이기 위해 이름을 바꾸었다는 것이다.그래서 위의 예제는 다음 코드로 바꿀 수 있다.@Test@DisplayName(&quot;자바11 파일 입출력&quot;)void Java11FileWriteRead() throws IOException{ //write Path path = Path.of(&quot;./samplejava11.txt&quot;); String text=&quot;java 11 file test&quot;; Files.writeString(path,text,StandardCharsets.UTF_8); //read String reader = Files.readString(path,StandardCharsets.UTF_8); System.out.println(reader.toString());}✏️7. Epsilon: A No-Op Garbage CollectorEpsilon GC라는 가비지 컬렉터가 추가되었다.Epsilon GC는 힙에 할당된 객체들을 관리하는 가비지 컬렉터인데 일반적인 가비지 컬렉터 기능인 메모리해제 기능을 수행하지 않는다.왜냐하면 Epsilon GC는 시스템의 성능을 측정하거나, 시스템에서 가비지 컬렉션이 정상적으로 수행되는지 확인하는데 쓰이기 때문이다.-XX:+UseEpsilonGC이 커맨드를 java명령어에 추가해서 Epsilon GC를 사용할 수 있게 되었다.✏️8. Launch Single-File Source-Code Programspublic class Hello { public static void main(String[] args) { if (args.length &amp;gt; 0) { System.out.printf(&quot;Hello %s!%n&quot;, args[0]); } else { System.out.println(&quot;Hello!&quot;); } }}이러한 코드가 있을때 이를 실행하려면 컴파일을 거치고 실행했어야했다.$ javac Hello.java$ java Hello Anna⟶Hello Anna!Java 11부터는 컴파일 명령어를 생략할 수 있게 되었다.$ java Hello.java Anna⟶Hello Anna!위와 같이 달라져서 소스코드는 작업메모리에서 컴파일되고 실행이 되는 하나의 과정을 거치게 된다.✏️9. Nest-Based Access Control 이부분은 해석하기 어려워서 다른사람글을 가져왔습니다.출처: https://dreamchaser3.tistory.com/4class Test { static class Nest1 { private int nest1Var; } static class Nest2 { private int nest2Var; } }위와 같이 nested class의 경우, ‘Test’, ‘Nest1’, ‘Nest2’는 모두 ‘nestmate’이다. 기존 JVM 상에서는 nestmate끼리 private 멤버 변수를 접근하려면 컴파일러가 중간에 bridge method를 만들어야 했다. 따라서, reflection을 사용하여 nestmate class의 private 멤버 변수에 접근하려고 하면, llegalAccessException이 발생한다. 이러한 모순을 해결하고자, 새로운 ‘nest’라는 class file 개념을 도입해 하나의 중첩 클래스이지만 서로 다른 클래스파일로 분리하여 bridge method의 도움 없이도 서로의 private 멤버에 접근할 수 있도록 하였다.✏️10. Java Flight RecorderJava에는 개발을 도와주는 많은 분석 툴들이 있다. 근데 애플리케이션 런타임에 발생하는 문제들을 잡기는 보통 어렵다. 런타임에 발생하는 문제를 재발생 시키거나 재구현 하는게 까다로운 일인데 Java Flight Recoder는 런타임의 JVM 데이터나 여러환경들을 실시간으로 저장하고 분석하기 쉬운 파일로 저장할 수 있게 하여 에러 분석하는데 도와준다.Java Flight Recorder는 Oracle JDK에는 상용화 되었는데, 이번에 OpenJDK의 일부가 되면서 자유롭게 사용할 수 있게 되었다.#https://docs.oracle.com/javacomponents/jmc-5-4/jfr-runtime-guide/run.htm#JFRUH164# 이런식으로 실행이 가능하다.java -XX:+UnlockCommercialFeatures -XX:+FlightRecorder -XX:StartFlightRecording=duration=60s,filename=myrecording.jfr myApp✏️11. JDK Mission ControlJDK Mission Control은 Java 개발자를 위한 도구 중 하나로, Java 프로그램의 디버깅과 성능 모니터링을 돕는 데 사용된다. 이 도구는 JDK에 포함되어 있으며, Java 프로그램을 실행하는 동안 사용자가 실행 중인 작업을 모니터링하고 디버깅을 수행할 수 있도록 도와준다. 또한, 이 도구를 사용하면 Java 프로그램의 성능을 향상시킬 수 있는 방법을 찾을 수 있다고 한다.✏️ 12. ZGC: A Scalable Low-Latency Garbage CollectorZ Garbage Collector = ZGC는 Oracle에서 개발한 새로운 가비지 컬렉터로 전체 GC의 STW(Stop-The-World)하는 시간을 최대 10ms까지 줄여버린다. Java11기준 리눅스에서만 사용이 가능하고 다음 명령어를 통해 사용할 수 있다.-XX:+UnlockExperimentalVMOptions -XX:+UseZGC여담으로 ZGC는 Java15버전에서 프러덕션으로 상용화 되었다.결론Java11버전 에서는 람다 표현식에 var를 사용할 수 있게 되었고,새로운 HttpClient클래스가 나와 편리성을 도왔으며, 파일 입출력의 변화로 단 한 줄로 파일 입출력이 가능해졌다. 또한, Path클래스에 대한 변화를 줘서 코드 가독성이 힘을 주었고, Epsilon GC를 도입함으로써 시스템 성능을 향상 시켰다.java 명령을 통해 별도의 컴파일 없이 컴파일부터 실행까지 진행할 수 있게 되었다.Nest-Based Access Control를 통해서 컴파일러가 nested class를 인식하기 편하게 되었고, 여러 분석툴(Flight Recorder, JDK Mission Control)을 통해 애플리케이션을 추적, 모니털이 하기 쉬워졌다." }, { "title": "가상 면접 사례로 배우는 대규모 시스템 설계 기초 4장 - 처리율 제한 장치의 설계", "url": "/posts/2022-12-12-InterviewBook04/", "categories": "Book, 가상 면접 사례로 배우는 대규모 시스템 설계 기초", "tags": "book, interview", "date": "2022-12-12 01:02:00 +0900", "snippet": " 가상 면접 사례로 배우는 대규모 시스템 설계 기초 책 정리 글입니다.개요이 장에서는 클라이언트가 보내는 트래픽을 제한하는 방법을 설명한다.클라이언트의 요청 횟수를 제한하는것이 대표적이며, 처리율을 제한함으로써 얻는 이점은 다음과 같은게 있다. Dos(Denial of Service) 공격에 의한 자원고갈을 방지할 수 있다. 비용절감. 만약 써드 파티API에의해 서비스를 제공하고 있다면 처리율을 제한함으로써 비용절감 효과를 볼 수 있다. 서버 과부하 제어. Dos 방지와 비슷하게 사용자의 잘못된 패턴으로 유발된 트래픽을 걸러내거나 봇(bot)을 이용한 유발된 트래픽을 걸러낼 수 있다.✏️ 1단계: 문제 이해 및 설계 범위 확정처리율 제한 장치를 구현하는 데는 여러 알고리즘을 사용할 수 있는데, 질문을 통해서 어떤 제한 장치를 구현해야할 지 명확히 할 필요가 있다. 서버측 제한장치 or 클라이언트 제한장치인지?(서버측 제한 장치라 가정) IP주소를 기준으로? 사용자ID를 기준으로 API호출을 제한해야할지? 또 다른 기준이 있는지? 시스템 규모는 스타트업 정도인지? 사용자가 많은 큰 기업인지? 분산 환경에서도 작동해야하는지? 처리율 제한 장치는 독립된 서비스인지? 애플리케이션 코드에 포함 되는지? 처리율 제한에 걸리면 사용자에게 알려야하는지?✏️ 2단계: 개략적 설계안 제시 및 동의 구하기기본적인 클라이언트-서버 통신 모델을 사용하도록 하자.처리율 제한 장치는 어디에 둘 것인가?클라이언트에 둘 수도 있고 서버에 둘 수도 있다. 클라이언트에 둔다: 클라이언트 요청은 쉽게 위/변조가 가능해서 모든 클라이언트를 통제하기가 어렵다. 클라이언트에 두는 선택이 좋은 선택이 될 수 없다. 서버에 둔다: 서버측에 제한 장치를 두거나, 처리율 제한 미들웨어(middleware)를 만들어 해당 미들웨어로 하여금 API 서버로 가는 요청을 제한한다.만약 미들웨어를 두고 초당 2번씩 요청을 받는 제한을 걸었다고 치자.만약 3번째 요청이 오면 다음과 같이 reject할 것이다.클라우드 마이크로서비스의 경우, 처리율 제한 장치는 보통 API 게이트웨이라 불리는 컴포넌트에 의해 구현된다.API 게이트웨이는 처리율 제한, SSL종단, 사용자 인증, IP 목록 관리 등을 지원하는 클라우드 업체가 유지 보수를 담당하는 서비스이다.그래서 API 게이트웨이를 둬서 중간에 요청을 막는게 좋은지, 서버에 둬서 요청을 막는게 좋은지는 회사의 기술스택이나 인력, 우선순위, 목표에 따라 달라진다고 한다.고려해야할 사항은 다음과 같다. 프로그래밍 언어, 캐시 서비스 등 현재 사용하고 있는 기술스택이 서버에서 처리율 제한을 구현할 정도로 효율이 좋은지 확인해야 한다. 처리율 제한 알고리즘을 정하고, 제 3사업자가 제공하는 게이트웨이가 해당 알고리즘을 지원하는지 확인해야한다. 서버측에서 모든걸 구현하기로 했다면 알고리즘은 자유롭게 선택할 수 있다.처리율 제한 알고리즘 토큰 버킷(token bucket) 누출 버킷(leaky bucket) 고정 윈도 카운터(fixed window counter) 이동 윈도 로그(sliding window log) 이동 윈도 카운터(sliding window counter)토큰 버킷 알고리즘아마존과 스트아리프가 API 요청을 통제하기 위해 이 알고리즘을 사용한다. 폭넓게 이용되어, 개발자들의 이해도가 높은 편이다.동작 원리토큰 버킷은 지정된 용량을 가지는 컨테이너다.이 버킷에는 사전에 설정된 양의 토큰이 주기적으로 채워지는데, 토큰이 꽉 차면 더 이상의 토큰은 추가되지 않고, 추가로 공급된 토큰들은 버려진다.그림은 용량이 4인 버킷이고 매초 2개의 토큰을 추가한다. 그리고 더 추가되는 토큰들은 버려진다.각 요청은 처리될 때마다 하나의 토큰을 사용한다. 요청이 도착하면 토큰이 있는지 검사하고 토큰이 있으면 버킷에서 토큰 하나를 꺼내, 요청을 처리하고 토큰이 없는 경우 해당 요청은 버려진다.토큰 버킷은 2개의 인자를 받는다. 버킷 크기: 버킷에 담을 수 있는 최대 토큰의 수 토큰 공급률: 초당 몇 개의 토큰이 버킷에 공급되는지버킷을 몇 개나 사용해야하는지는 공급 제한 규칙에 따라 달라진다. 통상적으로, API 엔드포인트마다 별도의 버킷을 둔다. 사용자마자 하루에 한 번 포스팅을 할 수 있고, 하루에 한 번 댓글을 달 수 있고, 150명의 친구를 추가할 수 있다고 하면 사용자마다 3개의 버킷을 두어야할 것이다.(포스팅API, 댓글API, 친구추가API) IP 주소별로 처리율을 제한해야한다면 IP 주소마다 하나의 버킷을 둬야할 것이다. 시스템 처리율을 초당 10,000개 요청으로 제한하고 싶다면, 모든 요청이 하나의 버킷을 공유해야 할 것이다.장점 구현이 쉽다. 메모리 사용 측면에서도 효율적이다. 짧은 시간에 집중되는 트래픽도 처리 가능하다.단점 버킷 크기와 토큰 공급률을 적절하게 튜닝하는 것은 까다로운 일이다.누출 버킷 알고리즘토큰 버킷 알고리즘과 비슷하지만 요청 처리율이 고정되어 있다는것이 다르다. 보통 FIFO 큐로 구현된다.동작 원리 요청이 도착하면 큐가 가득 차 있는지 확인한 뒤, 빈 자리가 있으면 큐에 요청을 추가 큐가 가득 차 있는 경우에는 새 요청은 버린다. 지정된 시간마다 큐에서 요청을 꺼내서 처리.누출 버킷 알고리즘은 두 개의 인자를 갖는다. 버킷 크기: 큐 사이즈와 같은 값. 처리율: 지정된 시간당 몇 개의 항목을 처리할지 지정하는 값. 보통 초 단위장점 큐의 크기가 제한되어 메모리 사용량 측면에서 효율적 고정된 처리율을 갖고 있어서 안정된 출력(stable outflow rate)가 필요한 경우에 적합.단점 단시간에 많은 트래픽이 몰리면 큐에 요청들이 쌓이고, 요청을 제때 처리하지 못하면 최신 요청들이 버려진다. 토큰 버킷과 마찬가지로 두 개의 인자를 튜닝하는것이 까다롭다.고정 윈도 카운터 알고리즘동작방식 타임라인을 고정된 간격의 윈도(window)로 나누고, 각 윈도마다 카운터를 붙인다. 요청이 접수될 때마다 카운터의 값은 1씩 증가한다. 이 카운터의 값이 사전에 설정된 임계치에 도달하면 새로운 요청은 새 윈도가 열릴때까지 버려진다.위의 예제를 해석하자면 타임라인은 1초이고, 시스템은 초당 3개까지의 요청을 허용한다. 만약 3개 이상의 요청이 밀려오면 초과분은 버려진다.이 알고리즘은 문제는 경계 부근에 순간적으로 많은 트래픽이 집중된 경우 할당된 양보다 더 많은 요청이 처리될 수 있다는 것이다.위 예제는 분당 최대 5개의 요청을 허용하는 시스템이다.분마다 카운터가 초기화 되는데, 2:00:30초부터 2:01:30초까지 10개의 요청이 몰려 처리해버리게 된다. 이는 2:01:00초에 카운터가 초기화되서 이런 현상이 벌어진 것이고, 분당 최대 5개 처리하는 허용 한도의 2배를 처리해버리게 되는 것이다.장점 메모리 효율이 좋다.단점 위와같이 윈도 경계 부근에서 일시적으로 많은 트래픽이 몰리는 경우, 설정했던 처리 한도보다 많은 양의 요청을 처리하게 된다.이동 윈도 로깅 알고리즘고정 윈도 카운터 알고리즘의 문제를 해결하기 위해 나타난 알고리즘이다.동작원리 요청의 타임스탬프(timestamp)를 추적한다. 타임스탬프 데이터는 보통 레디스(Redis)의 정렬 집합(sorted set)와 같은 캐시에 보관한다. 새 요청이 오면 만료된 타임스탬프는 제거한다. 새 요청의 타임스탬프를 로그에 추가한다. 로그의 크기가 허용치보다 같거나 작으면 요청을 시스템에 전달하고 그렇지 않은 경우 처리를 거부한다.위의 예시는 그림을 보면 간단히 이해가 되기에 추가적으로 해석하지는 않겠습니다.장점 처리율 제한 매커니즘은 아주 정교하다. 어느 순간 윈도를 보더라도, 허용되는 요청의 개수는 시스템의 처리율 한도를 넘지 않는다.단점 다량의 메모리를 사용한다. 거부된 요청의 타임스탬프도 보관되기 때문이다.이동 윈도 카운터 알고리즘고정 윈도 카운터 알고리즘 + 이동 윈도 로깅 알고리즘을 결합한 것이다.두 가지 접근법이 있지만 여기서는 하나만 다루었다.처리율 한도가 분당 5개인데, 이전 1분에서 5개 현재 1분동안 3개의 요청이 왔다. 현재 1분의 30%시점(1분 18초정도?)에 요청이 도착한 경우 현재 윈도에 몇 개의 요청이 온 것으로 보고 처리해야할까? 현재 1분간의 요청 수 + 직전 1분간의 요청 수 * 이동 윈도와 직전 1분이 겹치는 비율=&amp;gt; 이 공식에 따라 현재 윈도에 들어 있는 요청은 3+5 * 70% = 6.5개다. 올림하거나 내림할 수 있는데 예제에서는 내림해서 6개로 계산하였다.처리율 한도가 분당 7개라하면 현재 1분의 30%시점에 도착한 신규 요청은 시스템으로 전달되지만 처리율 한도가 분당 5개라면 요청을 받을 수 없을 것이다.장점 메모리 효율이 좋다. 이전 시간대의 평균 처리율에 따라 현재 윈도의 상태를 계산하므로 짧은 시간에 몰리는 트래픽에도 잘 대응한다.단점 직전 시간대에 도착한 요청이 균등하게 분포되어 있다고 가정한 상태에서 추정치를 계산하기에 다소 느슨하지만, 그렇게 심각하지는 않다.개략적인 아키텍처위에서 설명한 카운터는 어디에 보관할 것인가?데이터베이스는 디스크접근을 해야하므로 느려서 안된다. 빠른데다가 시간 만료 정책을 지원하는 캐시가 적절하다. 레디스(Redis)는 처리율 제한 장치를 구현할 때 자주 사용되는 메모리 기반 저장장치다. 카운터에 관한 명령어도 지원한다.(INCR, EXPIRE)✏️ 3단계: 상세 설계 처리율 제한 규칙은 어떻게 만들어지고 어디에 저장되는가? 처리가 제한된 요청들은 어떻게 처리되는가?에 대한 이야기다.처리율 제한 규칙리프트라는 회사는 처리율 제한에 오픈소스를 사용하고 있다.domain: messagingdescriptiors: - key: message_type Value: marketing rate_limit: unit: day requests_per_unit: 5 마케팅 메시지의 최대치를 하루 5개로 제한하는 예제이런 규칙들은 보통 설정 파일 형태로 디스크에 저장된다.(.env같은거 말하는듯)처리율 한도 초과 트래픽의 처리어떤 요청이 한도 제한에 걸리면 HTTP 상태코드는 429(too many requests)를 클라이언트에 보낸다.경우에 따라 요청을 처리하기 위해 큐에 보관하여 처리할 수도 있을 것이다.처리율 제한 장치가 사용하는 HTTP헤더클라이언트가 자기 요청이 처리율 제한이 걸리고 있는지, 자기 요청이 처리율 제한에 걸리기까지 얼마나 많은 요청을 보낼 수 있는지를 알 수 있을까?HTTP 응답헤더에는 이러한 정보를 담고 있다. X-Ratelimit-Remaining: 윈도 내에 남은 처리 가능 요청의 수 X-Ratelimit-Limit: 매 윈도마다 클라이언트가 전송할 수 있는 요청의 수 X-Ratelimit-Retry-After: 한도 제한에 걸리지 않으려면 몇 초 뒤에 요청을 다시 보내야하는지에 대한 정보정리 처리율 제한 규칙은 디스크에 저장하고 작업 프로세스가 수시로 디스크에서 읽어서 캐시에 저장. 클라이언트가 요청을 보내면 처리율 제한 미들웨어에 도착. 처리율 제한 미들웨어는 캐시에서 규칙을 가져오고 카운터 및 마지막 요청의 타임스탬프를 레디스 캐시에서 가져온 뒤, 가져온 값에 근거하여 결정을 내린다. 해당 요청이 처리율 제한에 걸리지 않으면 API서버로 보냄. 처리율 제한에 걸리면 Http Status는 429를 보냄. 요청은 폐기하거나 큐에 보관. 분산 환경에서의 처리율 제한 장치의 구현여러 대의 서버와 병렬 스레드를 지원하도록 시스템을 확장하는 것은 또 다른 문제다.경쟁 조건과 동기화라는 어려운 문제를 해결해야하기 떄문이다.경쟁 조건처리율 제한 장치는 대략 다음과 같이 동작한다. 레디스에서 카운터의 값을 읽는다. counter+1이 임계치를 넘는지 본다. 넘지 않는다면 레디스에 보관된 카운터 값을 1 증가시킨다.여기서 문제는 counter+1에 있는데요청들이 counter를 증가시키기 전에 캐시에서 꺼내버리면 다음과 같은 일이 벌어진다.사실상 요청이 2개가 끝난 뒤 counter값은 5가되어야하지만 병렬로 읽어버려서 counter값은 5가 안 될수도 있다는 것이다.이를 해결하기 위해서 락(lock)을 걸 수도 있지만 성능이 떨어진다는 문제가 있다.그래서 루아 스크립트(Lua script)나 정렬 집합(sorted set)이라 불리는 레디스 자료구조를 사용하여 해결할 수 있다.동기화 이슈수백만의 사용자를 지원하려면 하나의 처리율 제한 서버로는 부족할 것이다. 그래서 처리율 제한 장치 서버를 여러 대 두게 되는데, 이 경우 동기화가 필요해진다.저번에 설명한 고정 세션을 통해서 같은 클라이언트로부터의 요청은 항상 같은 처리율 제한 장치로 보낼 수 있지만 확실히 유연하지 않다.더 나은 해결책은 레디스와 같이 중앙 집중형 데이터 저장소를 사용하는 것이다.성능 최적화서버와 멀어지면 사용자에게 응답을 주는 지연시간(latency)가 증가할 수 밖에 없다. 이를 고려해야한다.또한, 제한 장치간에 데이터를 동기화할 때 최종 일관성 모델을 사용해야하는데 이것도 고려해야할 점이다.모니터링요약하자면 채택된 처리율 제한 알고리즘이 효과적인지, 정의한 처리율 제한 규칙(파라미터)등이 효과적인지를 확인해야 한다.✏️ 4단계: 마무리책에서는 다음과 같은 부분을 추가적으로 생각해보면 좋다고 한다. 경성(hard) 또는 연성(soft) 처리율 제한 경성: 요청의 개수는 임계치를 절대 넘어설 수 없다. 연성: 요청 개수는 잠시 동안은 임계치를 넘을 수 있다. 다양한 계층의 처리율 제한 이 장에서는 OSI7계층 기준 7번째인 어플리케이션 계층에서 처리율을 제한한 것이다. 다양한 계층에서 처리율을 제한할 수 있다고 한다. 처리율 제한을 회피하는 방법. 최대한 클라이언트쪽에서 해결하는방법에 대한 고민 클라이언트 측 캐시를 사용하여 API호출을 줄인다. 예외나 에러를 처리하는 코드를 도입하여 클라이언트가 예외적 상황으로부터 우아하게 복구될 수 있도록 한다. 재시도(retry)로직을 구현할 때 충분한 백오프(back-off) 시간을 둔다. 🤔 정리1단계에서는 처리율 제한 장치가 왜 필요한지, 어떻게 설계해야할지 질문을 통해 찾아갔다.2단계에서는 처리율 제한장치를 어디에 둘지를 정하고(거의 서버쪽) 미들웨어를 둘지 서버에 둘지도 선택하였다. 이를 선택하는 요인들은 있었다. 알고리즘에 따라 기술스택에 따라처리율 제한 알고리즘은 토큰 버킷, 누출 버킷, 고정 윈도 카운터, 이동 윈도 로그, 이동 윈도 카운터가 있었다.카운터는 보통 동작이 빠르고 만료 정책을 지원하는 캐시에 저장하고 이를 도와주는 도구로는 레디스가 있었다.3단계에서는 처리 제한 규칙과 제한된 요청들은 어떻게 처리할 지에 대한 이야기를 했다.처리 제한 규칙은 설정 파일에, 캐시에 저장하여 처리율 제한 미들웨어가 요청이 들어올때마다 캐시에 저장된 설정 파일을 근거해 처리하였다.분산 처리환경에서는 동시성 문제와 일관성 문제를 해결하기 위해 정렬 집합이고 중앙 집중형 데이터 저장소라 불리는 레디스 자료구조를 추천하였다.성능 최적화와 모니터링할 때는 응답지연시간과 알고리즘 처리율에 대해 지켜봐야하는것도 알아봤다.이번장은 면접에서 몇 번 나온적이 있다.중요한 내용이므로 복기가 필수적으로 필요할 것 같다." }, { "title": "가상 면접 사례로 배우는 대규모 시스템 설계 기초 3장 - 시스템 설계 면접 공략법", "url": "/posts/2022-12-09-InterviewBoo03/", "categories": "Book, 가상 면접 사례로 배우는 대규모 시스템 설계 기초", "tags": "book, interview", "date": "2022-12-09 01:02:00 +0900", "snippet": " 가상 면접 사례로 배우는 대규모 시스템 설계 기초 책 정리 글입니다.개요시스템 설계 면접은 두 명의 동료가 모호한 문제를 풀기 위해 협력하여 해결책을 찾아가는 과정이다. 때문에 정답도 없고 결과도 없다. 설계과정에서 내린 결정에 대해 방어하는 능력을 보는 과정이고, 면접관의 피드백을 건설적인 방향으로 처리할 자질이 있음을 보는 면접이다.시스템 설계 면접은 지원자의 설계 능력의 기술적 측면을 평가하는 자리이면서 더 나아가 협력에 적합한 사람인지, 압박이 심한 상황에서도 잘 대처해나가는지, 모호한 문제도 잘 해결해나갈 수 있는지 등을 보는 자리다.✏️ 4단계 접근 방법1단계: 문제 이해 및 설계 범위 확정퀴즈쇼처럼 답을 빨리 할 필요가 없다. 속도를 늦추고 깊이 생각하고 질문하여 요구사항과 가정을 분명히 해야한다. 올바른 질문을 하고, 면접관이 대답을 해주면 적어두는 편이 좋다. 나중에 쓰이기 때문이다.예를 들어, 다음과 같은 질문들을 할 수 있다. 어떤 기능을 만들어야하는가? 제품 사용자 수는 얼마나 되는가? 회사의 규모가 얼마나 빨리 성장할 것 같은가? 3개월 뒤, 6개월 뒤 규모가 얼마가 되리라 생각해야하는가? 회사가 주로 사용하는 기술 스택은 무엇인가?2단계: 개략적인 설계안 제시 및 동의 구하기개략적인 설계안을 제시하고 면접관의 동의를 얻어야 한다. 설계안의 최초 구성도를 제시하고 의견을 구하라. 팀원인 것처럼 대하라. 훌륭한 면접관들은 지원자와 대화하고 설계하는걸 즐긴다. 화이트보드나 종이에 핵심 컴포넌트를 그려라. CDN, 클라이언트, 웹 서버, 데이터베이스 서버, 캐시 등이 포함될 수 있다. 이 설계안이 제약사항을 만족하는지 개략적으로 계산하자. 그 과정은 소리내어 설명하고 계산이 필요한지도 물어봐야한다.예를들어 뉴스피드를 발행하고 생성해야하는 기능이 있다고 생각하자. 뉴스피드 발행: 사용자가 포스트를 올리면 관련된 데이터가 캐시/데이터베이스에 기록되고 친구의 뉴스피드에 뜨게 된다. 피드 생성: 어떤 사용자의 뉴스 피드는 해당 사용자의 친구들의 포스트를 시간 역순으로 정렬하여 만든다.3단계: 상세 설계설계 대상 컴포넌트 사이의 우선순위를 정하여 상세설명을 해야한다.책에서도 강조하는 내용이 똑같은 면접이라는건 있을 수 없으며 주니어, 시니어에 따라 면접관이 캐치하려는 능력이 다를것이다.만약 채팅시스템을 구현하는 문제였다면 어떻게하면 지연시간(latency)를 줄이고, 사용자의 온/오프라인을 표시할지에 대한 얘기를 할 것이다.또한 URL단축생성기라고 하면 어떤 해시함수를 사용하였고, 그 해시함수를 왜 사용했는지에 대한 이야기를 할 것이다.위의 예제를 상세적으로 설계하면 밑의 그림이 된다고 한다. 피드발행 인증여부에 따라 알림서비스를 하는 절차가 추가되었다. 포스팅 정보들은 포스팅 캐시와 데이터베이스에 저장한다. 피드를 발행하는 사용자의 친구들 목록 id를 받고 캐시에서 친구들 데이터를 조회후 메시지큐를 통해 피드 발행 전송 작업을 다른 서버에 비동기적으로 요청한다. 피드 생성 사용자의 요청이 로드밸런서를 거치고 웹서버에 도달한다. 뉴스피드 서비스에서 사용자의 뉴스피드를 저장한 캐시에서 포스팅 정보 키 값을 가져온다. 포스팅 정보 키 값을 가지고 캐시에서 조회하여 포스팅을 나타내는 정보들(예를들면 요약, 제목 등)을 가져온다. 마찬가지로 사용자 정보(사용자 이름, 프로필 url 등)을 가져온다. 사용자에게 해당 정보들을 보여준다. 책에는 상세 설명이 없습니다. 제가 임의로 해석해서 적어놓은 것이니 참고만 해주세요.4단계: 마무리후속 질문이 들어올 수도 있고, 스스로 추가 논의를 진행할 수도 있다. 면접관이 병목, 개선점을 더 찾아보라할 수 있다. 설계는 완벽할 수 없으니 없다고 하지 않는다. 설계를 요약해주는 것도 좋다. 환기시켜주는 효과가 있어서다. 오류가 발생하면 어떤 일이 생기는지도 이야기하면 좋다. 규모 확장에 대해서도 이야기하면 좋다. 현재 설계한 이용자의 10배 또는 100배 들어온다면?🤔 정리실제 면접에 들어가면 어떤 방식으로 진행을 유도할지에 대한 설명이 있는 챕터였다.유튜브에도 이러한 단계로 면접 진행가이드를 나타냈다.유튜브에도 System Design을 검색하면 트위터 설계, 넷플릭스 설계 등이 나오니까 참고해도 좋을것 같다." }, { "title": "Java 10버전은 뭐가 달라졌나", "url": "/posts/2022-12-08-JavaVersion10/", "categories": "Java, CS", "tags": "Java", "date": "2022-12-08 04:02:00 +0900", "snippet": "개요2018년 3월 20일에 출시된 자바 10버전은 뭐가 달라졌을까?현재 19버전까지 나왔는데, 좋은 글을 발견하여 이 글을 읽어가면서 예제를 작성하고 학습할 예정이다.✏️ Local-variable Type inference(“var”)10버전에서부터 로컬변수에 var를 사용하여 선언할 수 있다.@Test@DisplayName(&quot;1.var를 사용할 수 있다.&quot;)void test1(){ var i = 0; var stringTest = &quot;kms is kms&quot;; var list = List.of(1,2,3,4,5); var httpClient = HttpClient.newBuilder().build(); logger.debug(&quot;i: {}&quot;, i); logger.debug(&quot;stringTest: {}&quot;, stringTest); logger.debug(&quot;list: {}&quot;, list); logger.debug(&quot;httpClient: {}&quot;, httpClient);}하지만 var의 사용을 고려해야할 사항이 있다. 데이터 타입을 명확히 알고 있어야하고, 협업시 해당 데이터에 대한 논의를 할 수도 있다는 것이다.그래서 var를 사용할때는 팀원간의 협의가 이루어져야 할 것이다.✏️ Immutable Collections불변객체의 컬렉션들이 생겼다.@Test@DisplayName(&quot;2. 불변 컬렉션이 생겼다.&quot;)void immutableCollections(){ List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); list.add(1); list.add(2); list.add(3); List&amp;lt;Integer&amp;gt; unmodifiedList = Collections.unmodifiableList(list); try{ unmodifiedList.add(4); }catch (UnsupportedOperationException e){ logger.warn(&quot;error: &quot;,e); }finally { list.add(10); logger.debug(&quot;list: {}&quot;, list); logger.debug(&quot;unmodifiedList: {}&quot;, unmodifiedList); }}사진과 같이 add(4)로 요소를 추가해주면 예외가 발생한다.또한, 원본 list가 변경됨에 따라 수정불가능한 자료구조 객체도 따라 바뀌는걸 확인할 수 있다.이와 같은 이유는 불변객체가 리스트의 복사본을 포함하지 않기 때문이라는데.. 잘 모르겠다.피드백 부탁드립니다.This is because the wrapper does not contain a copy of the listList.copyOf(), Set.copyOf(), and Map.copyOf()Java10에서는 불변 컬렉션들을 위의 함수들을 통해 복사할 수 있다.@Test@DisplayName(&quot;2.1 List.copyOf(), Set.copyOf(),Map.copyOf()&quot;)void immutableCollectionsFunction(){ List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); list.add(1); list.add(2); list.add(3); List&amp;lt;Integer&amp;gt; immutable = List.copyOf(list); list.add(4); logger.debug(&quot;immutableList: {}&quot;,immutable); try{ immutable.add(10); }catch (UnsupportedOperationException e){ logger.warn(&quot;error: &quot;,e); }}코드를 보면 List.copyOf()를 통해 복사를 하고 add()함수를 통해 요소를 추가해줬는데 불변 컬렉션에는 2번의 예제와 달리 값이 들어가지 않은걸 볼 수 있다.즉, 원본 컬렉션을 변경해도 복사된 불변 컬렉션에는 값이 들어가지 않는다는 것이다.그리고, try~catch문에서도 볼 수 있는데, 불변객체에 값을 추가하려하니 예외가 발생하는 모습이다.Collectors.toUnmodifiableList(), toUnmodifiableSet(), and toUnmodifiableMap()제목에서도 알 수 있다싶이 저 함수들을 이용해 불변 컬렉션들을 만들 수 있다.가변 컬렉션들은 이렇게 만들 수 있다.@Test@DisplayName(&quot;2.2 Collectors.toUnmodifiableList(), toUnmodifiableSet(), and toUnmodifiableMap()&quot;)void toUnmodifiedCollectors(){ List&amp;lt;Integer&amp;gt; list = IntStream.rangeClosed(1,5).boxed().collect(Collectors.toList()); Set&amp;lt;Integer&amp;gt; set = IntStream.rangeClosed(1,5).boxed().collect(Collectors.toSet()); Map&amp;lt;Integer,String&amp;gt; map = IntStream.rangeClosed(1,5).boxed().collect(Collectors.toMap(Function.identity(),String::valueOf)); list.add(8); set.add(8); map.put(8,&quot;8&quot;); logger.debug(&quot;list: {}&quot;,list); logger.debug(&quot;set: {}&quot;,set); logger.debug(&quot;map: {}&quot;,map); //불변 List&amp;lt;Integer&amp;gt; immutableList = IntStream.rangeClosed(1,5).boxed().collect(Collectors.toUnmodifiableList()); Set&amp;lt;Integer&amp;gt; immutableSet = IntStream.rangeClosed(1,5).boxed().collect(Collectors.toUnmodifiableSet()); Map&amp;lt;Integer,String&amp;gt; immutableMap = IntStream.rangeClosed(1,5).boxed().collect(Collectors.toUnmodifiableMap(Function.identity(),String::valueOf)); //error immutableList.add(4);}✏️ Optional.orElseThrow()자바8에서 Optional이 나왔는데, get()함수를 통해 값을 받을 수 있었다.근데, get()을 호출하기 전에는 반드시 ifPresent()함수를 통해 검증절차를 진행해야했다.Optional&amp;lt;String&amp;gt; result = getResult();if (result.isPresent()) { System.out.println(result.get());}왜냐하면 만약 객체가 없는 경우 get()을 호출했다면 NoSuchElementException 예외가 터지기 때문이다.인텔리제이에서는 이를 방지하기 위해 마우스를 올려놓으면 경고를 띄웠다.때로는 의도적으로 예외를 발생시켜야하는 경우가 생기는데 이때는 경고들을 무시하기 위해서 @SuppressWarnings 어노테이션을 적절한곳에 삽입하기도 하였다.자바 10으로 넘어오면서 orElseThrow()가 등장하였고, 이 함수를 통해 좀 더 깔끔하게 예외를 인지시킬 수 있게 되었다.orElseThrow()는 get()함수와 이름만 다르고 동일하게 동작한다. 이름부터 예외를 던진다고 되어있기에 가독성이 증가하였고, 개발자의 의도를 파악할 수 있게 되었다.//orElseThrow()의 구현 부분public T orElseThrow() { if (value == null) { throw new NoSuchElementException(&quot;No value present&quot;); } return value;}//get()의 구현 부분public T get() { if (value == null) { throw new NoSuchElementException(&quot;No value present&quot;); } return value;}✏️ Time-Based Release Versioningjava -version에 대한 내용이다.java8버전부터 11버전까지 달라진 점을 나타낸다. Java8$ java -versionjava version &quot;1.8.0_291&quot; Java9$ java -versionjava version &quot;9.0.4&quot; //가독성이 좋게 버전을 보여줌 Java10$ java -versionjava version &quot;10.0.2&quot; 2018-07-17 //배포날짜를 보여줌 Java11$ java -versionjava version &quot;11.0.11&quot; 2021-04-20 LTS // Long-Term Support가 추가됨✏️ Parallel Full GC for G1Java9에서는 G1 가비지 컬렉터를 사용했다. 이전에는 병렬 컬렉터를 사용했는 G1으로 바뀌면서 병렬적으로 수행하지 못했다. Java9의 G1은 임시적으로 STW를 실행하여 응답시간의 지연이 조금 있었다.Java10에서는 병렬적으로 G1 가비지 컬렉터를 수행할 수 있게 하였다.✏️ Application Class-Data SharingClass-Data SharingJVM이 뜰 때, JDK 클래스 라이브러리를 읽고 클래스들을 추출하고 스펙에 명시된 바이너리 폼으로 바꿔버린다. 그리고 메인 메모리에 JVM 프로세스를 올리는데하나의 컴퓨터에서 JVM을 여러개 띄워버리면 저 방식을 그대로 똑같이 반복할 것이다. 이는 시간적으로나 메모리적으로도 부담이 갈 수 밖에 없다. 여러개의 JVM을 띄울때Class-Data Sharing(CDS)는 두가지 목표가 있는데 JVM이 띄워질때까지의 시간을 줄이기 JVM의 메모리를 줄이기CDS는 다음과 같이 동작한다. java -Xshare:dump명령을 통해 classes.jsa(현재 아키텍처의 클래스 라이브러리를 이진 형식으로 나타낸 파일)을 만든다. 이를 사용하여 JVM이 시작될 때 클래스 라이브러리를 메모리에 적재하는 시간을 줄일 수 있게 해준다. JVM이 시작될 때 운영체제는 이 파일을 메모리 매핑 I/O를 이용하여 JVM 메모리에 매핑시킨다. 이렇게하면 jar또는 jmod파일을 로드하는 것보다 더 빠르게 동작한다. 또한 운영체제는 파일을 RAM에 한 번만 로드하므로 각 JVM 프로세스는 동일한 메모리 영역의 읽기 전용 뷰를 제공받게 된다. 이 덕분에 JVM 프로세스 간의 리소스를 지원하는 장점이 있다.예제는 이 깃허브 주소을 참고하기 바란다.위 스텝대로 진행하면와 같은 절차를 거친다는 말과 같다.✏️ Experimental Java-Based JIT CompilerJava9 버전에서는 Graal Compiler라는 컴파일러가 테스트 되었는데, 이 컴파일러를 통해 네이티브 실행 파일(exe파일 같은거)를 컴파일 할 수 있게 되었다.자바 10 버전에서는 Graal Compiler가 정식적으로 JIT컴파일러로 사용할 수 있고, Linux/x86플랫폼에서만 사용할 수 있다.-XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler이 명령어를 치면 된다.✏️ Heap Allocation on Alternative Memory DevicesJava 힙을 일반적인 RAM 대신에 다른 메모리 장치(NV-DIMM와 같은 비휘발성)메모리에 할당할 수 있게 되었다.이 방식을 사용하려면 운영체제가 파일시스템 경로를 제공해야한다. 즉, 접근이 가능해야한다는 것이다.그리고 다음 Java 명령행에 옵션을 사용하여 추가할 수 있다.-XX:AllocateHeapAt=&amp;lt;file&amp;gt;이 방식을 통해 Java 힙을 메모리 대신 다른 메모리 장치에 할당할 수 있으므로 어플리케이션 성능을 향상시킬 수 있다.✏️ Additional Unicode Language-Tag ExtensionsLocale 객체에 다음과 같은 추가 정보를 저장할 수 있다. 지역 이름과 언어 이름의 정규화 형태 지역 이름과 언어 이름에 관련된 추가 메타데이터 지역 이름과 언어 이름에 대한 호환성 정보@Test@DisplayName(&quot;Locale 테스트&quot;)void LocaleTest(){ Locale locale = Locale.forLanguageTag(&quot;de-DE-u-cu-usd-fw-wed-tz-uslax&quot;); Currency currency = Currency.getInstance(locale); Calendar calendar = Calendar.getInstance(locale); DayOfWeek firstDayOfWeek = DayOfWeek.of((calendar.getFirstDayOfWeek() + 5) % 7 + 1); DateFormat dateFormat = DateFormat.getTimeInstance(LONG, locale); String time = dateFormat.format(new Date()); System.out.println(&quot;currency = &quot; + currency); System.out.println(&quot;firstDayOfWeek = &quot; + firstDayOfWeek); System.out.println(&quot;time = &quot; + time);}de-DE-u-cu-usd-fw-wed-tz-uslax 구문 해석을 해보자 de-De: 독일의 로케일정보다. cu-usd: US달러를 의미한다. fw-wed: 첫 주 수요일(wednesday)를 의미한다. tz-uslax: 로스 엔젤레스의 타임존(tz)를 의미한다.✏️ Garbage Collector InterfaceJava9버전까지는 가비지 컬렉터 소스 코드의 일부가 Java 인터프리터와 C1, C2 컴파일러의 소스 코드 내부의 긴 if-else문에 있었다고 한다. 새로운 가비지 컬렉터를 구현하려면 개발자는 이러한 구문의 모든 위치를 알고 있어야 하고, 요구사항에 맞게 확장해야 했는데, 이번 Java10에서는 가비지 컬렉터 알고리즘을 인터프리터와 컴파일러로 부터 분리를 했다는 것이다.이 인터페이스를 통해서 더 이상 인터프리터와 컴파일러에 의존성 없이 GC를 추가할 수 있게 되었다.✏️ Root CertificatesJava9에서는 cacerts 키 저장소 파일에 루트 인증서가 포함되어 있지 않아서 SSL/TLS 기반의 기능을 쉽게 실행할 수 없었는데, Java10에서는 루트 인증서가 포함되어 SSL/TLS 기능을 사용할 수 있게 되었다.결론조금 더 많은 내용이 있지만 이해하기 어려운 내용들이므로좀 더 자세한건 https://www.happycoders.eu/java/java-10-features/#ListcopyOf_SetcopyOf_and_MapcopyOf 이 글을 참고하길 바랍니다." }, { "title": "가상 면접 사례로 배우는 대규모 시스템 설계 기초 2장 - 개략적인 규모 추정", "url": "/posts/20221208InterviewBook02/", "categories": "Book, 가상 면접 사례로 배우는 대규모 시스템 설계 기초", "tags": "book, interview", "date": "2022-12-08 02:02:00 +0900", "snippet": " 가상 면접 사례로 배우는 대규모 시스템 설계 기초 책 정리 글입니다.개요이 장은 시스템 용량이나 성능 요구사항을 개략적으로 측정하는 방법에 대해 다룬다.개략적 규모 추정을 효과적으로 필요한 기본기에 능숙해야 한다. 특히, 2의 제곱수나 응답지연(latency) 값, 그리고 가용성에 관계된 수치들을 기본적으로 잘 이해하고 있어야 한다고 한다.✏️ 2의 제곱수보통 컴퓨터의 최소 단위는 1byte이고 이는 8bit로 구성된다. ASCII문자 하나가 차지하는 메모리 크기는 1byte이다.|2의 x제곱|근사치|이름|축약형||–|—|—|—||10|1천|1킬로바이트|1KB||20|1백만|1메가바이트|1MB||30|10억|1기가바이트|1GB||40|1조|1테라바이트|1TB||50|1000조|1페타바이트|1PB| 데이터 볼륨 단위들✏️ 모든 프로그래머가 알아야 하는 응답지연 값구글의 제프딘은 2010년에 통상적인 컴퓨터에서 구현된 연산들의 응답지연값을 공개한 적이 있다고 한다. 현대와는 꽤 차이가 나지만 어림짐작하는데에는 큰 도움이 된다니 책에 실었다고 한다.위의 정보를 통해 다음과 같은 사실을 알 수 있다. 메모리는 빠르지만 디스크는 아직 느리다. 디스크 탐색(seek)은 피해야 한다. 단순한 압축 알고리즘은 빠르다. 그렇기에 데이터를 인터넷으로 전송하기 전에 압축을 하는편이 좋다. 데이터센터끼리 데이터를 주고 받는데에도 시간이 유의미하게 걸린다.✏️ 가용성에 관계된 수치들시스템이 얼마나 오랫동안 지속적으로 중단없이 운영되었는지를 나타내는 지표인 고가용성에 대한 지표는 대부분 99% ~ 100%의 값을 갖는다.SLA(Service Level Agreement)는 구글, 아마존, MS 등 서비스 사업자가 보편적으로 사용하는 용어이고, 여기에는 가용시간이 공식적으로 기록되어 있다.관습적으로 9를 이용해 표시하고 9가 많을수록 좋다.✏️ 예제: 트위터 QPS와 저장소 요구량 추정 제시된 수치들은 예시를 위한 가정값이며 실제 값이 아닙니다. 그리고 실제 책과 다른 수치로 연습해보았으니, 틀린 계산결과가 나왔다면 피드백 부탁드립니다.가정 월간 능동 사용자는 4억명이다. 50%의 사용자가 트위터를 매일 사용한다. 평균적으로 각 사용자는 매일 4건의 트윗을 한다. 미디어를 포함하는 트윗은 5% 정도다. 데이터는 3년간 보관된다.추정QPS(Query Per Seconds)추정지 일간 능동 사용자(Daily Active User, DAU): 4억 * 50% = 2억 QPS = 2억 /4(트윗) /24(시간) / 3600(초) = 약 578 Peek QPS = 578 * 2 = 약 1156미디어 저장을 위한 저장소 요구량 평균 트윗 크기 tweet_id에 64바이트 텍스트에 200바이트 미디어에 1MB 미디어 저장소 요구량: 2억 * 4(트윗) * 5% * 1MB = 40,000,000MB = 40TB/일 3년간 미디어를 보관하기 위한 저장소 요구량: 40TB * 365(일) * 3(년) = 약 43.8PB✏️ 팁정확도는 떨어져도 올바른 값을 도출해기 위한 과정이 중요하다고 한다. 근사치를 이용한 계산: “99987.1/9.1”의 계산결과는 무엇인가요? 라는 질문을 받았을때 실제 계산하는건 시간낭비다. 계산의 정확함을 평가하는것이 목적이 아니기 때문이다. 이는 적절한 근사치를 이용하여 시간을 절약하자. “100000/10” 로 간소화할 수 있다. 가정들은 적어둬라. 나중에 살펴볼 수 있도록 단위(unit)을 붙여라. 10이라고만 적지말고 10TB, 10s처럼 말이다. 붙이지 않으면 나중에 스스로 헷갈릴 수가 있다. 많이 출제되는 문제는 QPS, 최대 QPS, 저장소 요구량, 캐시 요구량, 서버 수 등을 측정하는 것이다. 미리 연습하자.🤔 정리2장에서는 개략적으로 QPS나 저장소의 용량을 계산할 수 있는 방법에 대해 알 수 있었다.요구사항에 따라 유연하게 대처할 수 있어야하며 이 책에서는 내 기준 정말 짧게 다루었기에 좀 더 찾아보고 연습이 필요할 것 같다고 생각이 들었다." }, { "title": "real-world프로젝트 Spring 시작하기(8) - 회원가입API 및 Jwt Token 만들기(2)", "url": "/posts/realworld08/", "categories": "Toy, real-world-spring", "tags": "Spring", "date": "2022-12-08 01:02:00 +0900", "snippet": " real-world project 구현 과정 카테고리 보기이번에는 토큰을 만들어보고, 응답값을 조립하여 응답을 해볼 것이다.저번에는 컨트롤러와 DTO를 구현했으므로, 서비스계층을 구현해야한다.일반적으로 Service는 구현체와 인터페이스를 나눈다.그 이유로는 다형성을 위함이 있다. 하지만 1대1로 매핑되어있는 경우에는 굳이 할 필요가 없지만 확장성을 고려해서 하면 좋고 협업시 코드 유지보수에도 좋으니까 하는게 좋다.package com.io.realworld.domain.aggregate.user.service;import com.io.realworld.domain.aggregate.user.dto.*;public interface UserService { UserResponse signup(UserSignupRequest userSignupRequest);}따라서 인터페이스를 이렇게 따로 두고👍 UserServiceImpl@Service@RequiredArgsConstructorpublic class UserServiceImpl { private final UserRepository userRepository; private final PasswordEncoder passwordEncoder; private final JwtService jwtService; public UserResponse signup(UserSignupRequest userSignupRequest) { User findEmail = userRepository.findByEmail(userSignupRequest.getEmail()); Optional&amp;lt;User&amp;gt; findUsername = userRepository.findByUsername(userSignupRequest.getUsername()); if ( findEmail != null &amp;amp;&amp;amp; !findUsername.isEmpty()) { throw new CustomException(Error.DUPLICATE_EMAIL_USERNAME); }else if(findEmail != null){ throw new CustomException(Error.DUPLICATE_EMAIL); }else if(!findUsername.isEmpty()){ throw new CustomException(Error.DUPLICATE_USERNAME); } else { return convertUser(userRepository.save(User.builder(). username(userSignupRequest.getUsername()). email(userSignupRequest.getEmail()). password(madeHash(userSignupRequest.getPassword())). image(&quot;https://api.realworld.io/images/smiley-cyrus.jpeg&quot;).build())); } } private String madeHash(String password) { return passwordEncoder.encode(password); } private UserResponse convertUser(User user){ return UserResponse.builder().username(user.getUsername()) .email(user.getEmail()) .bio(user.getBio()) .image(user.getImage()) .token(jwtService.createToken(user.getEmail())) .build(); }}구현체를 만든다.아직 만들지 않은 Repository, passwordEncoder, jwtService는 잊고 위에서 부터 차근히 리뷰하겠다. @Service: Service어노테이션은 부트가 최초에 뜰때 스캔하여 빈에 등록하라는 뜻이다. @RequiredArgsConstructor: 이 어노테이션은 final이나 @NotNull이 붙은 필드의 생성자를 자동으로 생성해주는 롬복 어노테이션이다. (생성자 주입) 컨택스트에 등록된 여러 빈(repository, jwtService, passwordencoder)를 사용하기 위해 넣어줘야한다.로직은 간단하다. 들어온 Email을 기준으로 데이터베이스에 조회하여 Email 중복이 있는지 확인한다. 중복이라면 throw new CustomException(Error.DUPLICATE_EMAIL);로 에러를 발생시킨다. 마찬가지로 UserName도 조회하여 중복값이 있는지 확인한다. 만약 중복이라면 throw new CustomException(Error.DUPLICATE_USERNAME); 에러를 발생시킨다.공통 예외처리는 다음에 알아보고 일단 저런 에러를 발생시킨다는것만 이 글에 적겠다.중복 처리가 끝났다면 그대로 들어온 객체를 데이터베이스에 저장해주면된다.userRepository.save(User.builder(). username(userSignupRequest.getUsername()). email(userSignupRequest.getEmail()). password(madeHash(userSignupRequest.getPassword())). image(&quot;https://api.realworld.io/images/smiley-cyrus.jpeg&quot;).build()유저를 저장하는부분인데 save()함수는 리턴값을 따로 지정하지 않는다면 JPA를 상속받을때 지정한 엔티티 오브젝트 유형으로 리턴한다. 이는 User객체이고 우리는 password가 포함된 User객체를 그대로 응답값으로 넘기면 안되므로 convertUser()함수로 통해 응답 객체를 맞춰줘야한다.그리고 madeHash()함수에 PasswordEncoder를 통해 패스워드를 암호화한다.👍 PassowordEncder ?스프링 시큐리티에서 제공하는 암호화하는 인터페이스다.이를 사용하기 위해서는 먼저 Bean에 등록해줘야하는데, 앞에 포스팅에서 등록해줬다. 그것도 BCryptPasswordEncoder라는 클래스 유형으로 말이다.BCryptPasswordEncoder는 기본 암호 해시함수를 통해 암호화하는 구현체다. 시큐리티에서 제공하는 PasswordEncoder의 문서를 보면 이 구현체를 선호한다는걸 알 수 있다.//DocService interface for encoding passwords. The preferred implementation is BCryptPasswordEncoder.비크립트 인코더에 다루는건 좀 더 깊은 내용이 될 수 있으므로 비크립트라는 알고리즘을 통해 패스워드를 암호화한다는걸 알아두면 될 것 같다.👍 UserRepositoryJPA를 사용해서 구현하면 된다. 아직 save()말고는 구현할 게 없다.save()의 리턴값을 직접명시해줘도 되지만 나는 명시하지 않았다.public interface UserRepository extends JpaRepository&amp;lt;User, Long&amp;gt; {}기본제공되는 save()함수를 사용할 것이고 리턴값은 Jpa제너릭으로 지정한 첫번째 값 User객체가 될 것이다.다시 Service함수로 돌아가서 save()의 리턴을 받았다 치고 이를 real-world에서 요구하는 리턴 객체로 맞춰줘야한다.👍 UserSingup Response DTO 만들기@Builder@Getter@JsonTypeName(&quot;user&quot;)@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.WRAPPER_OBJECT)public class UserResponse { private String email; private String token; private String username; private String bio; private String image;}Request DTO를 만들면서 어노테이션에 대한 설명을 했으므로 따로 리뷰할건 없다. 주목점은 password가 포함되어있지 않고 token을 리턴한다는 것이다.👍 JwtService 만들기convertUser()함수 안에 있는 jwtService.createToken(user.getEmail())를 리뷰해야한다.JwtService 클래스는 다음처럼 구현했다.@Service@AllArgsConstructorpublic class JwtService { private final JwtConfig jwtConfig; private Key getSignKey(String secretKey){ byte[] keyBytes = secretKey.getBytes(StandardCharsets.UTF_8); return Keys.hmacShaKeyFor(keyBytes); } public String createToken(String email){ Claims claims = Jwts.claims(); claims.put(&quot;email&quot;,email); return Jwts.builder() .setClaims(claims) .setIssuedAt(new Date(System.currentTimeMillis())) .setExpiration(new Date(System.currentTimeMillis() + jwtConfig.getExpiry() * 1000)) .signWith(getSignKey(jwtConfig.getKey())) .compact(); }} Jwt 인증, 데이터 파싱 부분은 뺐습니다. 현재는 이 코드만 보면 될 것 같아서입니다.먼저 서비스에서 호출하는 createToken()을 봐야한다.Claims객체를 만들기 위해 인스턴스를 생성하는데 Jwt 및 Claims에 대해서는 이 글에서 설명했다.jwt에 필요한 issue, expiry을 지정하고 signWith()는 두번째 인자를 통해 암호화 방식도 지정해준다.이 코드에 signWith()는 두번째 인자값이 없어서 암호화 방식이 없는데, 이도 받는다. 다만 암호화 방식을 통해 암호화된 값을 인자로 받길 원한다. /** * ~~~~ * recommended signature algorithm isn&#39;t sufficient for your needs, consider using * {@link #signWith(Key, SignatureAlgorithm)} instead. * ~~~~~ */ JwtBuilder signWith(Key key) throws InvalidKeyException;하지만 getSignKey() 함수의 리턴값을 보면 Keys.hmacShaKeyFor()를 통해 암호화해줬다는걸 알 수 있다. hmacShaKeyFor()함수는 HMAC-SHA 암호 알고리즘을 통해서 들어온 값을 암호화 시켜버린다.코드에서는 claims에 email값을 집어넣었는데, 이는 잘 선택해야한다. 개인정보를 최대한 담아놓지 않아야한다. 민감한 정보를 저장해 놓으면 토큰을 탈취당했을대 피해가 더 클 위험이 있기 때문이다.compact()함수는 Jwt토큰을 빌더패턴을 통해 생성하고, 직렬화하여 외부에서도 쓰일 수 있게 한다.또한, 이 코드에 보면 jwtConfig이라는게 나오는데, 다음과 같이 구현시켜놨다.👍 JwtConfig.class@Component@Getter@PropertySource(&quot;classpath:application.properties&quot;)public class JwtConfig { @Value(&quot;${real-world.token.expiry}&quot;) private Long expiry; @Value(&quot;${real-world.token.key}&quot;) private String key;}@PropertySource어노테이션을 통해 application.properties에 저장되어있는 환경변수 값들을 가져온다.나 같은 경우real-world.token.expiry=3000000real-world.token.key=rea12312412412SQL0132474654564564213131d31vfxvjfijkjdks이렇게 저장해놨으며 개발자의 입맛에 따라 바꾸면된다. expiry는 토큰 만료시간, key는 개발자가 정의할 비밀키값이다.여기까지가 token을 생성하고 응답값을 지정해준것이다.여기까지가 회원가입 컨트롤러, 서비스, 레포지토리의 구현이다. 만약 코드가 제대로 동작하지 않는다면 댓글을 남겨주세요. 이는 전체코드 중 리뷰에 필요한 부분만 절삭하여 보여준것이므로 해결해드리겠습니다. 현재 이 프로젝트는 vue.js + vite + vuex + Spring boot, Spring Data JPA + Spring Security 를 이용하여 real-world 데모버전을 제작완료하였습니다. https://github.com/kkminseok/real-world-springboot" }, { "title": "가상 면접 사례로 배우는 대규모 시스템 설계 기초 1장 - 사용자 수에 따른 규모 확장성", "url": "/posts/20221207InterviewBook01/", "categories": "Book, 가상 면접 사례로 배우는 대규모 시스템 설계 기초", "tags": "book, interview", "date": "2022-12-07 02:02:00 +0900", "snippet": " 가상 면접 사례로 배우는 대규모 시스템 설계 기초 책 정리 글입니다.개요원준이라는 친구가 나 공부 열심히하라고 책을 선물해줬다.읽어보도록 했다.1장은 한 명의 사용자를 지원하는 시스템에서 시작한다.✏️ 단일 서버웹브라우저, 웹 서버, DNS가 있을때 사용자의 요청 (웹 브라우저에서 요청을 보냄)이 어떻게 처리되는지를 알아야한다.naver에 접속한다고 가정하자. www.naver.com를 주소창에 입력 DNS서버에 www.naver.com의 IP를 질의 DNS서버에서 www.naver.com에 맞는 IP를 반환. 반환받은 IP에 HTTP 요청. 요청을 받은 웹 서버는 요청을 처리.✏️ 데이터베이스여기서 만약 사용자가 늘면 트래픽 처리 서버(웹 계층)과 데이터베이스 서버(데이터 계층)을 분리하여 확장시킬 수 있다.어떤 데이터베이스를 사용할지는 크게 관계형 데이터베이스(relational database)와 비-관계형 데이터베이스 사이에서 고를 수 있다.관계형 데이터베이스 RDBMS(Relational Database Management System)으로도 불린다. MySQL, Oracle, PostgreSQL 등이 있다. 조인 연산이 가능.비-관계형 데이터베이스 NoSQL로도 불린다. CouchDB, Neo4j, Cassandra, HBase, Amazon DynamoDB 등이 있다. 이것들은 4개로 또 분리될 수 있다. 키-값 저장소(key-value store) 그래프 저장소(graph store) 칼럼 저장소(column store) 문서 저장소(document sotre) 일반적으로 조인 연산이 불가능.관계형 데이터베이스는 꾸준히 사랑받았기에 쓰이는것도 있다. 비-관계형 데이터베이스는 다음과 같은 상황에서 고려하기 좋다. 아주 낮은 응답 지연시간(latency)가 요구됨. 다루는 데이터가 비정형이라 관계형 데이터가 아님. 데이터(JSON, YAML, XML, …)를 직렬화 또는 역직렬화 하기만하면 된다. 아주 많은 양의 데이터를 저장할 필요가 있다. NoSQL이 빠른 이유는 키-값인 경우 데이터를 읽는데에 최적화된 자료구조를 사용하기 때문이다. NoSQL 키-값 저장소는 접근 속도가 O(1)인 HashMap을 일반적인 RDB는 O(N)인 배열을 사용한다.✏️ 수평적 규모 확장 vs 수직적 규모 확장스케일 업(scale up)이라고 불리는 수직적 확장, 스케일 아웃(scale out)이라고 불리는 수평적 확장이 있다.스케일 업 방식은 서버에 CPU를 더 놓거나 RAM을 많이 확보하는 등 하드웨어 등을 추가하여 하나의 서버에서 가능한한 할 수 있는 것들을 하는 방식이라고 생각하고스케일 아웃 방식은 서버를 증설하여 성능을 개선하는 방식이다.스케일 업 장점 확장이 단순하다. 단점 CPU나 메모리를 무한대로 늘릴 순 없다. 장애에 대한 자동복구(failover) 방안이나 다중화(redundancy) 방안을 제시하지 않는다. 서버 장애 발생시 웹,앱 등 서비스가 완전히 중단된다. 단점이 너무 치명적이라 대규모 시스템에서는 스케일 아웃방식을 사용하는것이 좋다.서버 장애가 발생시에는 사용자가 웹 사이트에 접속할 수 없고, 서버 장애가 발생하는 원인 중에는 과도한 트래픽양이 있다.이를 해결하기 위해서 부하 분산기 또는 로드밸런스(load balancer)를 도입하는게 최선이다.로드밸런서로드밸런서는 부하 분산 집합(load balancing set)에 속한 웹 서버들에게 트래픽 부하를 고르게 분산하는 역할을 한다.위에서 설명한대로 사용자는 하나의 서버 IP로 들어오면 서버 시스템 설계 내부에 있는 로드밸런서가 Private IP 즉, 사설IP라고도 불리는 각 웹 서버의 IP에 적절한 알고리즘으로 트래픽을 할당해준다. 사설IP는 같은 네트워크에 속한 서버 사이의 통신에서만 쓰이는 IP 주소다.이렇게 로드밸런서를 추가하면 자동복구 문제도 해소되고 웹 계층의 사용성도 증가한다.왜냐하면 서버1이 죽으면 복구되는동안 서버2로 트래픽을 주면 되고, 트래픽이 과도하게 증가한다 싶으면 서버를 증설하고 로드밸런서를 통해 우아하게 대처가 가능하기 때문이다.웹 서버는 이렇게 증설하면 되고 데이터 계층인 데이터베이스는 어떤식으로 확장이 가능할까데이터베이스 다중화보통 주(master)-부(slave) 관계를 설정하고 데이터 원본은 주 서버에, 사본은 부 서버에 저장하는 방식을 사용한다.쓰기 연산 같이 읽기 연산보다 상대적으로 오래걸리고 많은데서 관리하면 일관성 문제를 일으킬 수 있기에 주 서버에서만 지원한다. 부 데이터베이스 서버는 주 데이터베이스 서버로부터 사본을 받고, 읽기 연산만 지원한다. 장점 더 나은 성능: 읽기 연산과 쓰기 연산이 분산처리 되므로 효율적이고, 읽기 같은 경우는 병렬로 처리될 수 있으므로 성능이 좋아진다. 안정성: 여러군데에 데이터 사본을 저장해놨기에 데이터베이스 서버 일부가 파고되어도 데이터는 다른데에 보존되어 있을 것이다. 가용성: 여러군데 복사를 해놨기에 하나의 데이터베이스 서버에 장애가 발생해도 다른 서버에 있는 데이터를 가져와 계속 서비스를 진행할 수 있다. 그래서 최종적으로 웹 서버에는 로드밸런서를 둬서 부하를 분산시키고, 데이터베이스는 주, 부 데이터베이스 서버를 나눠 부하를 분산시킨다.✏️ 캐시캐시를 알아둬야하는 이유는 응답시간(latency)를 개선하기 위함이다.캐시는 값비싼 연산 결과나 자주 참조되는 데이터를 메모리 안에 두고 요청에 대한 처리를 빨리하도록 도와준다.만약 새로고침을 한다하면 데이터를 새로 가져와야할텐데 그때마다 데이터베이스를 호출하는것은 성능에 문제가 생길 수 있다. 캐시는 이런 문제를 완화시켜줄 수 있다.캐시 계층(Cache tier)캐시 계층은 데이터가 잠시 보관되는 곳이다. 데이터베이스보다 훨씬 빠르고 데이터베이스의 부하도 줄일 수 있다. 캐시 계층을 독립적으로 확장도 가능하다.위와 같이 캐시 서버는 동작하고 이러한 방식을 읽기 주도형 캐시 전략(read-through caching strategy)라고 부른다. 캐시할 데이터 종류, 크기, 액세스 패턴 등에 따라 전략이 달라지므로 맞는걸 선택하면 된다.캐시 서버는 일반적으로 널리 쓰이는 프로그래밍 언어로 API를 제공하기에 사용하기 쉽다.// memcached라는 캐시 시스템 C언어를 사용SECONDS = 1cache.set(&#39;cache&#39;, &#39;hi cache&#39;, 3600 * SECONDS)cache.get(&#39;cache&#39;)캐시 사용시 주의점 갱신은 자주 일어나지 않지만 참조는 빈번이 일어난다면 고려할만 하다. 캐시는 휘발성이므로 영속적으로 보관할 데이터는 캐시에 두는것이 바람직하지 않다. 캐시는 언제 어떻게 만료(expire)되는가?에 대한 정책을 수립할 필요가 있다. 만료시간을 너무 짧게, 너무 길게 가져가지 않도록 주의해야한다. 데이터베이스와 일관성을 어떻게 유지할 것인가? 에 대한 생각도 해봐야한다. 찾아보니 이는 논문도 나올정도로 많은 연구가 진행되고 있는 것 같다. 장애에는 어떻게 대처할 지도 생각해봐야한다. 캐시 서버를 하나로 두면 해당 서버는 단일 장애 지점이 되어버릴 가능성이 있다. 때문에 여러 지역에 걸쳐 캐시 서버를 분산 시켜야 한다. 단일 장애 지점(Single Point of Failure, SPOF)는 어떤 특정 지점에서의 장애가 전체 시스템의 동작을 중단시켜버릴 수 있는 경우 그 지점을 단일 장애 지점이라고 부른다. 캐시 메모리는 얼마나 크게 잡을 것인가? 캐시 메모리가 작다면 데이터가 밀려나면서 자주 갱신되기에 성능이 저하된다. 크게 잡는편이 좋다고 한다. 데이터 방출(eviction) 정책도 수립해야한다. 캐시가 꽉 차면 기존 데이터를 내보내고 새로 데이터를 받아야하는데, 자주 쓰이는 알고리즘은 LRU(Least Recently Used)방식이다. 외에 LFU, FIFO 등이 있다.✏️ CDN(컨텐츠 전송 네트워크)CDN은 정적 콘텐츠를 전송하는데 쓰이는 지리적으로 분산된 서버 네트워크다이미지, 비디오, CSS, javascript파일 등을 캐시할 수 있다.동작방식은 다음과 같이 간단하다. 사용자가 웹 사이트에 방문 지리적으로 가까운 CDN 서버가 정적 콘텐츠를 사용자에게 전달.지리적으로 분산된 네트워크라서 거리가 멀면 응답이 느린건 당연하다. 거리가 멀수록 요청전달이 느려진다. CDN은 이런식으로 캐싱하여 전달된다.동작방식은 어렵지 않아서 설명하지 않아도 되지만 추가적으로 알아야할 것들이 있다.사용자는 이미지 URL을 통해 image.png에 접근하는데, 이 URL 도메인은 CDN 사업자가 제공한 것이다.https://mysite.cloudfront.net/logo.png와 같은 이미지 URL 예시가 있다.또한 3번에서 이미지를 저장하고 있는 원본 서버에서 파일을 CDN서버에 반환할 때, 파일이 얼마나 오래 캐시 될 수 있는지를 설명하는 TTL(Time-To-Live) 값이 들어 있다. 이 값을 통해 CDN은 해당 이미지가 캐시에 얼마나 존재할 수 있는지를 정할 수 있다.CDN 사용 시 고려해야할 사항 비용: CDN은 보통 제 3 사업자에 의해 운영되고, 데이터 전송 양에 따라 요금을 내기 때문에 자주 참조되지 않는 콘텐츠를 캐싱해두는건 비용적으로 손실이 있다. 적절한 만료 시한 설정: 캐시와 마찬가지로 만료시간을 잘 설정해야 성능을 개선할 수 있다. CDN 장애에 대한 대처 방안: CDN이 응답하지 않는 경우 어떻게 해야할 지 생각해야한다. 원본 서버에서 직접 콘텐츠를 가져오도록 클라이언트를 구성하는 것도 방법 중 하나다. 콘텐츠 무효화(invalidation) 방법: 아직 만료되지 않은 콘텐츠라 하더라도 밑의 방법을 통해 CDN에서 제거할 수 있다. CDN 서비스 사업자가 제공하는 API를 이용하여 무효화 콘텐츠의 다른 버전을 서비스하도록 오브젝트 버저닝(object versioning)이용. 새로운 버전을 지어하기 위해 URL 마지막에 버전 번호를 인자로 주면 된다. ex) image.png?v=2 웹서버, 데이터베이스 서버, 로드밸런서, 데이터베이스 다중화(Master-Slave), 캐시 서버, CDN을 추가하면 다음과 같은 시스템 설계가 될 것이다.✏️ 무상태(stateless) 웹 계층상태 아키텍처웹 계층을 수평적으로 확장하기 위해서는 상태 정보(사용자 세션 데이터 등)을 웹 서버에서 제거해야한다. 만약 3개의 서버(A서버, B서버, C서버)가 있고, 3명의 사용자(A유저, B유저, C유저)가 있다고 치자.서버 A에는 A유저의 인증정보가, 서버 B에는 B유저의 인증정보가, 서버 C에는 C유저의 인증정보가 있다고 하면 유저가 요청 보낼때마다 해당 서버에 요청이 전달되어야할 것이다.즉, 사용자에 따라 항상 같은 서버에 요청을 보내야한다. 대부분 로드밸런서는 고정 세션(sticky session)이라는 기능을 제공하여 위의 상황을 지원하는데 로드밸런스 입장에서는 부담이다. 게다가 추가적으로 서버를 늘리거나 제거할 때도 예기치 않은 장애를 일으킬 수 있고 로드밸런서 설정을 건드려줘야하기에 까다로워진다.무상태 아키텍처그렇기에 사용자의 데이터들을 따로 모아놓는 저장소를 두는게 좋다. 이 저장소는 공유 저장소(shared storage)라고 불려진다.위처럼 구성하면 요청에 대해 물리적으로 분리해줄 필요는 없기에 부담없이 웹 서버를 수평적으로 확장할 수 있고 이처럼 단순하고 안정적이라 규모확장에도 이점이 있다.보통 공유 저장소는 관계형 데이터베이스일 수도 있고, Redis와 같은 캐시 시스템일수도 있고, NoSQL일수도 있다.만약에 서비스가 성장하여 전 세계에 배포되고 서비스를 제공해야 한다면 전 세계에서 빠르게 편하게 사용할 수 있도록 데이터 센터(data center)를 지원하는 것이 필수다.✏️ 데이터 센터두 개의 데이터 센터가 있다고 하면 다음 그림처럼 될 것이다.별 일이 없는 경우 사용자의 요청은 가장 가까운 데이터 센터로 요청이 갈텐데, 이를 지리적 라우팅(geoDNS-routing)이라고 한다. 사용자의 위치에 따라 어떤 IP 주소를 반환할지 결정하는 역할을 한다.책에서는 x%를 지정하면 x%는 왼쪽 데이터센터로, (100-x)%는 오른쪽 데이터센터로 요청을 보내는 예제를 보여줬다.만약 데이터 센터 하나가 장애가 발생하여 다른 하나의 데이터 센터로 트래픽이 몰린다면 어떻게 될까?이 상황을 방지하기 위해 데이터센터를 만들때 고려해야할 사항들이 있다. 트래픽우회: 올바른 데이터센터로 요청을 보내는 방법을 생각해야한다. 데이터동기화(synchronization): 데이터센터마다 별도의 데이터베이스를 사용하고 있다면 데이터일관성의 문제가 발생할 수 있으므로 데이터를 각 데이터센터에 다중화처리를 하는것이다. 그 방법 중 하나는 넷플릭스가 사용하고 있다고 한다. 테스트와 배포(deployment): 여러 데이터센터를 사용하도록 구축되었다면 다양한 환경에서 테스트해보고 배포해야한다. 자동화 배포를 통해 데이터센터가 동일한 서비스를 제공하도록 하자.더 큰 규모로 확장하기 위해서는 시스템의 컴포넌트들을 분리하여 각기 독립적으로 확장 될 수 있도록 도와줄 필요가 있는데 이를 도와주는 것이 메시지 큐(Message Queue)이다.✏️ 메시지 큐메시지 큐는 메시지의 무손실을 보장하는, 비동기 통신을 지원하는 컴포넌트이다.메시지의 버퍼 역할을 하며 비동기적으로 전송한다.생산자(producer/publisher)가 메시지를 만들어 메시지 큐에 발행하면 소비자(consuemer/subscriber)가 메시지를 받아 메시지에 맞는 동작을 수행한다.메시지 큐를 사용하면 서비스 또는 서버 간의 결합이 느슨해져서, 규모 확장성이 보장되어야하는 어플리케이션에 안정감을 줄 수 있다.메시지 큐가 있기에 생산자는 소비자 프로세스가 다운되어도 메시지를 발행할 수 있고, 소비자 또한 생산자가 다운되어 있어도 메시지큐에서 메시지를 받아 볼 수 있다.만약에 사진 보정과 같이 작업이 오래걸리는 일을 수행해야한다면웹 서버는 메시지큐에 해당 작업을 보내고, 소비자의 워커(worker)프로세스들은 이 메시지를 받아 비동기적으로 작업을 수행하면 된다.이렇게 하면 소비자와 생산자가 독립적으로 규모를 확장시킬 수 있다. 메시지 큐가 커지면 소비자에 더 많은 프로세스를 추가하여 처리시간을 줄일 수 있고, 메시지 큐가 거의 비어있다면 프로세스를 줄여 비용절감에 효과를 줄 수도 있다.✏️ 로그, 메트릭, 자동화소규모 웹 사이트라면 로그, 메트릭(metric), 자동화(automation)을 하면 좋지만 필수적인 요소는 아니여서 관심이 없었다. 하지만 웹사이트 규모가 커지면서 이런 도구에 필수적으로 투자하는 환경이 조성되었다. 로그: 에러 로그를 모니터링 하는건 따로 적지 않아도 중요하다. 서버 단위로 모니터링 하는것보다 로그를 단일 서버로 모아주는 도구를 활용하면 좋다. 메트릭: 시스템의 현재 상황을 손쉽게 파악할 수 있도록 도와준다. 호스트 단위 메트릭: CPU, 메모리, 디스크I/O에 관한 메트릭 종합 메트릭: DB계층의 성능, 캐시 계층의 성능 핵심 비즈니스 메트릭: 일별 사용자, 수익, 재방문 같은 것들. 자동화: CI(continuous integration) 지속적 통합을 도와주는 도구를 활용하여 개발자의 코드가 어떤 검증 절차를 자동으로 거치도록 할 수 있다. 이를 통해 문제를 감지할 수도 있다. 더 나아가 빌드, 테스트, 배포 자동화를 하여 개발 생산성을 증대시킬 수 있다.✏️ 데이터베이스의 규모 확장위에서 스케일 업의 장단점에 대해 설명하였고, 책에서는 스케일 아웃 = 수평적 확장 = 샤딩으로 설명하고 있다.샤딩에 대해서 정리할 것이다.샤딩샤딩은 대규모 데이터베이스를 샤드라는 작은 단위로 분할하는 기술을 일컫는다.모든 샤드들은 같은 스키마를 사용하지만 데이터 중복은 없다.위 방식은 user_id를 나눈 나머지 값에 따라 데이터를 보관하는 샤드를 정한다.그렇기에 샤드0에는 user_id가 0,4,8,12 …인 값들이 저장될 것이고, 샤드1에는 user_id가 1,5,9,13, …인 값들이 저장될 것이다.이처럼 샤드를 구성할때에는 user_id처럼 샤드를 결정짓는 샤딩 키(sharding key)를 정하는 것이 중요하다. 샤딩 키는 파티션 키(partition key)로도 부른다. 데이터를 어떻게 분산시킬 지 정하는 하나 이상의 컬럼으로 구성된다. 데이터를 고르게 분산할 수 있는 샤딩 키를 정하는 것이 중요하다.샤딩은 완벽하지는 않다. 샤딩을 도입하면서 새로 고려해야할 문제들이 생기기 때문이다. 데이터의 재샤딩: 데이터가 너무 많아져서 하나의 샤드로 감당이 안되거나 샤드 간 데이터 불균형으로 인해 어떤 한 샤드의 공간이 빠르게 소진될 때 발생하는 문제이다. 이를 샤드 소진(shard exhaustion)로도 불리며 샤드 키를 계산하는 함수를 변경하여 데이터를 재배치 해야한다. 안정 해시(consistent hashing)을 통해 해결할 수 있다. 유명인사(celebrity) 문제: 만약 한 샤드에 봉준호, BTS, 손흥민이 있다고 치면 해당 샤드에 read가 많이 걸려 부하가 발생할 수 있다. 위 유명인사들을 각각 샤드로 쪼개 해결할 수는 있다. 조인과 비정규화: 샤드는 데이터가 여러군데에 분산되어 있기에 조인이 힘들어진다. 하나의 방법은 데이터베이스를 비정규화하여 하나의 테이블에서 하나의 질의가 수행되도록 하는 것이다.🤔 정리1장 내용은 스토리형식으로 시스템 규모가 확장될때마다 고려해야할 사항에 대해 설명했다. 데이터베이스를 설정할때 고려해야할 사항(관계형 DB ? NoSQL ?) 스케일 업의 단점이 있기에 스케일 아웃을 선호하는데 이를 해결하기 위해선 웹 계층에서는 로드밸런서로 트래픽을 관리, 데이터 계층에서는 Master-Slave방식으로 트래픽을 관리하였다. 더나아가 자주 참조되는건 캐시 서버로 둬서 빠른 응답속도를 제공하였지만, 데이터 일관성 부분은 숙제로 남아있다. CDN을 통해서 정적 리소스들을 사용자들에게 빠르게 전달할 수 있게 되었다. 좀 더 유연한 요청처리를 위해 무상태로 웹을 구성해야하는데, 이를 도와주기 위해 공유저장소를 두었다. 위의 구성들을 사용자들에게 빠른 응답을 제공하기 위해 데이터센터를 두었고, 각각 데이터 센터에서도 데이터 일관성을 고려하기 시작하였다. 메시지 큐를 둬서 소비자와 생산자가 각각 독립적으로 확장할 수 있게 돕고, 비동기적 처리로 인해 일의 효율성도 증대 되었다. 로그, 메트릭을 통해 시스템을 헬스체크를 할 수있고 모니터링 할 수 있게 되었다. 자동화를 통해 검증된 로직을 통해 테스트, 빌드, 배포까지 할 수 있게 도와주게 되었다. 데이터베이스를 샤드라는 작은 단위로 쪼개 효율적으로 데이터베이스를 관리할 수 있게 되었지만 그에 따른 고려해야할 사항이 많다는걸 알게되었다." }, { "title": "real-world프로젝트 Spring 시작하기(7) - 회원가입API 및 Jwt Token 만들기(1)", "url": "/posts/realworld07/", "categories": "Toy, real-world-spring", "tags": "Spring", "date": "2022-12-07 01:02:00 +0900", "snippet": " real-world project 구현 과정 카테고리 보기Spring Security를 이용한 JWT token 적용하기.앞선 포스팅에서 JWT와 쿠키, 세션에 대해서 설명하였다.이번 포스팅에서는 이거를 코드로 구현할 것이다.회원가입API를 구현하면 Return값으로 Token을 넘겨야하기 때문이다.API마다 토큰을 가지고 검증하기 위해 Filter를 이용하지만 지금 단계에서는 필요하지 않으므로 Token을 만드는것까지만 해볼 것이다.✔ API명세 확인real-world에서는 회원가입(Registration)에 대해 명세를 이렇게 주었다. Endpoint: /api/users [post] body: user객체. 인증은 필요 없다. email, username, password 가 필요하다.인증 및 인가는 필요없으니 필터를 아직 구현할 필요가 없는것이다.✔ 회원가입 Request DTO 만들기username, email, password를 필드로 가지는 user객체를 넘겨 받기로 했으니 이를 받아주는 객체가 필요할 것이다.나는 UserSignupRequest라는 객체로 만들었다.package com.io.realworld.domain.aggregate.user.dto;import com.fasterxml.jackson.annotation.JsonTypeInfo;import com.fasterxml.jackson.annotation.JsonTypeName;import lombok.AllArgsConstructor;import lombok.Builder;import lombok.Getter;import javax.validation.constraints.Email;import javax.validation.constraints.NotBlank;@Getter@Builder@JsonTypeName(&quot;user&quot;)@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.WRAPPER_OBJECT)public class UserSignupRequest { @NotBlank private String username; @Email private String email; @NotBlank private String password;}DDD설계를 따르기 위해 패키지 구조를 저렇게 가져갔다는걸 확인하면 좋다.위에서 부터 설명을 하자.@GetterExample: private @Getter int foo; will generate: public int getFoo() { return this.foo; }라고 doc에는 적혀있다. 롬복에서 제공한다.필드레벨에 달면 저렇게 코드를 생성해주고 클래스 레벨에 @Getter어노테이션을 달면 클래스 내에 선언된 필드 전체에 적용이 된다는 것이다.이렇게 @Getter를 쓴 이유는 저기에 쓰인 필드 모두 어딘선가 재사용될 가능성이 굉장히 크기 때문이다. username과 email로 중복 검증받아야할 일도 있고, password는 암호화할때 쓰일것이다.그래서 클래스 레벨에 @Getter를 달아놓는것이다. 사실 @Setter만 아니면 클래스레벨에 쓰는건 크게 신경 쓰지 않아도 되는것 같다.@BuilderBuilder패턴은 많은 이점을 가지고 있다.**Bulder를 사용한 이유는 ** Builder를 통해 추가적인 연산이 필요하지만 여러 생성자에 대해 유연하게 대처가 가능하고,코드를 간략히 짤 수가 있게 된다. 자세한건 따로 정리하고 여기에는 적지 않겠다.@Builder는 생성자가 없을 경우 모든 멤버 변수를 파라미터로 가지는 기본 생성자를 생성하는데, 이 때문에 @AllArgsConstructor를 명시해주지 않아도 된다. 만약 @NoArgsConstructor를 @Builder와 같이 쓰는경우에는 명시해줘야한다.@JsonTypeName, @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.WRAPPER_OBJECT)JSON의 논리적 이름을 명시해준다는 것이다.real-world에서는 요청에 대한 JSON형식을 user라는 객체에 담아 보내기로 되어있다.이를 받기 위해서 필요한게 이 어노테이션이고 이름을 맞춰줘야한다.{ &quot;user&quot;: { &quot;email&quot;: &quot;test@naver.com&quot;, &quot;password&quot;: &quot;&amp;lt;password&amp;gt;&quot;, &quot;username&quot;: &quot;kms&quot; }}하지만 단독으로 쓸 경우에는 위처럼 요청오는 JSON을 파싱할 수도, 응답을 보내기가 힘들다.그래서 @JsonTypeInfo 이 구문이 필요한데, 첫번째 인자인 JsonTypeInfo.Id.NAME는 사용자가 @JsonTypeName으로 지정한 이름을 객체의 이름으로 지정하겠다는 뜻이다.JsonTypeInfo.As.WRAPPER_OBJECT구문은 JSON전체에 대한 객체를 오브젝트 형식으로 묶는다는 뜻이다.JsonTypeInfo.As.WRAPPER_Array도 존재하는데 이를 사용할 경우 Request는 다음과 같은 양식으로 받아야할 것이다.[ &quot;user&quot;: { &quot;email&quot;: &quot;test@naver.com&quot;, &quot;password&quot;: &quot;&amp;lt;password&amp;gt;&quot;, &quot;username&quot;: &quot;kms&quot; }]@NotBlank, @Emailjavax.validation에 정의되어 있는 이 두 어노테이션은 검증을 담당한다. @NotBlank: 하나 이상의 문자가 들어가야한다. (“”,” “)불가. @Email: Java Bean에서 제공하고 있는 검증방식. 이메일 검증을 한다.이렇게 Request로 들어오는 DTO에 대한 코드 설명은 끝이 났다.이제 이를 받는 컨트롤러를 설계한다.✔ 회원가입 컨트롤러 생성@RestController@RequestMapping(&quot;/api/users&quot;)public class UsersController { private final UserServiceImpl userService; public UsersController(UserServiceImpl userService) { this.userService = userService; } @PostMapping public UserResponse signup(@Valid @RequestBody UserSignupRequest userSignupRequest) { return userService.signup(userSignupRequest); }}기본적인 코드이므로 따로 설명할 건 없다. 쓴 이유에 대해서는 알아야겠다. @RestController: real-world에서는 모든 응답을 JSON방식으로 바디에 담아서 넘겨야한다. @ResponseBody와 @Controller역할을 둘 다 하는 @RestController를 채택 @RequestMapping: 공통 엔드포인트를 지정하기 위해 클래스단에다가 넣어두었다. private final ~: @RequiredArgsConstructor어노테이션을 사용하면 생성자 주입을 따로 안해줘도 되지만 방식 자체를 까먹을까봐 명시해두었다. @PostMapping: 회원가입은 Post형식으로 받을것이므로 해당 어노테이션을 사용하였다. @Valid: DTO에서 사용한 검증 어노테이션에 대한 검증을 진행한다. 같은 자바빈즈 패키지에서 지원하기에 검증할 수 있다. @RequestBody: 요청 본문에 담긴 값을 HttpMessageConvert가 우리가 선언한 자바객체형식으로 반환해서 꽂아넣어준다.근데, HttpMessageConver는 키와 밸류를 기준으로 데이터를 꽂아주는데 real-world가 요청형식으로 보내는 것은 user라는 객체로 감싸져 있다. 이를 해독하기 위해서는 DTO클래스 어노테이션 @JsonTypeInfo와 @JsonTypeName이 필요한 것이다.✔ 회원가입 Response DTO 만들기위 코드를 보면 컨트롤러의 리턴 객체타입이 UserResponse이다.real-world에서는 리턴객체를 다음과 같이 지정해주고 있다.{ &quot;user&quot;: { &quot;email&quot;: &quot;jake@jake.jake&quot;, &quot;token&quot;: &quot;jwt.token.here&quot;, &quot;username&quot;: &quot;jake&quot;, &quot;bio&quot;: &quot;I work at statefarm&quot;, &quot;image&quot;: null }}이 필드값에 맞는 DTO를 Request DTO를 만들었던거와 똑같이 생성하면 된다.@Builder@Getter@JsonTypeName(&quot;user&quot;)@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.WRAPPER_OBJECT)public class UserResponse { private String email; private String token; private String username; private String bio; private String image;}위의 내용과 같으므로 따로 설명하지는 않겠다.여기까지가 회원가입을 하기 위한 컨트롤러 제작이다.요청 DTO, 응답 DTO, 컨트롤러, 어노테이션에 대한 설명을 하였고,다음 포스팅에서는 Token만들어서 리턴하기, 회원가입 서비스, 레포지토리 구현을 포스팅할 것이다. 현재 이 프로젝트는 vue.js + vite + vuex + Spring boot, Spring Data JPA + Spring Security 를 이용하여 real-world 데모버전을 제작완료하였습니다. https://github.com/kkminseok/real-world-springbootReference https://www.logicbig.com/tutorials/misc/jackson/json-type-info-with-wrapper.html JSON어노테이션 https://seongtak-yoon.tistory.com/70 JSON어노테이션 구현체 분리 https://wildeveloperetrain.tistory.com/49 Service Impl 분리이유" }, { "title": "OSI7계층 통신 세부정리", "url": "/posts/TIL20221128/", "categories": "Interview", "tags": "interview", "date": "2022-11-28 00:02:00 +0900", "snippet": "OSI 7 Layer, TCP/IP 4 Layer OSI 7계층, TCP/IP 4계층은 복잡한 네트워크를 단계별로 나누어 이해하기 쉽도록 도와주게 한다.비교과거에 통신에 대한 규약이 표준화되어 있지 않았고 벤더사마다 별도로 개발해서 호환되지 않은 시스템, 애플리케이션이 많았다.이를 하나의 규약으로 통합하려는 노력이 현재의 OSI 7계층인것이다.7계층이라 네트워크 동작을 나누어 이해하고 개발하는데 많은 도움을 주어서 레퍼런스용으로 많이 쓰이는데, 현재는 대부분의 프로토콜이 TCP/IP 프로토콜 스택 기반으로 되어 있다.각각의 장단점이 있고, 구글링을 해본결과.TCP/IP가 먼저 사용되어서 라는 내용보다는 진화: OSI는 문서화되어 각 기능이 명시된 논리적 모델이고, TCP/IP는 프로토콜로 구현되고 문서화되었다. 그렇기에 OSI는 이론적으로, TCP/IP는 실용적으로 진화를 한 것이다. 그렇기에 실질적으로 네트워크 모델을 구현하려면 TCP/IP모델을 사용해야한다. 목표: OSI의 목표는 연결 절차, 계층화 구조, 서비스, 인터페이스 등 표준 모델을 고안하는데에 있고, TCP/IP는 신뢰할 수 있는 엔드포인트들끼리의 통신을 구성하는데에 있다는 것. 따라서 일반적이고 표준적인 모델이 필요하면 OSI, 네트워크를 통해 신뢰성과 보안이 필요한 경우 TCP/IP 모델을 선택하는게 좋다. 호환성: OSI가 일반적인 모델이라 다양한 유형의 네트워크에서 사용이 가능한데, TCP/IP는 프로토콜에 의존하다보니 현재의 아키텍처에 호환이 된다. 그렇기에 다른 아키텍처에 호환이되지 않을 수 있다는 점이 있다. 범용성의 차이가 있다는 것. 문서화: OSI가 일반적이라 TCP보다는 문서화(각 계층의 사양과 기능)이 잘 명시되어 있다. 설정: 마찬가지로 표준적인 OSI가 설정 및 구성이 쉽다. TCP/IP는 특정 도메인과만 호환되기에 좀 더 복잡하다.요약하자면 OSI는 보편적이여서 다른 이들에게 설명하기도 쉽다. TCP/IP는 프로토콜에 의존적이라서 구성환경이 각각 네트워크마다 다르므로 다른이들에게 설명하기 어렵다는 것이다. 자체적으로 프로토콜을 구현해서 집어넣을수도 있다는 것이다.OSI 7계층-- Layer -- 데이터(PDU)애플리케이션(Application) Data프레제테이션(Presentation), 표현 Data세션(Session) Data트랜스포트(Transport), 전송 Segments네트워크(Network) Packets데이터링크(Data Link) Frames피지컬(Physical), 물리 Bits 1 ~ 4계층: 데이터 플로 계층/하위 계층 5 ~ 7계층: 애플리케이션 계층/상위 계층 데이터 플로계층에서는 데이터를 상대방에게 잘 전달하는 역할을 가지고 있는 것들 애플리케이션 계층에서는 개발자들이 데이터를 표현하는데에 역할을 갖고 있는것들그렇기에 네트워크 개발자는 상향식(Bottom-up)으로 1계층 -&amp;gt; 2계층 -&amp;gt; 3계층.. 으로 바라보고, 애플리케이션 개발자들은 하향식(Top-Down) 7계층 -&amp;gt; 6계층 -&amp;gt; 5계층 … 으로 바라본다.TCP/IP 4계층잘보면 네트워크 개발자가 고려해야할 1 ~ 4계층과 애플리케이션 개발자가 고려해야할 5 ~ 7계층의 구분이 더 확연히 드러나있다.1계층(피지컬 계층)우리는 네트워크를 통해서 JSON 데이터를 받던 헤더에 200 OK를 받던 이 모든것들은 우리가 알아볼 수 있는 글로 변환된 것이고 컴퓨터끼리 통신할때에는 컴퓨터가 알아볼 수 있는 2진수로 이루어진 전기신호로 대화를 했을것이다. 그렇기에 물리적 통신에 목표를 둔 1계층은 전기신호를 나타내는 Bits로 대화를 하며 주소의 개념이 없어서 전기 신호가 들어온 포트를 제외하고 모든 포트에 같은 전기신호를 보낸다. 주요장비로는 허브, 리피터, 케이블, 커넥터, 트랜시버, 탭이 있다.케이블, 커넥터, 트랜시버케이블과 커넥터의 사진인데, 그 종류로는 트위스티드(Twisted), 동축(Coaxial), 광(Fiber-optic)케이블이 있다.케이블을 연결해야하는 거리나 속도에 따라 나뉘고 용도에 맞게 사용하면 된다. 여러 표준이 있으며, 해석하는 방법이 있다.이는 기가비트 이더넷 및 10기가비트 이더넷 표준이며, 이 외에도 여러 표준이 있다.ex) 1000 BASE -T 속도, 채널, 케이블 타입를 예시로 들면 1000은 1000Mbps로 1기가를 뜻하고, BASE는 단일 채널이라는 뜻이며 여기에는 안나와 있는 Broad는 다채널 통신을 의미한다. 그리고 마지막에 T는 (Twisted)라는 트위스티드 페어 케이블을 나타낸다. 마지막 케이블 종류에 따라 그에 맞춘 광신호, 트랜시버의 종류가 달라진다.트랜시버는 외부 여러 신호를 컴퓨터가 알 수 있는 전기신호로 변환해주는 수신부와 전기 신호를 외부 신호로 변환시키는 송신부가 있는데, 이를 합쳐(Transmitter + Recevier) 트랜시버라 부른다.옛날에는 다양한 이더넷 표준과 케이블을 만족하기 위해서 네트워크 장비나 NIC(네트워크 인터페이스 카드)를 별도로 구매해야 했는데, 이러한 불편함을 해소하기 위해 서로 다른 다양한 네트워크 표준을 혼용해 사용할 수 있도록 트랜시버를 사용하게 되었다.트랜시버가 없었다면 케이블의 길이나 속도마다 다른 네트워크 장비나 NIC를 구매해야 했는데, 트랜시버를 통해 통신 길이나 속도를 조절하여 불편한 점을 해소할 수 있도록 한다.트위스티드 페어의 경우 별도의 트랜시버가 없는 경우가 많지만, 광 케이블은 다양한 속도와 거리를 지원해야 하므로 트랜시버를 따로 분리하는 경우가 많다. 광 트랜시버허브 허브허브의 역할은 거리가 멀어질수록 줄어드는 전기 신호를 재생성하고, 여러대의 장비를 연결할 목적으로 사용된다.위에서 주소의 개념이 없어서 모든 포트에다가 전기신호를 보낸다 했는데, 허브가 그 역할을 수행한다.이런한 점 때문에 전체 네트워크 성능이 줄어들고 패킷이 무한 순환해 네트워크 전체를 마비시키는 경우가 있어서 현재는 거의 사용되고 있지는 않다.리피터근거리 통신망을 확장하거나 서로 연결하는데 주로 사용된다.주 역할은 신호를 증폭하여 다음 구간으로 재전송하는 장치. 즉, 신호 감쇠현상을 대비하여 사용한다.탭패킷을 모니터링하는 장비이다. 트래픽을 복사해 그 복사본만 따로 확인하여 모니터링한다. 이와 반대로 회선 안에 장비가 들어가 있는 인라인(In-Line Mode)가 있는데 이는 회선에 영향을 주는 반면, 탭은 미러링(Mirroring Mode)로 회선에 영향을 주지 않는다는 장점이 있다. 탭2계층(데이터 링크 계층) 1계층에서 받은 전기 신호를 우리가 알아볼 수 있는 데이터 형태로 처리하는 곳이다. 1계층의 목표가 전기신호를 정확하게 전달하는 것이였다면 주소 정보를 정의하고 정확한 주소로 통신이 되도록 하는데에 초점이 맞춰져 있다. 2계층에서는 출발지와 목적지 주소를 확인하고 내게 보낸 것이 맞는지, 내가 처리해야 하는지에 대해 검사한 뒤 데이터 처리를 수행한다. 여기서는 MAC 주소라는 개념이 등장한다. 이를 통해 NIC와 스위치가 주소를 이해하고 통신해야할 포트를 지정해 내보내는 능력을 지닐 수 있다.NIC는 고유 MAC 주소가 있는데, 입력되는 전기 신호를 데이터 형태로 만들고 데이터에서 도착지 MAC주소를 확인 후 내 것이 맞지 않다면 버려버리고 맞다면 상위 계층에서 처리할 수 있도록 메모리에 적재한다. NIC는 전기적 신호를 데이터 신호 형태로 또는 데이터 신호 형태를 전기적 신호로 변환하는데 이를 직렬화라고 한다. NIC 네트워크 인터페이스 카드스위치는 허브와 동일하게 여러 장비를 연결하고 통신을 중재하는 역할을 담당한다.내부동작은 다르지만 여러 장비를 연결하고 케이블을 한곳으로 모아주는 역할은 같으므로 이를 ‘허브’라고 공통적으로 사용한다.스위치는 허브의 역할과 통신을 중재하는 역할을 담당하여 스위칭 허브라고도 불린다.허브와 달리 MAC주소를 이해하여 연결된 포트로만 전기 신호를 보낸다.네트워크 전체에 불필요한 처리가 감소하면서 이더넷 기반 네트워크가 급장하는 계기가 되었다. MAC주소와 스위치 개념도목적지가 없는경우, MacTable에 존재하는경우, 목적지가 출발지와 같은 포트에 존재하는 경우 알고리즘이 다른데,좀 더 자세한 내용은 https://bannavi.tistory.com/147를 읽어보는것을 추천한다. 스위치 허브3계층 네트워크 계층2계층의 MAC주소는 물리적 주소라면 네트워크 계층에는 IP주소라는 논리적 주소가 있다.MAC 주소와 달리 IP 주소는 사용자가 환경에 맞게 변경해 사용할 수 있다. NIC에는 주소가 자체적으로 있다했는데, 그게 MAC 주소이고 마음대로 바꿀 수 없다.MAC주소와 IP 주소는 아무런 연관관계가 없는데, 상대방의 MAC 주소를 알아내기 위해서 사용하는 프로토콜이 ARP(Address Resoulution Protocol)이다.ARP3계층에서 쓰이는 라우터 장비는 3계층에서 정의한 IP주소를 사용해 최적의 경로를 찾아주고 해당 경로로 패킷을 전송하는 역할을 한다. ARP 프로토콜 필드(헤더 + 데이터)호스트에서 처음 통신을 시도하면 패킷을 바로 캡슐화할 수 없다. 출발지와 목적지 IP 주소는 미리 알고 있어 이를 캡슐화하는데 문제가 없지만 MAC 주소를 알 수 없어서 2계층 캡슐화가 불가능한 것이다. 상대방의 MAC 주소를 알아내려면 ARP 브로드캐스트를 이용해 네트워크 전체에 상대방의 MAC 주소를 질의해야 한다.ARP브로드캐스트를 받은 목적지들은 자신의 MAC주소를 응답하고, 출발지 목적지 둘다 상대방에 대한 MAC주소를 학습하고 이후 패킷이 캡슐화되어 상대방에게 전달될 수 있다.arp -a명령어를 통해 ARP 테이블 정보를 확인할 수 있고, ARP 프로토콜을 통해 IP주소와 MAC 주소를 매핑하면 “유형” 필드에 ‘‘동적’으로 표기된다. 패킷을 보낼때마다 ARP브로드캐스트를 진행하면 네트워크 효율성이 크게 저하되므로 메모리에 이 정보를 저장해두고 재사용한다. IP주소 특성상 바뀔 수 있으므로 일정 시간 동안 통신이 없으면 테이블은 삭제가 된다. ARP 동작방식출발지 MAC | 목적지 MAC | 출발지 IP | 목적지 IPAA - 1.1.1.1 1.1.1.2-------------------------------------------------서버A(1.1.1.1) --------&amp;gt; 서버B(1.1.1.2)MAC(AA) MAC(BB) 이러한 예제가 있다고 치면, 서버A에서 ping을 보낼때 3계층의 IP주소 까지는 캡슐화하지만 상대방의 MAC 주소를 모르기에 2계층은 캡슐화가 불가능하다. 상대방의 MAC 주소를 알아내기 위해 ARP 요청을 네트워크에 브로드캐스트 한다. ARP 요청을 보내기 위해 패킷을 다음과 같이 구성한다.--ARP 패킷출발지 MAC | 목적지 MAC | 전송자 MAC | 전송자 IP | 대상자 MAC | 목적지 IPAA 브로드캐스트 AA 1.1.1.1 00 1.1.1.2-------------------------------------------------서버A(1.1.1.1) --------&amp;gt; 서버B(1.1.1.2)MAC(AA) MAC(BB) 참고용 브로드캐스트는 (FF-FF-FF-FF-FF-FF), 대상자 MAC은 (00-00-00-00-00-00)으로 채움.이를 네트워크에 뿌린다. 모든 단말이 요청을 받았을때 자기의 IP면 응답하고 아니면 ARP패킷을 폐기한다. 응답할때 송신자와 대상자의 위치가 바뀐다. 이때 B서버기준 패킷을 받았을때 보낸곳의 IP와 MAC주소를 알고 있으므로 자신의 ARP 캐시 테이블에 정보를 담아 놓는다. 그리고 보낼때는 출발지와 도착지의 MAC 주소가 명시되어 있는 유니캐스트(unicast)로 한다.--ARP 패킷 응답출발지 MAC | 목적지 MAC | 전송자 MAC | 전송자 IP | 대상자 MAC | 목적지 IPBB AA BB 1.1.1.2 AA 1.1.1.1-------------------------------------------------서버A(1.1.1.1) &amp;lt;-------- 서버B(1.1.1.2)MAC(AA) MAC(BB)------------------------------------------------서버 A 캐시테이블---------------인터넷 주소 | 물리 주소 | 유형1.1.1.2 BB 동적 서버 A는 ARP 응답을 받고 자신의 ARP 캐시 테이블을 갱신하고 데이터를 캡슐화하여 ping을 보낸다.--ping 요청출발지 MAC | 목적지 MAC | 출발지 IP | 목적지 IPAA BB 1.1.1.1 1.1.1.2-------------------------------------------------서버A(1.1.1.1) --------&amp;gt; 서버B(1.1.1.2)MAC(AA) MAC(BB)이 외에도 GARP, RARP같은 프로토콜이 있다.4계층(트랜스포트 계층)4계층은 1, 2, 3계층과는 다른 역할을 수행한다.1, 2, 3계층은 신호와 데이터를 올바른 위치에 보내고 실제 신호를 잘 만들어 보내는 데 집중하였다.4계층은 해당 데이터들이 실제로 잘 보내졌는지 확인하는 역할을 담당한다.예를들어, 패킷이 도중에 유실되거나 순서가 바뀌는 등 이러한 문제를 바로 잡아주는 역할을 수행한다.4계층에서 동작하는 장비로는 로드 밸런서와 방화벽이 있다. 부하를 분산시키거나 보안 정책을 수립해 패킷을 통과하거나 차단하는 기능을 수행한다.또한 여기에 포함되어 있는 TCP, UDP 프로토콜에 대해서는 준식이 글을 통해 볼 수 있다.5계층(세션 계층)5계층의 역할은 양 끝단의 응용 프로세스가 연결을 성립하도록 도와주고 연결이 안정적으로 유지되도록 관리하고 작업 완료 후 연결을 끊는 역할을 한다. 예를 들어 통신이 끊어진 부분부터 다시 이어서 데이터를 전송받는 기능을 생각하면 된다.6계층(프레제테이션 계층)데이터 형식을 변환하거나, MIME 인코딩, 암호화와 복호화, 데이터 압축을 수행한다.예를 들어 EBCDIC(확장 이진화 십진법 교환 부호)로 인코딩된 문서 파일을 ASCII로 인코딩 된 파일로 바꿔주거나 해당 데이터가 TEXT인지, 그림인지 등을 식별한다.7계층(애플리케이션 계층)네트워크 소프트웨어의 UI부분이나 사용자 입.출력 부분을 정의하는 것이 애플리케이션 계층의 역할EX) chome, firefox등 사용자에게 보여지는 UI 이를 통해 사용자는 네트워크 통신을 할 수 있다.그리고 대표적으로 FTP, SMTP, HTTP, TELNET 등의 프로토콜이 있다.인캡슐레이션과 디캡슐레이션데이터를 보내는 과정을 인캡슐레이션 데이터를 받는 과정을 디캡슐레이션이라고 한다.Reference https://afteracademy.com/blog/which-model-is-better-osi-or-tcpip/ - TCP/IP가 더 쓰이는 이유. https://bannavi.tistory.com/147 MAC주소에 대한 동작방식 읽기 추천." }, { "title": "real-world프로젝트 이슈 - vue에서 오브젝트에 담긴 리스트를 보내고 싶을때", "url": "/posts/2022-11-21Issue/", "categories": "Toy, real-world-spring", "tags": "Spring", "date": "2022-11-22 00:02:00 +0900", "snippet": " real-world project 구현 과정 카테고리 보기개요나는 vue단에서 이렇게 데이터를 보내야했다.{ &quot;article&quot;: { &quot;title&quot;: &quot;How to train your dragon&quot;, &quot;description&quot;: &quot;Ever wonder how?&quot;, &quot;body&quot;: &quot;You have to believe&quot;, &quot;tagList&quot;: [&quot;reactjs&quot;, &quot;angularjs&quot;, &quot;dragons&quot;] }}처음에 {}와 article의 title,description,body을 감싸주는데에는 큰 문제가 없었다.근데 Java단에서 저 tagList에 대해 인식할 수 없다고 했다.js코드에서는 다음과 같이 요청 코드를 작성하고 있었다.const tag = ref(&quot;&quot;);const article = reactive({ title: &quot;&quot;, description: &quot;&quot;, body: &quot;&quot;, tagList: new Array(tag),})... axios.post(url+&quot;/api/articles&quot;,JSON.stringify({article}) ,{headers:{ ... }지나고와서보면 코드부터 틀린긴했다. tag가 아니고 ref에 의해서 tag.value를 넣어줘야했다. 근데 저래도 값이 제대로 들어가지 않는다.물론 저 코드를 계속 수정하긴 하였다.아무튼 나는 원래 나타난 저 스크린샷의 원인을 해결하기 위한 방법을 찾고 다녔다.생각생각 @JsonFormat을 사용해보기 https://stackoverflow.com/questions/39041496/how-to-enforce-accept-single-value-as-array-in-jacksons-deserialization-process 커스텀 방법2 https://parksay-dev.tistory.com/51 응용할 수 있을지 https://stackoverflow.com/questions/17560258/pass-array-data-from-javascript-in-browser-to-spring-mvc-controller-using-ajax JSON 역직렬화 커스텀 https://multifrontgarden.tistory.com/172 ObjectMapper 커스텀 https://stackoverflow.com/questions/14588727/can-not-deserialize-instance-of-java-util-arraylist-out-of-value-string어떻게든 파싱을 직접 커스텀해서 할 생각이었다. 결론은 모두 안 되었다.해결모두 잘 되지 않고, 가만히 생각해보니 vue에서는 list에 대해서 동적으로 상태관리를 할 수 없다고 했다.vue에서는 List에 요소를 추가할때, this.$set을 사용한다고 한다. 하지만 Composition API 방식에서는 어떻게 사용하는지는 모르겠고, arry.push()메소드를 통해 요소를 추가할 수 있다고 한다.그래서 ,를 기준으로 태그들을 파싱해준 후, 순차적으로 list에 넣어서 요청을 보내도록 하였다. article.tagList.push(tag.value); console.log(article) console.log(JSON.stringify(article)); console.log(JSON.stringify({article})); console.log(tag.value); console.log({article});또한 각각의 출력물들을 통해서 요청이 어떻게 가는지 확인하였다.실제 데이터베이스에도 잘 저장된다. 현재 이 프로젝트는 vue.js + Spring boot, Spring Data JPA 를 이용한 풀스택개발, 컨트리뷰션에 목표를 두고 있습니다. https://github.com/kkminseok/real-world-springboot" }, { "title": "Https 정리", "url": "/posts/TIL20221121/", "categories": "Interview", "tags": "interview", "date": "2022-11-21 01:02:00 +0900", "snippet": " 오타, 지적 환영입니다. ✏️CS스터디 저장소HTTPs HTTPs는 (Hyper Text Transfer Protocol over Secure Socket Layer)의 약자이고 HTTP over TLS, HTTP over SSL, HTTP Secure로도 불린다. 소켓통신에서 일반 텍스트(평문)을 사용하는 대신에 SSL이나 TLS 프로토콜을 통해 세션 데이터를 암호화한다. 기본 TCP/IP 포트는 443이다. 보호의 수준은 웹 브라우저에서의 구현 정확도, 서버 소프트웨어, 지원하는 암호화 알고리즘에 달려있다. HTTP 프로토콜에 대칭, 비대칭 인증서 기반 암호 기법을 결합한 것이다. HTTPs 나오게된 이유HTTP의 문제점HTTPs가 나오게 된 배경에는 HTTP의 한계를 보안하기 위함이 있다.암호화되지 않은 HTTP 메시지를 TCP를 통해 전 세계에 보내는 대신해 HTTPS가 HTTP 메시지를 TCP로 보내기 전에 암호화하는 보안계층으로 보내버린다.이 보안계층에서는 SSL과 이를 나름 최신화해서 업데이트한 TLS로 구현되어 있다. 우리는 이를 모두 의미하는 SSL을 말할 뿐이다.HTTPS 스킴현재 보안 HTTP는 선택적인데, 이를 웹 서버에 요청보낼때 알려줄 필요가 있다. 이것은 URL의 스킴을 통해 이루어진다.http://~https://~이처럼 https라는 URL 스킴이 붙은것은 보안 HTTP를 사용한다고 웹 서버에 알리는 것이다.기본적으로 http요청은 80번 포트에, https요청은 443번 포트에 연결을 하게 된다.(http요청) port 80client ---------------&amp;gt; Server(https요청) port 443client ---------------&amp;gt; Server http는 요청을 보내면 일반 HTTP 명령을 보내게 된다. https는 요청을 보내고, 서버와 바이너리 포맷으로 된 몇몇 SSL 보안 매개변수들을 교환하며 핸드쉐이크를 하고 암호화된 HTTP 명령이 뒤를 잇는다. SSL은 바이너리 프로토콜이기에 HTTP와는 다르다.(HTTP는 텍스트 프로토콜) 보안 전송암호화 되지 않은 HTTP는 웹 서버의 80번 포트에 커넥션을 맺고 데이터를 주고 받은 후에 커넥션을 닫는다.HTTPS는 이보다 좀 더 복잡하다. 443포트에 커넥션을 연결한다. 클라이언트와 서버는 암호법 매개변수와 교환 키를 협상하면서 SSL 계층을 초기화한다. 핸드셰이크가 완료되면 SSL 초기화가 완료된 후, 클라이언트는 요청 메시지를 보안 계층에 보낼 수 있다. 이 메시지는 TCP/IP 계층으로 가기 전에 암호화가 된다. 이후 응답을 보내고, SSL을 닫고 커넥션을 닫는다. SSL 핸드셰이크핸드셰이크에서는 다음과 같은 일들이 벌어진다. 프로토콜 버전 번호 교환 양쪽이 알고 있는 암호 선택 양쪽의 신원을 인증 채널을 암호화하기 위한 임시 세션 키 생성SSL은 통신을 시작하기 전에 상당한 양의 핸드셰이크 데이터를 주고 받는다. 3-way-handshake 이후, HTTPS라는걸 알게된 브라우저는 다음 정보를 웹 서버에 보낸다. 브라우저가 사용하는 SSL, TLS버전 정보 브라우저가 지원하는 암호화 방식 모음(cipher suite) 브라우저가 순간적으로 생성한 임의의 난수(숫자) 만약 SSL 핸드셰이크가 완료된 상태라면, 그때 생성된 세션 아이디 기타 정보 cipher suite란 암호화 알고리즘, 메시지 무결성 확인 알고리즘, 전달 대상 인증 등 이러한 방식들을 패키지로 모아놓은 것을 의미한다. 서버쪽에서 이를 응답하면서 다음 정보를 클라이언트에 제공한다 브라우저가 전달한 암호화 방식중에 서버가 지원하고 선택한 암호화 방식(cipher suite) 서버의 공캐키가 담긴 SSL 인증서 서버가 순간적으로 생성한 임의의 난수(숫자) 클라이언트는 위의 정보를 받고 내부적 검증절차를 거친다. 클라이언트 브라우저에 설치된 CA들의 정보와 CA가 만든 공개키를 통해 서버가 보낸 SSL인증서가 정말 CA가 만든 것인지를 확인.(복호화) 등록된 CA가 만든 인증서가 아니거나, 그런것처럼 꾸몄다면 이 과정에서 브라우저 경고를 보낸다. 웹 서버 인증서에 딸려온 웹 사이트 공캐키로 암호화하여 위 정보들을 서버로 전송. 이 부분은 밑에서 또 설명. 서버는 사이트의 비밀키로 브라우저가 보낸 정보들을 복호화한다. 복호화된 정보를 master secret값으로 저장. 이것을 사용하여 브라우저와 만들어진 연결에 대한 고유한 session key를 생성. 이 session key는 대칭키 암호화에 사용할 키이다. 이것으로 브라우저와 서버 사이에 주고받는 데이터를 암복화한다. SSL 핸드셰이크를 종료하고, HTTPS 통신 시작. 이 시점에서는 서버는 서로에게 공유된 sesssion key를 폐기한다. 브라우저에서 요청시에 세션ID만 알려주면 되기에 파기시켜도 된다. 서버 인증서위에서 웹 서버 인증서에 딸려온 웹 사이트 공개키로 암호화 한다고 하였는데, 여기서 제공되는 인증서에 대해 알아보자.SSL은 서버 인증서를 클라이언트로 나르고 다시 클라이언트 인증서를 서버로 나르는 상호 인증을 지원한다.오늘날 클라이언트 인증서는 흔히 쓰이지 않고, 직원들에게 보여주지 않을 정보를 기업 내에서 관리하는 등의 상황에서는 쓰이고 있다.HTTPS는 항상 서버 인증서를 요구하는데, 잘 알려진 인증기관에 의해 서명된 서버 인증서는 민감한 데이터를 보낼때 그 서버를 얼마나 신뢰할 수 있는지 평가하는데 도움을 준다.서버 인증서는 조직의 이름, 주소, 서버 DNS 도메인 이름, 등의 정보를 보여준다. 이러한 정보를 통해 클라이언트는 모든 정보가 믿을만한지 인증서를 검증할 수 있다.사이트 인증서 검사SSL 자체는 사용자에게 웹 서버 인증서를 검증하라고 시키지는 않지만, 최신 브라우저들은 대부분 인증서에 대한 기본적인 검사를 한다. 넷스케이프가 제안한 웹 서버 인증서 검사를 위한 한 알고리즘은 대부분 웹브라우저의 검사 기반의 기초를 구축했다.위의 사진을 순서대로 따라가본다. 웹 서버는 인증기관에 자신의 사이트에 대한 정보를 인증기관에 공개키와 함께 보낸다.(비밀키는 본인이 소유하고 있음) CA에서 내부 검증을 통해 사이트 인증에 성공했으면 이를 인증기관 비밀키를 통해 암호화하여 인증서를 서버에 발급한다. 클라이언트에서 요청을 할 경우 SSL핸드셰이크를 수행한다. 그 과정중에 서버가 공개키를 담은 인증서를 보내는데, 이 인증서를 브라우저에 저장된 CA키를 가지고 그 기관에서 발급한 인증서가 맞는지 확인한다. 인증 되었다면 웹 서버가 보내준 공개키를 통해서 자신이 보낼 데이터를 암호화하고, 웹 서버는 자신의 비밀키를 통해 데이터를 복호화한다. 이후 cpu리소스 소모가 적은 대칭키 방식으로 데이터를 주고 받는다. 위의 통신 과정은 비대칭키 방식(공개키, 비밀키)을 사용한다. 이는 복잡한 수학적 원리로 이루어져 CPU 리소스 부담이 크다.대칭키는 탈취당하면 모든 통신이 유출위험에 놓여있다. 때문에 웹 서버인증 과정에서 상대적으로 안전한 비대칭키 방식을 통해 얻은 서버의 공개키를 통해 대칭키 자체를 암호화해서 서버에 보내는 것이다.참고이것은 와이어샤크로 HTTP 패킷와 HTTPs패킷을 확인해본 사진이라고 한다.위는 HTTPs, 밑은 HTTP메시지이다.HTTPs는 암호화 되어있고, HTTP 패킷은 평문으로 보이는걸 확인할 수 있다.Reference HTTP완벽가이드 서적 https://brunch.co.kr/@sangjinkang/37 인증 과정 https://brunch.co.kr/@sangjinkang/38 SSL 핸드셰이크 https://ko.wikipedia.org/wiki/HTTPS 위키백과 https://yunzema.tistory.com/358 패킷 까보기" }, { "title": "real-world프로젝트 이슈 - vuex state undefined", "url": "/posts/20221117issue/", "categories": "Toy, real-world-spring", "tags": "Spring", "date": "2022-11-18 01:02:00 +0900", "snippet": " real-world project 구현 과정 카테고리 보기개요vuex를 적용하는데 state를 읽을 수 없다고 한다.//기존에는import { useStore } from &quot;vuex&quot;;const store = useStore();console.log(store.state);store.commit(&#39;REGISTER&#39;,user)이런식으로 리팩터링하고 있었는데, store.state를 읽을 수 없다는 것.생각한건 2가지다. typescript만의 vuex 선언 방법이 있나? -&amp;gt; 없는것 같다. vuex를 잘못 넣어줬나??Stack OverFlow에서는 app구동시 globalSetting을 해줘라..뭐 등의 방법이 있었지만 좀 더 찾다보니 나와 똑같은 사람을 발견했다.https://stackoverflow.com/questions/67056563/vuex-cannot-read-property-state-of-undefined여기를 보면import { createApp } from &#39;vue&#39;import App from &#39;./App.vue&#39;import router from &#39;./router.js&#39;import {store} from &#39;./store.js&#39;const app = createApp(App)app.use(router, store)app.mount(&#39;#app&#39;)이런식으로 앱을 구동하고 있는데, 나의 의도는 router와 store를 한 번에 등록함에 있었다.. 하지만, app.use()의 2번째 인자는 옵션의 의미다. 원본은 app.use(plugin, itsOptions)라고 되어있으며 나는 옵션에다가 store이라는 plugin을 넣어서 안되었던 것이다. 이를 수정하여import { createApp } from &#39;vue&#39;import App from &#39;./App.vue&#39;import router from &#39;./router.js&#39;import {store} from &#39;./store.js&#39;const app = createApp(App)app.use(router).use(store)app.mount(&#39;#app&#39;)로 고치면 해결된다.또 하나의 문제는 저건 그냥 Action을 타기 전에 호출한 console.log()이고, 실제 Action을 타지 않아서 수정해줘야했다.보아하니, Action은 dispatch를 호출하여 작동시키므로import { useStore } from &quot;vuex&quot;;const store = useStore();console.log(store.state);//store.commit(&#39;REGISTER&#39;,user)store.dispatch(&#39;REGISTER&#39;,user로 바꾸면 된다. 현재 이 프로젝트는 vue.js + Spring boot, Spring Data JPA 를 이용한 풀스택개발, 컨트리뷰션에 목표를 두고 있습니다. https://github.com/kkminseok/real-world-springboot" }, { "title": "DNS(Domain Name System) 정리", "url": "/posts/1115TIL01/", "categories": "Interview", "tags": "interview", "date": "2022-11-15 01:02:00 +0900", "snippet": " 오타, 지적 환영입니다. ✏️CS스터디 저장소DNS(Domain Name System)0. 알아둬야하는 이유 네트워크 프로토콜은 크게 2가지로 나눔. 실제로 데이터를 실어나르는 데이터 프로토콜과 데이터 프로토콜이 잘 동작하도록 도와주는 컨트롤 프로토콜 컨트롤 프로토콜은 통신에 직접 관여하지는 않지만 처음 통신 관계를 맺거나 유지하는데 큰 도움을 줌.(ex: ARP,ICMP,DNS)DNS는 도메인주소를 IP로 변환하는 역할을 수행한다.192.168.10.12같은 ip보다는 www.naver.com 등의 도메인 주소를 이용하는 것이 일반 사용자들에게 더 익숙하고 서버 IP 변경에 유연하게 대처가 가능하기 때문이다.또한, MSA기반의 서비스 설계가 많아지면서 다수의 API를 이용하다보니 서비스 간 API 호출이나 인터페이스가 많아져 DNS의 중요도는 더욱 높아짐.1. DNS 소개http://202.179.177.21와 같은 IP주소로도 사이트에 접속이 가능하고, http://www.naver.com과 같이 도메인 주소를 통해 사이트에 접속이 가능하다.네트워크 통신에서는 202.179.177.21와 같은 IP주소를 이용하게 된다. 하지만 사용자는 이를 외우기도 힘들고, 사이트마다 이 IP주소를 외우는것은 사용자에게 좋은 경험을 선사해줄 수 없기에 의미 있는 문자열로 구성된 도메인 주소가 나오게 되었다.도메인 주소를 사용할 경우 서비스 중인 IP가 변경되어도 도메인 주소 그대로 유지해 접속 방법 변경 없이 서비스할 수 있다는 장점도 있다.만약 DNS주소를 직접 입력하였다면 해당 DNS로 도메인에 대한 IP 질의를 보내고 그 결과값으로 요청한 도메인의 서비스 IP주소를 받게 된다.[1] www.naver.comclient ------------------&amp;gt; DNS Server[2] 202.179.177.21client &amp;lt;----------------- DNS Server [3] 202.179.177.21client ----------------------&amp;gt; naver.com (202.179.177.21 Server) &amp;lt;---------------------- Web Page 내부 시스템의 서비스 간 연결에도 DNS가 쓰인다고 한다. 어느 한 서비스의 IP가 변경이 필요한 경우, 여러 가지 설정을 변경하거나 프로그램을 재배포 해야하는데, 도메인 주소를 사용하면 DNS서버에서 간단한 설정 변경으로 해결이 가능하다고 한다. 그렇기에 인터넷 연결을 위한 DNS와 내부 서비스를 위한 DNS를 분리하여 운영한다고 한다.2. DNS 구조와 명명 규칙 도메인은 계층 구조로 이루어져서 원하는 인터넷 주소를 효율적으로 찾아갈 수 있다. 역트리 구조로 최상위 루트부터 TOP-Level, Second-Level, Third-Level 순으로 찾아간다. 계층간의 구조를 &quot;.&quot;으로 표시하고 뒤에서 앞으로 해석한다. 맨 뒤의 .(Root)는 생략된다. 알파벳, 숫자, ‘-‘만 사용이 가능하고, 대소문자 구분은 없다.[Third-Level] [Second-Level] [Top-Level] [Root] www . naver . com .(생략)2.1 루트 도메인 DNS 서버는 사용자가 쿼리한 도메인에 대한 값을 직접 가지고 있거나 캐시에 저장된 정보를 사용하여 응답한다. 만약 DNS 서버에 해당 도메인의 정보가 없다면 루트 도메인을 관리하는 루트DNS에 쿼리하게 된다. 루트 DNS는 전세계에 13개가 있고 DNS 서버를 설치하면 루트 DNS의 IP주소를 기록한 힌트 파일을 가지고 있어 루트 DNS관련 별도 설정은 필요 없다.2.2 Top-Level Domain(TLD)IANA에서 구분한 6가지 유형으로 구분이 가능하다. Generic(gTLD): 특별한 제한없이 일반적으로 사용되는 최상위 도메인com: 일반 기업체edu: 4년제 이상 교육기관gov: 미국 연방정부기관int: 국제기구, 기관mil: 미국 연방군사기관net: 네트워크 관련기관org: 비영리기관... Country Code TLD(ccTLD): 국가 최상위 도메인 보통 ISO 3166표준에 의해 규정되어 씀. 우리나라는 kr 보통 이를 사용하면 Second Level TLD에서 사이트 용도에 따른 코드를 사용한다. 예를들면 일반회사는 co.kr, 정부기관은 go.kr 나라마다 다르다. Sponsored(sTLD): 특정 목적을 위한 스폰서를 두고 있는 최상위 도메인 ex) .aero, .asia … Infrastructure: 운용상 중요한 인프라 식별자 공간을 지원하기 위해 전용으로 사용되는 최상위 도메인 ex) .arpa Generic-Restricted(grTLD): 특정 기준을 충족하는 사람이나 단체가 사용할 수 있는 최상위 도메인 ex) .biz, .name … Test(tTLD): 개발 프로세스 테스트용 최상위 도메인 ex) .test 3. DNS 동작방식도메인을 IP 주소로 변환하려면 DNS 서버에 질의해야하지만, 로컬에서 도메인과 IP 주소를 관리하는 hosts파일을 통해 사용할 수도 있다.이 파일에 등록해두면 해당 도메인 리스트는 DNS 캐시에 저장된다.도메인을 쿼리하면 DNS 캐시에 먼저 들려서 없으면 DNS 서버로 쿼리를 수행하고 그 결과를 다시 캐시에 저장한다.ipconfig /displaydns # 를통해 DNS 캐시를 볼 수 있다.전 세계의 도메인 정보를 DNS 서버 하나에 저장할 수 없기에, DNS는 분산된 데이터베이스로 서로 도와주도록 설계가 되어있다.자신이 가진 도메인 정보가 아니면 다른 DNS에 질의해 결과를 받는 형식이다.예를 들어서 kmsdns.net이라는 도메인을 클라이언트가 DNS 서버에 쿼리를 보냈다고 한다. 도메인 주소의 IP가 로컬 캐시에 저장되어있는지 확인. 저장되어 있지 않으면 사용자 호스트에 정의된 DNS에 해당 도메인에 대한 쿼리를 진행. DNS 서버는 kmsdns.net가 로컬 캐시와 자체에 설정되어 있는지 확인하고 없으면 루트 도메인서버에 ‘.net’에 대한 정보를 가진 도메인 주소를 쿼리. 루트 DNS는 ‘.net’을 관리하는 네임 서버 정보를 DNS서버에 응답. DNS 서버는 응답받은 정보를 가지고 kmsdns.net에 대해 쿼리를 보냄. kmsdns.net에 대한 정보를 가진 네임 서버 정보(가칭 kms)를 DNS 서버에 응답. DNS 서버는 kms 네임 서버에 kmsdns.net에 대한 정보를 쿼리. kms 네임 서버는 해당 도메인에 대한 정보를 DNS 서버에 응답. DNS 서버는 응답받은 정보를 로컬 캐시에 저장하고 사용자 호스트에 kmsdns.net에 대한 정보를 응답. 사용자 호스트는 DNS로부터 받은 도메인에 대한 IP주소를 가지고 사이트에 접속하게 됨.4. 마스터와 슬레이브 DNS 서버는 마스터(Master, Primary) 서버와 슬레이브(Slave, Secondary) 서버로 나눌 수 있다. 마스터 서버라서 우선순위가 더 높은게 아니라 도메인에 대한 존(Zone) 파일을 직접 관리하는지 여부에 따라 나뉜다. 마스터 서버는 존 파일을 직접 생성해 도메인 관련 정보를 관리한다. 슬레이브 서버는 마스터에 만들어진 존 파일을 복제한다. 이 과정을 영역 전송(Zone Transfer) 라고 한다. 즉, 마스터 서버는 도메인 영역을 생성하고 레코드를 직접 관리하지만 슬레이브 서버는 마스터 서버에 설정된 도메인 영역과 레코드를 정기적으로 복제한다. 출처: https://computingforgeeks.com/configure-slave-bind-dns-server-on-ubuntu/따라서 슬레이브 서버를 만들때에는 도메인을 복제해올 마스터 서버 정보를 입력해야 한다.반대로 마스터 서버는 인가받지 않은 다른 DNS서버가 복제해가지 못하도록 슬레이브 서버를 지정해 복제를 제한할 수 있다. 무분별한 복제를 막기위해 설정해두는것을 추천한다고 한다.DNS 서버는 마스터 서버에 문제가 발생하면 슬레이브 서버도 마스터서버에 대한 복제정보를 받아오지 못한다. 이를 만료 시간(Expiry Time)이라고 하고 SOA레코드에 설정된다.만료 시간 안에 슬레이브 서버가 마스터 서버로부터 정보를 받아오지 못하면 슬레이브의 존 정보는 사용할 수 없게 된다.따라서 만료 시간 안에 마스터 서버를 복구하거나 슬레이브 서버를 마스터로 전환해야 서비스 장애를 막을 수 있다.5. DNS 주요 레코드도메인에는 다양한 내용을 매핑할 수 있는 레코드들이 있다.레코드란 도메인 서버를 직접 관리할시 사용자 요청에 대한 응답을 지정해줘야하는데 이 응답의 형식들을 말한다.A(IPv4 Host): 도메인 주소를 IP(IPv4)로 매핑AAAA(IPv6 Host): 도메인 주소를 IP(IPv6)로 매핑CNAME(별칭): 도메인 주소에 대한 별칭SOA(권한 시작): 본 영역 데이터에 대한 권한NS(도메인의 네임서버): 본 영역에 대한 네임 서버MX(메일 교환기): 도메인에 대한 메일 서버 정보(Mail eXchanger)PTR(포인터): IP 주소를 도메인에 매핑(역방향)TXT(레코드): 도메인에 대한 일반 텍스트 A(IPv4): 기본 레코드, 하나의 A 레코드는 한 개의 도메인 주소와 한 개의 IP가 1:1로 매핑. 하나의 도메인이 여러 IP 주소와 매핑 가능. 반대도 가능 출처: https://support.wix.com/ko/article/%EA%B8%B0%EB%B3%B8-a-%EB%B0%8F-cname-%EB%A0%88%EC%BD%94%EB%93%9C-%EC%9E%AC%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0 AAAA(IPv6): A레코드와 역할은 같음. IPv6 주소체계에 사용. CNAME(Canonical Name): 레코드 값에 IP주소를 매핑하는 A 레코드와 달리 도메인 주소를 매핑. 네임서버가 CNAME레코드에 대한 질의를 받으면 CNAME 레코드에 설정된 도메인 정보를 확인하고 그 도메인 정보를 내부적으로 질의한 결과 IP를 응답한다. 대표적으로 www가 있다. 예시로 kmsjava.net라는 웹사이트에 접속하려면 ‘kmsjava.net’이나 ‘www.kmsjava.net’을 입력할텐데 각각 A레코드로 입력하면 IP주소가 변경될 때 두 레코드 모두 변경해줘야하지만, ‘kmsjava.net’을 A 레코드로 ‘www.kmsjava.net’은 CNAME으로서 ‘kmsjava.net’을 매핑하면 IP 주소가 변경될 때에도 ‘kmsjava.net’ A레코드만 변경해주면 된다는 이점이 있다.[A레코드 각각 사용시]------------IP 변경전--------------------레코드 값kms.java.net 10.10.10.10wwww.java.net 10.10.10.10------------IP 변경후--------------------레코드 값kms.java.net 20.20.20.20wwww.java.net 20.20.20.20---------------------------------------------------------------------[CNAME과 A레코드 사용시]------------IP 변경전--------------------레코드 값kms.java.net 10.10.10.10wwww.java.net(CNAME) kms.java.net------------IP 변경후--------------------레코드 값kms.java.net 20.20.20.20wwww.java.net(CNAME) kms.java.net SOA(Start Of Authority): 도메인 영역에 대한 권한을 나타내는 레코드. 현재 네임 서버가 이 도메인 영역에 대한 관리 주제임을 의미 하므로 다른 네임 서버에 질의하지 않고 직접 응답한다. 도메인 영역 선언 시 SOA 레코드는 필수 항목이여서 반드시 만들어야한다. 또한 현재 도메인 관리에 필요한 속성값을 설정. 도메인 동기화에 필요한 타이머 값, TTL 값, 관리자 정보도 SOA 레코드에서 설정. NS(Name Sever): 도메인에 대한 권한이 있는 네임 서버 정보를 설정하는 레코드. MX(Mail eXchange): 메일 서버 구성시 사용되는 레코드. 네이버의 MX 레코드네이버는 우선순위 10을 가지는 메일서버가 3개가 있음. 참고로 적을수록 우선순위가 높다.이 경우 랜덤으로 메일서버로 요청을 보낸다. PTR(Pointer): A 레코드는 도메인 주소에 대한 질의를 IP로 응답받기 위한 레코드라면 PTR은 그 반대이다. IP 주소에 대한 질의로 도메인 주소로 응답하기 위한 레코드이다. A 레코드는 정방향 조회, PTR 레코드는 역방향 조회이다. A레코드와 달리 당연하겠지만 하나의 IP 주소에 대해 하나의 도메인 주소만 가질 수 있다. 보통 화이트 도메인구성용으로 사용된다. TXT(TexT): 도메인에 대한 설명과 같이 텍스트를 입력할 수 있는 레코드. 공백 포함도 가능하고 대소문자 구분, 최대 255자 입력가능. 6. 화이트 도메인 정상적인 도메인을 인증, 관리하는 제도가 화이트 도메인 현재 보유하고 있는 도메인을 화이트 도메인으로 등록하려면 KISA RBL 사이트에서 등록하면 된다. SPF레코드를 미리 설정해야한다. SPF레코드를 통해 사전에 메일 서버 정보를 공개하면 수신 측 메일서버에서 해당 도메인을 통해 발송된 메일이 실제 메일서버에 등록된 정보와 일치하는지 확인. 일치하지 않을 경우 비정상적인 이메일 서버에서 정송된 것으로 간주해 해당 이메일을 수신하지 않고 스팸처리 SPF레코드를 작성하기 위해서는 TXT레코드를 사용해야함. 출처: https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&amp;amp;blogId=hilineisp&amp;amp;logNo=220107284167요약하자면 위 IP로 들어온 메일을 제외하면 모두 폐기하라는 뜻.7. TTL(Time To Live) DNS에 질의해 응답받은 결과를 캐시에서 유지하는 시간을 의미한다. DNS 서버에서 TTL 값을 늘리면 캐시된 정보가 많아서 응답 시간이 단축되지만, 해당 도메인 정보가 변경되었을때, 정보 갱신이 자주 일어나 그만큼 지연되는 단점이 있다. 그렇기에 적절히 조절하는것이 필요하다." }, { "title": "Programmers_옹알이(1)(python)", "url": "/posts/Programmers_ORE1/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2022-10-28 01:00:00 +0900", "snippet": " 이 글을 보시기 전에 문제를 풀기 위해 충분한 생각을 하셨나요? 답을 안 보고 푸는게 최대한 고민하는게 가장 중요하다고 생각합니다.!!프로그래머스 옹알이(1) 문제 입니다.1.☑️ 문제https://school.programmers.co.kr/learn/courses/30/lessons/120956?language=python32.☑️ 분류 및 난이도Programmers 문제입니다.Level 1난이도의 문제입니다.3.☑️ 생각한 것들(문제 접근 방법) 은근 까다롭지만 브루트하게 풀면 풀 수 있습니다.4.☑️ 접근 방법을 적용한 코드def solution(babblings): answer = 0 for babbling in babblings: idx = 0 size = len(babbling) while idx &amp;lt; size: if babbling[idx] == &#39;a&#39; and idx + 2 &amp;lt; size and babbling[idx:idx+3] == &#39;aya&#39;: idx +=3 elif babbling[idx] == &#39;y&#39; and idx + 1 &amp;lt; size and babbling[idx:idx+2] == &#39;ye&#39;: idx +=2 elif babbling[idx] == &#39;w&#39; and idx + 2 &amp;lt; size and babbling[idx:idx+3] == &#39;woo&#39;: idx +=3 elif babbling[idx] == &#39;m&#39; and idx + 1 &amp;lt; size and babbling[idx:idx+2] == &#39;ma&#39;: idx +=2 else: break if idx == size: answer += 1 return answer브루트하게 조건을 모두 적어줘서 풀었습니다.5.☑️ 결과 c++로 작성이 필요하거나 도움이 필요하시면 댓글을 작성해주세요.!! 기록용이라 설명이 자세하지 않습니다." }, { "title": "Programmers_햄버거 만들기(python)", "url": "/posts/Programmers_Hambuger/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2022-10-28 01:00:00 +0900", "snippet": " 이 글을 보시기 전에 문제를 풀기 위해 충분한 생각을 하셨나요? 답을 안 보고 푸는게 최대한 고민하는게 가장 중요하다고 생각합니다.!!프로그래머스 햄버거 만들기 문제 입니다.1.☑️ 문제https://school.programmers.co.kr/learn/courses/30/lessons/133502?language=python32.☑️ 분류 및 난이도Programmers 문제입니다.Level 1난이도의 문제입니다.3.☑️ 생각한 것들(문제 접근 방법) 나오는 순서가 일정해야하고 그 순서가 문제에서 주어진 조건과 동일하다면 없애야합니다 -&amp;gt; 스택 생각.4.☑️ 접근 방법을 적용한 코드from collections import dequedef solution(ingredients): answer = 0 stack = deque() for ingredient in ingredients: stack.append(ingredient) if ingredient == 1 and len(stack) &amp;gt; 3 and stack[-2] == 3 and stack[-3] == 2 and stack[-4] == 1: for i in range(4): stack.pop() answer+=1 return answer구간을 탐색하고 맞다면 pop 해주고 아니면 넘어갑니다.5.☑️ 결과 c++로 작성이 필요하거나 도움이 필요하시면 댓글을 작성해주세요.!! 기록용이라 설명이 자세하지 않습니다." }, { "title": "시스템 디자인 설계 인터뷰 준비", "url": "/posts/TIL2022-1018/", "categories": "Interview", "tags": "", "date": "2022-10-18 01:02:00 +0900", "snippet": " 오타, 지적 환영입니다.B사에서 면접을 볼 때 시스템 설계 인터뷰를 본다.주변 인사이트를 통해 조언을 구해보니, 준비한 것과 준비 안 한것의 차이가 큰 편이고 유튜브에도 공부하는 방법같은게 나와있으니 검색하고 공부하라했다.https://www.youtube.com/watch?v=NtMvNh0WFVM 유튜브 주소1. 요구사항 질문하기.보통 처음에는 모호하게 알려주는 경우가 많다고 한다. 예를 들어 “주차장 시스템을 만들어보세요.” 와 같은 것이다.요구사항을 명확히 할 필요가 있다. 그렇기에 요구사항에 대해 질문하고 내가 이해한것이 맞는지 확인해야한다.2. 화이트보드같은곳에 요구사항을 적기. 주차장 시스템을 만들기 위해서는 주차공간과 사용자가 이를 예약했을때 티켓같은 어떤것을 받아야한다. 주차공간에 대해 사용자는 지불해야한다. 같은 공간에 2명의 사람이 예약할 수 없다. 주차공간의 크기가 다를 수 있다 -&amp;gt; 질문 필요 -&amp;gt; 주창공간에 따른 페이가 다른가?3. API 명세엔드포인트를 정의하고 어떠한 기능을 하는지 설계하자.// Public/reserveParams : garage_idstart_time, end_timeReturn : (spot_id, reservation_id)//Internal/calculate_paymentParams: reservation_id와 같은것을 말한다.해당 영상에서는 Public EndPoint 와 Internal Endpoint로 나누었다.Public EndPoint는 기업 외부에서 보안적으로 안전한 연결 및 컨텐츠를 공유를 가능하게 하여 고객에게 경험을 선사해주는 EndPoint이고Internal EndPoint는 팀 간에 데이터를 공유하고 기존의 데이터 사일로를 해제하여 구성한 Endpoint이다.4. 데이터타입을 정하기 + 테이블 만들기// Table : ReservationsID : primary Key, serialgarage_id : foregin_key, intspot_id : foregin_key, intstart : timestampend : tiemstamppaid : boolean처럼 말이다.로드밸런싱을 위한 테이블을 설계를 한 것도 기억을 해두면 좋을것 같다.5. 디자인 하기읽기 전용 데이터베이스를 놓았다.!!그리고 사용자 거주지 기준으로 로드 밸런서를 놓았다.6. Trade-off절충안에 대해서 설명한다.영상에서는 위의 디자인에 대한 절충안을 물어보았다.자신이 생각하는것을 논리정연하게 말해야한다." }, { "title": "real-world프로젝트 Spring 시작하기(6) - Jwt Filter 만들기 전 JWT,쿠키,세션 설명", "url": "/posts/realworld06/", "categories": "Toy, real-world-spring", "tags": "Spring", "date": "2022-10-17 21:02:00 +0900", "snippet": " real-world project 구현 과정 카테고리 보기개요회원가입 하나 만들기 위해서 해야될 게 참 많다.사용자가 비밀번호를 입력해서 로그인을 한다고 치자.HTTP 프로토콜은 stateless의 특성을 가지고 있어서 서버와의 통신이 끝나면 연결이 끊어져버린다.HTTP1.1 프로토콜은 keep-alive를 통해서 어느정도 요청시간을 유지할 수 있지만 무한정 연결을 걸어놓고 있을수도 없는것이다.그래서 클라이언트나 서버에 사용자에 대한 인증 정보를 담아놓는데, 이는 쿠키와 세션으로 가능하다이 프로젝트에서는 당연하게도 Jwt토큰을 쓰라길래 썼지만 왜 쓰는지는 알아둬야 하는것이다.쿠키와 세션이 있는데 jwt를 쓰는 이유는 당연히 저 둘과 다른 차별점과 얻는 이점이 있기 때문이다. 그 전에 쿠키와 세션에 대해 간단히 복기겸 정리를 해보았다.쿠키쿠키란 HashMap처럼 키-값을 가지는 정보이다.키 값test_cookie = 1234쿠키를 확인하는 방법은 간단하다. 브라우저에서 개발자도구를 켜서 상단 메뉴탭에 Application -&amp;gt; Storage -&amp;gt; Cookies에 들어가면 된다.이를 통해서 사용자 인증을 할 수가 있다.로그인을 성공하면, 클라이언트에 응답을 줄 때 서버에서는 고유한 쿠키를 만들고 헤더에 포함시킨다.그 이후 클라이언트는 이 쿠키값을 브라우저에 저장하고 요청때 request에 포함시켜 서버에서는 이를 통해 클라이언트를 식별한다.이러한 방식은 쿠키의 값을 암호화하지 않고 보낼 수도 있기에 보안에 취약하고, 브라우저에 저장하기에 네트워크 부하도 있다. 그리고 브라우저간 쿠키에 대한 지원 형태가 달라서 브라우저간 공유가 안되게 된다.세션위 그림을 보는게 편하다. 순서대로 사용자가 로그인을 시도하면 서버에서 요청을 받고 DB에서 비교 (비밀번호를 확인한다던지) 사용자 식별이 되었으면 세션저장소에서 회원정보가 포함된 SessionID를 발급. 클라이언트에 SessionID를 발급하면서 로그인 성공을 알림. 클라이언트는 SessionID를 쿠키에 저장하고, 매 요청(request)마다 해당 쿠키를 헤더에 포함해서 요청을 보냄. 서버에서는 요청을 받고 쿠키값을 뜯어봐서 있는 SessionID를 검증. 즉, 서버에는 세션을 관리하는 세션저장소가 있어야함. 검증이 성공하면 클라이언트에 응답을 보내줌.쿠키와 마찬가지로 세션의 단점은 세션을 관리해야하는 저장소가 필요한 것이다. 사용자 수가 많으면 많을수록 부하가 심해질것은 당연하고, 해커가 중간에 가로챌 수도 있다.jwt토큰 기반 인증 방식이라고 불리는 jwt는 다르다. 일단 서버에 이를 관리하는 저장소가 필요없다. 일반 jwt단점을 보완시킨 refreshToken을 쓴다면 서버에 저장소가 필요하긴 하다.일단 jwt는 JWT header, JWT payload, signature라는 세개가 포함된다.xxxxx.yyyyy.zzzzz x는 header, y는 payload, z는 signature라고 생각만하자. 왜냐하면 저 값들은 나중에 인코딩 되기 때문에 형식을 지금 딱 정할 수는 없는 값이기 때문이다. header토큰 타입과 사용되는 알고리즘에 대한 정보를 담는다.{ &quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot;} payloadclaims이라는 것을 포함하는데, Claims이란 user같은 객체와 추가적인 데이터를 포함한 키-값 데이터라고 할 수 있다.이렇게 하면 뭔 소린지 모를것이다.Claims에는 3종류가 있다. Registered Claim, Public Claim, Private Claim.Registered Claim은 **토큰 정보를 표현하기 위한 이미 정해진 종류의 데이터다. iss: 토큰 발급자(issuer) sub: 토큰 제목(subject) aud: 토큰 대상자(audience) exp: 토큰 만료 시간(expiration), NumericDate 형식으로 되어 있어야 함 ex) 1480849147370 nbf: 토큰 활성 날짜(not before), 이 날이 지나기 전의 토큰은 활성화되지 않음 iat: 토큰 발급 시간(issued at), 토큰 발급 이후의 경과 시간을 알 수 있음 jti: JWT 토큰 식별자(JWT ID), 중복 방지를 위해 사용하며, 일회용 토큰(Access Token) 등에 사용내가 써본것은 iss, sub, exp 정도이다.그리고 이것들의 공통점은 3글자라는 것이다.Public Claim은 사용자가 정의한 Claim의 종류로 충돌 방지를 위한 URL형식을 사용하라고 한다.{ &quot;kkminseok.github.io&quot; : true}Prviate Claim은 사용자 정의 Claim이지만 서버와 클라이언트 사이에 임의로 지정한 정보를 저장한다.{ &quot;token_type&quot;: access }이러면{ &quot;sub&quot;: &quot;1234567890&quot;, &quot;name&quot;: &quot;John Doe&quot;, &quot;admin&quot;: true}이렇게 생긴건 어느정도 구분이 될 것이다. Signature(서명)이건 앞에서 설명한 header와 payload를 BASE64URL로 인코딩 한 뒤, 이를 사용자가 정의한 비밀 키를 이용하여 헤더에 정의한 알고리즘으로 해싱하고 사용자가 설정한 암호화 방식으로 암호화해버린다.만약 HMAC SHA256 방식으로 암호화할 것이라면 Signature는 다음과 같이 생성될 것이다.HMACSHA256( base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret)이를 통해 실제 토큰을 만들면‘eyJhbGciOiJIUzM4NCJ9.eyJlbWFpbCI6InRlc3RAbmF2ZXIuY29tIiwiaWF0IjoxNjY1OTMwOTgxLCJleHAiOjE2Njg5MzA5ODF9.CnTX7jJ0gG9R7AhJ14YRSYN9k8jBqn8V9rtVJDAsQRQj0hOCgicuG3qBGI3Ovfha’이런 값이 랜덤으로 탄생할 것이다.Header부분과 Payload부분은 단순히 인코딩된 값이기에 3자가 복호화 및 조작이 가능하지만, Signature 부분은 비밀 키만 누출되지 않는다면 복호화가 불가능하다는 특징을 가지고 있다.그래서 Payload 부분에는 유저에대한 중요한 정보를 넣지 않는게 중요하다.https://jwt.io/#debugger-io에 들어가서 위에 적힌 토큰을 그대로 넣어 디코드 해보면…이렇게 email이라는 고객정보가 떠있다.이렇게 생성된 token을 이용하여Authorization : Bearer &amp;lt;token&amp;gt;와 같은 형식을 헤더에 포함해서 로그인 성공할때 등 토큰을 서버에서 클라이언트로 보낸다.클라이언트에서는 이 토큰을 쿠키에 저장하던지, 로컬 스토리지에 저장하던지 저장하고 가지고 다녀서 서버에 요청할 때 Authorization 헤더를 통해 보낸다. 서버는 이 토큰을 복호화하여 유효기간, 사용자 정보를 매칭하고 매칭되었다면 요청에 응답한다.이러한 토큰을 통해서 서버에 인증관련 저장소가 필요가 없어졌고, Signature를 통해 데이터 위변조를 막을 수 있게 되었다.하지만 이러한 토큰도 결국 탈취되어버리면 대처가 어려워진다.보통 토큰의 유효기간을 짧게는 가져가지 않기에 해커가 활동할만한 시간을 주어준다.심지어 이 토큰은 폐기가 불가능하다.이러한 단점을 제거하기 위해 Refresh Token이 생겨났다.이 프로젝트에서는 Refresh Token을 사용하지 않기에 자세한 설명을 적지는 않겠다.Refresh Token는 기존 Token의 유효시간을 짧게 가져가고 유효시간이 길고 서버에서 관리하는 Refresh Token을 둔다.문제는 이 Refresh Token도 탈취 당할 수 있다는 것이다.이는 RTR 기법이 사용된다고 한다.Refresh Token을 한 번 쓰면 다음 refresh Token을 발급하여 탈취되어 다시 한 번사용되면 탈취된 것으로 간주하고 탈취된 것으로 간주된 모든 Refresh Token을 폐기한다.이를 감지하기 위해선 Token Chain으로 연결하고 관리한다고 한다.결론해당 프로젝트에서는 JWT Token을 이용하여 사용자를 인증, 인가를 하므로 더 깊이까지는 정리하지 않았다.하지만 refreshToken에 대해서는 알아두는 게 좋다.Reference https://jwt.io/introduction jwt.io라는 공식사이트? https://mangkyu.tistory.com/m/56 jwt Registered Claim 종류 https://developer-ping9.tistory.com/m/239 RefreshToken 탈취되었을 때 현재 이 프로젝트는 vue.js + vite + vuex + Spring boot, Spring Data JPA + Spring Security 를 이용하여 real-world 데모버전을 제작완료하였습니다. https://github.com/kkminseok/real-world-springboot" }, { "title": "real-world프로젝트 Spring 시작하기(5) - 회원가입 만들기 전 설정 Web설정파일 만들기", "url": "/posts/realworld05/", "categories": "Toy, real-world-spring", "tags": "Spring", "date": "2022-10-12 00:02:00 +0900", "snippet": " real-world project 구현 과정 카테고리 보기코드package com.io.realworld.security;import com.io.realworld.security.jwt.JwtAuthenticationFilter;import lombok.RequiredArgsConstructor;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.http.HttpStatus;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityCustomizer;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.security.web.SecurityFilterChain;import org.springframework.security.web.authentication.HttpStatusEntryPoint;import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;@Configuration@RequiredArgsConstructor@EnableWebSecuritypublic class WebConfig { private final JwtAuthenticationFilter jwtAuthenticationFilter; @Bean public PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); } @Bean public WebSecurityCustomizer configure() throws Exception{ return (web) -&amp;gt; web.ignoring().antMatchers(&quot;/h2-console/**&quot;); } @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http.csrf() .disable() .authorizeRequests() .antMatchers(&quot;/api/users/**&quot;).permitAll() .anyRequest().authenticated() .and() .formLogin() .disable() .exceptionHandling().authenticationEntryPoint(new HttpStatusEntryPoint(HttpStatus.UNAUTHORIZED)) .and() .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class); return http.build(); }}이 코드를 분석해볼 것이다.@EnableWebSecurity@EnableWebSecurity와 @Configuration을 통해서 Spring Security 설정할 클래스라고 정의를 한다.보통 WebSebSecurityConfigurerAdapter을 상속받아서 구현하는데, 현재 필자 버전에서는 WebSebSecurityConfigurerAdapter가 Deprecate되어버려서 직접 필요한것들은 빈으로 생성해야한다.원래는 여러 configure()함수를 오버라이딩 해주면서 설정을 해줘야했지만 그런것들이 사라졌다.참고로 Spring boot를 사용하면 해당 어노테이션은 자동으로 세팅되므로 따로 적어주지 않아도 된다길래 나도 지웠다.@RequiredArgsConstructor롬복 어노테이션으로 초기화되지 않은 final필드나 @NonNull이 붙은 필드에 대해 생성자를 생성해준다. 이를 통해 JWT관련 필터 클래스를 초기화해준다.BCryptPasswordEncoderBCrypt라는 해시 알고리즘을 통해 암호화인코더를 구현한 클래스다.BCrypy는 반복된 brute-force에도 잘 대응하고 가장 강력한 해시 메커니즘 중 하나라고 한다.회원가입할 때 패스워드를 암호화해줘야하므로 이것을 Bean으로 등록해준다.configure()함수@Beanpublic WebSecurityCustomizer configure() throws Exception{ return (web) -&amp;gt; web.ignoring().antMatchers(&quot;/h2-console/**&quot;);}WebSecurityCustomizer는 @FunctionalInterface어노테이션이 붙어 있어서 람다표현식을 사용하여 작성해야한다.WebSecurity 클래스를 커스터마이징하여 이를 반환해야한다.위의 문법을 통해 h2-console로 들어오는 모든 요청에 대해 인증 필터를 안 타게 해준다.이는 예전 WebSecurity 설정을 해주는것과 동일하다.filterChain()함수위가 예전 WebSecurity 설정을 하는거라면 이함수의 리턴타입은 HttpSecurity 설정을 하는것과 동일하다.@Beanpublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http.csrf() .disable() .authorizeRequests() .antMatchers(&quot;/api/users/**&quot;).permitAll() .anyRequest().authenticated() .and() .formLogin() .disable() .exceptionHandling().authenticationEntryPoint(new HttpStatusEntryPoint(HttpStatus.UNAUTHORIZED)) .and() .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class); return http.build();}코드를 보면 antMatchers()라는 함수가 똑같이 쓰인다. 그러면 여기서 반환하는 HttpSecurity와 WebSecurity의 차이점은 뭘까??HttpSecurity vs WebSecuritystackoverflow 글을 보면 WebSecurtiy로 설정하면 스프링 시큐리티가 제공하는 다른 기능들도 무시하면서 요청을 받을 수 있다.예를들면 스프링 시큐리티 컨텍스트를 사용하지 못한다.그리고 저 코드에서 /h2-console url을 기준으로해당 url로 요청으로 들어왔을때 XSS 어택, 스니핑, Cross-Site-Scripting과 같은 공격에 방어할 수 없다.그러면 HttpSecurity는 스프링 시큐리티가 제공하는 기능들을 쓸 수 있어서 위와 같은 공격에 대응이 가능하다. HttpSecurity로 설정한 것들은 인증에 대해서 무시하는것이고, 필터는 다 거치기에 필터를 거치는 비용이 있을 수 밖에 없다.그렇기에 WebSecurity에 등록하는 것들은 보통 이미지나, js파일과 같은 인증/인가 정보가 필요없는 것들을 등록하고 사용한다고 한다.문법설명함수들을 설명했으니 함수 안에 있는 것들이 어떤것을 나타내는지 알아볼 것이다.http.csrf() - 1 .disable() - 2 .authorizeRequests() - 3 .antMatchers(&quot;/api/users/**&quot;).permitAll() - 4 .anyRequest().authenticated() - 5 .and() -6 .formLogin() - 7 .disable() - 8 .exceptionHandling().authenticationEntryPoint(new HttpStatusEntryPoint(HttpStatus.UNAUTHORIZED)) - 9 .and() - 10 .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class); - 11 return http.build(); - 12 1, 2 : csrf().disable()란 csrf()란 것을 사용하지 않겠다는 것인데, CSRF라는 것에 대해 알고 있어야한다.CSRF란 세션과 쿠키의 특징을 이용한 공격방법인데, 사용자가 로그인이나 요청을 보냈을 경우 서버에서 sessionID를 주고 이를 사용자 쿠키에 저장하게 되는데, 공격자가 악성 스크립트를 누르도록 유도하여 사용자 브라우저에 저장 되어있는 sessionID를 이용하여 서버에 요청을 보내는 것이다.서버는 sessionID를 통해 정상 사용자로 판단하고 요청을 처리하게 된다.보통 stateless한 RestAPI에서는 쿠키나 세션을 사용하지 않고, 이 프로젝트도 JWT토큰을 사용하기에 csrf보호가 따로 필요없어서 disable처리를 했다.그렇다해서 이를 따로 명시해주지 않는다면 Spring Security는 자동으로 csrf보호를 하기 때문에 어떤 요청에서도 csrf토큰이 포함되지 않아서 401 Unauthorized 상태를 반환할 것이다.csrf를 직접 생성하여 해결하는 방법은 이 블로그를 참조하면 좋다. 3, 4 : authorizeRequests()는 HttpServletRequest에 따라 접근을 제한한다는 의미이다. 뒤에 있는 문법들이 제한하는것을 도와줄 것이다. antMatchers(url).permitAll()은 적힌 url에 들어오는 요청에 대해서는 아무 인가된 사용자가 아니여도 접근이 가능하게 지정한다. 참고로 url뿐만 아니라 Http Method도 적어줄 수 있고 혼용하여 사용할 수 있다. 5 : antMatchers().permitAll()는 어떤 요청에 대해서도 인증된 사용자만 접근허용하도록 한다는 제한을 건다. 혼자 궁금해서 antMatchers().permitAll()와 anyRequest().authenticated()의 순서를 바꿔서 써봤다. 우선순위가 antMatchers 먼저일까 anyRequest가 먼저일까 궁금해졌기 때문이다. 결과는 에러가 발생한다. 그리고 친절하게 알려준다. antMatchers는 anyRequest뒤에 나올 수 없단다. 6 : and()는 상위 메소드들을 연결하기 위해 필요한 연결점이라고 생각하면 된다. 7,8 : 사용자 정의 로그인 기능과 로그아웃 기능을 가진 상위 메소드라는데, loginPage(url)처럼 login페이지 경로를 알려줄 수도 있고 로그인에 실패했을때 페이지, 성공했을때 페이지를 따로 또 지정해줄 수 있다. 이 기능말고 다양한 기능을 수행한다. 또한 보안 검증을 form기반으로 할 것이라고 하는데, 이 프로젝트에서는 그러지 않으므로 disable처리를 해주었다. 9 : exceptionHandling()는 예외가 발생했을때 핸들링할 수 있게 도와준다. 이 놈은 ExceptionHandlingConfigurer를 받아야하고, 이를 만들기 위해서는 authenticationEntryPoint()함수를 사용한다. 이 함수의 구현을 보면public ExceptionHandlingConfigurer&amp;lt;H&amp;gt; authenticationEntryPoint(AuthenticationEntryPoint authenticationEntryPoint) { this.authenticationEntryPoint = authenticationEntryPoint; return this;}AuthenticationEntryPoint타입의 객체를 받는데, HttpStatusEntryPoint 클래스는 AuthenticationEntryPoint를 상속받아 구현되었기에 인자로 쓸 수 있다. 다행스럽게도 HttpStatusEntryPoint는 비교적 간단하게 구현되어있다.public final class HttpStatusEntryPoint implements AuthenticationEntryPoint { private final HttpStatus httpStatus; /** * Creates a new instance. * @param httpStatus the HttpStatus to set */ public HttpStatusEntryPoint(HttpStatus httpStatus) { Assert.notNull(httpStatus, &quot;httpStatus cannot be null&quot;); this.httpStatus = httpStatus; } ...}간단하게 httpStatus만 넘겨주면 알아서 인증에 실패했을때 인자로 넘긴 httpStatus에러를 발생시킨다는 것이다. 이는 메세지를 넘기도록 커스텀마이징도 가능하다. 하단에 있는 Reference를 참고하면 된다.아무튼 나는 HttpStatus.UNAUTHORIZED를 넘겨 401 UnAuthorized를 발생시키도록 설정해놨다. 11 : 말그대로 필터를 등록한다는 것이다.addFilterBefore(filter A, filter B.class): filter A 추가 (filter B보다 우선)그렇기에 향후 작성할 jwt관련 필터는 UsernamePasswordAuthenticationFilter라는 필터보다 먼저 실행될 것이다.그러면 또 새로운 UsernamePasswordAuthenticationFilter에 대해 간단히 알 필요가 있다.UsernamePasswordAuthenticationFilter코드 자체는 어렵지 않으나 내부동작이 어렵다. 간단히만 알아볼 것이다.이것은 jwt토큰만들때 + user정보 찾을때와 연동이 되어야하기에 대략적인 느낌만 적어둘것이다. 향후 위의 두 가지를 다룰때 상세히 적어보도록 하겠다.코드를 까보면public class UsernamePasswordAuthenticationFilter extends AbstractAuthenticationProcessingFilter { ... @Override public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException { if (this.postOnly &amp;amp;&amp;amp; !request.getMethod().equals(&quot;POST&quot;)) { throw new AuthenticationServiceException(&quot;Authentication method not supported: &quot; + request.getMethod()); } String username = obtainUsername(request); username = (username != null) ? username.trim() : &quot;&quot;; String password = obtainPassword(request); password = (password != null) ? password : &quot;&quot;; UsernamePasswordAuthenticationToken authRequest = UsernamePasswordAuthenticationToken.unauthenticated(username, password); // Allow subclasses to set the &quot;details&quot; property setDetails(request, authRequest); return this.getAuthenticationManager().authenticate(authRequest); }이렇게 되어있다. POST요청이 아닌경우에는 에러를 발생시킨다. 문제는 String username = obtainUsername(request);이 구문이다.protected String obtainUsername(HttpServletRequest request) { return request.getParameter(this.usernameParameter);}이렇게 이놈은 헤더에서 값을 찾는데, 어떻게 JSON으로 요청을 보내는데 받는다는 말인가?이는 나중에 작성할 jwt필터에서 이미 인증정보를 넣었기 때문이라고 말할 수 있다.jwt 필터에는 다음과 같은 코드가 있다.Authentication auth = jwtService.getAuthentication(jwt);SecurityContextHolder.getContext().setAuthentication(auth);Authentication이라는 객체를 만들어서 시큐리티 컨텍스트에 넣고있다. 기존 UsernamePasswordAuthenticationFilter에서는 UsernamePasswordAuthenticationToken()메소드를 호출하여 컨텍스트에 넣고 있는데, 내가 만든 jwtService.getAuthentication()을 보면...public Authentication getAuthentication(String jwtToken) { UserDetails userDetails = userServiceDetail.loadUserByUsername(getEmail(jwtToken)); User user = (User)userDetails; UserAuth authenticatedUser = UserAuth.builder() .username(user.getUsername()) .id(user.getId()).build(); return new UsernamePasswordAuthenticationToken(authenticatedUser,&quot;&quot;, userDetails.getAuthorities()); }유저객체로 토큰을 만들어서 리턴하고 jwt필터에서는 이를 시큐리티 컨텍스트에 넣고 있는것이다.실제로 jwt필터의 auth를 찍어보면2022-10-11 23:42:53.205 INFO 14560 --- [nio-8080-exec-2] c.i.r.s.jwt.JwtAuthenticationFilter : auth: UsernamePasswordAuthenticationToken [Principal=com.io.realworld.domain.aggregate.user.dto.UserAuth@216ee17a, Credentials=[PROTECTED], Authenticated=true, Details=null, Granted Authorities=[]]이렇게 출력되는것을 볼 수 있다.사실 이를 이해하려면 Spring-Security 내부동작에 대해 좀 더 학습해야하는 것 같다.결론Spring Web설정에 대해 이해하려고 했다.고작 구현은 30줄인 코드를 해석하는데 vscode 기준 300줄이 넘는 설명을 덧붙였다.그리고 글을 작성하는데 2일이 걸렸다.. 부족한 부분은 따로 회사 점심시간에 찾아보고 그래도 글이 많이 부족하다.그리고 Spring Security는 진짜 방대하다는것을 다른 문서들을 찾아보면서 느꼈다.내가 글을 좀 더 잘 썼다면 정리가 더 잘되고 깔끔한 글이 되었을텐데 아쉽다.Reference https://engineering-skcc.github.io/spring-security-series/Spring-Security-guide/ SK C&amp;amp;C Tech 블로그 https://spring.io/blog/2022/02/21/spring-security-without-the-websecurityconfigureradapter https://stackoverflow.com/questions/56388865/spring-security-configuration-httpsecurity-vs-websecurity 스택오버플로우 WebSecurity vs WebSecurity https://zzang9ha.tistory.com/341 CSRF에 대하여 https://catsbi.oopy.io/c0a4f395-24b2-44e5-8eeb-275d19e2a536 Spring Security 로그인 상세정리글. https://sas-study.tistory.com/362 exceptionHandling 커스텀마이징 https://ckinan.com/blog/spring-security-credentials-from-json-request/ 필터 동작방식 조금 현재 이 프로젝트는 vue.js + vite + vuex + Spring boot, Spring Data JPA + Spring Security 를 이용하여 real-world 데모버전을 제작완료하였습니다. https://github.com/kkminseok/real-world-springboot" }, { "title": "Spring Security - mvcMatchers vs antMatchers", "url": "/posts/Spring_Mvc_vs_Ant/", "categories": "Java, Spring", "tags": "Spring", "date": "2022-10-11 01:02:00 +0900", "snippet": "개요프로젝트 코드를 복기하던 중 이런 코드를봤다.// TODO// how diff antMatchers, mvcMatchers@Beanpublic WebSecurityCustomizer configure() throws Exception{ return (web) -&amp;gt; web.ignoring().mvcMatchers(&quot;/h2-console/**&quot;);}mvcMatchers말고 antMatchers를 적어도 된다. 그 둘의 차이점이 궁금해졌다.차이antMatcher는 AntPattern을 사용하는 url을 말하기에 AntPattern에 대해 알아야한다.AntPattern에서는 3가지 특수기호가 존재하고 이를 조합해서 url을 구성한 것을 말한다.그렇다해서 mvcPattern이 이와같은 문법을 사용하지 않는다는 것은 아니다. ? : 1개이상의 문자와 매칭 ＊ : 0개 이상의 문자와 매칭 ** : 0개 이상의 경로 또는 파일과 매칭AntPattern은 뒤에 슬래시(/)가 오면 인식을 못하는데 mvcPattern는 이를 감지한다.더 나아가 /~.html, /~.xyz처럼 뒤에 파일명이 붙어도 인식한다.그래서 설정해줄때 mvcMatchers가 좀 더 간편하게 조작이 가능하고, 보안적으로도 우수하다고 한다.참고로 두 개 모두 이러한 문법의 형태도 허용한다. Controller에 해당 url에 @PathVariable이 적용되어있어야한다./api/user/{num}/api/user/{*num} //매칭되어도되고 안 되어도됨. 문제를 발견했다. 위 두개가 동작방식이 달라서인지 필자가 작성한 코드에서 에러가 떴다. https://github.com/kkminseok/real-world-springboot/wiki/%F0%9F%91%8D%EA%B2%AA%EC%9D%80-%EB%AC%B8%EC%A0%9C에서 확인이 가능하고, 나름의 이유를 찾았다. 사실 내부동작이 달라서 나타나는 문제가 아닐수도 있다.결론결론적으로 mvcMatchers가 보안적으로 우수하고 유연하게 대처가 가능하다니 이것을 고려해보도록 하자.여담좀 더 깊게 찾아보고 싶었으나.. 회사 점심시간 30분동안 구글링해도 외의 내용을 찾기는 어려웠다.엄청 깊게 가면 HandlerMappingIntrospector와 뭔가 관련이 있는것 같은데.. 영어의 한계를 느껴서 제대로 찾진 못했다. 궁금한사람은 위의 키워드로 Spring Security 내부동작에 대해 학습하고 나한테도 알려줬으면 좋겠다.Reference https://stackoverflow.com/questions/50536292/difference-between-antmatcher-and-mvcmatcher stackOverFlow 질문글" }, { "title": "Spring - @SpringbootApplication가 뭘까 2편 EnableAutoConfiguration", "url": "/posts/Spring_Annotation2/", "categories": "Java, Spring", "tags": "Spring", "date": "2022-10-06 01:02:00 +0900", "snippet": "개요저번 포스팅에서는 메타 어노테이션들을 봤다. 이번에는 @EnableAutoConfiguration과 @ComponentScane 속성값들을 파볼것이다.@EnableAutoConfiguration이 또한 Javadoc를 읽어보면 친절하게 알려준다.간단하게 이 어노테이션은 Bean을 등록하는 설정파일이고, spring.factories 내부에 따라 여러 Configure들이 있고 이를 조건에따라 등록하는 것이다.@SpringBootApplication안에 있는 이 어노테이션이 결국 실행될 때 spring.factories에 있는 수많은 설정들이 자동으로 조건에 따라 적용되어 Bean이 생기는 것이다.해당 jar파일을 보면 spring.factories가 있는걸 볼 수 있다. 기본적인 class-path에 저장된 값들도 등록한다.예제는 이블로그에 잘 나와있다.또한 이를 확인하는 방법은 간단한데, @EnableAutoConfiguration어노테이션에 지정되어있는 @Import(AutoConfigurationImportSelector.class)의 AutoConfigurationImportSelector는 DeferredImportSelector, BeanClassLoaderAware, ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered를 구현하게 되어있는데 이것들은 이름에서도 알 수 있게 특정 조건에 따라서 빈들을 담아온다.그래서 이 들 중 하나에 들어가서 디버그를 찍으면 빈들이 등록되는것을 볼 수 있다.@EnableAutoConfiguration -&amp;gt; @AutoConfigurationPackage -&amp;gt; @Import(AutoConfigurationPackages.Registrar.class) 에서 Registrar를 타고 들어가면 다음과 같이 구현 되어있는걸 볼 수 있다.static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports { @Override public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) { register(registry, new PackageImports(metadata).getPackageNames().toArray(new String[0])); } @Override public Set&amp;lt;Object&amp;gt; determineImports(AnnotationMetadata metadata) { return Collections.singleton(new PackageImports(metadata)); }}여기서 register()의 인자를 설명해보면, registry는 빈 정의에 대해 관리를 하고, 두번째 인자로 넘겨주는 것은 이 어플리케이션에 있는 패키지 이름들이다.디버그를 찍고 확인해보면beanDefinitionNames에 내 프로젝트에 등록된 빈 이름들을 볼 수 있다.이는 근데 어떻게 미리 알고 있을까? 이는 뒤에나올 ComponentScan을 먼저 수행하기 때문이다.아무튼 빈에 대한 정보들을 가지고 있고 new PackageImports~이부분은 내 프로젝트 같은 경우 이렇게 이루어져있다.실제 디버그를 또 직고 구현과정을 보면 basePackageClasses이라는 것과 basePackages라는 것을 넣고있는데,이 두개는 다음과 같이 활용되기도 한다.@ComponentScan(basePackageClasses = Application.class)@ComponentScan(basePackages = com.io.realworld)별 다른 조건이 없으면 @SpringBootApplication가 정의된 곳이 basePackage가 되는것이다.이 어노테이션은 @Import(AutoConfigurationImportSelector.class)라는 구문도 가지고 있는데위에서 설명한 META-INF/spring.factories에 있는 자동설정해야할 클래스들의 이름 목록을 반환한다. 이 또한 디버그를 찍고 보면내가 안 쓴 Configuration이 있는거 보니 기본적인 Configuration은 다 가져온다.ComponentScan컴포넌트 스캔은 @Configuration, @Controller, @Service, 등 다른 @Component가 붙은 클래스들을 스캔하고 빈에 등록한다.위에서 basePackageClasses, basePackages에 대해서 말했는데 이를 따로 설정해주지 않으면 디폴트 설정 패키지를 스캔한다.@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class)구문을 해석하자면 Custom타입의 필터를 등록하는데, TypeExcludeFilter 클래스에 정의된 필터로 가져온다는 뜻이다.그러면 TypeExcludeFilter에 있는 match()메소드를 봐야한다. 왜냐하면 TypeFilter를 상속받고 있는데, 이 메소드를 오버라이딩 해줘야하기 때문이다.@Overridepublic boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException { if (this.beanFactory instanceof ListableBeanFactory &amp;amp;&amp;amp; getClass() == TypeExcludeFilter.class) { for (TypeExcludeFilter delegate : getDelegates()) { if (delegate.match(metadataReader, metadataReaderFactory)) { return true; } } } return false;}TypeExcludeFilter클래스에 있는 메소드다. 무슨의미인지 해석하다가 날밤 샐거 같아서 나중에 기회되면 알아보는게 좋을것 같다.또한@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })이것도 적용되어있는데 비슷한 방식으로//AutoConfigurationExcludeFilter.class@Overridepublic boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException { return isConfiguration(metadataReader) &amp;amp;&amp;amp; isAutoConfiguration(metadataReader);}로 되어있다.결론@SpringBootApplication은 @EnableAutoConfiguration를 통해 설정들을 자동으로 해주고 @ComponentScan을 통해 각 필터에 맞는 어노테이션을 스캔해준다.더 깊이 파고 싶지만 머리가 복잡해져간다. 점점 산으로 가는 느낌도 들고 일단 목적에 맞게 @SpringBootApplication 어노테이션이 어떤식으로 동작되는지 간단하게 알아봤다.Reference https://www.baeldung.com/spring-componentscan-filter-type filterType" }, { "title": "Spring - @SpringbootApplication가 뭘까 1편 메타어노테이션까지", "url": "/posts/Spring_Annotation/", "categories": "Java, Spring", "tags": "Spring", "date": "2022-10-06 01:02:00 +0900", "snippet": "개요@SpringbootApplication에 대해 설명해 달라는 질문을 받았다.당연히 main에 붙어있고 그 이후에 볼 일이 없어서 당연시하게 쳐다도 안 보게 되었다.(사실 의식하지 않으면 있는지도 몰랐음.)boot를 쓴다하면 다 붙어있는데 답변을 못했고 부끄러워서 정리를 해보려고 한다.뜻부트의 가장 기본적인 설정을 해준다고 알려져 있다.@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })public @interface SpringBootApplication { ...}으로 되어있는데 어노테이션 하나씩 까보도록 하자.@Target(ElementType.TYPE)Target 어노테이션은 이 어노테이션이 붙을 수 있는 타입에 대해 지정한다.위 표를 보면 Type은 Class, Interface, enumeration에 붙을 수 있다고 써있다.즉, @SpringBootApplication어노테이션은 우리가 프로젝트로 생성한 main을 감싸고 있는 클래스 위에 붙어있으므로 맞게 부착되었다고 할 수 있다.@Retention(RetentionPolicy.RUNTIME)Retention의 소스를 까보면Indicates how long annotations with the annotated interface are to be retained. If no Retention annotation is present on an annotation interface declaration, the retention policy defaults to RetentionPolicy.CLASS.A Retention meta-annotation has effect only if the meta-annotated interface is used directly for annotation. It has no effect if the meta-annotated interface is used as a member interface in another annotation interface.Since:1.5Author:Joshua Blochjls9.6.4.2 @Retention@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Retention { RetentionPolicy value();}이렇게 되어있다. Target이 ANNOTATION_TYPE으로 되어있어서 결국 @Retention은 어노테이션에만 붙을 수 있다.윗 주석을 읽어보면 어노테이션의 설명을 볼 수 있다. 어노테이션을 어디까지 살려둘 지를 결정하며 디폴트값은 CLASS이다. RetentionPolicy값을 넘기면서 어노테이션 메모리 범위를 정해주는 것인데, 이는 enum으로 되어 있다.// RetentionPolicy enumpublic enum RetentionPolicy { SOURCE, CLASS, RUNTIME}SOURCE, CLASS, RUNTIME을 넘길 수 있으며 주석으로 살아있는 시점이 적혀져 있다.이를 이해하려면 JVM 동작방식에 대해 알고 있어야한다. SOURCE : complie될 때 어노테이션을 메모리에서 해제. 즉, 소스코드(.java)까지만 남아있는다. CLASS : .class파일에 어노테이션을 기록, 이후 메모리에서 해제. 즉, 런타임때는 남아있지 않음. RUNTIME : RUNTIME때까지 살아있는 어노테이션https://jeong-pro.tistory.com/234 포스팅의 댓글을 보면 이해가 빠르다.결론은 @SpringBootApplication은 @Retention(RetentionPolicy.RUNTIME)이므로 런타임때까지 살아있는다. 개인적인 생각입니다.개인적인 생각으로 왜 런타임때까지 살아있어야하냐면 런타임때까지 살아있으면 어노테이션의 정보를 뽑아쓸 수 있는데(Reflection) 컴포넌트 스캔은 런타임때 어노테이션의 정보를 가지고 스캔을 돌리므로 @SpringBootApplication도 런타임때까지는 살아있어야하는 것이라는 추측이다.@Documented이 어노테이션은 자바doc로 API를 만들때 해당 어노테이션에 대한 설명도 추가해주는 어노테이션이다.@Inherited상속받은 클래스에도 어노테이션 속성이 붙는다.보통 main을 포함하는 클래스는 하나이고 이를 상속받을 일은 없기에 @Inherited가 붙어있는 이유를 모르겠어서 생각해봤지만.. 프로젝트가 좀 더 커지면 그런 일이 생기겠지?.. 좀 더 생각이 필요하다.예제 : https://hongsii.github.io/2018/12/12/java-annotation/여기까지는 메타 어노테이션이다. 그래서 해석하는데 어려움은 없었다.@SpringBootConfiguration이 또한 들어가보면 다음처럼 코드가 되어있다./** * Indicates that a class provides Spring Boot application * {@link Configuration @Configuration}. Can be used as an alternative to the Spring&#39;s * standard {@code @Configuration} annotation so that configuration can be found * automatically (for example in tests). * &amp;lt;p&amp;gt; * Application should only ever include &amp;lt;em&amp;gt;one&amp;lt;/em&amp;gt; {@code @SpringBootConfiguration} and * most idiomatic Spring Boot applications will inherit it from * {@code @SpringBootApplication}. * * @author Phillip Webb * @author Andy Wilkinson * @since 1.4.0 */@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Configuration@Indexedpublic @interface SpringBootConfiguration { @AliasFor(annotation = Configuration.class) boolean proxyBeanMethods() default true;}기본으로 제공되는 메타 어노테이션은 위에서 다 설명했고 특이한점이 없다. @Configuration이 붙어있는데 이는 환경설정 빈을 표현하는 어노테이션이다.맨위의 설명 주석을 보면 @Configuration을 대신 쓸 수 있다고 써 있다.그리고 그 밑에 ‘@SpringBootConfiguration’ 어노테이션은 하나만 붙어있을 수 있고, 이는 ‘@SpringBootApplication’어노테이션이 상속한다고 되어있는데..어떤 글에서는 계층을 주기 위함이 아니냐라고 써있다.@SpringBootApplication-------&amp;gt; @SpringBootConfiguration -------&amp;gt; @Configuration구성을 자동으로 찾아준다는게 일반 @Cofiguration과 다른점이라고 한다. 이는 단위테스트나 통합테스트를 작성할때 유용하다고는 써있지만..그 방식은 모르겠지만 일단 뒤로 넘어가면 힌트가 있을 수 있다. 그래서 다음부분을 보겠다.그러면 @Indexed는 무엇인가??JavaDoc를 읽어보면 굉장히 어렵게 설명이 되어있다..Indicate that the annotated element represents a stereotype for the index.The CandidateComponentsIndex is an alternative to classpath scanning that uses a metadata file generated at compilation time. The index allows retrieving the candidate components (i.e. fully qualified name) based on a stereotype. This annotation instructs the generator to index the element on which the annotated element is present or if it implements or extends from the annotated element. The stereotype is the fully qualified name of the annotated element.Consider the default Component annotation that is meta-annotated with this annotation. If a component is annotated with Component, an entry for that component will be added to the index using the org.springframework.stereotype.Component stereotype.This annotation is also honored on meta-annotations. Consider this custom annotation:@Indexed는 @Override처럼 명시를 한다. 인덱스라는 명시를 하고, 내부적으로 인덱싱을 한다.스프링은 패키지들에 어노테이션이 붙은 컴포넌트를 스캔한다. 컴파일때 스프링은 인덱싱된 candidate components 즉, 컴포넌트 후보자들을 이용하여 빈들을 생성한다.스프링은 @Indexed가 붙은 클래스들을 찾고 인덱스에 추가한다. 그리고 @Indexed가 붙은 어노테이션들에게 메타 어노테이션 권한을 부여한다.메타 어노테이션이란 다른 어노테이션에 해당 어노테이션을 붙일 수 있게 해줘서 여러 어노테이션이 붙은 하나의 어노테이션을 사용자가 만들 수 있게 해준다.예를 들어서 @Component어노테이션을 보겠다.@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Indexedpublic @interface Component { }@Component어노테이션이 붙은 그 어떤것도 컴포넌트 인덱스에 추가될 후보자가 된다. 비슷하게 @Repository, @Service도 결국 @Component가 명시되어있으므로 모두 컴포넌트 인덱스에 추가된다.내가 만들고 있는 프로젝트의 경우 META-INF/spring.components 파일로 들어가면com.javabyexamples.spring.core.beanindexing.indexedbased.UserController=org.springframework.stereotype.Componentcom.javabyexamples.spring.core.beanindexing.indexedbased.UserServiceImpl=org.springframework.stereotype.Componentcom.javabyexamples.spring.core.beanindexing.indexedbased.UserRepository=org.springframework.stereotype.Component이런식으로 들어갈 것이다. 인터페이스랑 클래스에도 사용이 가능하며, 상속을 받을 수도 있다.는 2편에서 계속 작성..여담 및 결론오래 안 걸릴줄 알고 회사 점심시간 1시간을 할애해서 작성하였는데, 생각보다 작성해야할 내용이 많았다. 그래서 집에서 추가로 2편을 작성해야할것 같다.현재까지를 요약하자면 다음과 같다.@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@SpringBootApplication은 @Target을 통해 클래스위에 붙을 수 있음을 알려주고 @Retention을 통해 런타임때까지 살아있음을 알려주고 @Documented를 통해 Javadoc에 설명을 달아주고 @Inherited를 통해 해당 어노테이션을 상속받아도 똑같이 적용되게 해주고 @SpringBootConfiguration을 통해 설정값들을 스캔하고 이 어노테이션을 인덱스에 추가해 스프링이 뜰때 우선적으로 스캔할 수 있게한다.Reference https://www.geeksforgeeks.org/java-target-annotations/ Target 어노테이션 타입표 https://jeong-pro.tistory.com/234 Retention 설명 관련글. https://hongsii.github.io/2018/12/12/java-annotation/ Inherited어노테이션 예제 https://livenow14.tistory.com/52 Spring 설정 계층 https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Indexed.html @Indexed javaDoc https://www.intertech.com/spring-4-meta-annotations/ what is meta Annotation" }, { "title": "라이브코테 준비 - 연습문제3", "url": "/posts/banksalad03/", "categories": "Interview", "tags": "Python", "date": "2022-10-04 02:02:00 +0900", "snippet": "어떤 기업의 라이브코테를 봐야했다.메일로 연습문제를 보내줬으므로 풀어보도록 하였다. 마지막이다.출처링크문제애플에서 출제된 문제입니다.주어진 이진 트리에서, 루트 (최상위 노드) 에서 리프 (자식이 없는 최하위 노드) 까지의 경로를 모두 더하였을 떄 가장 작은 값을 갖는 경로를 찾고, 그 합을 반환하세요.예를 들어, 이 트리에서 최소 값을 갖는 경로는 [10, 5, 1, -1] 이며, 그 합인 15를 반환해야 합니다. 10 / \\5 5 \\ \\ 2 1 / -1테스트 코드def test_p135_1(): node = Node(10) assert(min_path_sum(node) == 10)def test_p135_2(): node = Node(10, Node(5), Node(5)) assert(min_path_sum(node) == 15)def test_p135_3(): node = Node(10, Node(5, None, Node(2)), Node(5)) assert(min_path_sum(node) == 15)def test_p135_4(): node = Node(10, Node(5, None, Node(2)), Node(5, None, Node(1))) assert(min_path_sum(node) == 16)def test_p135_5(): node = Node(10, Node(5, None, Node(2)), Node(5, None, Node(1, Node(-1), None))) assert(min_path_sum(node) == 15)풀이노드를 선언해야하는데, 테스트코드를 잘 보면 왼쪽 노드와 오른쪽 노드를 한 번에 초기화 받는다. 안 받을 수도 있으므로 디폴트값도 지정해줘야한다.class Node: def __init__(self, value, left=None, right=None): self.value = value self.left = left self.right = rightleft와 right모두 Node형태의 클래스가 들어오거나 None 값이 들어올 것이다.테스트코드에서 min_path_sum(node)를 통해 최소값을 찾고 int형으로 값을 비교하므로 인자와, 리턴 타입은 정해졌다. 메소스이름까지도. 메소드 시그니처가 완성되었으므로 내부 로직만 작성하면 된다.def min_path_sum(node: Node) -&amp;gt; int: result = float(&#39;inf&#39;) dq = deque() dq.append((node, node.value)) while dq: node, value = dq.popleft() if node.left: node.left.value += node.value dq.append((node.left, node.left.value)) if node.right: node.right.value += node.value dq.append((node.right, node.right.value)) if not node.left and not node.right: result = min(result, value) return result나는 그래고 pop()연산이 배열보다 빠른 deque를 사용하여 작성하였다. 최솟값을 구해야하므로 float(&#39;int&#39;)를 통해 max값을 설정해준다.BFS방식으로 노드들을 탐색할 것이기에 while문을 돌기전에는 초기값으로 맨 처음 들어온 노드와, 그 value를 넣는다.탐색하면서 탐색하는 노드들에 누적합을 저장할 것이고(1번만 방문할 것이므로 상관없음.), 만약 리프노드에 들어갔다면(자식이 없음) 여태 더해진 누적합과 최솟값을 비교하여 갱신해준다.그리고 리턴하면 된다.결론이런 문제는 예외상황이 거의 없다고 보면된다. 그렇기에 이대로 작성해도 될 것 같다.참고로 나와 답지는 꽤나 다른 부분이 있다. 하지만 로직은 같다고 생각하여.. 굳이 수정하지 않았다." }, { "title": "Mockito doReturn vs thenReturn 설명", "url": "/posts/Mockito-thenReturn-doReturn/", "categories": "Java, Spring", "tags": "Spring", "date": "2022-10-04 01:02:00 +0900", "snippet": "개요개인 프로젝트에서 테스트로 Mockito를 사용하고 있다.처음에 doReturn-when을 사용하여 테스트코드를 작성하였으나, 테스트코드에서 오류가 발생했고 스택오버플로우 등에서 doReturn-when보다 when-thenReturn구문을 많이써서 그 차이를 적어보려고 한다.처음에는 이해할 수 없었다. when-thenReturn이 doReturn.when~보다는 한국인이 읽기에는 더 쉽지 않은가? 하지만 때때로 doReturn을 써야할 때가 있다고 한다No type safetydoReturn-when은 컴파일 단계에서 타입을 체크하지 않는다. 그래서 타입이 미스매칭 되어도 컴파일러는 잡아주지 않는다.기존 userRepository.save()는 User객체를 반환하게 설계되어있다.doReturn-when경우는 컴파일러가 타입체크를 하지 않아서 ‘123’을 반환해도 실행할 수 있게 하지만 when-thenReturn은 그렇지 않다.이게 가능한한 when-thenReturn을 써야하는 이유 중 하나다.No side effectdoReturn-when은 side-effect가 없다. 여기서 말하는 side-effect는 실제 함수가 호출이 되는 경우를 말한다.그러면 when-thenReturn은 실제로 함수가 호출될 때가 있다는 것인데..보통 Mockito 오브젝트를 모킹할때 제일 먼저 만든다.User user = Mockito.mock(User.class);이렇게 Mockito.mock으로 객체를 만들었을때는 위에서 말한 type-safety를 제외하고는 거의 동일하게 작동한다.하지만 Mockito.spy로 객체를 만들면 두 방식의 차이점이 생긴다.Spy오브젝트는 실제 메소드와 연결을 하고 프로그래머가 이를 호출하면 실제 메소드가 호출된다. 문제는 when-thenReturn을 사용했을때도 실제 메소드가 호출된다는 점이다.이는 함수 파라미터 때문이라고 한다. when-thenReturn문법을 보면 실제 함수를 호출하는 부분이 있다. @Test void test(){ List list = new LinkedList(); List spy = spy(list); //error when(spy.get(0)).thenReturn(&quot;foo&quot;); // You have to use doReturn() for stubbing doReturn(&quot;foo&quot;).when(spy).get(0); }위의 경우라면 when-thenReturn은 IndexOut관련 Exception이 떠야할 것이다. 왜냐하면 빈 리스트에 get()함수를 실제로 호출했기 때문이다.실제로 에러가 발생한다.이러한 경우 외에도 어떠한 로직에서 netowrk와 통신해야하는 로직과 실제 함수를 호출해야하는 로직이 섞여 있다면 어떻게 해야할까?실제 함수를 호출해야하기에 spy를 사용해야할 것이지만 network에 의존적이지 않은 테스트코드를 짜기 위해서는 network부분을 모킹해줘야할 것이다.그래서 doReturn-when을 사용하면 network부분의 실제함수를 호출하지 않기에 이를 사용해서 테스트코드를 작성할 수 있다.결론위와같은 고려사항이 없다면 when-thenReturn을 사용해도된다.spy오브젝트와 함께 드물게 사용하는 doReturn-when도 좋지만 컴파일러에서 컴파일 에러라는 좋은 것을 발생시켜주고 가독성이 더 좋은 when-thenReturn이 더 활용도가 높지 않을까싶다.Reference http://sangsoonam.github.io/2019/02/04/mockito-doreturn-vs-thenreturn.html 원본글" }, { "title": "면접준비 - SOLID 정리, 상속단점", "url": "/posts/1003TIL01/", "categories": "Interview", "tags": "", "date": "2022-10-03 01:02:00 +0900", "snippet": " 오타, 지적 환영입니다.개요SOLID를 글로 봤을때와 CleanCode를 읽었을때는 달랐고, 그 차이를 한 번 정리겸 적어보려고 한다.SOLID는 객체지향의 장점을 좀 더 효과적으로 보기 위한, 그리고 무분별한 책임을 가지는 코드 작성을 방지하기 위해 나타난 원칙이다.1. S : 단일 책임 원칙 (Single Responsible Principle)단일 책임 원칙이란 객체는 단 하나만의 책임을 가져야한다.그래서 어떤 변화에 의해 클래스를 변경하는 경우는 단 하나의 이유여야한다.이 말이 무슨 뜻이냐면 클래스는 하나의 책임을 가지지 않으면 여기저기 수정할 일이 생기니까 하나의 책임을 가지란 말이다.너무나도 당연한 말이겠지만 단 하나만이라는 키워드를 클래스를 생성할때나 코드를 작성할때 계속 박아둬야한다.2. O : 개방 폐쇄 원칙 (Open Closed Principle)개방 패쇄 원칙은 기존 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계 해야한다.나는 회사에서 이런적이 있었다. 어떤 신규화면을 만들어야하는데, 정렬기능이 있어서 여러가지 html속성들을 정렬순으로 옮겨야했다.---- box1[제목][금리][상품명]---- box2[제목][금리][상품명]---- box3[제목][금리][상품명]정렬순에 맞게 box안에 있는 제목, 금리, 상품명을 정렬해야해했다. 은행시스템이라서 순수 js와 html로 이 기능을 구현해야했기에 돔을 직접 조작해서 움직였다.나는 제목을 옮기는 함수 sortTitle(), 금리를 움직이는 함수 sortProfit(), 상품명을 움직이는 함수 sortItemName()을 작성하고 sort(정렬 기준 변수)를 작성하고 이 안에다가 넣었다.즉, ┌-&amp;gt; sortTitle()sort() ----&amp;gt; sortProfit() └-&amp;gt; sortItemName()근데 갑자기 [상품 내용]이라는게 추가되었다고 생각해보자.만약에 함수를 분리하지 않고 한 군데에(sort()) 저 모든 코드를 집어 넣었다면 [상품 내용]을 추가하기 위해서 sort()코드 내부를 수정해야한다.근데 저런식으로 분리를 했다면? 나는 그냥 sortItemContent()라는 함수를 작성해서 넣기만 하면 된다. 이게 기존코드를 최대한 건들지 않고 추가에는 확장성있는 코드가 아닐까 생각한다.3. L : 리스코프 치환 원칙리스코프 치환원칙이란 부모객체와 이를 상속한 자식객체가 있을때 부모 객체를 호출하는 동작에서 자식 객체가 부모 객체를 완전히 대체할 수 있다.이다.리스코프 치환원칙을 이해하기 위해서는 가장 대표적인 예시인 정사각형-직사각형문제가 있다.https://blog.itcode.dev/posts/2021/08/15/liskov-subsitution-principle이 블로그를 참조하는게 편하다.4. I : 인터페이스 분리 원칙인터페이스 분리 원칙이란 객체는 자신이 호출하지 않는 메소드에 의존하지 않아야한다.이다.이 또한 https://blog.itcode.dev/posts/2021/08/16/interface-segregation-principle블로그에 정리가 잘 되어있으니 보는게 편하다.5. D : 의존관계 역전 원칙(DIP)의존관계 역전 원칙이란 객체는 저수준 모듈보다 고수준 모듈에 의존해야한다는 원칙이다.저수준 모듈은 구현된 객체이고, 고수준 모듈은 인터페이스와 같은 객체의 추상적 개념을 말한다.Spring은 이 DIP를 제공하고 있는데, 왜 DIP가 필요할까?만약 객체에 의존하게 된다면, 그 객체가 수정이 될때마다 바라보고 있는 객체의 코드도 수정해야할 지 모른다. 이는 의존성이 객체로 향해 있기 때문이다.하지만 DIP원칙에 따르기 위해 인터페이스를 작성하고 의존성을 그쪽에 향하게 한다면 그 객체의 수정내용에 대해서 알 필요가 없다는 것이다.인터페이스가 변경되지 않는 이상 그 객체가 수정되는거에 관여하게 될 일이 없기 때문이다.결론막상 글로 설명하려니 어렵다.클린코드 책을 3번 읽었는데도 나는 멀은것 같다.Reference https://tothefullest08.github.io/php/2020/02/03/Cleancode17-dip/ DIP https://blog.itcode.dev/posts/2021/08/16/interface-segregation-principle 대부분의 글 https://github.com/backtony/Backend_Interview_for_Beginner/blob/master/Java.md 글을 작성하게 된 이유1" }, { "title": "면접준비 - LRU Cache는 2가지 자료구조로 만들어졌다.", "url": "/posts/1002TIL04/", "categories": "Interview", "tags": "Java", "date": "2022-10-02 05:02:00 +0900", "snippet": " 오타, 지적 환영입니다.개요카카오 다니는 형이 면접준비 도와준다고 하나의 질문을 던졌다.“실제 나온 내용이고 LRU cache 2가지 자료구조로 만들어졌는데 뭔지 아니?”답변 못했다.LRU cache?LRU Cache는 운영체제 페이지 교체 알고리즘인데, Least Recently Used라는 의미로 가장 오랫동안 참조되지 않은 페이지를 교체 대상으로 삼는 기법이다.오랫동안 사용되지 않은 페이지는 앞으로도 사용되지 않을 가능성이 크다. 라는 이론에 따라 캐시 히트율을 높이는 것이다.자료구조2가지 자료구조는 Double Linked List와 HashMap이다.Java기준 코드를 보겠다.전체코드출처 : https://hee96-story.tistory.com/47import java.util.HashMap;import java.util.Map;public class LRUCache { private Map&amp;lt;Integer, node&amp;gt; nodeMap; private int capacity; private node head; private node tail; private class node { private int key; private int value; private node prev; private node next; public node(int key, int value) { this.key = key; this.value = value; this.next = null; this.prev = null; } } public LRUCache(int capacity) { this.nodeMap = new HashMap&amp;lt;&amp;gt;(); this.capacity = capacity; head = new node(0, 0); tail = new node(0, 0); head.next = tail; tail.prev = head; } //시간 복잡도 O(1) private void remove(node node) { node.prev.next = node.next; node.next.prev = node.prev; nodeMap.remove(node.key); } //시간 복잡도 O(1) private void insertToHead(node node) { this.head.next.prev = node; node.next = this.head.next; node.prev = this.head; this.head.next = node; nodeMap.put(node.key, node); } //시간 복잡도 O(1) public int get(int key) { if (!nodeMap.containsKey(key)) return -1; node getNode = nodeMap.get(key); remove(getNode); insertToHead(getNode); return getNode.value; } //시간 복잡도 O(1) public void put(int key, int value) { node newNode = new node(key, value); if (nodeMap.containsKey(key)) { node oldNode = nodeMap.get(key); remove(oldNode); } else { if (nodeMap.size() &amp;gt;= this.capacity) { node delNode = tail.prev; remove(delNode); } } insertToHead(newNode); }}1. nodeprivate class node { private int key; private int value; private node prev; private node next; public node(int key, int value) { this.key = key; this.value = value; this.next = null; this.prev = null; }}key와 value를 가지는 특이한 노드이다. 기존 링크드 리스트의 노드는 value하나만 갖는데 키 값도 갖는다는게 특이점이다. 그 외에는 앞 뒤 노드를 가르킬 next와 prev이다.2. LRU Cachepublic class LRUCache { private Map&amp;lt;Integer, node&amp;gt; nodeMap; private int capacity; private node head; private node tail; ... public LRUCache(int capacity) { this.nodeMap = new HashMap&amp;lt;&amp;gt;(); this.capacity = capacity; head = new node(0, 0); tail = new node(0, 0); head.next = tail; tail.prev = head; }}capacity는 LRU Cahce의 사이즈겠고, 탐색속도를 높이기 위한 Map이 들어가있다. 링크드리스트는 탐색속도가 O(N)이기에 O(1)로 탐색하기 위해 넣은 것이다.초기 노드는 더미 노드로 의미없는 노드 2개를 생성해서 head와 tail이 가리키고 있다.이렇게 해놓은 이유는 만들기.. 쉬워서다. 노드를 애초에 생성하지 않는다면 맨 처음 노드가 들어올때 이를 감지하고 head, tail 셋팅을 매 번 해줘야하기 때문이다.3. remove(node node)//시간 복잡도 O(1)private void remove(node node) { node.prev.next = node.next; node.next.prev = node.prev; nodeMap.remove(node.key);}링크드 리스트에서 노드 삭제하는것처럼 구현된다.이전노드 -&amp;gt; 현재노드(삭제할 노드) -&amp;gt; 다음노드 &amp;lt;- &amp;lt;-//삭제 과정 ┌---------------------------┐ ↓ ↑이전노드 현재노드(삭제) 다음노드 ↓ ↑ └---------------------------┘이렇게 연결한다.4. get(int key)//시간 복잡도 O(1)public int get(int key) { if (!nodeMap.containsKey(key)) return -1; node getNode = nodeMap.get(key); remove(getNode); insertToHead(getNode); return getNode.value;}만약 맵에 키가 없다면 -1를 리턴하고 있다면 그 값을 빼어서 위에서 구현한 remove()함수를 호출하여 맵에서 제거하고 링크드 리스트를 이어준다. 그리고 최근 참조되었으므로 insertToHead(getNode)를 통하여 헤드에 값을 넣고 가리킬 것이다.5.insertToHead(node node)//시간 복잡도 O(1)private void insertToHead(node node) { this.head.next.prev = node; node.next = this.head.next; node.prev = this.head; this.head.next = node; nodeMap.put(node.key, node);}헤드의 다음노드의 이전 포인터는 새로운 노드를 가리켜야할 것이고, 새로 들어온 노드는 그 노드를 또 가리켜야 양방향으로 이어질것이다. 그리고 헤드 노드와 새로운 노드 또한 양방향으로 잇고, Map에 노드의 키값을 추가하여 탐색시의 속도를 높인다.6. put(int key, int value)//시간 복잡도 O(1)public void put(int key, int value) { node newNode = new node(key, value); if (nodeMap.containsKey(key)) { node oldNode = nodeMap.get(key); remove(oldNode); } else { if (nodeMap.size() &amp;gt;= this.capacity) { node delNode = tail.prev; remove(delNode); } } insertToHead(newNode);} int형 key와 value를 받아 새로운 노드를 생성한다. 만약 새로운 노드가 Map에 존재한다면 Map에 저장된 노드를 꺼내서 링크드리스트에서 삭제시킨다. (새로 갱신해줘야하기 때문에) 만약 없고, 수용범위를 초과하거나 동일하다면 맨 끝에있는 노드를 삭제한다. 새로운 노드를 헤드에 넣는다.결론어렵지는 않지만 이해는 하고 있어야한다고 생각했다." }, { "title": "면접준비 - Java 는 Call by Reference가 없다.", "url": "/posts/1002TIL03/", "categories": "Interview", "tags": "Java", "date": "2022-10-02 05:02:00 +0900", "snippet": " 오타, 지적 환영입니다.개요이 생각을 하게 된건 단순하다.C, C++를 학습할 때 swap()를 구현한 적이 다들 한 번씩 있을 것이다.Call by Value로 넘겼을 때는 인자로 넘긴값이 바뀌지 않고, Call by Reference로 넘긴거에는 값이 바뀌었다.void swap(int a,int b){ int temp = a; a = b; b = temp; //는 호출한 인자는 안바뀜.}void swap(int* a, int* b){ int temp = *a; *a = *b; *b = temp; //호출한 곳에서도 바뀜.}Java는 포인터가 없어서 위의 swap(int a,int b)로 넘겨도 원본값이 변경 되기에 당연히 Call By Reference인줄 알았다. 근데 아니다.Call by Reference란?이를 알기 위해선 정의를 알 필요가 있다. 주소값을 직접 넘기는 것을 Call by Reference라고 한다.자바는 근데 직접 넘기는것이 아니고 주소 값을 복사해서 넘기기에 Call By Value라고 하는 것이다.복사된 주소값으로 참조가 가능하니 주소값을 가리키는 객체의 내용이 바뀌는 것이다." }, { "title": "면접준비 - Java String vs StringBuilder vs StringBuffer", "url": "/posts/1002TIL02/", "categories": "Interview", "tags": "Java", "date": "2022-10-02 04:02:00 +0900", "snippet": " 오타, 지적 환영입니다.String String은 Immutable하다. 바꿀 수 없다. 그런데 +와 같은 연산을 수행하는것은 새로운 String객체를 생성하고 이를 반환한다는 의미이다. 그래서 메모리 공간의 낭비가 발생하고 성능이 떨어진다.그 의미는 결과를 리턴할 String 객체를 새로 생성해서 원본 값들을 모두 담고 거기에 피연산자들을 추가(append) 연산을 한다는 것이다. 굉장히 비효율적. 그렇기에 시간복잡도는 &quot;test&quot; + &quot;code&quot; 사실상 O(test의 길이 + code의 길이)만큼 수행된다는 것이다. JDK1.5 이후에는 컴파일 타임에 StringBuilder로 변경한다고 한다. 그래도 불변객체이기에 멀티 쓰레드 환경에서 동기화 작업에는 신경을 쓰지 않아도 됨. 그렇기에 업데이트를 자주 하지 않고 조회성에서는 쓰기 좋다.String PoolString은 String Pool에서 관리한다. 동등성, 동일성 포스팅에서 ==는 가리키는 주소값이 같을때 동일하다고 하였다.String a = &quot;Cat&quot;; //String literalString b = &quot;Cat&quot;; //String literalString c = new String(&quot;Cat&quot;);System.out.println(a == b); // trueSystem.out.println(a == c); // falsea와 b는 같은 주소를 가리킨다. 이를 메모리 구조로 나타내면로 나타낼 수 있다. 즉 이러한 방식을 통해 String literal로 정의된 String객체는 똑같은 메모리 값 주소를 가리키므로 그만큼 메모리 재사용성이 늘어나는 것이다. new연산을 통해 생성된 객체는 Heap영역 내 별도의 메모리를 할당하여 주소를 가리키게 된다.StringBuilder, StringBuffer공통점 Mutable하다. 그렇기에 연산시 새로운 객체를 생성하지 않고, 기존 객체에 연산을 수행하므로 String보다는 연산속도가 빠르다. 따라서 업데이트성이 많은 문자열에 쓰기 유리하다.차이점 StringBuilder : Thread-Safe하지 않다. 멀티 스레드 지원이 없다. StringBuffer : Thread-Safe하다. 멀티 스레드 지원한다.StringBuilder는 싱글 스레드환경일 때 사용하고 StringBuffer는 멀티 스레드환경에서 고려해야할 경우 사용하는게 좋다. 무조건적으로 StringBuffer를 사용하는건 아니다. StringBuilder가 성능은 더 좋다. StringBuffer는 내부적으로 synchronized이 적용되어 block을 걸기 때문이다.Reference https://codingdog.tistory.com/entry/java-string-%EC%97%B0%EC%82%B0-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8F%99%EC%9E%91%ED%95%98%EB%8A%94%EC%A7%80-%EC%95%8C%EC%95%84%EB%B4%85%EC%8B%9C%EB%8B%A4 String 연산 https://velog.io/@heoseungyeon/StringBuilder%EC%99%80-StringBuffer%EB%8A%94-%EB%AC%B4%EC%8A%A8-%EC%B0%A8%EC%9D%B4%EA%B0%80-%EC%9E%88%EB%8A%94%EA%B0%80 StringBuffer vs StringBuilder https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Java/%5BJava%5D%20String%2CStringBuilder%2CStringBuffer%20%EC%B0%A8%EC%9D%B4.md 거의 원본글 https://github.com/jvm-hater/java-study/blob/main/5%EC%A3%BC%EC%B0%A8/String%20vs%20StringBuilder%20vs%20StringBuffer.md String Pool" }, { "title": "면접준비 - Java Annotation 상세 설명", "url": "/posts/1002TIL/", "categories": "Interview", "tags": "Java", "date": "2022-10-02 02:02:00 +0900", "snippet": " 오타, 지적 환영입니다.배경어노테이션의 의미는 ‘주석’이다. 주석은 코드로만 알기 힘든 내용이나 코드로 설명하기 어려운 디테일한 부분을 설명하기 위해 추가하기도 한다.어노테이션은 그렇기에 소스코드 안에 다른 프로그램을 위한 정보를 미리 약속된 형식으로 포함시키기 위해 작성한다.기존의 자바 웹 어플리케이션은 구성과 설정값들을 외부 XML설정 파일에 명시하여 프로그래밍 되었다. 외부에서 변경될 수 있는 값을 관리하기에 재컴파일 없이 쉽게 변경사항을 적용할 수 있었지만, 프로그램의 규모가 커질수록 설정을 다 적어줘야했고, 프로그램을 작성할때 마다 많은 설정을 작성해야했기에 문제점이 있었다. 이를 해결하기 위해 고안된 문법이 어노테이션이다. 어노테이션은 런타임 또는 컴파일에 어노테이션은 해석될 수 있다. 어노테이션은 보통 문서화, 컴파일러 체크, 코드 분석을 위한 용도로 사용되는데 본질적인 목적은 소스 코드에 메타데이터를 표현하는 것이다.소스 코드에 메타데이터를 표현하다는 것은 정보에 대한 정보를 표시한다는 의미인데..@Override라는 어노테이션은 보통 많이 접해봤으니까 이를 통해 설명을 하자면 @Override 어노테이션의 기능은 뒤에서도 설명하겠지만 명시적으로 이 함수가 오버라이딩 됨을 알려주고 오버라이딩을 하지 않으면 빨간 밑줄이 생기면서 컴파일러에서 경고를 해준다. 이것은 ‘이 함수는 오버라이딩 해야해!’라는 정보를 포함하고 있기에 함수(정보)에 대한 정보를 표시한다는 것이다. 내 개인적인 이해와 생각이다. 지적은 환영입니다.종류어노테이션은 Java에 기본적으로 내장되어 있는 것들도 있는데, 이를 Built-in-Annotation이라고 한다. 주로 컴파일러를 위한 것으로 컴파일러에 유용한 정보를 준다.대표적으로Built-in-Annotation@Override위에서 설명했지만 컴파일러에게 현재 메소드가 수퍼클래스의 메소드를 오버라이드한 메소드라는 것을 명시한다.이를 통해 메소드 이름 오타나 오버라이딩을 하지 않으면 컴파일러가 잡아준다.@Deprecated차후 버전에 지원되지 않을 수 있기 때문에 더 이상 사용되지 말아야 할 메소드를 말한다.예로는 최근 스프링에서 웹설정을 위한 어댑터에 @Deprecated가 달리게 되었다.@Deprecatedpublic abstract class WebSecurityConfigurerAdapter implements WebSecurityConfigurer&amp;lt;WebSecurity&amp;gt; { ...}@SupreesWarning프로그래머의 의도를 컴파일러에게 전달하여 경고를 제거한다.회사에서 쓴걸 본 적이 있는데 이걸 지우면 노란줄(warning)이 뜨던것이 이 어노테이션을 달면 사라지는것을 알 수 있었다.@SafeVarargs@SupressWarning과 비슷한데, 변수나 타입에 대한 경고성도 무시한다는 의미다.@FunctionalInterface컴파일러에게 해당 인터페이스가 함수형 인터페이스라는 것을 알린다. @Override와 비슷하게 프로그래머가 실수를 하는것을 미연에 방지한다. 자바의 람다식은 함수형 인터페이스로만 접근이 가능하기 때문이다.글이 좀 새지만 내가 궁금해서 찾아봤다.함수형 인터페이스는 1개의 추상 메소드를 갖고 있는 인터페이스를 말한다. Single Abstract Method(SAM)으로도 불리기에 만약 저 어노테이션을 달고 두 개이상의 추상메서드를 선언하면 컴파일러 경고가 뜰 것이다.당연하게도 저 어노테이션을 지우면 빨간줄도 사라진다.@NativeJava 8버전 이후의 새로운 어노테이션이다.이는 필드에만 적용할 수 있고 native code영역과 관련이 있다는것을 명시적으로 알려준다.public final class Integer { @Native public static final int MIN_VALUE = 0x80000000; // omitted}네이티브 영역은 외부 언어로 작성된 파일을 저장하는 메모리 영역인데 보통 C언어로 작성되어 있기에 이를 명시하는 의미로 쓰인다. Native 메서드에서 참조되는 상수 앞에 붙인다고 한다.Meta-Annotation어노테이션에 사용되는 어노테이션으로 해당 어노테이션의 동작대상을 결정한다. 주로 새로운 어노테이션을 정의할 때 사용한다.@Target어노테이션이 적용가능한 대상을 지정하는데 사용한다. {}를 통해 열거할 수도 있다. 패키지, 어노테이션, 멤버 변수 등에 따라 지정할 수 있다.@Retention어노테이션이 유지되는 기간을 지정한다. 세 가지 유지정책(retention policy)를 사용할 수 있다. SOURCE : 소스코드(.java)까지 남아있는다. CLASS : 클래스 파일(.class)까지만 남아있는다. = 바이트 코드 RUNTIME : 런타임까지만 남아있는다.이렇게만 설명하면 이해가 되지 않는다. 주의!! 레퍼런스가 있긴하지만 제 생각을 곁든 개인적인 견해입니다.먼저 JVM이 동작하는 방식을 알아야할 필요가 있다. compile load.java -&amp;gt; .class -&amp;gt; classLoader in JVM이렇게 되기에 SOURCE는 .java시점에 살아있고, CLASS는 .class시점에 살아있을것이고 실제 프로그램이 구동되면서는 런타임이 된것이므로 RUNTIME에 살아있을 것이다.대표적으로 롬복의 @Getter는 정책이 SOURCE로 되어있는데 컴파일될 때 메서드들의 get()함수를 바이트코드로 생성해 컴파일을 시켜버리고 사라지게 되는것이다.@NonNull의 정책은 CLASS인데 동작방식은 이게 붙어있는데 null을 넣게되면 노란색 경고로 프로그래머에게 알려주는 동작을 한다.Maven/Gradle로 다운받은 라이브러리와 같이 jar파일에는 소스가 포함되어 있지 않기에 SOURCE정책을 사용하는데에 한계가 있다. 이미 컴파일된 파일이기에 어노테이션 정보가 남아있지 않기 때문이다.그렇기에 .class만 남아있는 라이브러리 경우에 대하여 타입체커, IDE부가기능 등을 사용할 수 있으려면 CLASS에 대한 정책이 필요하게 되는 것이다.RUNTIME정책에 대해서는 자바의 Reflection API등을 통하여 런타임에 어노테이션 정보를 알 수 있다는 의미이다. @Controller, @Service와 같이 스프링이 올라오는 런타임 시점에 스캔이 컴포넌트 스캔이 가능해야하기에 RUNTIME정책을 필요로 한다.@Documented어노테이션에 대한 정보가 javadoc로 작성한 문서에 포함되도록 할 때 사용하는 어노테이션이다.@Inherited어노테이션이 자손 클래스에도 상속되도록 하는 어노테이션이다. 즉, 조상 클래스에 붙이면 자손 클래스도 이 어노테이션이 붙은것과 같이 인식된다.Reference https://asfirstalways.tistory.com/309 어노테이션 틀 https://www.baeldung.com/java-default-annotations Built-in-Annotations 종류" }, { "title": "라이브코테 준비 - 연습문제2", "url": "/posts/banksalad02/", "categories": "Interview", "tags": "Python", "date": "2022-10-02 01:02:00 +0900", "snippet": "어떤 기업의 라이브코테를 봐야했다.메일로 연습문제를 보내줬으므로 풀어보도록 하였다.출처링크문제Problem 134 [Easy]페이스북에서 제출된 문제입니다.0이 대다수를 차지하는 큰 배열이 있습니다.더 공간 효율적인 자료구조인 SparseArray를 다음과 같은 인터페이스로 구현하세요.init(arr, size): 큰 원본 배열과 사이즈를 인자로 받아 초기화 합니다.set(i, val): 인덱스 i 를 val 값으로 업데이트 합니다.get(i): 인덱스 i 번째 값을 반환합니다.저번에 풀었던 경험처럼 이렇게만 주어지면 너무 모호하다.나는 일단 풀었으므로 고려해야할 사항을 추가하겠다.먼저, 실제 테스트코드를 보면서 유추를 해봐야겠다.def test_p134_1(): arr = SparseArray([0, 0, 0], 5) assert arr.get(0) == 0 assert arr.get(3) == 0 with pytest.raises(IndexError): assert arr.get(-1) assert arr.get(-1, 0) assert arr.get(5) assert arr.set(5, 0) arr.set(0, 1) assert arr.get(0) == 1 arr.set(4, 1) assert arr.get(4) == 1이 코드가 돌아가게 하면 되는데, 인자로 들어온 오리진 배열의 크기는 3이다. 근데 초기화 사이즈로 받는 값은 5이다.근데 assert arr.get(3) == 0이 통과된 것으로 보아 오리진 배열의 크기를 벗어나도 초기화 사이즈 안에만 있으면 0을 리턴해야한다는 것이다.그리고 with구문 안에 assert arr.get(-1,0)은 출제자의 오타 같고 이슈를 냄기려 했으나 막아놓으신 관계로.. 오타라고 생각하겠다. 아무튼 초기화 사이즈의 인덱스 범위를 벗어나면 IndexError를 발생시켜야한다.풀이import pytestclass SparseArray: def __init__(self, origin_list, input_size): self.size = input_size self.dic = {} for i in range(input_size): if i &amp;gt;= len(origin_list): self.dic[i] = 0 else: self.dic[i] = origin_list[i] def get(self, idx) -&amp;gt; int: try: return self.dic[idx] except Exception: raise IndexError def set(self, idx, value) -&amp;gt; None: try: self.dic[idx] = value except Exception: raise IndexError나는 이렇게 풀었는데, 실제로 답지는 좀 더 효율적으로 풀었다.나와 다른점은 나는 오리진 배열의 크기를 넘어서면 0으로 초기화해줬는데, 답지는 그렇게 하지 않았고 초기화 작업을 하지 않았다.그리고 get()이나 set()함수 호출시 초기화 사이즈를 넘어서는지 확인하고 get()경우 벗어나지 않지만 초기화되지 않았다면(None인 경우) 0을 리턴해버리고, set()경우는 처음 접근하는 값이던 아니던 초기화작업을 수행해준다.그래서 나와 달리 초기화 작업을 거칠 필요가 없으므로 나보다 더 빠른 코드가 탄생할 것이다.또한, 모든 예외에 대해서 IndexError를 발생시키도록 하였는데, 답지는 좀 더 디테일하게 범위를 정하여 예외처리를 하였다.결론라이브 코테를 좀 해보니까 알것같다.최소한의 조건만줘도 얼마나 디테일하게 설계하는지를 보는것 같단 생각을 하였다. 그냥 푸는것도 중요하지만 주어진 조건으로 예외를 어떻게 생각하는지?에 대해 고민하게 만드는것 같다.다음 문제는 좀 더 디테일하게 풀어보도록 해야겠다." }, { "title": "면접준비 - Java GC(Garbage Collection) 상세설명", "url": "/posts/1001TIL2/", "categories": "Interview", "tags": "Java", "date": "2022-10-01 02:02:00 +0900", "snippet": " 오타, 지적 환영입니다.배경C언어는 메모리를 직접 해제할 수 있다. free()를 통해서 직접 메모리를 해제하고 malloc()등을 통해 메모리를 할당할 수 있다. 또한 포인터를 통해 주소값에 직접 접근이 가능하다.하지만, Java에서는 JVM가 메모리를 관리한다. 직접 주소에 접근할 수도 없다.앞의 포스팅에서 JVM의 메모리구조에 대해서 말했다. Stack PC Register Native Method Stack Method Area Heap으로 이루어져있는데, 보통 런타임시에는 빈번하게 접근이 일어나는게 Stack과 Heap이다.메소드와 지역변수들은 실행순서대로 스택에 쌓인다.public class main { public static void main(String[] args) { call(); } public static void call(){ Spot home = new Spot(3,4); }}class Spot{ public int x; public int y; Spot(int x,int y){ this.x = x; this.y = y; }}이러한 코드가 있다고 치면 스택과 힙에는 이렇게 쌓일것이다.| home | | || call() | |Spot1| home -&amp;gt; Spot1| main() | | |+++++++++ +++++++Stack Heapcall()에서는 home 살아있다. 만약 call()호출이 끝나면 home인스턴스는 어떻게 되는것인가?사라질 것이다. 그러면 가리키고 있던 Spot1은?| | | || | |Spot1| ? -&amp;gt; Spot1| main() | | |+++++++++ +++++++Stack Heap이 정리를 GC가 담당한다.그러면 GC는 언제 이 메모리들을 정리한다는 것일까?Garbage Collection Algorithm단순한건 메소드 호출이 끝날때마다 해주는 것이다.하지만 메모리를 계속 모니터링해야하고, GC자체도 프로그램 성능에 영향을 주기에 문제가 있다. 그렇기에 GC알고리즘을 개선한다는 것은 GC시점을 언제 정하여 성능에 최대한 덜 지장을 주는가에 있다.Reference CountingGC를 수행할때 오브젝트에 몇 개의 레퍼런스가 연결되어 있는지 체크하는 방법이다.위의 경우| home | | || call() | |Spot1| home -&amp;gt; Spot1| main() | | |+++++++++ +++++++Stack Heap에서 call()의 지역변수 home은 Spot1이라는 오브젝트를 가리키므로 Spot1의 카운트는 1이다. 이처럼 객체를 참조하는 변수의 수가 늘어나면 1을 올리고 사라지면 1을 내려 카운트가 0이되면 GC를 수행할 때 제거하는 방법이다.직관적이지만 문제가 있다. 서로가 서로를 가리킬 때이다.public class Test { public static void main(String[] args) { call(); } public static void call(){ Home home = new Home(1,2); School school = new School(3,4); home.mySchool(school); school.myHome(home); }}class Spot{ public int x; public int y; Spot(int x,int y){ this.x = x; this.y = y; }}class Home extends Spot{ private School school; Home(int x, int y) { super(x, y); } public void mySchool(School school){ this.school = school; }}class School extends Spot{ private Home home; School(int x, int y) { super(x, y); } public void myHome(Home home){ this.home = home; }}이렇게 짜는 경우는 없겠지만.. 내 머릿속에서 생각한 예제의 한계이다.아무튼 이 경우| myHome() | | mySchool() || school || home | |school1[2] | home -&amp;gt; Home1| call() | |home1[2] | school -&amp;gt; School1| main() | | | Home1 -&amp;gt; school -&amp;gt; School1 +++++++++ ++++++++++++ School1 -&amp;gt; home -&amp;gt; Home1Stack Heap이렇게 서로가 서로를 참조할 경우에는 call()이 끝나도 힙에 남아있는 Home1이 결국 School1을 가리킬것이기에 사라지지 않을 것이다.Tracing오브젝트의 레퍼런스를 추적한다.처음에는 스택의 지역변수에서 시작해 해당 변수가 가리키는 오브젝트를 찾는다.오브젝트가 연결되어 있다면 해당 오브젝트의 marked값을 true로 바꾼다.| myHome() | | mySchool() || school || home | |school1[true] | home -&amp;gt; Home1| call() | |home1[true] | school -&amp;gt; School1| main() | | | Home1 -&amp;gt; school -&amp;gt; School1 +++++++++ ++++++++++++ School1 -&amp;gt; home -&amp;gt; Home1Stack Heap지역변수로부터 레퍼런스가 끊기면 marked의 값을 false로 바꿔 GC수행시에 false인 오브젝트들을 메모리에서 해제시킨다.| | |school1[false] | ? -&amp;gt; Home1| | |home1[false] | ? -&amp;gt; School1| main() | | | Home1 -&amp;gt; school(School1)++++++++++++++ +++++++++++++++++ School1 -&amp;gt; home(Home1)Stack Heap하지만 이럴경우 메모리에 빈 공간이 생기게 되는데, 빈 공간이 늘어날때마다 이를 피해서 비집고 들어가는 상황이 발생하기에 메모리 공간은 충분하지만 할당되지 못하는 문제가 생긴다.효율적이지 않다.이미 할당된 메모리 공간을 다른 한 쪽으로 모아주는 compacting작업을 해줘야한다. 이것도 GC에서 수행되고, Tracing기법은 mark-and-sweep으로도 불린다.mark-and-sweep -&amp;gt; Compacting 작업이 수행되기에 MSC(Mark,Sweep,Compacting)으로도 불린다.Generational GCJVM은 GC를 더 효율적으로 수행하기 위해 힙 메모리 구조를 더 세밀하게 분류한다.GC는 오버헤드가 큰 작업이다. 왜냐하면 GC가 시작될 때마다 JVM이 stop-the-world라는 프로그램의 스레드를 모두 멈추고 MSC를 수행한다. 따라서 GC주기가 잦으면 규모가 클수록 오버헤드가 커진다.보통 오브젝트가 생성된지 얼마 안되어서 레퍼런스가 사라진다. 이러한 점을 착안해서 만든게 이 알고리즘이고, heap영역을 세대별로 쪼개 관리한다.5가지 영역으로 Eden, S0, S1, Tenured, Permanent로 나누어진다. 이는 Java8 버전 이전이다. Java8버전 이후에는 Permanent가 사라지고 Metaspace가 생겼다.Java8버전 이전이 설명하기 편하므로 이를 기준으로 정리해보겠다. |--------- Old ---------|+------+----+----+-----------+-----------+| Eden | S0 | S1 | Tenured | Permanent |+------+----+----+-----------+-----------+|----- Young ----|Eden, S0, S1은 Young영역이라고 생성된지 얼마 안 된 오브젝트들이 쌓이는 공간이다. Eden : 오브젝트가 처음 생성되었을 때 Eden에 들어간다. Survivor 0, Suvivor1 : 생성된 이후 시간이 흐르면 garbage되지 않은 오브젝트들이 eden에서 여기로 옮겨진다. 즉, 에덴에서 살아남은 오브젝트들이 들어가서 suvivor space라고도 불러진다. 두 개로 분리된것은 보통 하나의 Suvivor 공간이 꽉차게되면 다른 Suvivor공간으로 옮겨진다. 이 메커니즘 때문에 Suvivor들 중 하나의 공간은 비워지게 된다.옮겨진 오브젝트들은 age count가 1 증가한 상태로 넘어간다.이 과정에서 1차 GC라고 하는 Minor GC가 발생하게 된다. 이 GC를 통해 Eden 또는 Suvivor영역들에 사용되지 않은 객체들을 메모리 해제하게 된다.이 과정을 반복해도 살아남은 객체들의 age counter가 일정 이상으로 넘어가버리면 Old영역인 tenured로 보내 Suvivor영역이 꽉 차지 않게 한다.이렇게 오브젝트가 살아남아 다음 세대로 넘어가는 것을 promotion이라고 한다.Old 영역은 GC가 잘 발생하지 않으므로 메모리가 크게 할당된다.Permanent영역은 Method Area라고도 하는데, 객체나 문자열정보를 저장하는 곳이며, GC가 절대 발생하는 곳은 아니고 발생한다. 이는 Major GC에 포함된다. Eden영역에서 바로 Old영역으로 넘어가는 객체가 있는데, 이는 객체의 크기가 아주 큰 경우를 말한다. Survivor영역의 크기가 20MB인데, 객체의 크기가 24MB인 그런 경우에 해당한다.Java 8버전 이후 GCPermanent영역이 Metaspace로 변경되었다. 기존 Permanent 영역에는 다음과 같은 정보가 저정되어 있었다. Class Meta정보 Method Meta정보 Static Object 상수화된 String Object Class 관련 배열 객체 및 객체 Meta 정보 JVM 내부적인 객체들과 최적화컴파일러(JIT)의 최적화 정보이는 Metaspace가 생기면서 다음과 같이 바뀌었다. Class Meta정보 -&amp;gt; Metaspace로 이동 Method Meta정보 -&amp;gt; Metaspace로 이동 Static Object -&amp;gt; Heap영역으로 이동 상수화된 String Object -&amp;gt; Heap영역으로 이동 Class 관련 배열 객체 및 객체 Meta 정보 -&amp;gt; Metaspace로 이동 JVM 내부적인 객체들과 최적화컴파일러(JIT)의 최적화 정보 -&amp;gt; Metaspace로 이동왜 이렇게 바뀌었냐면 Permanet에 있던 Static Object들이 문제를 유발했다고 한다. 이를 Heap영역으로 옮겨서 최대한 GC대상이 되도록 변경했다고 한다.다음과 같은 오류를 발생했다고 한다.OutOfMemoryError : PermGen Space error이는 메모리 누수가 발생했을때 나타나는 예외이고 로딩된 클래스와 클래스 로더가 종료될때 이것들이 GC되지 않았을때 발생한다고 한다.수정될 필요가 없는 정보만 Metaspace에 저장하고 JVM의 필요에 따라 리사이징할 수 있게 바뀌었다고한다.GC 방식 Java7 : Parallel GC Java8 : Parallel GC Java9 : G1(proPosed) Java10 : G1 Java15 : ZGC(proPosed)1. Serial GCJDK 5,6 에서 쓰이던 방식으로 Major GC, Minor GC 모두 싱글스레드로 실행되어 Stop-The-World가 다른 GC에 비하여 오래걸린다.절대 사용하면 안되는 GC로 설명되어 있으며 MSC 알고리즘을 사용한다.2. Parallel GC(Throughput Collector)Serial GC와 동일하나 Young Gen을 멀티스레드를 통해 병렬 처리한다.compaction 단계 이전에 summary라는 단계를 가지며, 해당 작업에서는 이전 GC 이후의 메모리를 인덱싱하는 작업을 수행하고 compact 작업을 수행한다.공간에 대한 인덱싱 작업때문에 약간의 메모리를 더 소모할 수 있다.업그레이드 방식으로 Parallel old GC가 있다. 이는 Old영역에서 발생하는 FullGC도 병렬로 처리한다.3. CMS(Concurrent Mark &amp;amp; Sweep) GCFull GC의 수행시간을 최소한으로 줄이는데 초점을 맞춘 GC이다. 즉 Stop-The-World의 시간을 최소화한다. 그렇기에 GC대상을 정밀하게 파악한다.기존 Parallel GC 방식은 Full GC를 수행할때마다 Compaction 작업을 하여 시간을 많이 소요하였지만, 수행된 이후에는 메모리를 연속적으로 저장할 수 있어 메모리를 더 빠르게 할당할 수 있다.CMS는 Compaction작업을 수행하지 않기 때문에 속도가 빠르지만 메모리 단편화로 인해 Concurrent mode failure가 발생할 수 있고, 이 경우 Compaction 작업을 수행한다.다만, Compaction 과정이 Parallel GC보다 오래걸릴 수 있다. 그리고 CPU리소스가 부족해지거나 메모리 단편화로 인해 메모리 공간이 부족해지면 Serial GC방식의 Full GC가 발생 한다.그러면 CMS는 어떤식으로 GC대상을 파악할까? Initial Mark : 현재 살아남은 객체를 탐색하는데, GC ROOT에서 참조하는 객체들만 우선 탐색하기 때문에 STW발생 시간이 적다. Concurrent Mark : 위 단계에서 탐색한 객체들이 참조하고 있는 객체를 찾아가며, GC대상인지 확인한다.(STW 발생 x) ReMark : Concurrent Mark 과정 중 새로 생성된 객체나, 참조가 끊기는 등 변경된 객체가 있는지 다시 한번 점검한다.(STW 발생 - 멀티스레드로 인해 시간이 짧다.) Concurrent Sweep : Remark 단계까지 검증이 완료된 GC대상 객체를 해제한다.(STW x)4. G1 GC(Garbage First GC)G1 GC는 기존 메모리 구조에서 좋은 성능을 내기 힘들어서 개선하고자 등장했다.힙 메모리 영역 전체를 Region이라는 논리적인 단위로 나눠서 관리한다. Region은 특정 역할(Eden, Suvivor, Old 등)을 동적으로 부여한다.CMS와 달리 Compaction 단계를 진행하고 메모리 단편화 문제를 없앴다. STW 시간을 예측할 수 있다는 것이 G1 GC가 가진 큰 장점 중 하나다.이렇게 Region 단위로 나뉘는데, 2048개의 Region으로 Heap을 나눌 수 있다.각 Region은 1MB ~ 32MB의 크기를 지정할 수 있다.여기서 Humonogous, Avliable, Unused영역은 처음보는데 이를 정리해야 한다. Humonogous : Region 크기의 50%를 초과하는 객체가 저장되는 공간이다. 이 공간에서는 GC가 효율적으로 일어나지 않는다. Avaliable/Unused : 아직 사용되지 않은 비어있는 공간의 Region이다.G1 GC에서는 Young GC를 수행할 때는 STW가 발생하고, STW시간을 줄이기 위해 멀티스레드로 GC를 진행한다.Young GC는 Region 중 GC대상 객체가 가장 많은 Region(Eden or Survivor역할)에서 수행 되며, 이 Region에서 살아남은 객체를 다른 Region(Suvivor 역할)으로 옮긴 후, 비워진 Region을 사용 가능한 Region으로 돌리는 형태로 작동한다.Old GC에서는 CMS처럼 백그라운드 쓰레드로 이 영역들을 정리한다.Heap 메모리에 객체가 살아 있는지 동시적이고 전역적인 마킹을 수행하고, 어떤 영역의 메모리가 가장 많이 비어있는지 확인하여 메모리를 회수 한다. 그렇기 때문에 Garbage First라는 이름을 갖고 있는 것이다. G1에 의해서 교체를 해야하는 공간은 배출(evacuation)에 의해 GC를 시작한다.배출은 Region 내의 unreachable object만 삭제하는 것이 아니고, Reachable object는 다른 Old영역Region으로 이동시키고 해당 Region 전체를 클리어한다. 다른 Region으로 옮기는 과정에서 Compacting을 하여 메모리 단편화가 생기지 않는다.5. ZGCjdk 15버전이상에서 사용되는 GC종류로, 조금 더 큰 메모리(8MB ~ 16TB)에서 효율적으로 GC하기 위한 알고리즘이다. 주된 목적은 STW시간을 줄이기 위해 Marking 시간에서만 STW를 진행하도록 하고 있다.G1GC와 유사한 구조를 가지고 있는데, ZGC는 Colored pointers와 Load barriers라는 2가지 주요 알고리즘을 가지고 있다. Colored Pointers객체를 가리키는 변수의 포인터에서 64bit를 활용해서 Marking을 한다.Finalizable : finalizer을 통해서만 참조되는 Object의 GarbageRemapped: 재배치 여부를 판단하는 MarkMarked 1/0 : Live Object그렇기에 ZGC는 64비트 운영체제에서만 사용이 가능하다. Load barriers위의 비트를 이용해서 G1GC와 다르게 메모리 재배치 과정에서 STW를 발생시키지 않는다.그리고 비트를 이용해 참조 값과 mark 상태를 업데이트 한다.마킹 과정은 내가 이해를 못해서.. 정리하기 어려우므로 다른 글을 읽는것을 추천한다. https://kchanguk.tistory.com/174 https://huisam.tistory.com/entry/jvmgcReference https://1-7171771.tistory.com/140 Java8버전 이후 GC참조 https://parksb.github.io/article/2.html GC 디테일 https://d2.naver.com/helloworld/1329 Naver D2 https://code-factory.tistory.com/48 Metaspace 정보 참조" }, { "title": "면접준비 - Java 동등성, 동일성", "url": "/posts/1001TIL/", "categories": "Interview", "tags": "Java", "date": "2022-10-01 02:02:00 +0900", "snippet": " 오타, 지적 환영입니다.A라는 객체와 B라는 객체가 있다고 치자.한줄로 요약해서 동일성은 A와 B의 메모리 주소가 같은 경우이고, 동등성은 둘이 다른 메모리를 가리킬지라도 저장된 정보는 같은 경우를 말한다.✍️동등성 String A = new String(&quot;안녕하세요?&quot;); String B = A; System.out.println(A == B); // true //Primitive type int a = 1; int b = a; System.out.println(a == b); // trueA는 어딘가에 생성된 인스턴스(“안녕하세요?”)의 JVM내의 메모리 주소를 가리키고 있을 것이다.B는 A를 가리키고 있으므로 둘의 메모리 주소는 같을 것이다. 고로 동등하다고 볼 수 있다.동등하다는것을 코드로 확인하기 위해서는 A==B문구를 통해 확인할 수 있다.원시타입의 경우는 가리키는 객체의 메모리 주소가 없으므로 값을 비교하여 같다면 동등하다고 판단한다.// 내용이 같아도 가리키는 객체의 주소가 다르므로 String A = new String(&quot;안녕하세요?&quot;); String B = new String(&quot;안녕하세요?&quot;); System.out.println(A == B); // false내용이 같아도 각 다른 인스턴스이므로 당연하게도 false가 출력된다.동등성가리키는 객체의 정보가 같다면 동등하다고 본다.동일하다면 동등하다고 볼 수 있지만, 동등하다면 동일한것은 아니다 String A = new String(&quot;안녕하세요?&quot;); String B = new String(&quot;안녕하세요?&quot;); System.out.println(A == B); // false System.out.println(A.equals(B)); // true둘의 정보는 같기에 동등하다.String객체의 경우는 내부적으로 다음과 같이 동작한다. step1 동일성을 먼저 체크. 동등할경우 true리턴public boolean equals(Object anObject) { if (this == anObject) { return true; } return (anObject instanceof String aString) // &amp;lt; 이 부분 &amp;amp;&amp;amp; (!COMPACT_STRINGS || this.coder == aString.coder) &amp;amp;&amp;amp; StringLatin1.equals(value, aString.value); } step2 String객체인지 확인return (anObject instanceof String aString) // &amp;lt; 이 부분 &amp;amp;&amp;amp; (!COMPACT_STRINGS || this.coder == aString.coder) &amp;amp;&amp;amp; StringLatin1.equals(value, aString.value); step3 배열의 요소를 돌면서 값이 같은지 확인return (anObject instanceof String aString) &amp;amp;&amp;amp; (!COMPACT_STRINGS || this.coder == aString.coder) //&amp;lt;- 해석 불가. &amp;amp;&amp;amp; StringLatin1.equals(value, aString.value); //&amp;lt;- 이 부분//배열을 돌면서 요소 확인@IntrinsicCandidatepublic static boolean equals(byte[] value, byte[] other) { if (value.length == other.length) { for (int i = 0; i &amp;lt; value.length; i++) { if (value[i] != other[i]) { return false; } } return true; } return false;}실제 String,Integer,ArrayList 모두 이해하는대로 잘 동작한다.내부 코드에 대해서 설명이 더 필요하다면 이 글을 추천한다.근데, 클래스의 경우는 어떻게 동등하다고 판단할까? 클래스의 경우 값이 같다고 동등하지 않았다.클래스의 경우 동등하다?class Test { private int age; private String name; public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; }}//main이라는 뜻psvm{ Test classA = new Test(); Test classB = new Test(); classA.setAge(18); classA.setName(&quot;name&quot;); classB.setAge(18); classB.setName(&quot;name&quot;); System.out.println(classA.equals(classB)); //false System.out.println(classA.getName().equals(classB.getName())); //true}내용이 같다면 “동등하다”라고 했는데 클래스의 경우 그렇지 않았다.요소들의 값이 동등하지만 클래스 자체는 동등하지 않다는 것이다.왜 그럴까? 일단 클래스는 Object형이다. 그러면 Object에서 재정의된 equals()를 보면 답이 나온다.//java 18public boolean equals(Object obj) { return (this == obj); }java 18 버전 기준 다음과 같이 위 코드를 해석하면 다음과 같이 정의된다. 동일하지 않다면 동등하지 않다.Object는 equals()에 대한 동등성이 없으므로 Object 자료형 같은 경우 equals()로 동등성을 비교하고 싶다면 오버라이딩 해줘야한다는 것이다.위의 경우 Test 클래스 안에@Override public boolean equals(Object obj) { return (this.getClass().getName().equals(obj.getClass().getName())); }로 오버라이딩 해주면 true가 된다. 간단하게 클래스 이름만 동등한지 확인하는 코드다.Reference https://ifuwanna.tistory.com/282 클래스 이름 출력 https://nesoy.github.io/articles/2018-06/Java-equals-hashcode 클래스 예제 https://steady-coding.tistory.com/534 동등성 동일성 정리" }, { "title": "라이브코테 준비 - 연습문제1", "url": "/posts/banksalad01/", "categories": "Interview", "tags": "Python", "date": "2022-10-01 01:02:00 +0900", "snippet": "어떤 기업의 라이브코테를 봐야했다.메일로 연습문제를 보내줬으므로 풀어보도록 하였다.출처링크문제Problem 77 [Easy]스냅챗에서 출제된 문제입니다.중첩될 수 있는 인터벌들을 갖는 리스트가 있습니다. 중첩되는 인터벌들을 하나로 합친 새로운 리스트를 반환하세요.입력 리스트는 정렬되어 있지 않습니다.예를 들어, [(1, 3), (5, 8), (4, 10), (20, 25)] 가 주어지면, [(1, 3), (4, 10), (20, 25)] 를 반환해야 합니다.먼저 풀고 답을 보니까 고려해야할 사항들 중 하나가 빈 리스트 들어올 수 있다는 것이다.풀이def solution(input): result = [] input.sort() for i in range(len(input)): if result and result[-1][1] &amp;gt;= input[i][0]: result[-1] = (result[-1][0], max(input[i][1], result[-1][1])) else: result.append(input[i]) return resultinput = [(1, 3), (5, 8), (4, 10), (20, 25)]intervals = [(1, 3), (5, 8), (4, 10), (20, 25), (22, 27)]assert solution(input) == [(1, 3), (4, 10), (20, 25)]assert solution(intervals) == [(1, 3), (4, 10), (20, 27)]결과를 리턴할 새로운 배열을 생성하고 그 배열의 끝만 비교하면 된다. 처음에는 result[i-1]로 비교하였지만 연속으로 겹치는 배열이 들어올 경우 result에는 2번 연속 적재되지 않아서 out of range 뜬다. 때문에 Python에서 제공하는 배열[-1]를 통해 끝값을 확인한다. 겹친다는 의미는 다음과 같은 경우가 있을 것이다. 현재 요소가 (4,10)이라고 치면다음 요소가 (3,5)인 경우 즉 x값이 작은 경우 (4,9)인 경우 안쪽에 완벽히 겹친 경우 (9,11)인 경우 다음요소 x가 기존 요소의 y값에 걸쳐진 경우 첫 번째 경우는 정렬을 통해 막을 수 있다. 무조건 x가 작은 요소가 먼저 들어오기 때문이다. 그래서 정렬을 해줬다.두 번째 경우는 요소에 추가하지 않으면 된다.세 번째 경우는 어차피 x는 작은 요소가 들어오게 보장되어있기에 끝 부분만 업데이트 해주면 된다. 다음 요소의 y와 현재 요소의 y를 비교해서 큰 경우는 업데이트를 해주고, 아닌 경우는 현재 값을 수정하지 않는다(두 번째 경우 해소)결론처음에는 빈 리스트가 들어올경우를 생각하지 않고 풀었다. 뿐만 아니라 문제의 첫 예제만 보고 완벽히 포개어진 경우만 생각하였는데, 다음에는 다양한 인풋 예제를 먼저 생각하는 것이 필요할 것 같다." }, { "title": "면접준비 - Java 오버로딩, 오버라이딩", "url": "/posts/TIL0929/", "categories": "Interview", "tags": "Java", "date": "2022-09-28 01:02:00 +0900", "snippet": " 오타, 지적 환영입니다.메소드 시그니처(method signature)오버로딩, 오버라이딩을 공부하기 전에 메소드 시그니처에 대해 알아야한다.메소드 시그니처란 메소드의 선언부에 명시되어 있는 매개변수의 리스트다. 나는 파라미터가 더 이해하기 편해서 파라미터라 하겠다.다음 조건을 만족시 같은 시그니처를 갖는다 메소드 이름 파라미터 수 파라미터 타입의 순서리턴 타입은 포함 하지 않는다고 한다.즉,public class Test{ public int calcu(int x,int y){ return x+y; } public void calcu(int x,int y){ return ; }}는 같은 시그니처를 갖기에 둘 중 하나는 선언할 수 없다.메소드 오버로딩(Method Overloading)그러면 위의 조건에서 메소드 이름은 같지만 파라미터 수나 파라미터 타입의 순서가 바뀌게 선언해도 될까?가능하다. 메소드 오버로딩은 이렇듯 같은 이름의 메소드를 중복하여 정의하는 것을 말한다.public class Test{ public int calcu(int x,int y){ return x+y; } public int calcu(int x){ return x; }}결론단점 비슷한 기능으로 사용하지 않으면 협업시에 혼동을 줄 수 있다.장점 메소드 이름을 몇가지만 기억할 수 있다. (매개변수 형태만 다른것들을 SumInt(), SumLong()이렇게 안 지어도 된다는 것.) 위로 인해서 Sum()으로만 선언할 수 있으므로 메소드 길이가 짧아질 수 있다. 이로인해서 기능을 예측하기가 쉽다. 파라미터를 다양하게 받아서 처리할 수 있다. 결국 코드의 가독성이 향상한다.특이사항오버로딩의 메소드 호출 대상은 컴파일시점에 결정되기에 원하는대로 작동하지 않을 수 있다. 그렇기에 오버로딩은 정적으로 선택된다.Reference https://github.com/jvm-hater/java-study/blob/main/1%EC%A3%BC%EC%B0%A8/%EC%98%A4%EB%B2%84%EB%A1%9C%EB%94%A9%EA%B3%BC%20%EC%98%A4%EB%B2%84%EB%9D%BC%EC%9D%B4%EB%94%A9.md오버라이딩오버라이딩은 상위 클래스가 가지고 있는 메소드들을 하위 클래스에서 재정의하는 것이다.상속 관계에 있는 클래스 간 메소드 재정의를 말한다.조건부모 클래스 메소드와 동일한 시그니처 + 메소드 리턴타입을 가져아한다. 접근지정자 빼고 모든것이 같다고 생각하면 된다. 접근지정자는 부모클래스보다 좁은 범위로는 지정할 수 없다. 부모 클래스의 메서드보다 더 많은 예외를 선언할 수 없다.필요성 오버라이딩을 하지 않고 이름을 짓는다면 다른 메소드를 호출할 위험이 존재하고, 다른 이름을 짓는다는것 자체가 문제다. 추가로 @Override라는 어노테이션을 추가하여 오버라이딩된 메소드라고 명시할 수 있다. 자식 클래스에서 상황에 맞게 오버라이딩 해야하는 경우도 있기에 필요하다.메소드 디스패치메소드 디스패치란 어떤 메소드를 호출할지 결정하여 실제로 실행하는 것을 의미한다.컴파일 시점에 정하는 것을 정적 메소드 디스패치라 하고, 런타임 시점에 정하는 것을 동적 메소드 디스채리라고 한다.정적 메소드 디스패치 컴파일 시점에 어떤 메소드를 호출할지 명확히 알고 있는 경우이다. 컴파일 시 생성된 바이트 코드에도 이 정보가 그대로 남아있다.public class Parent { public void method1(){ System.out.println(&quot;Parent method1입니다&quot;); }}public class Child extends Parent{ @Override public void method1() { System.out.println(&quot;Child method1입니다&quot;); }}public class Main { public static void main(String[] args){ Child child = new Child(); child.method1(); //정적 메소드 디스패치 }}명확하게 인스턴스 타입을 지정하고 @Override로 오버라이딩된 메소드도 알 수 있다. 이와 같은 예시를 말한다.다이나믹 메소드 디스패치 동적 메소드 디스패치는 컴파일 시점에 어떤 메소드를 호출할 지 몰라서 런타임때 정하는 것을 말한다.public class Dispatch { static abstract class Service { abstract void run(); } static class MyService extends Service { @Override void run() {//(1) System.out.println(&quot;MyService.run()&quot;); } } static class YourService extends Service { @Override void run() {//(2) System.out.println(&quot;YourService.run()&quot;); } } public static void main(String[] args) { Service service = new MyService(); // = new MyService() 부분을 무시하고 아래 코드만 본다고 하자 service.run(); }}부모 클래스이자 추상 클래스인 Service 타입을 선언하고 run()을 호출하여 컴파일 시점에는 어떤 메소드가 수행될 지 알수 없다. 하지만, 예상하듯이 (1)의 함수가 호출될 것인데, 이때 발생하는 것이 동적 메소드 디스패치이다.어떻게 이런 방식이 가능하냐면 run()메소드 호출당시 receiver parameter가 전달되는데 이는 클래스의 this에 해당되는 Object이다. 그래서 MyService가 전달되고 (1)이 호출된다.Refrence https://github.com/jvm-hater/java-study/blob/main/1%EC%A3%BC%EC%B0%A8/%EC%98%A4%EB%B2%84%EB%A1%9C%EB%94%A9%EA%B3%BC%20%EC%98%A4%EB%B2%84%EB%9D%BC%EC%9D%B4%EB%94%A9.md https://doompok.tistory.com/21 동적 메소드 디스패치 https://ttl-blog.tistory.com/776?category=916885 메소드 디스패치" }, { "title": "면접준비 - Java JVM(1)", "url": "/posts/TIL0928/", "categories": "Interview", "tags": "Java", "date": "2022-09-28 01:02:00 +0900", "snippet": " 오타, 지적 환영입니다.JVM 이란 무엇인가? JVM은 JAVA Virtual Machine의 약자. 자바 가상 머신이란 뜻이다. 가상 머신은 프로그램 실행 등을 위해 물리적 머신과 비슷하게 소프트웨어로 구현한 것이다. JVM의 목적은 클래스 로더를 통해 자바API와 함께 자바 애플리케이션을 실행하는 것. JVM은 OS와 JAVA사이에 중개자 역할을 한다. 중간에서 자바 바이트코드를 읽는다. JVM은 따라서 OS에 구애받지 않고 자바 애플케이션을 실행할 수 있고, 그 외에 GC, 메모리 관리의 역할도 한다. JVM은 스택 기반의 가상머신이다. ARM 아키텍쳐 같은 하드웨어는 레지스터 기반으로 동작하는데 JVM은 스택으로 동작한다고 한다. 왜 그럴까?JVM은 왜 스택기반 가상머신일까스택기반 VM의 장단점.장점 하드웨어(레지스터, CPU)에 직접적으로 다루지 않아 하드웨어에 덜 의존적이다. 피연산자들은 TOP에 존재하여 피연산자의 메모리 주소를 사용할 필요가 없어서 명령어의 길이가 짧아짐.단점 명령어의 수가 많아짐. POP, PUSH 이런 명령어를 자주 사용해야하므로. 스택을 사용하면 오버헤드가 존재한다. 명령어 최적화가 힘듦레지스터기반 VM의 장단점장점 명령어 수가 적다. 오버헤드의 부담이 상대적으로 덜하다 명령어 최적화가 가능. (연산결과를 레지스터에 넣어서 사용이 가능)단점 피연산자의 메모리 주소를 적어줘야 하기에 명령어의 크기가 커짐.결론개인적인 생각으로 JVM의 목적은 하드웨어에 종속되지 않는것이므로 스택기반의 VM을 사용하는것이 어찌보면 당연할 수 있다. 레지스터 기반으로는 레지스터 갯수, 사이즈 등에 의존할 수 밖에 없기 때문이다.JVM을 알아둬야 하는 이유는 메모리를 잘 관리하기 위해서는 메모리를 직접적으로 관리하는 JVM에 대해 알아야한다.자바프로그램 실행과정 JVM은 OS로부터 자바프로그램이 할당받을 메모리를 요청하여 받는다. JVM은 용도에 따라 이 메모리를 나눠 관리한다. 자바 컴파일러가 자바 소스코드를 자바 바이트 코드로 변환함 (.java -&amp;gt; .class) Class Loader가 .class파일을 JVM로 로딩한다. 로딩된 .class파일은 Execution engine에 의해 해석된다. 해석된 바이트 코드들은 Runtime Data Area에 배치되어 실질적인 수행이 이루어짐.Class Loader(클래스 로더)애플리케이션 실행중 필요할때마다 동적으로 Java 클래스들을 로드한다.클래스 로더에는 로딩, 링크, 초기화 단계로 나뉘어져 있다.로딩자바 바이트 코드(.class)파일을 메소드 영역에 저장하고, 각 자바 바이트 코드 JVM에 의해 메모리 영역에 다음정보를 저장한다. 로드된 클래스, 로드된 클래스의 부모 클래스 정보 클래스 파일과 Class, Interface, Enum등 정보 변수나 메소드 정보링크 검증 : 읽어들인 클래스와 자바 언어 명세 및 JVM 명세된 대로 구성되어있는지 검증. 준비 : 클래스가 필요로 하는 메모리를 할당하고, 클래스들에서 정의된 필드, 메소드 등을 나타내는 데이터구조를 준비 분석 : 심볼릭 메모리 레퍼런스를 메소드 영역에 있는 실제 레퍼런스로 교체초기화 초기화 : 클래스 변수들을 적정한 값으로 초기화. static필드들이 설정된 값으로 초기화종류클래스 로더에는 종류가 있다. 부트스트랩 클래스 로더 : JVM 시작 시 가장 최초로 실행되는 클래스 로더. 자바 클래스를 로드할 수 있는 자바 자체의 클래스 로더와 최소한의 클래스(java.lang.Object, Class, ClassLoader)만을 로드. 확장 클래스 로더 : java.ext.dirs 환경 변수에 설정된 디렉토리의 클래스 파일들을 로드. 시스템 클래스 로더 : 개발자가 지정한 Classpath에 있는 클래스 파일 혹은 jar에 속한 클래스들을 로드.클래스 로더가 지켜야할 세 가지 원칙 위임원칙 : 리소스를 찾기 위해 요청을 받았을때 상위 클래스 로더에게 책임을 위임. (부트스트랩 클래스로더 -&amp;gt; 확장 클래스로더 -&amp;gt; 시스템 클래스로더) 가시 범위 원칙 : 하위 클래스 로더는 상위 클래스 로더가 로드한 클래스를 볼 수 있지만, 상위 클래스 로더는 하위 클래스 로더가 로드한 클래스를 볼 수 없다. 유일성 원칙 : 하위 클래스 로더가 상위 클래스 로더에게 로드한 클래스를 다시 로드하지 않아야 한다는 원칙동적 클래스 로딩런타임에 동적으로 클래스를 로딩한다는 것은 JVM이 미리 모든 클래스에 대한 정보를 메소드 영역에 로딩하지 않는다는 것을 의미.종류와 과정 실습 코드는 링크를 참고.Execution Engine(실행 엔진)클래스를 실행 시키는 역할. 클래스 로더가 JVM내의 런타임 데이터 영역에 바이트 코드를 배치시키고, 실행엔진에 의해서 실행됨. 바이트 코드 자체는 기계어가 아니기에 실행 엔진이 바이트 코드를 JVM내부에서 기계가 알 수 있는 형태로 변경. 두 가지 방식이 있음.인터프리터 방식인터프리터 방식은 원시 코드를 바로 실행하는 프로그램 또는 환경을 말한다. 바로 실행한다는 것은 컴파일러와 달리 명령어를 한번에 한 줄씩 읽어서 실행하는 프로그램이다. 인터프리터는 고급 명령어들을 중간 형태로 번역한 다음 그대로 실행해버린다는 특징을 가지고 있다. 하지만 컴파일된 프로그램들에 비해 일반적으로 느리지만 컴파일을 거칠 필요가 없어서 프로그램의 크기가 커지면 커질수록 컴파일된 프로그램보다 빠르게 동작할 수 있다는 장점이 있다.JIT(Just In Time)인터프리터 방식의 단점을 보완하기 위해 나타난 JIT 컴파일러이다.인터프리터 방식으로 실행하다가 적절한 시점에 바이트코드 전체를 컴파일하여 네이티브 코드로 바꿔버려 인터프리팅을 하지 않고 이후 네이티브 코드를 직접 실행한다.네이티브 코드는 캐시에 보관하기에 한 번 컴파일된 코드는 빠르게 수행이 가능하다.여기서 적절한 시점이란 프로그램 실행 흐름 단위를 실시간으로 추적하고 탐색하는 Tracing JIT도 있고, 메소드들이 얼마나 자주 수행되는지 추적하여 일정 수준이 넘으면 컴파일하는 경우도 있다.JVM Runtime Data AreaJVM의 메모리 영역으로 자바 애플리케이션을 실행할 때 사용되는 데이터들을 적재하는 곳.먼저 스레드가 각자 갖고 있는 3가지 영역에 대해 알아둘 필요가 있다.1. PC Register(스레드 별)스레드가 생성될 때마다 생성되는 공간으로 스레드마다 하나씩 존재한다. 스레드가 어떤 부분을 어떤 명령으로 실행해야할 지에 대한 기록을 하는 부분으로 현재 수행중인 JVM 메모리를 갖음.2. Stack Area(스레드 별)Stack Frame을 저장하여 메소드 안에서 사용되는 값들(지역 변수)들을 임시로 저장하고, 호출된 메소드의 매개변수나 리턴 값 등을 임시로 저장.3. Native Method Stack(스레드 별)자바 프로그램이 컴파일되어 생성되는 바이트 코드가 아닌 기계어로 작성된 프로그램을 실행 시키는 영역. 자바 이외의 언어(C, C++ 등)로 작성된 코드를 실행할 때 할당됨.4. Method Area(Class area, Static area)클래스 정보를 처음 메모리 공간에 올릴 때 초기화 되는 대상들을 저장하기 위한 공간.이 공간에는 Runtime Constant Pool이라는 별도의 관리 영역이 존재. 이는 상수 자료형을 저장하여 참조하고 중복을 막는 역할을 수행. 멤버 변수의 이름, 데이터 타입, 접근제어자 정보 메소드 리턴타입, 이름, 매개변수, 접근제어자 정보 class인지 interface인지 여부 저장가비지컬렉션 관리 대상에 포함.5. Heap(힙 영역)객체를 저장하는 가상 메모리 공간. new 연산자로 생성된 객체와 배열 등을 저장.자바 8버전 이후에는 Permenant Generation 영역이 사라짐.GC에 대해서는 다음 포스팅에서Reference https://steady-coding.tistory.com/593 JVM의 클래스 로더란? https://asfirstalways.tistory.com/158 JVM https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0 인터프리터 위키 https://steady-coding.tistory.com/305 JVM 메모리 구조란? https://hongsii.github.io/2018/12/20/jvm-memory-structure/ JVM 메모리구조" }, { "title": "real-world프로젝트 Spring 시작하기(4) - 회원가입 만들기 전 설정 및 의존성 파일들 설명.", "url": "/posts/realworld_04/", "categories": "Toy, real-world-spring", "tags": "Spring", "date": "2022-09-20 01:02:00 +0900", "snippet": " real-world project 구현 과정 카테고리 보기백엔드 명세서를 보면 Authentication : POST /api/users/login 과 Registration POST /api/users에 겹치는 url이 존재한다. /api/users다.이를 prefix로 해주는 방법이 있을거라 생각해봤다. 1번 @RequestMapping()안에다가 /api/users까지만 적기 2번 application.propeties설정 파일에 설정하기. server.servlet.contextPath=/api 를 적어주면 된다.처음에는 2번의 경우로 했으나, Webconfig에 허용범위설정 등을할 때 내가 계속 prefix를 적어놨다는걸 까먹어서 에러를 많이 발생시켰다. 예를 들어서 WebConfig설정 파일 중 다음과 같은 코드를 적을 수 있다. .antMatchers(&quot;/api/users/**&quot;).permitAll()이 뜻은 ‘/api/users/~~~’로 들어오는 모든것들에 대해 인증없이 요청을 허용한다는 것인데 2번처럼 설정파일에 prefix를 설정해버리면 .antMatchers(&quot;/users/**&quot;).permitAll()로 적어줘야한다. 설정파일의 prefix가 우선이다. 이걸로 몇 번을 해맸고, 굳이 이렇게할거면 API명세는 왜 있겠는가 생각하여 1번 방식으로 바꿔버렸다.그래서 그냥 1번 방법으로 했다. WebConfig에 관해서는 뒤에서 또 다뤄볼 것이다.명세에서 보면 회원가입시 jwt를 이용해서 token도 포함한 객체를 리턴해야하는데 이는 다른 포스팅에서 다루기로 하고 설정을 먼저 보겠다.먼저, 의존성을 살펴보자. 나의 프로젝트 환경이다.Spring : 2.7.3java : 18 dependencies { org.springframework.boot:spring-boot-starter-validation&#39; implementation &#39;org.springframework.boot:spring-boot-starter-security&#39; implementation &#39;org.springframework.boot:spring-boot-starter-web&#39; implementation &#39;org.springframework.boot:spring-boot-starter-test&#39; implementation &#39;org.projectlombok:lombok:1.18.24&#39; implementation &#39;io.jsonwebtoken:jjwt-api:0.11.5&#39; implementation &#39;io.jsonwebtoken:jjwt-impl:0.11.5&#39; implementation &#39;io.jsonwebtoken:jjwt-jackson:0.11.5&#39; annotationProcessor &#39;org.projectlombok:lombok&#39; implementation group: &#39;org.bgee.log4jdbc-log4j2&#39;, name: &#39;log4jdbc-log4j2-jdbc4&#39;, version: &#39;1.16&#39; // inmemory runtimeOnly &#39;com.h2database:h2&#39; testImplementation &#39;org.springframework.boot:spring-boot-starter-test&#39; testImplementation &#39;org.springframework.boot:spring-boot-starter-jdbc:2.7.3&#39; testImplementation &#39;org.springframework.security:spring-security-test&#39;}참고로 이는 더 추가되고 있다.Spring 2.7.3 버전과 java 18을 쓴 건 그냥 최신버전이라 쓴거다.근데 Spring은 .. 설정 부분이 많이 바뀌었더라. 특히 deprecated된 것들 처리하느라 애먹었다.자바와 스프링 설명을 이렇게 해두고 dependencies를 하나씩 뜯어보겠다.spring-boot-stater-security많은것을 포함하고 있지만, 인증을 구현하려면 이 프레임워크가 가지고 있는 것들을 사용해야한다.예를들면 위에서 말한 WebConfig 설정을 해줘서 요청에대해 인가하거나 인가하지 않거나를 정할 수 있다.이 프레임워크를 dependency 하면 모든 요청에 인증이 필요해져서 설정을 따로 해줘야한다.spring-boot-starter-validation대표적으로 @Valid라는 어노테이션을 쓰기위함이다. @Valid는 이름에서도 알 수 있게 검증을 한다. 여기서는 @RequestBody와 함께 쓰여 요청 객체를 검증할 것이다. 검증방식은 객체DTO에 따로 정의해야한다. NotNULL어노테이션을 달거나, @Email 어노테이션을 다는 필드에 맞는 어노테이션을 달아주면 알아서 검증을 해준다.실제 코드에서는 이렇게 쓰인다.public UserResponse signup(@Valid @RequestBody UserSignupRequest userSignupRequest) { return userService.signup(userSignupRequest);}이러면 UserSignupRequest에 검증 방식이 들어있어야한다.@Getter@AllArgsConstructor@Builder@JsonTypeName(&quot;user&quot;)@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.WRAPPER_OBJECT)public class UserSignupRequest { @NotBlank private String username; @Email private String email; @NotBlank private String password;}Json~어노테이션을 무시하길 바란다. 나중에 또 복기할 것이다.이렇게 적어놓으면 username,과 password는 빈 값, null이 들어올 수 없고 email은 Email형식을 지키게 해놓는다. 참고로 @Email 어노테이션은 null을 허용한다.spring-boot-starter-data-jpaJPA를 좀 더 쉽게 다루기 위함이다. 처음에는 공부의 목적으로 쿼리를 직접 작성하여 모든걸 구현할 생각이었지만, 생산성도 크게 줄어들고 자료가 잘 나와있지 않다.. 구글링하면 대부분이 Spring-data-jpa를 기본값으로 쓴다. 순수 jpa를 공부하려면 김영한 선생님의 책을 사야할 것 같다.spring-boot-starter-webWeb과 관련되어있는 프레임워크다. 이를 사용하지 않으면 Filter를 구현할 수 없고, HttpServletRequest, HttpServletResponse 등을 사용할 수 없다. real-world는 Web Application 구현에 목적을 두고 있으니 사용하는게 맞다. 또한 API 호출을 위해선 당연히 사용해야한다.spring-boot-starter-test이 프레임워크를 사용하면 @SpringBootTest와 WebMvcTest 등을 사용할 수 있는데, 향후 코드에서 사용할 것이므로 그때가서 자세히 복기할 것이다.lombok적절한 롬복 사용은 사랑이라는 것을 알았다.jjwt-api:0.11.5jjwt-api는 Claims, 예외처리인 ExpiredJwtException, Jwts, Keys..등 이라는 객체를 가지고 있다. Claims는 토큰에 담는 정보이다. ExpiredJwtException은 토큰을 생성할 때의 지정한 유효기간이 지났는지 확인하고 지났을 경우 예외를 발생시키는 Exception이다. Jwts는 jwt토큰을 builder를 통해 만들거나 parser를 통해 정보를 뽑아내는 객체이다.참고로 parser()는 deprecated되어서 parserBuilder()를 사용해야한다. 이도 애먹었다.아마 많은곳들에서는 0.9버전을 사용하는데 여기는 parser()가 사용가능할 것이다.왜 Deprecated되었는지는 찾아보고 나중에 복기할 때 쓸 수 있으면 쓰겠다.jjwt-impl:0.11.5이거 없으면 에러낸다. 위의 jjwt-api에서 정의되어 있는 Claims의 코드를 까보면 다음과 같이 생성자가 정의 되어있다.public static Claims claims() { return Classes.newInstance(&quot;io.jsonwebtoken.impl.DefaultClaims&quot;);}이는 jjwt-impl에 정의되어있는 클래스를 사용하겠다는 뜻이다.참고로 import되어 있지 않아도 Spring이 친절하게 설명해주므로 걱정하지말라.에러내용io.jsonwebtoken.lang.UnknownClassException: Unable to load class named [io.jsonwebtoken.impl.DefaultClaims] from the thread context, current, or system/application ClassLoaders. All heuristics have been exhausted. Class could not be found. -&amp;gt;&amp;gt;Have you remembered to include the jjwt-impl.jar in your runtime classpath?&amp;lt;&amp;lt;-jjwt-jackson이게 있어야 JJWT가 토큰을 생성할때 자동으로 Jackson 라이브러리를 가져다 JSON매핑을 한다고 한다. 그러므로 이도 필요한것. 이게 없으면 또 에러난다.이는 JSON에 대해서 에러가 나는게 아니고, Serializer를 못해서 나는 에러같다. 토큰을 만들때 compact()함수를 호출해야하는데, 이 부분에서 Serializer를 하기 때문이다.커스텀으로 따로 구현하거나 맞는 구현체를 끼워넣으라고 한다.에러내용Unable to find an implementation for interface io.jsonwebtoken.io.Serializer using java.util.ServiceLoader. Ensure you include a backing implementation .jar in the classpath, for example jjwt-impl.jar, or your own .jar for custom implementations.implementation group: ‘org.bgee.log4jdbc-log4j2’, name: ‘log4jdbc-log4j2-jdbc4’, version: ‘1.16’log4j와 jdbc를 연결하여 만들어진 오픈소스 프로젝트로, DB관련 로그를 수집하거나 필터링해서 필요한 로그만 출력한다. 파일로 로그를 남길 수도 있다. 필요없다면 빼도 된다.testImplementationtestImplementation는 테스트 코드를 수행할 때만 적용하는 라이브러리다.여기서 새로 등장하는건 spring-security-test이다.spring-security-test아직 공부중이다. 통합테스트를 진행한다고 할 때 유저 인증은 어떻게 할것인가? 필터는 어떻게 적용되고? 이를 테스트하기 위한 환경을 구축하는데 도와주는 하위 프레임워크다.임시로 인증을 하거나 인증을 무시할 수도 있다.여러 테스트환경을 구축할 수 있게 도와준다. 이거 나중에 진짜 골머리 아프다. 현재 이 프로젝트는 vue.js + vite + vuex + Spring boot, Spring Data JPA + Spring Security 를 이용하여 real-world 데모버전을 제작완료하였습니다. https://github.com/kkminseok/real-world-springboot" }, { "title": "real-world프로젝트 Spring 시작하기(3) - AutoTest gitAction적용, 설명", "url": "/posts/realworld_03/", "categories": "Toy, real-world-spring", "tags": "Spring", "date": "2022-09-15 02:02:00 +0900", "snippet": " real-world project 구현 과정 카테고리 보기저번 포스팅때 API구현을 한다고 하였지만, 이미 구현한 상태에서 느끼기엔 언젠가 Git Action을 쓸 거 지금 미리쓰면 좋다고 생각하였다.이게 선행되어야된다고 생각하고 만약 다시 만든다면 CI구축을 할 것이므로 API구현보다 빠른 순서에 넣었다.간단한 GitAction에 대해서는 큰 공부 필요없이 도큐읽고 작성하면 된다.템플릿도 제공하고 있으니.. 참고하자.먼저 코드를 보면name: auto test javaon: push: branches: [ &quot;master&quot; ]jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - name: Setup Java JDK uses: actions/setup-java@v3.5.0 with: distribution: &#39;temurin&#39; java-version: &#39;18&#39; - name: Grant execute permission gradlew run: chmod +x gradlew - name: Build run: ./gradlew build -x test - name: Test run: SPRING_PROFILES_ACTIVE=[test] ./gradlew test - name: Publish Test Results uses: EnricoMi/publish-unit-test-result-action@v2 if: always() with: junit_files: &quot;build/test-results/test/**/*.xml&quot;위에서 부터 하나씩 공부해보았다. name : 작성하지 않아도 된다. 이 전체 흐름인 워크플로우의 이름이다. 공식문서에 따르면 작성을 하지 않으면 root기준의 파일경로가 워크플로우의 이름이 된다고 한다. 작성시에는 on:push:branches : 워크플로우가 작동하는 이벤트를 정의하는 구문이다. on이 달려있으면 그 뒤에는 트리거 역할을 한다. 뒤에 있는 push와 branches는 트리거를 작동시키는 조건인 것이다. 위의 코드에서는 마스터 브런치가, push했을때 이 트리거를 작동시키게 설정해놨다. jobs : workflow가 작동시킬 일들을 정의한다. 따로 지정하지 않으면 병렬적으로 수행된다고 한다. 해당 프로젝트에서는 여러 job을 지정하지 않을것이므로 알아만 두었다. build : build는 문법이 아니다. 보통 당연하게 jobs:build:~로 해놔서 여기까지 문법인줄 알았는데 그게 아니고 job의 unique한 이름이다. 즉, build라는 이름을 지정해준것. 그래서 build라고 지정하지 않고 realworld_test로 지정해보았다. 느낌이 확 온다. runs-on : 간단하게 구동될 환경을 설정한다. 윈도우, 맥환경도 가능하다. 보통 리눅스환경에서 돌리므로 ubuntu-latest로 지정하였다. steps : 앞으로 지정해줄 연속적인 task들을 말한다. run이라는 명령어를 통해 task들을 만들 수 있다. 모든 run들이 동작하지 않을 수 있지만, 모든 run들은 steps안에서 실행되어야 한다. 당장 위의 코드만 봐도 run이 없는 steps들이 있다. uses : 공용 레퍼지토리, 공개된 다른 사람들의 작업단위를 가져다 실행시킬 수 있게 한다. {소유자}/{저장소명}@{참조자} 등의 문법으로 사용할 수 있다. 위의 경우 uses: actions/checkout@v3uses: EnricoMi/publish-unit-test-result-action@v2 이렇게 쓰인 두개를 보면, 소유자는 action, EnricoMi이고 저장소명은 checkout과 publish-unit-test-result-action으로 확인할 수 있다. 또한 참조자는 v3과 v1인데 배포된 주요 버전명 및 브랜치를 넣을 수 있다. 그래서 실제로 https://github.com/EnricoMi/publish-unit-test-result-action에 접근하면 저 레포지토리를 확인할 수 있다. with : with은 위의 uses를 사용할 때 필요한 인풋값들을 설정할 수 있게 한다.위의 코드에서with: distribution: &#39;temurin&#39; java-version: &#39;18&#39;의 의미는 저바 버전을 18로 맞추고 Eclipse Temurin저장소에서 jdk를 받아올 것을 알려주는 것이다.☝️ETC이제 남은 구문들에 대한 간단한 해석을 해볼 것이다.run: SPRING_PROFILES_ACTIVE=[test] ./gradlew test는 왜 작성하였나면, 이를 작성하지 않는다면 Spring Test를 Github에서 실행할 때 DataBase Connect을 찾지 못해서 에러가 뜬다.왜지? profile이 뭔데? 이를 이해하기 위해서 스프링 부트 공식 문서를 살펴보았다.https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.profiles?? 무슨 test환경을 분리한다는데..그럴려면 test파일을 작성해야한다고 했다. 근데 난 test파일을 작성한 적이 없다.spring.profiles.active=test이런 구문을 짜야한다는데 나는 이런 구문을 작성한 적이 없다. 근데 된다?그래서 코드를 지워보고 다시 action을 돌려봤다.잘 된다?생각해보았다. 왜 이 코드가 필요 없었는지처음에 커넥션 즉, 데이터베이스 관련 설정을 못찾아서 테스트가 오류가 났다.그래서 tests폴더안에 appliation.properties를 작성하여 데이터베이스 관련 설정을 삽입하였다.# H2spring.jpa.database-platform=org.hibernate.dialect.H2Dialectspring.jpa.hibernate.ddl-auto=createspring.jpa.properties.hibernate.format_sql=truespring.jpq.show-sql=true#secretreal-world.token.expiry=3000000real-world.token.key=realworldPostGreSQL0132474654564564213131d31vfxvjfijkjdks그리고 gitAction에 spring boot Profile 관련 코드를 넣었다.그랬더니 되었다.즉, 이미 appplication.properties를 작성한 시점부터 되는거였다.깃 액션을 작성할 당시 https://jane514.tistory.com/4이 블로그를 참조하여 작성하였는데, 무분별하게 작성하니까 불필요한 코드를 삽입하게 된 것이다.아직 공부가 더 필요하겠지만 그렇다.때문에 바뀐 코드는name: auto test javaon: push: branches: [ &quot;master&quot; ]jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - name: Setup Java JDK uses: actions/setup-java@v3.5.0 with: distribution: &#39;temurin&#39; java-version: &#39;18&#39; - name: Grant execute permission gradlew run: chmod +x gradlew - name: Build run: ./gradlew build -x test - name: Test # run: SPRING_PROFILES_ACTIVE=[test] ./gradlew test run: ./gradlew test - name: Publish Test Results uses: EnricoMi/publish-unit-test-result-action@v2 if: always() with: junit_files: &quot;build/test-results/test/**/*.xml&quot;가 될 것이다.다음 구문은 이것이다.- name: Publish Test Results uses: EnricoMi/publish-unit-test-result-action@v2 if: always() with: junit_files: &quot;build/test-results/test/**/*.xml&quot;이 구문인데, 이는 저기 명시된 저장소에 문법이 설명되어 있다.if: alway() : 이 구문은 앞의 steps들에서 실패가 나도 무조건 실행하도록 보장하는 코드라고 한다.with:junit_files: &quot;build/test-results/test/**/*.xml&quot; : with에 대해서는 위에서 설명했다. 여기서 junit_files:~구문은 junit_files라는 변수를 생성하고 저 값을 넣어서 uses의 인풋에 전달한다는 의미이다.여기서 설정해줘야할것이 있는데, 뒤에 있는 build~는 실제 사용하는 path여야한다.내 프로젝트의 경우, junit을 통해 test를 실행하면 build/test-results/test/binary/??.xml에 쌓인다. 이 경로를 적어줘야한다. 설정에 따라 다를것이므로 잘 확인해서 써야한다.만약 제대로된 경로를 적지 않았을 경우처럼 Could not find any files for 본인이 작성한 Path가 뜨고, Test Results에는 아무것도 수행되지 않을 것이다.더욱 무서운 점은 이 테스트가 ☑️가 뜨며 성공으로 뜬다는 것이다. 그러므로 주의가 필요하다.Next다음은 User Singup관련 서비스들을 작성해볼 것이다.Reference https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions gitaction 공식문서 https://github.com/EnricoMi/publish-unit-test-result-action junit gitaction ui관련 저장소 https://jane514.tistory.com/4 java gitacion 관련 현재 이 프로젝트는 vue.js + vite + vuex + Spring boot, Spring Data JPA + Spring Security 를 이용하여 real-world 데모버전을 제작완료하였습니다. https://github.com/kkminseok/real-world-springboot" }, { "title": "real-world프로젝트 Spring 시작하기(2) - DDD입문 프로젝트 구조 설정.", "url": "/posts/realworld_02/", "categories": "Toy, real-world-spring", "tags": "Spring", "date": "2022-09-15 01:02:00 +0900", "snippet": " real-world project 구현 과정 카테고리 보기나는 당연하게도 웹 애플리케이션 제작이고, 배운게 간단한 3-tier 아키텍처라, Repository, Service, Controller로 분리하였다.근데 Real-world의 다른 데모앱들은 프로젝트 구조를 거의 도메인 중심으로 가져갔다.이때까지는 이해못했다. 왜 저렇게 했을까?대신에 개발을 하면서 계속 생각해보기로 했다. 저 구조가 가지는 장점이 도대체 뭘까? 하니까 느껴졌다.현재 User의 CR**만 작성했는데도 뭔가 한계가 느껴졌다.접근성이 떨어짐.만약 UserService를 보고 있다가 UserRepository에 수정사항이 생겼다면 /repository 디렉터리에 가서 확인해야한다. 이거 여간 불편하지않았다.현재는 User에 관한 서비스밖에 없지만, 점점 프로젝트가 커지면 tag, comment, article, 등 더 생길것이다.이것 또한 문제가 되는게 만약 comment에 대한 레포지토리를 찾아야하기에, 내 의식은 전부 comment에 대한 집중과 논리로 가득한 상태일 것이다. 근데 갑자기 tagRepository 보이고 articleRepository 보이면 생각의 흐름을 깨버린다. 내 머릿속에 갑자기 if문이 들어와서 가지고 있던 집중과 논리가 깨진다는 것이다. 그래서 내가 다시 흐름을 잡아야한다는 문제가 생긴다.이는 마찬가지로 테스트에도 작동된다.그래서 나는 프로젝트 구조를 바꾸기로 결심하였다.real-world 데모앱들의 구조를 참고하여 바꾸기로 했다.intellij가 편하게 파일을 옮겨도 리팩터링을 자동으로 해주므로 큰 시간이 걸리지 않았다.아직 개선해야할 점이 있다.DTO안에 userResponse, userRequest, userDto라는 세 가지로 분리된 객체들이 있다.real-world 코드를 보니 이를 하나의 모듈에서 관리할 수 있게 짤 수 있었다.이미 정답지를 보고 짜는건 나에게 도움이 되지 않을것이니, 이것도 부딪혀가면서 수정이 필요할때 고치려고 한다.이번에는 프로젝트 구조에 대해 한계를 느끼고 이를 리팩터링을 진행하였다.다음에는 Global Exception, User Singup(회원가입) 서비스 구현과정에 대해 적으려고 한다. 겪은 트러블 슈팅에 대해서도 이야기할 것이고 당연히 테스트코드도 포함이다. 글이 너무 길어지면 두 개로 잘라서 쓸 것이다. 현재 이 프로젝트는 vue.js + vite + vuex + Spring boot, Spring Data JPA + Spring Security 를 이용하여 real-world 데모버전을 제작완료하였습니다. https://github.com/kkminseok/real-world-springboot" }, { "title": "real-world프로젝트 Spring 시작하기(1) - real-world란?", "url": "/posts/realworld_01/", "categories": "Toy, real-world-spring", "tags": "Spring", "date": "2022-09-13 01:02:00 +0900", "snippet": " real-world project 구현 과정 카테고리 보기먼저 우아한형제 리얼월드 글에서 글을 읽어보면 이해하기 편하다.나는 저 글을 읽고 시작할때 어떻게 해야할지 감을 못잡았다.현재 리얼월드를 Spring + boot + JPA + thymeleaf 템플릿엔진 + js (Axios or Ajax)로 구현할 예정이다.기술스택은 바뀌겠지만 내가 이 기술들을 채택한 이유를 적자면.. Spring 공부를 하고싶어서 JPA 공부를 하고 싶어서- thymeleaf의 경우는 현재 이 기술로 올라온 데모앱이 없어서 .. 컨트리뷰션하고 싶어서 사용하게 되었다.- js랑 Ajax, Axios는 내 기준 어쩔 수 없이 채택하였다. thymeleaf에서 form으로 데이터를 넘기면 ContentType이 &#39;application/x-www-form-urlencoded로 고정되어버리는데, 이를 해결하기 위해서는 일반적인 방법으론 불가능해서이다. 그래서 임의로 지정할 수 있는 Ajax를 선택했다.해당 기술스택을 사용하지 않기로 했다.이유는 thymeleaf는 템플릿엔진이고, 결국 클라이언트와 API로 상호작용을 하려면 클라이언트에도 서버를 둬야한다는 것이다.막힌 부분이 BackEnd 명세에는 JSON으로 응답을 주고받아야하는데, 응답을 하면 thymeleaf에서를 이를 처리하지 못한다. 데이터를 받고 해당 데이터를 가지고 페이지 이동을 해야하는데, thymeleaf는 한계가 있다는 것. Axios이든 Ajax든 통신에만 신경쓰지 결과값에는 신경쓰지 않는다. 결국 홈페이지를 이동하고 받아온 값들의 상태를 저장하는건 순수 js로 처리해야한다는것.순수js로 처리가 가능하지만 이는 데모앱을 작성하는 의미가 없다. 굳이 클라이언트에 서버를 안 두고 상태값을 계속 들고다닐 필요가 없다는것이다.아무튼..저 글을 통해 리얼월드 감을 잡았다면 시작하기 위해선 어떻게 해야할까?필자의 real-world링크1. Real World github 방문https://github.com/gothinkster/realworld에 접속하게 되면 여러 폴더들이 있다.여기서 필요한건 /api 폴더에 있는 것들이다.postman에서 Collections이라는 것을 등록할 수 있는데 이는 모든 API를 테스트할 수 있게 도와주는 기능이다.이것까지 설명하기엔 글의 범위를 벗어나기도하고 나도 쓰는 방법을 완벽히 알지는 못하므로..구글링 해야한다.그러므로 저 폴더에 있는 것들을 받아서 postman에 등록하면 된다.2. Backend, Frontend 명세 확인https://realworld-docs.netlify.app/docs/intro에 들어가서 Spec이라는 곳을 들어가면 API명세를 볼 수 있다.이제 이 명세대로 그냥 시작하면 된다.나는 FullStack으로 개발할 것이므로 https://demo.realworld.io/#/라는 곳에 들어가서 validation 및 기능동작도 확인해서 개발해야한다.다음글은 내가 설정한 초기셋팅에 대해서 설명할 예정이다. 현재 이 프로젝트는 vue.js + Spring boot, Spring Data JPA 를 이용한 풀스택개발, 컨트리뷰션에 목표를 두고 있습니다. https://github.com/kkminseok/real-world-springboot" }, { "title": "Intellij에서 Spring framework추가하기 (Add Frameworks에 없을 때)", "url": "/posts/Intellij_spring/", "categories": "Java, Spring_CS", "tags": "Spring", "date": "2022-09-07 01:02:00 +0900", "snippet": "이렇게 그냥 빈 프로젝트를 생성했을때 Spring Frame work을 추가하고 싶을때가 있다.아니면 아차 싶어서 못했을때 프로젝트를 다시 파는 삽질을 하는 사람도 있을것이다.보통 프로젝트 상단 우클릭에서 Add Frameworks Support를 클릭하여 프레임워크를 찾는 경우가 있다.보통 여길 누르면 SpringFramework가 뜨는 데 뜨질 않는다.이럴경우 따로 등록해줄 수 있는데프로젝트 상단 우클릭에서 Open Module Settings -&amp;gt; Libraries에 들어간다.그리고 +버튼을 누른다.여기서 검색할 수 있는 창이 뜨는데, 나는 Spring-mvc를 쓸 것이므로 spring-mvc를 찾는다.그리고 다 OK OK OK하면 설정한 라이브러리를 다운받는다.빨간줄도 안 쳐지고 import도 잘 해온다. 성공.이 방식으로 통해서 매 번 받아오는건 곤란하므로 그냥 Add Frameworks Support에서 maven을 추가하고 pom.xml을 작성하는것도 방법이다." }, { "title": "Baekjoon11660 - 구간 합 구하기 5 (Python)", "url": "/posts/baekjoon11660/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon", "date": "2022-09-01 01:02:00 +0900", "snippet": "백준 사이트 11660 - 구간 합 구하기 5 문제입니다. 이 글을 보시기 전에 문제를 풀기 위해 충분한 생각을 하셨나요? 답을 안 보고 푸는게 최대한 고민하는게 가장 중요하다고 생각합니다.!!☑️ 1. 문제https://www.acmicpc.net/problem/11660☑️ 2. Input , Output☑️ 3. 분류 및 난이도solved.ac class 4 문제입니다.☑️ 4. 생각한 것들 수학 + DP문제입니다. 크게 어렵지 않습니다. 어떻게 시간을 줄일 수 있을지가 관건인 문제입니다. 입력을 받는데, 기존 맵은 쓰일 일이 없고 그들의 합이 쓰일테니까 그들의 합으로 초기화 해줍니다. 행과 열이 정해져있으면 항상 그 구간의합 모양은 맵에서 봤을때 사각형이므로 가로 세로를 어떤방식으로 구할지 생각만 하면 됩니다.5. codefrom sys import stdindef row_sum(row: list) -&amp;gt; list: for i in range(1, len(row)): row[i] += row[i - 1] return rowdef solution() -&amp;gt; None: n, m = map(int, stdin.readline().split()) maps = [] for i in range(n): row = list(map(int, stdin.readline().split())) row = row_sum(row) maps.append(row) for j in range(m): x1, y1, x2, y2 = map(int, stdin.readline().split()) result = 0 for x in range(x1 - 1, x2): if y1 - 2 &amp;lt; 0: result += maps[x][y2 - 1] else: result += maps[x][y2 - 1] - maps[x][y1 - 2] print(result)solution()6. 후기 이문제를 토대로 Gold1 달성 c++로 작성이 필요하거나 도움이 필요하시면 댓글을 작성해주세요.!! 기록용이라 설명이 자세하지 않습니다." }, { "title": "Baekjoon5430 - AC (Python)", "url": "/posts/baekjoon5430/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon", "date": "2022-08-31 02:02:00 +0900", "snippet": "백준 사이트 5430 - AC 문제입니다. 이 글을 보시기 전에 문제를 풀기 위해 충분한 생각을 하셨나요? 답을 안 보고 푸는게 최대한 고민하는게 가장 중요하다고 생각합니다.!!☑️ 1. 문제https://www.acmicpc.net/problem/5430☑️ 2. Input , Output☑️ 3. 분류 및 난이도solved.ac class 3 문제입니다.☑️ 4. 생각한 것들 당연하겠지만 ‘R’명령어로 기본 내장라이브러리인 reverse를 호출하는건 바보같은 짓입니다. 시간초과 나겠지요. 그냥 R이 홀수번나왔냐 짝수번 나왔냐 체크만 해주면 됩니다. 나머지는 어렵지 않습니다. 저는 특이하게 deque의 특성을 이용해서 앞 뒤로 자유자재로 빼줬습니다. 이 문제는 오답률이 굉장히 높은데, 문제에 적혀있지 않은.. 여러 입출력 문제들 때문에 사람들이 곤욕을 치룬것 같습니다. 무조건 D명령어에 대해서만 ‘error’를 발생시켜야합니다. 즉 빈 배열이라해도 R명령어를 하면 []를 출력해야합니다. 그리고 Python은 list를 그대로 출력하면 숫자사이에 공백에 붙습니다. 이렇게도 출력하면 안되고 공백들을 제거한 상태로 출력해야합니다. 이것저것 추가하다보니 더티코드가 되었습니다.5. codefrom collections import dequefrom sys import stdindef solution() -&amp;gt; None: t_case = int(stdin.readline()) for _ in range(t_case): func = stdin.readline().rstrip(&#39;\\n&#39;) size = int(stdin.readline().rstrip(&#39;\\n&#39;)) data_list = stdin.readline().rstrip(&#39;\\n&#39;).strip(&quot;[]&quot;) if data_list: data_list = deque(map(int, data_list.split(&#39;,&#39;))) # cnt == True -&amp;gt; R이 짝수번 cnt = True error = False for i in range(len(func)): if func[i] == &#39;R&#39;: cnt = not cnt else: if cnt: if data_list: data_list.popleft() else: print(&#39;error&#39;) error = not error break else: if data_list: data_list.pop() else: print(&#39;error&#39;) error = not error break if not error: if cnt: print(&#39;[&#39; + &#39;,&#39;.join(map(str, data_list)) + &#39;]&#39;) else: print(&#39;[&#39; + &#39;,&#39;.join(map(str, list(reversed(data_list)))) + &#39;]&#39;)solution()6. 후기 c++로 작성이 필요하거나 도움이 필요하시면 댓글을 작성해주세요.!! 기록용이라 설명이 자세하지 않습니다." }, { "title": "Baekjoon7662 - 이중 우선순위큐 (Python)", "url": "/posts/baekjoon7662/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon", "date": "2022-08-31 01:02:00 +0900", "snippet": "백준 사이트 7662 - 이중 우선순위큐 문제입니다. 이 글을 보시기 전에 문제를 풀기 위해 충분한 생각을 하셨나요? 답을 안 보고 푸는게 최대한 고민하는게 가장 중요하다고 생각합니다.!!☑️ 1. 문제https://www.acmicpc.net/problem/7662☑️ 2. Input , Output☑️ 3. 분류 및 난이도solved.ac class 3 문제입니다.☑️ 4. 생각한 것들 당연하게도 brute하게 접근하면 시간초과가 나옵니다. max,min에 대한 heap을 가지고 있어야하는데, 각각 데이터를 뺄때나 더할때나 동일한 값을 가지고 있어야합니다. 이것을 해결하는게 이 문제의 핵심입니다. 중복으로 값이 들어올 수도 있으므로, dictionary를 통하여 상태를 관리합니다. 뺄때의 while문은 이전 루프에서 루트값을 제거한 경우를 해결하기 위해 넣은것입니다. 예를들면 max_heap,min_heap이 7,7,-8 두 개의 값을 가지고 있고 D 1라는 두번의 명령으로 빼면 max_heap은 -8만 남은 값이 되고, dic[7] = 0이 될 것입니다. 만약 여기서 D -1 명령어 두 번을 통해 최소값을 두 번 뺀다고 하면 처음에는 min_heap에는 여전히 7,7이라는 숫자가 남게 되는데, 두 번째 명령어를 실행할땐 dic[root]는 0인데, 7,7이라는 숫자가 있기에 그 차이만큼 계속 빼주는 것입니다. 마지막 while문도 동일한 방식으로 생각하면 됩니다.5. codefrom heapq import heappop, heappushfrom sys import stdindef solution() -&amp;gt; None: t = int(stdin.readline()) for i in range(t): command_count = int(stdin.readline()) max_heap = [] min_heap = [] dic = {} for _ in range(command_count): command, data = map(str, stdin.readline().split()) data = int(data) if command == &#39;I&#39;: heapq.heappush(max_heap, -data) heapq.heappush(min_heap, data) if data in dic: dic[data] += 1 else: dic[data] = 1 else: if data == -1: while min_heap: root = heappop(min_heap) if dic[root] != 0: dic[root] -= 1 break else: while max_heap: root = -heapq.heappop(max_heap) if dic[root] != 0: dic[root] -= 1 break while max_heap and dic[-max_heap[0]] == 0: heapq.heappop(max_heap) while min_heap and dic[min_heap[0]] == 0: heapq.heappop(min_heap) if max_heap: print(-max_heap[0], min_heap[0]) else: print(&quot;EMPTY&quot;)solution()6. 후기 어렵습니다. c++로 작성이 필요하거나 도움이 필요하시면 댓글을 작성해주세요.!! 기록용이라 설명이 자세하지 않습니다." }, { "title": "Baekjoon1074 - Z (Python)", "url": "/posts/baekjoon1074/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon", "date": "2022-08-25 03:02:00 +0900", "snippet": "백준 사이트 1074 - Z 문제입니다. 이 글을 보시기 전에 문제를 풀기 위해 충분한 생각을 하셨나요? 답을 안 보고 푸는게 최대한 고민하는게 가장 중요하다고 생각합니다.!!☑️ 1. 문제https://www.acmicpc.net/problem/1074☑️ 2. Input , Output☑️ 3. 분류 및 난이도solved.ac class 3 문제입니다.☑️ 4. 생각한 것들 재귀는 어렵습니다.. 이 문제는 브루트포스하게 풀면 당연하게도 시간초과가 납니다. 일정 규칙을 발견해야하는데, 막상 발견하고나면 아무것도 아니지만 발견하기까지 생각하기가 어려웠습니다. 전체 크기를 N * N이라고 했을때 1사분면에 있는것은 N//2 * N//2 안에 있으면 됩니다. 2사분면에 있는것은 N//2 * (N//2 ~ N) 안에 있으면 됩니다. 3사분면에 있는것은 (N//2 ~ N) * N//2 안에 있으면 됩니다. 4사분면에 있는것은 (N//2 ~ N) * N//2 ~ N) 안에 있으면 됩니다. 이를 반복하여 위치를 찾는 코드를 만듭니다.5. codefrom sys import stdindef solution(): n, r, c = map(int, stdin.readline().split()) size = 1 for i in range(n): size *= 2 result = x = y = 0 while size != 0: size //= 2 if r &amp;lt; x + size and c &amp;lt; y + size: result += 0 elif r &amp;lt; x + size and c &amp;gt;= y + size: result += size * size * 1 y += size elif r &amp;gt;= x + size and c &amp;lt; y + size: result += size * size * 2 x += size else: result += size * size * 3 x += size y += size if size == 1: print(result)solution()6. 후기 어렵습니다. 저도 참고하면서 풀었는데, 막상 알고나니 별 거 아닙니다. 그래서 Sliver1난이도 같습니다.. 알면 풀고 모르면 못푸는.. c++로 작성이 필요하거나 도움이 필요하시면 댓글을 작성해주세요.!! 기록용이라 설명이 자세하지 않습니다." }, { "title": "Baekjoon1992 - 쿼드트리 (Python)", "url": "/posts/baekjoon1992/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon", "date": "2022-08-25 02:02:00 +0900", "snippet": "백준 사이트 1992 - 쿼드트리 문제입니다. 이 글을 보시기 전에 문제를 풀기 위해 충분한 생각을 하셨나요? 답을 안 보고 푸는게 최대한 고민하는게 가장 중요하다고 생각합니다.!!☑️ 1. 문제https://www.acmicpc.net/problem/1992☑️ 2. Input , Output☑️ 3. 분류 및 난이도solved.ac class 3 문제입니다.☑️ 4. 생각한 것들 ‘색종이 만들기’라는 문제와 비슷하게 풀 수 있습니다. 제 포스트를 참고해주세요.5. codefrom sys import stdinresult = []def recur(maps, row, col, size): def is_full(maps, row, col, size): bit = maps[row][col] for i in range(row, row + size): for j in range(col, col + size): if bit != maps[i][j]: return False return True if is_full(maps, row, col, size): result.append(maps[row][col]) return new_size = size // 2 result.append(&#39;(&#39;) recur(maps, row, col, new_size) recur(maps, row, col + new_size, new_size) recur(maps, row + new_size, col, new_size) recur(maps, row + new_size, col + new_size, new_size) result.append(&#39;)&#39;)def solution(): size = int(stdin.readline()) maps = [] for _ in range(size): maps.append(stdin.readline().rstrip(&#39;\\n&#39;)) recur(maps, 0, 0, size) print(&#39;&#39;.join(result))solution()6. 후기 c++로 작성이 필요하거나 도움이 필요하시면 댓글을 작성해주세요.!! 기록용이라 설명이 자세하지 않습니다." }, { "title": "Baekjoon11286 - 절댓값 힙 (Python)", "url": "/posts/baekjoon11286/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon", "date": "2022-08-25 01:02:00 +0900", "snippet": "백준 사이트 11286 - 절댓값 힙 문제입니다. 이 글을 보시기 전에 문제를 풀기 위해 충분한 생각을 하셨나요? 답을 안 보고 푸는게 최대한 고민하는게 가장 중요하다고 생각합니다.!!☑️ 1. 문제https://www.acmicpc.net/problem/11286☑️ 2. Input , Output☑️ 3. 분류 및 난이도solved.ac class 3 문제입니다.☑️ 4. 생각한 것들 최댓값 힙이라는 문제를 풀다보면 힙의 가중치를 부여할 수 있다는 점을 알 수 있었습니다. 해당방법을 통하여 풀었습니다.5. codefrom heapq import heappush, heappopfrom sys import stdindef solution(): command_line = int(stdin.readline()) heap = [] for _ in range(command_line): command = int(stdin.readline()) if command == 0: if len(heap) != 0: print(heappop(heap)[1]) else: print(0) else: heappush(heap, (abs(command), command))solution()6. 후기 c++로 작성이 필요하거나 도움이 필요하시면 댓글을 작성해주세요.!! 기록용이라 설명이 자세하지 않습니다." }, { "title": "Baekjoon11659 - 구간 합 구하기 4 (Python)", "url": "/posts/baekjoon11659/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon", "date": "2022-08-24 03:02:00 +0900", "snippet": "백준 사이트 11659 - 패션왕 신해빈 문제입니다. 이 글을 보시기 전에 문제를 풀기 위해 충분한 생각을 하셨나요? 답을 안 보고 푸는게 최대한 고민하는게 가장 중요하다고 생각합니다.!!☑️ 1. 문제https://www.acmicpc.net/problem/11659☑️ 2. Input , Output☑️ 3. 분류 및 난이도solved.ac class 3 문제입니다.☑️ 4. 생각한 것들 수학적으로 접근하면 어렵지 않습니다. 구간합이라는 연속적인 합에 대해서 물어보는 것이기 때문에 경계의 특성을 잘 이용하면 됩니다.5. codefrom sys import stdindef solution(): n, m = map(int, stdin.readline().split()) input_list = list(map(int, stdin.readline().split())) for i in range(1,len(input_list)): input_list[i] += input_list[i-1] for _ in range(m): start, end = map(int,stdin.readline().split()) if start == 1: print(input_list[end-1]) else: print(input_list[end-1] - input_list[start-2])solution()6. 후기 c++로 작성이 필요하거나 도움이 필요하시면 댓글을 작성해주세요.!! 기록용이라 설명이 자세하지 않습니다." }, { "title": "Baekjoon9375 - 패션왕 신해빈 (Python)", "url": "/posts/baekjoon9375/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon", "date": "2022-08-24 02:02:00 +0900", "snippet": "백준 사이트 9375 - 패션왕 신해빈 문제입니다. 이 글을 보시기 전에 문제를 풀기 위해 충분한 생각을 하셨나요? 답을 안 보고 푸는게 최대한 고민하는게 가장 중요하다고 생각합니다.!!☑️ 1. 문제https://www.acmicpc.net/problem/9375☑️ 2. Input , Output☑️ 3. 분류 및 난이도solved.ac class 3 문제입니다.☑️ 4. 생각한 것들 간단한 경우의 수 문제입니다. 클린코드적으로 짜는데에 집중을 좀 했습니다..5. codefrom sys import stdindef solution(): t = int(stdin.readline()) for i in range(t): n = int(stdin.readline()) dict = {} result = 1 for k in range(n): name, type = list(map(str, stdin.readline().split())) if type not in dict: dict[type] = [] dict[type].append(name) for key, value in dict.items(): result *= (len(value) + 1) print(result - 1)solution()6. 후기 c++로 작성이 필요하거나 도움이 필요하시면 댓글을 작성해주세요.!! 기록용이라 설명이 자세하지 않습니다." }, { "title": "Baekjoon15666 - N과M (12) (Python)", "url": "/posts/baekjoon15666/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon", "date": "2022-08-24 01:02:00 +0900", "snippet": "백준 사이트 15666 - N과M (12) 문제입니다. 이 글을 보시기 전에 문제를 풀기 위해 충분한 생각을 하셨나요? 답을 안 보고 푸는게 최대한 고민하는게 가장 중요하다고 생각합니다.!!☑️ 1. 문제https://www.acmicpc.net/problem/15666☑️ 2. Input , Output☑️ 3. 분류 및 난이도solved.ac class 4 문제입니다.☑️ 4. 생각한 것들 N과 M시리즈의 12번째로 특이 사항으로 중복이 가능하다는 점과 오름차순 정렬을 해야한다는 것입니다. 또한 앞자리의 숫자가 뒷 숫자보다 크면 안됩니다.5. codefrom sys import stdindef recur(data_list: list, size: int): pick = [] pick_dict = {} def get_solution(): if len(pick) == size: pick_dict[&#39; &#39;.join(map(str, pick))] = 1 else: for i in range(len(data_list)): if len(pick) != 0 and (pick[-1] &amp;gt; data_list[i]): continue pick.append(data_list[i]) get_solution() pick.pop() get_solution() for key, value in pick_dict.items(): print(key)def solution(): n, m = map(int, stdin.readline().split()) input_list = list(map(int, stdin.readline().split())) recur(sorted(input_list), m)solution()6. 후기 c++로 작성이 필요하거나 도움이 필요하시면 댓글을 작성해주세요.!! 기록용이라 설명이 자세하지 않습니다." }, { "title": "Baekjoon15663 - N과M(9) (Python)", "url": "/posts/baekjoon-15663/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon", "date": "2022-08-23 06:02:00 +0900", "snippet": "백준 사이트 15663 - N과M (9) 문제입니다. 이 글을 보시기 전에 문제를 풀기 위해 충분한 생각을 하셨나요? 답을 안 보고 푸는게 최대한 고민하는게 가장 중요하다고 생각합니다.!!☑️ 1. 문제https://www.acmicpc.net/problem/15663☑️ 2. Input , Output☑️ 3. 분류 및 난이도solved.ac class 4 문제입니다.☑️ 4. 생각한 것들 기존 문제에서 추가된 사항은 사전순 + 중복x + 데이터 입력은 중복이 가능하다는 점입니다. 이를 확인하기 위해서 dictionary자료형을 사용하였고 결과를 도출하였습니다.5. codefrom sys import stdindef recur(listed: list, m: int): pick = [] size = len(listed) visit = [False] * size dict = {} def combination(): pick_data = &#39; &#39;.join(map(str, pick)) if len(pick) == m: dict[pick_data] = 1 else: for i in range(size): if visit[i] == True: continue pick.append(listed[i]) visit[i] = True combination() visit[i] = False pick.pop() combination() for key, item in dict.items(): print(key)def solution(): n, m = map(int, stdin.readline().split()) input_list = list(map(int, stdin.readline().split())) recur(sorted(input_list), m)solution()6. 후기 c++로 작성이 필요하거나 도움이 필요하시면 댓글을 작성해주세요.!! 기록용이라 설명이 자세하지 않습니다." }, { "title": "Baekjoon15657 - N과M (8) (Python)", "url": "/posts/baekjoon15657/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon", "date": "2022-08-23 05:02:00 +0900", "snippet": "백준 사이트 15657 - N과M (8) 문제입니다. 이 글을 보시기 전에 문제를 풀기 위해 충분한 생각을 하셨나요? 답을 안 보고 푸는게 최대한 고민하는게 가장 중요하다고 생각합니다.!!☑️ 1. 문제https://www.acmicpc.net/problem/15657☑️ 2. Input , Output☑️ 3. 분류 및 난이도solved.ac class 4 문제입니다.☑️ 4. 생각한 것들 N과 M시리즈의 8번째로 특이 사항으로 중복이 가능하다는 점과 오름차순 정렬을 해야한다는 것입니다. 위 조건만 맞춰준다면 큰 어려움없이 풀 수 있습니다.5. codefrom sys import stdindef recur(num_list: list, m: int): pick = [] def combination(): if m == len(pick): print(&#39; &#39;.join(map(str, pick))) else: for i in range(len(num_list)): if len(pick) != 0 and (pick[-1] &amp;gt; num_list[i]): continue pick.append(num_list[i]) combination() pick.pop() combination()def solution(): n, m = map(int, stdin.readline().split()) num_list = list(map(int, stdin.readline().split())) recur(sorted(num_list), m)solution()6. 후기 c++로 작성이 필요하거나 도움이 필요하시면 댓글을 작성해주세요.!! 기록용이라 설명이 자세하지 않습니다." }, { "title": "Baekjoon2630 - 색종이 만들기 (Python)", "url": "/posts/baekjoon2630/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon", "date": "2022-08-23 04:02:00 +0900", "snippet": "백준 사이트 2630 - 색종이 만들기 문제입니다. 이 글을 보시기 전에 문제를 풀기 위해 충분한 생각을 하셨나요? 답을 안 보고 푸는게 최대한 고민하는게 가장 중요하다고 생각합니다.!!☑️ 1. 문제https://www.acmicpc.net/problem/2630☑️ 2. Input , Output☑️ 3. 분류 및 난이도solved.ac class 3 문제입니다.☑️ 4. 생각한 것들 재귀 문제입니다. 맨 처음에 접근했을때 모든 영역이 ‘0’(white)나 ‘1’(blue)이면 그 영역에 대한 카운트를 세주고 영역검사를 하지 않아야합니다. 맨 처음에는 전체 사이즈에 대한 영역검사를 하고, 만약 영역별 다르다면 짜르기를 시작하여 최대한 쪼개도록합니다.5. codefrom sys import stdinfrom collections import dequeblue = 0white = 0def divide(maps, row, col, size): def is_full(maps, row, col, size): color = maps[row][col] for i in range(row, row + size): for j in range(col, col + size): if color != maps[i][j]: return False return True if is_full(maps, row, col, size): if maps[row][col] == 0: # 전역변수 호출 global white white += 1 else: global blue blue += 1 return new_size = size // 2 divide(maps, row, col, new_size) divide(maps, row, col + new_size, new_size) divide(maps, row + new_size, col, new_size) divide(maps, row + new_size, col + new_size, new_size)def solution(): n = int(stdin.readline()) maps = deque() for i in range(n): maps.append(list(map(int, stdin.readline().split()))) divide(maps, 0, 0, n) # &#39;\\n&#39;간격으로 출력. print(white, blue, sep=&#39;\\n&#39;)solution()6. 후기 c++로 작성이 필요하거나 도움이 필요하시면 댓글을 작성해주세요.!! 기록용이라 설명이 자세하지 않습니다." }, { "title": "Baekjoon1927 - 최소힙 (Python)", "url": "/posts/baekjoon1927/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon", "date": "2022-08-23 03:02:00 +0900", "snippet": "백준 사이트 1927 - 최소힙 문제입니다. 이 글을 보시기 전에 문제를 풀기 위해 충분한 생각을 하셨나요? 답을 안 보고 푸는게 최대한 고민하는게 가장 중요하다고 생각합니다.!!☑️ 1. 문제https://www.acmicpc.net/problem/1927☑️ 2. Input , Output☑️ 3. 분류 및 난이도solved.ac class 3 문제입니다.☑️ 4. 생각한 것들 간단한 문제입니다. 파이썬에서는 라이브러리를 제공하므로 잘 사용하면 됩니다.5. codefrom sys import stdinfrom heapq import heappop, heappushdef solution(): n = int(stdin.readline()) heap = [] for i in range(n): command = int(stdin.readline()) if command == 0: if len(heap) == 0: print(0) else: print(heappop(heap)) else: heappush(heap, command)solution()6. 후기 c++로 작성이 필요하거나 도움이 필요하시면 댓글을 작성해주세요.!! 기록용이라 설명이 자세하지 않습니다." }, { "title": "Baekjoon11279 - 최대힙 (Python)", "url": "/posts/baekjoon11279/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon", "date": "2022-08-23 02:02:00 +0900", "snippet": "백준 사이트 1620 - 최대힙 문제입니다. 이 글을 보시기 전에 문제를 풀기 위해 충분한 생각을 하셨나요? 답을 안 보고 푸는게 최대한 고민하는게 가장 중요하다고 생각합니다.!!☑️ 1. 문제https://www.acmicpc.net/problem/11279☑️ 2. Input , Output☑️ 3. 분류 및 난이도solved.ac class 3 문제입니다.☑️ 4. 생각한 것들 간단한 문제입니다. 파이썬에서는 라이브러리를 제공하므로 잘 사용하면 됩니다.5. codefrom heapq import heappush, heappopfrom sys import stdindef solution() -&amp;gt; None: n = int(stdin.readline()) heap = [] for i in range(n): command = int(stdin.readline()) if command == 0: if len(heap) == 0: print(0) else: print(heappop(heap)[1]) else: heappush(heap, (-command, command))solution()6. 후기 c++로 작성이 필요하거나 도움이 필요하시면 댓글을 작성해주세요.!! 기록용이라 설명이 자세하지 않습니다." }, { "title": "Baekjoon13398 - 연속합 2 (Python)", "url": "/posts/baekjoon13398/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon", "date": "2022-08-23 01:02:00 +0900", "snippet": "백준 사이트 13398 - 연속합 2 문제입니다. 이 글을 보시기 전에 문제를 풀기 위해 충분한 생각을 하셨나요? 답을 안 보고 푸는게 최대한 고민하는게 가장 중요하다고 생각합니다.!!☑️ 1. 문제https://www.acmicpc.net/problem/13398☑️ 2. Input , Output☑️ 3. 분류 및 난이도코딩테스트 준비-기초 : 브루트포스 - 다이나믹프로그래밍 문제입니다.☑️ 4. 생각한 것들 요소 하나를 삭제할 수 있기 때문에 삭제했을때 경우, 삭제를 하지 않았을때 경우를 생각해야합니다. 삭제 안 했을경우는 순차적으로 합한 경우 vs 현재 인덱스의 값을 비교해나가면서 해결하면 됩니다. 삭제의 경우는 딱 한 번만 삭제가 가능하므로, 전의 인덱스까지를 순차적으로 합한경우(삭제의 경우입니다.) vs 이미 삭제한 경우의 순차합을 비교해야합니다. 그래서 총 2개의 메모제이션 자료구조를 사용하였습니다.5. codefrom sys import stdindef solution() -&amp;gt; int: def init(): num = int(stdin.readline()) data_list = list(map(int, stdin.readline().split())) return num, data_list n, input_list = init() dp = [0] * n delete_dp = [0] * n dp[0] = delete_dp[0] = input_list[0] max_num = input_list[0] for i in range(1, n): # 삭제의 경우 delete_dp[i] = max(delete_dp[i - 1] + input_list[i], dp[i - 1]) # 순차합과 본인 인덱스 값을 비교 dp[i] = max(dp[i - 1] + input_list[i], input_list[i]) max_num = max(max_num, dp[i], delete_dp[i]) return max_numresult = solution()print(result)6. 후기 c++로 작성이 필요하거나 도움이 필요하시면 댓글을 작성해주세요.!! 기록용이라 설명이 자세하지 않습니다." }, { "title": "Baekjoon1620 - 나는야 포켓몬 마스터 이다솜 (Python)", "url": "/posts/baekjoon1620/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon", "date": "2022-08-21 01:02:00 +0900", "snippet": "백준 사이트 1620 - 나는야 포켓몬 마스터 이다솜 문제입니다. 이 글을 보시기 전에 문제를 풀기 위해 충분한 생각을 하셨나요? 답을 안 보고 푸는게 최대한 고민하는게 가장 중요하다고 생각합니다.!!☑️ 1. 문제https://www.acmicpc.net/problem/1620☑️ 2. Input , Output☑️ 3. 분류 및 난이도solved.ac class 3 문제입니다.☑️ 4. 생각한 것들 파이썬으로 풀 때는 어렵지 않습니다.5. codefrom sys import stdindef solution() -&amp;gt; None: name_dict = {} number_dict = {} poketmon_list_size, output_len = map(int, stdin.readline().split()) for i in range(1, poketmon_list_size + 1): poketmon_name = stdin.readline().rstrip(&#39;\\n&#39;) name_dict[poketmon_name] = i number_dict[i] = poketmon_name for i in range(output_len): get_data = stdin.readline().rstrip(&#39;\\n&#39;) if get_data.isdigit(): print(number_dict.get(int(get_data))) else: print(name_dict.get(get_data))solution()6. 후기 c++로 작성이 필요하거나 도움이 필요하시면 댓글을 작성해주세요.!! 기록용이라 설명이 자세하지 않습니다." }, { "title": "Baekjoon2108 - 통계학 (Python)", "url": "/posts/baekjoon2108/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon", "date": "2022-08-19 03:02:00 +0900", "snippet": "백준 사이트 2108 - 통계학 문제입니다. 이 글을 보시기 전에 문제를 풀기 위해 충분한 생각을 하셨나요? 답을 안 보고 푸는게 최대한 고민하는게 가장 중요하다고 생각합니다.!!☑️ 1. 문제https://www.acmicpc.net/problem/2108☑️ 2. Input , Output☑️ 3. 분류 및 난이도solved.ac의 클래스2난이도 문제입니다.☑️ 4. 생각한 것들 최빈값 구하는게 좀 귀찮을뿐이지 어렵지는 않습니다. 음수처리를 어떻게 해주냐에 따라 코드가 다를것 같습니다. 저는 부호없는 숫자로 만들었습니다.5. codefrom operator import itemgetterfrom sys import stdin# noinspection PyTupleAssignmentBalancedef solution() -&amp;gt; None: def init(): cnt = int(stdin.readline()) input_list = [] for i in range(cnt): input_list.append(int(stdin.readline())) return cnt, input_list def operation(li: list, counting_list: list): sum_ = 0 max_ = 0 for i in range(len(li)): sum_ += li[i] idx = li[i] + 4000 counting_list[idx] += 1 if max_ &amp;lt; counting_list[idx]: max_ = counting_list[idx] return sum_, max_ counting = [0] * 8001 max_list = [] n, data_input = init() data_input.sort() data_sum, max_result = operation(data_input, counting) for i in range(len(counting)): if counting[i] == max_result: max_list.append(i) max_result = max_list[-1] if len(max_list) == 1 else max_list[1] print(round(data_sum / n), data_input[n // 2], max_result - 4000, data_input[-1] - data_input[0], sep=&#39;\\n&#39;)solution()6. 후기 c++로 작성이 필요하거나 도움이 필요하시면 댓글을 작성해주세요.!! 기록용이라 설명이 자세하지 않습니다." }, { "title": "Baekjoon11650 - 좌표 정렬하기 (Python)", "url": "/posts/baekjoon11650/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon", "date": "2022-08-19 02:02:00 +0900", "snippet": "백준 사이트 11650 - 좌표 정렬하기 문제입니다. 이 글을 보시기 전에 문제를 풀기 위해 충분한 생각을 하셨나요? 답을 안 보고 푸는게 최대한 고민하는게 가장 중요하다고 생각합니다.!!☑️ 1. 문제https://www.acmicpc.net/problem/11650☑️ 2. Input , Output☑️ 3. 분류 및 난이도solved.ac의 클래스2난이도 문제입니다.☑️ 4. 생각한 것들 최대 10만개씩 들어오므로 O(N^2)로 풀면 시간초과가 뜰거라 생각했습니다. 정렬에 대해 찾아보던중 python에서 다중 정렬을 제공하는것을 알았습니다.5. codefrom operator import itemgetterfrom sys import stdinn = int(stdin.readline())result = []for i in range(n): data = tuple(map(int, stdin.readline().split())) result.append(data)list.sort(result, key=itemgetter(0, 1))for x, y in result: print(x, y)6. 후기 다중정렬에 정렬할 필요성을 느낀다. c++로 작성이 필요하거나 도움이 필요하시면 댓글을 작성해주세요.!! 기록용이라 설명이 자세하지 않습니다." }, { "title": "Baekjoon14002 - 가장 긴 증가하는 부분 수열 4 (Python)", "url": "/posts/baekjoon14002/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, 동적다이나믹프로그래밍", "date": "2022-08-19 01:02:00 +0900", "snippet": "백준 사이트 14002 - 가장 긴 증가하는 부분 수열 4 문제입니다. 이 글을 보시기 전에 문제를 풀기 위해 충분한 생각을 하셨나요? 답을 안 보고 푸는게 최대한 고민하는게 가장 중요하다고 생각합니다.!!☑️ 1. 문제https://www.acmicpc.net/problem/14002☑️ 2. Input , Output☑️ 3. 분류 및 난이도코딩테스트 준비-기초 : 브루트포스 - 다이나믹프로그래밍 문제입니다.☑️ 4. 생각한 것들 해당 수열의 특성을 이해해야합니다. 만약 [20,30,280,20,40,50,70] 이라는 수열이 있다고 합시다. 가장 긴 부분수열은 [20,30,40,50,70]입니다. 이것을 가장 DP로 표현하여, 각 인덱스마다 보유하고 있는 부분수열의 길이는 [1,2,3,1,3,4,5]가 되겠습니다. 이것을 DP로 표현하는것은 ‘가장 긴 증가하는 수열’ 문제입니다. sliver2문제이므로 이 문제를 풀어서 이미 DP로 표현하는 방법은 안다고 가정합니다. 이것을 사이즈 별로 분류합니다. {사이즈 : 수열의 데이터} 로 나타낼때 {1 : 20, 20}{2 : 30}{3 : 280, 40}{4 : 50}{5 : 70} 로 나타낼 수 있습니다. 길이가 가장 큰 수열의 기준으로 아무거나 뽑습니다. 여기서는 70이 가장 긴 수열을 가지고 있으므로 70을 기준으로 잡습니다. 아무거나 뽑는다라는게 굉장히 중요한데, 길이가 같기만 하다면 어떤 수열을 뽑아도 상관이 없지요. 어차피 그 보다 작은 수열은 앞에 존재하니까요. 이 부분을 이해하는것이 중요하다고 생각합니다. 위의 방식을 이해했다면 다음 식을 세우는것은 어렵지 않습니다. 70을 기준으로 사이즈를 줄여가면서 그 값보다 작은 값을 추가합니다. 예를 들어서 5의 사이즈를 가지고 있는 70 이 처음의 기준이고 [70] 그 다음 4의 사이즈를 가지고 있는 50이 70보다는 작으므로 리스트에 추가합니다. 그리고 50을 기준값으로 갱신합니다. 만약 배열 뒤에 데이터가 더 있다하더라도 보지 않습니다.[70,50] 그 다음 3의 사이즈를 가지고 있는 {280, 40} 중에 40이 기준값인 50보다 작으므로 40을 추가하고 갱신합니다. [70,50,40]… 이런식으로 하면 됩니다. 이런 방식이 가능한 이유는 당연하게도 기준값보다 작은 값이 있다면 뒤에 뭐가 나오든 전혀 신경 쓸 필요가 없기 때문입니다. 이게 이해가 되지 않는다면 메모장에 직접 써가면서 우려하는 경우가 있는지 만들어 보세요. 절대 없습니다. 증가하는 수열을 자료구조에 넣었기 때문입니다.5. codefrom sys import stdinfrom collections import dequedef solution() -&amp;gt; None: # input n = int(stdin.readline()) input_list = list(map(int, stdin.readline().split())) # 디폴트로 가장 긴 수열은 자기 자신의 길이다. 1 dp = [1] * n size = 1 result = [] # 초기 기준값은 맨 첫값으로 잡는다. 내림차순으로 들어왔을때를 대비. data_dict = {1: deque([input_list[0]])} #O(n^2) for i in range(n): for j in range(i - 1, -1, -1): # 만약 현재 값이 이전 값들보다 클 때 if input_list[i] &amp;gt; input_list[j]: # 갱신하면서 사이즈 별로 분류 if dp[i] &amp;lt; dp[j] + 1: dp[i] = dp[j] + 1 if dp[j] + 1 not in data_dict.keys(): data_dict[dp[j] + 1] = deque() size = max(size, dp[j] + 1) data_dict[dp[j] + 1].append(input_list[i]) # 현재값보다 작은 경우가 없는 경우는 1로 갱신 if j == 0 and dp[i] == 1: data_dict[1].append(input_list[i]) # 가장 긴 수열을 가지고 있는 데이터중 아무거나 뽑음. max_num = data_dict[size][0] # 나중에 뒤집을거니까 일단 값을 추가 result.append(max_num) # 사이즈 분류한 것들을 돌아가면서 기준값보다 작기만하면 추가하고 빠져나옴. for i in range(size - 1, 0, -1): for data in data_dict[i]: if max_num &amp;gt; data: result.append(data) max_num = data break print(size) #역순 출력 print(&#39; &#39;.join(map(str, result[::-1])))solution()6. 후기 c++로 작성이 필요하거나 도움이 필요하시면 댓글을 작성해주세요.!! 기록용이라 설명이 자세하지 않습니다." }, { "title": "Baekjoon15988 - 1,2,3 더하기 3(Python)", "url": "/posts/baekjoon15988/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, 동적다이나믹프로그래밍", "date": "2022-08-18 01:02:00 +0900", "snippet": "백준 사이트 15988 - 1,2,3 더하기 3 문제입니다. 이 글을 보시기 전에 문제를 풀기 위해 충분한 생각을 하셨나요? 답을 안 보고 푸는게 최대한 고민하는게 가장 중요하다고 생각합니다.!!☑️ 1. 문제https://www.acmicpc.net/problem/15988☑️ 2. Input , Output☑️ 3. 분류 및 난이도코딩테스트 준비-기초 : 브루트포스 - 다이나믹프로그래밍 문제입니다.☑️ 4. 생각한 것들 중복여부를 검사하지 않으므로 점화식이 간단합니다. 직전 수에서 1을 더하는 경우 전전 수에서 2를 더하는 경우 전전전 수에서 3을 더하는 경우즉, DP[n] = DP[n-1] + DP[n-2] + DP[n-3] 이라는 점화식이 나옵니다.5. codefrom sys import stdinfrom collections import dequeinput_list = []dp = deque([0, 1, 2, 4])max_num = 0mod = 1000000009def init(): def data_input(): t = int(stdin.readline()) for i in range(t): input_list.append(int(stdin.readline())) data_input() global max_num max_num = max(input_list)def result(): for i in range(4, max_num + 1): dp.append((dp[i - 1] + dp[i - 2] + dp[i - 3]) % mod) for data in input_list: print(dp[data])def solution(): init() result()solution()6. 후기 c++로 작성이 필요하거나 도움이 필요하시면 댓글을 작성해주세요.!! 기록용이라 설명이 자세하지 않습니다." }, { "title": "Baekjoon16194 - 카드 구매하기 2(Python)", "url": "/posts/baekjoon16194/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, 동적다이나믹프로그래밍", "date": "2022-08-17 01:02:00 +0900", "snippet": "백준 사이트 16194 - 카드 구매하기 2 문제입니다. 이 글을 보시기 전에 문제를 풀기 위해 충분한 생각을 하셨나요? 답을 안 보고 푸는게 최대한 고민하는게 가장 중요하다고 생각합니다.!!☑️ 1. 문제https://www.acmicpc.net/problem/16194☑️ 2. Input , Output☑️ 3. 분류 및 난이도코딩테스트 준비-기초 : 브루트포스 - 다이나믹프로그래밍 문제입니다.☑️ 4. 생각한 것들 크게 2가지 경우로 나눌 수 있습니다.100팩을 구매한다고 할 때 들어온 값이 애초에 제일 적은 비용인 경우 (ex 100팩이 1원 ) 그러지 않은 경우는 1팩 가격 + 99팩 가격 , 2팩 가격 + 98팩 가격 … 49팩 가격 + 51팩 가격.. 이런식으로 접근하면 됩니다. 팩의 개수는 최대 10,000이므로 최악의 경우 O(N^2)이라해도 1억이므로 시간내로 풀 수 있다고 생각하였습니다.또한 범위를 전체 도는게 아닌, 범위의 절반만 도므로 위의 경우보다 더 짧겠지요.5. codefrom sys import stdinn = int(stdin.readline())def make_dp(size: int) -&amp;gt; list: return [0 for _ in range(size + 1)]def soultion(dp: list, price: list) -&amp;gt; None: for i in range(1, len(price) + 1): # 1번의 경우. 애초에 제일 적은 비용인 경우를 생각해 초기화 dp[i] = price[i - 1] # 범위의 절반까지 돌면서 위의 점화식을 통해 계산. for j in range(1, (i // 2) + 1): dp[i] = min(dp[i], dp[j] + dp[i - j]) print(dp[n])price = list(map(int, stdin.readline().split()))dp = make_dp(len(price))dp[1] = price[0]soultion(dp, price)6. 후기 문제에서 입출력 예제를 많이줘서 오답률이 높지는 않은듯 하네요. c++로 작성이 필요하거나 도움이 필요하시면 댓글을 작성해주세요.!! 기록용이라 설명이 자세하지 않습니다." }, { "title": "TestPostGresContainer Python 컨테이너 이름 바꾸기", "url": "/posts/postgresContainer/", "categories": "Python, FastAPI", "tags": "FastAPI", "date": "2022-08-16 02:00:00 +0900", "snippet": "사이드 프로젝트중..진귀한 장면을 발견했다.컨테이너 이름이 무작위로 막 생성되어있었다.사실 몇개는 이미 컨테이너가 띄워진 상태로 돌아가고 있어서 다 꺼버렸다.원인을 찾던중..도커로 Postgres를 띄우는 코드는 사이드프로젝트 통합테스트 코드밖에 없다고 생각하여 코드를 뜯어봤다.오픈소스로 제공하는 testcontainers.postgres를 Python언어로 사용하고 있었는데, 분명 이 속에서 Docker Container의 이름을 지정하는 곳이 있을거라 생각했다.class PostgresTestContainer(PostgresContainer): def get_connection_url(self): # windows docker connection return super().get_connection_url().replace(&#39;localnpipe&#39;, &#39;localhost&#39;)@pytest.fixture(scope=&quot;session&quot;, autouse=True)def db_container(session_mocker): with PostgresTestContainer(image=&quot;postgres:9.5&quot;, port=5432) as postgres: ...PostgresTestContainer클래스는 PostgresContainer를 상속받고 있길래 PostgresContainer요 코드로 들어가봤다.## Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may# not use this file except in compliance with the License. You may obtain# a copy of the License at## http://www.apache.org/licenses/LICENSE-2.0## Unless required by applicable law or agreed to in writing, software# distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the# License for the specific language governing permissions and limitations# under the License.import osfrom testcontainers.core.generic import DbContainerclass PostgresContainer(DbContainer): &quot;&quot;&quot; Postgres database container. Example ------- The example spins up a Postgres database and connects to it using the :code:`psycopg` driver. :: with PostgresContainer(&quot;postgres:9.5&quot;) as postgres: e = sqlalchemy.create_engine(postgres.get_connection_url()) result = e.execute(&quot;select version()&quot;) &quot;&quot;&quot; POSTGRES_USER = os.environ.get(&quot;POSTGRES_USER&quot;, &quot;test&quot;) POSTGRES_PASSWORD = os.environ.get(&quot;POSTGRES_PASSWORD&quot;, &quot;test&quot;) POSTGRES_DB = os.environ.get(&quot;POSTGRES_DB&quot;, &quot;test&quot;) def __init__(self, image=&quot;postgres:latest&quot;, port=5432, user=None, password=None, dbname=None, driver=&quot;psycopg2&quot;, **kwargs): super(PostgresContainer, self).__init__(image=image, **kwargs) self.POSTGRES_USER = user or self.POSTGRES_USER self.POSTGRES_PASSWORD = password or self.POSTGRES_PASSWORD self.POSTGRES_DB = dbname or self.POSTGRES_DB self.port_to_expose = port self.driver = driver self.with_exposed_ports(self.port_to_expose) def _configure(self): self.with_env(&quot;POSTGRES_USER&quot;, self.POSTGRES_USER) self.with_env(&quot;POSTGRES_PASSWORD&quot;, self.POSTGRES_PASSWORD) self.with_env(&quot;POSTGRES_DB&quot;, self.POSTGRES_DB) def get_connection_url(self, host=None): return super()._create_connection_url(dialect=&quot;postgresql+{}&quot;.format(self.driver), username=self.POSTGRES_USER, password=self.POSTGRES_PASSWORD, db_name=self.POSTGRES_DB, host=host, port=self.port_to_expose)이 클래스는 DbContainer를 상속받고 있고, 컨테이너 이름을 설정하지는 않는것 같다. 부모 클래스로 들어가봐야겠다.## Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may# not use this file except in compliance with the License. You may obtain# a copy of the License at## http://www.apache.org/licenses/LICENSE-2.0## Unless required by applicable law or agreed to in writing, software# distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the# License for the specific language governing permissions and limitations# under the License.from testcontainers.core.container import DockerContainerfrom testcontainers.core.waiting_utils import wait_container_is_readyfrom deprecation import deprecatedADDITIONAL_TRANSIENT_ERRORS = []try: from sqlalchemy.exc import DBAPIError ADDITIONAL_TRANSIENT_ERRORS.append(DBAPIError)except ImportError: passclass DbContainer(DockerContainer): def __init__(self, image, **kwargs): super(DbContainer, self).__init__(image, **kwargs) @wait_container_is_ready(*ADDITIONAL_TRANSIENT_ERRORS) def _connect(self): import sqlalchemy engine = sqlalchemy.create_engine(self.get_connection_url()) engine.connect() def get_connection_url(self): raise NotImplementedError def _create_connection_url(self, dialect, username, password, host=None, port=None, db_name=None): if self._container is None: raise RuntimeError(&quot;container has not been started&quot;) if not host: host = self.get_container_host_ip() port = self.get_exposed_port(port) url = &quot;{dialect}://{username}:{password}@{host}:{port}&quot;.format( dialect=dialect, username=username, password=password, host=host, port=port ) if db_name: url += &#39;/&#39; + db_name return url def start(self): self._configure() super().start() self._connect() return self def _configure(self): raise NotImplementedErrorclass GenericContainer(DockerContainer): @deprecated(details=&quot;Use `DockerContainer`.&quot;) def __init__(self, image): super(GenericContainer, self).__init__(image)이 클래스도 컨테이너의 이름을 설정하지는 않는다. DockerContainer를 상속받으므로 저 코드로 또 들어가봐야겠다.from deprecation import deprecatedfrom docker.models.containers import Containerfrom testcontainers.core.docker_client import DockerClientfrom testcontainers.core.exceptions import ContainerStartExceptionfrom testcontainers.core.utils import setup_logger, inside_container, is_armlogger = setup_logger(__name__)class DockerContainer(object): def __init__(self, image, docker_client_kw: dict = None, **kwargs): self.env = {} self.ports = {} self.volumes = {} self.image = image self._docker = DockerClient(**(docker_client_kw or {})) self._container = None self._command = None self._name = None self._kwargs = kwargs def with_env(self, key: str, value: str) -&amp;gt; &#39;DockerContainer&#39;: self.env[key] = value return self def with_bind_ports(self, container: int, host: int = None) -&amp;gt; &#39;DockerContainer&#39;: self.ports[container] = host return self def with_exposed_ports(self, *ports) -&amp;gt; &#39;DockerContainer&#39;: for port in list(ports): self.ports[port] = None return self @deprecated(details=&#39;Use `with_kwargs`.&#39;) def with_kargs(self, **kargs) -&amp;gt; &#39;DockerContainer&#39;: return self.with_kwargs(**kargs) def with_kwargs(self, **kwargs) -&amp;gt; &#39;DockerContainer&#39;: self._kwargs = kwargs return self def maybe_emulate_amd64(self) -&amp;gt; &#39;DockerContainer&#39;: if is_arm(): return self.with_kwargs(platform=&#39;linux/amd64&#39;) return self def start(self): logger.info(&quot;Pulling image %s&quot;, self.image) docker_client = self.get_docker_client() self._container = docker_client.run(self.image, command=self._command, detach=True, environment=self.env, ports=self.ports, name=self._name, volumes=self.volumes, **self._kwargs ) logger.info(&quot;Container started: %s&quot;, self._container.short_id) return self def stop(self, force=True, delete_volume=True): self.get_wrapped_container().remove(force=force, v=delete_volume) def __enter__(self): return self.start() def __exit__(self, exc_type, exc_val, exc_tb): self.stop() def __del__(self): &quot;&quot;&quot; Try to remove the container in all circumstances &quot;&quot;&quot; if self._container is not None: try: self.stop() except: # noqa: E722 pass def get_container_host_ip(self) -&amp;gt; str: # infer from docker host host = self.get_docker_client().host() if not host: return &quot;localhost&quot; # check testcontainers itself runs inside docker container if inside_container(): # If newly spawned container&#39;s gateway IP address from the docker # &quot;bridge&quot; network is equal to detected host address, we should use # container IP address, otherwise fall back to detected host # address. Even it&#39;s inside container, we need to double check, # because docker host might be set to docker:dind, usually in CI/CD environment gateway_ip = self.get_docker_client().gateway_ip(self._container.id) if gateway_ip == host: return self.get_docker_client().bridge_ip(self._container.id) return gateway_ip return host def get_exposed_port(self, port) -&amp;gt; str: mapped_port = self.get_docker_client().port(self._container.id, port) if inside_container(): gateway_ip = self.get_docker_client().gateway_ip(self._container.id) host = self.get_docker_client().host() if gateway_ip == host: return port return mapped_port def with_command(self, command: str) -&amp;gt; &#39;DockerContainer&#39;: self._command = command return self def with_name(self, name: str) -&amp;gt; &#39;DockerContainer&#39;: self._name = name return self def with_volume_mapping(self, host: str, container: str, mode: str = &#39;ro&#39;) -&amp;gt; &#39;DockerContainer&#39;: # &#39;/home/user1/&#39;: {&#39;bind&#39;: &#39;/mnt/vol2&#39;, &#39;mode&#39;: &#39;rw&#39;} mapping = {&#39;bind&#39;: container, &#39;mode&#39;: mode} self.volumes[host] = mapping return self def get_wrapped_container(self) -&amp;gt; Container: return self._container def get_docker_client(self) -&amp;gt; DockerClient: return self._docker def get_logs(self): if not self._container: raise ContainerStartException(&quot;Container should be started before&quot;) return self._container.logs(stderr=False), self._container.logs(stdout=False) def exec(self, command): if not self._container: raise ContainerStartException(&quot;Container should be started before&quot;) return self.get_wrapped_container().exec_run(command)여기서 보아하니 이름을 설정하는 곳을 찾은것 같다 __init__에서 초기화 작업을 해주고 있다.확장성을 고려하여 None도 받아야한다. None을 받으면 컨테이너 이름을 랜덤으로 만들어서 띄우는데 이게 쌓이다보니 맨 위의 스크린샷이 된다.그래서class DockerContainer(object): def __init__(self, image, name = None, docker_client_kw: dict = None, **kwargs): ... self._name = name 처럼 name=None을 추가하고 self._name = name구문으로 초기화해주었다.그리고 다시 통합테스트 코드로 가서class PostgresTestContainer(PostgresContainer): def get_connection_url(self): # windows docker connection return super().get_connection_url().replace(&#39;localnpipe&#39;, &#39;localhost&#39;)@pytest.fixture(scope=&quot;session&quot;, autouse=True)def db_container(session_mocker): with PostgresTestContainer(image=&quot;postgres:9.5&quot;, port=5432, name=&quot;ZinsaContainer&quot;) as postgres: ...name을 추가하여 통합테스트를 실행해보았다.성공했다.혹시몰라 인자에서 name을 빼보고 실행해보았다.랜덤한 이름으로 컨테이너를 잘 띄운다.후기이걸 OCP라고하면 OCP일까? 기능을 확장시켰고 기존 요건인 None도 받을 수 있게 하였으니..다만 걱정스러운건 이 소스를 제공한 사람들이 일부러 name을 인자로 받지 못하게 설계한것이 아닐까? 충돌의 위험이 있을까?잘 모르겠다. 컨테이너가 계속 쌓이는것이 불편해서 하나의 이름을 가진 컨테이너로 띄웠다 내렸다 하고 싶은 마음에 시도해보았다.앞으로 부딪히다보면 이 방법의 단점을 알 수도 있을 것 같다.팀원들아 프로젝트 진행좀 해줘" }, { "title": "Baekjoon15990 - 1,2,3 더하기5(Python)", "url": "/posts/baekjoon15990/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, 순열", "date": "2022-08-16 01:02:00 +0900", "snippet": "백준 사이트 15990 - 1,2,3 더하기5 문제입니다. 이 글을 보시기 전에 문제를 풀기 위해 충분한 생각을 하셨나요? 답을 안 보고 푸는게 최대한 고민하는게 가장 중요하다고 생각합니다.!!☑️ 1. 문제https://www.acmicpc.net/problem/15990☑️ 2. Input , Output☑️ 3. 분류 및 난이도코딩테스트 준비-기초 : 브루트포스 - 다이나믹프로그래밍 문제입니다.☑️ 4. 생각한 것들 3가지 경우의 수가 있습니다. 1의 경우 [1]2의 경우 [2]3의 경우 [3], [1+2], [2+1]의 경우의 수를 가지고각 자리수가 1,2,3으로 끝납니다.다음 4를 계산할 때 [1+2+1], [1+3],[3+1]로 되는데이런식으로 끝이 나온 숫자를 표로 나타내면 끝이/n 1 2 3 4 5 1 1 0 1 2 1 2 0 1 1 0 2 3 0 0 1 1 1 여기서 식을 세울 수 있습니다. 5의 경우 4의 경우의 수에 1을 더하면 되는데 연속해서 1이 나올 수 없으므로 끝자리가 2이거나 3인 경우인 경우의 수에 1을 더하면 됩니다. 그래서 4의 경우의 수에서 끝자리가 2인 경우의 수 (0)과 끝자리가 3인 경우의 수 (1)을 합한 0+1의 경우의 수에 1을 더한 값이 5의 경우의 수중에 끝자리가 1인 경우에 포함됩니다.마찬가지로 5의 경우의 수 중 끝자리가 2인 경우의 수는 3+2가 5이므로 3의 경우의 수를 살펴봐야하는데, 연속된 숫자가 나오면 안되므로 3의 경우의수 중 끝자리가 1과 3으로 끝나는 것에 2를 더하면 됩니다. 그래서 3의 경우의 수중 끝자리가 1인 경우의수 1과 3으로 끝나는 경우의 수 1을 합한 2가 5의 끝자리가 2인 경우의 수가 되는거죠.(3+2), (2+1+2)이런식으로 접근하면 풀 수 있습니다. 시간 효율성을 고려하여 애초에 최대 경우의 수인 100,000크기의 메모제이션을 쓰지 않았고, 들어온 인풋값중 제일 큰것을 찾고 그 크기만큼 메모제이션을 수행하였습니다. 최악의 경우는 어차피 똑같겠지만요. 파이썬은 정수길이에 제한이 없어서 매 번 나눠줘야합니다.5. codefrom sys import stdinmod = 1000000009t = int(stdin.readline())input_list = []for i in range(t): input_list.append(int(stdin.readline()))max_num = max(input_list) + 1dp_one = [0] * max_numdp_two = [0] * max_numdp_three = [0] * max_numdp_one[1] = 1dp_one[3] = 1dp_two[2] = 1dp_two[3] = 1dp_three[3] = 1for i in range(4, max_num): dp_one[i] = (dp_two[i - 1] + dp_three[i - 1]) % mod dp_two[i] = (dp_one[i - 2] + dp_three[i - 2]) % mod dp_three[i] = (dp_one[i - 3] + dp_two[i - 3]) % modfor result in input_list: print((dp_one[result] + dp_two[result] + dp_three[result]) % mod)6. 후기 c++로 작성이 필요하거나 도움이 필요하시면 댓글을 작성해주세요.!! 기록용이라 설명이 자세하지 않습니다." }, { "title": "Baekjoon6603 - 로또(Python)", "url": "/posts/baekjoon6603/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, 순열", "date": "2022-08-15 01:02:00 +0900", "snippet": "백준 사이트 6603 - 로또 문제입니다. 이 글을 보시기 전에 문제를 풀기 위해 충분한 생각을 하셨나요? 답을 안 보고 푸는게 최대한 고민하는게 가장 중요하다고 생각합니다.!!☑️ 1. 문제https://www.acmicpc.net/problem/6603☑️ 2. Input , Output☑️ 3. 분류 및 난이도코딩테스트 준비-기초 : 브루트포스 - 순열 문제입니다.☑️ 4. 생각한 것들 python의 combination을 이용하여 풀면 쉽게 풀 수 있습니다.5. codefrom itertools import combinationsfrom sys import stdinwhile True: data = list(map(str, stdin.readline().split())) if data[0] == &#39;0&#39;: break new_data = list(combinations(data[1:], 6)) for output in new_data: print(&#39; &#39;.join(list(output)), end=&quot;\\n&quot;) print()6. 후기 c++로 작성이 필요하거나 도움이 필요하시면 댓글을 작성해주세요.!! 기록용이라 설명이 자세하지 않습니다." }, { "title": "Baekjoon10971 - 외판원 순회2(Python)", "url": "/posts/baekjoon10971/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, 순열", "date": "2022-08-12 05:02:00 +0900", "snippet": "백준 사이트 10971 - 외판원 순회2 문제입니다. 이 글을 보시기 전에 문제를 풀기 위해 충분한 생각을 하셨나요? 답을 안 보고 푸는게 최대한 고민하는게 가장 중요하다고 생각합니다.!!☑️ 1. 문제https://www.acmicpc.net/problem/10971☑️ 2. Input , Output☑️ 3. 분류 및 난이도코딩테스트 준비-기초 : 브루트포스 - 순열 문제입니다.☑️ 4. 생각한 것들 최대 10!의 경우의 수가 있어서 효율성에러가 뜰 줄 알았는데 다행히 뜨지 않았습니다. 경로가 존재하지 않을 수(입력값이 0) 있으므로 그것에 대한 처리를 해줘야합니다. 또한 경로를 다 돌고 다시 최초의 자리로 돌아갈때도 입력값이 0일 수 있으므로 그거에 대한 처리도 해줘야합니다.5. codefrom itertools import permutationsfrom collections import dequen = int(input())travel_map = deque()result_sum = 10e9load = [i for i in range(1, n + 1)]for i in range(n): tmp_li = deque(map(int, input().split())) travel_map.append(tmp_li)for result in permutations(load): tmp_sum = 0 judge = False for i in range(len(result) - 1): data = travel_map[result[i] - 1][result[i + 1] - 1] if data &amp;lt;= 0: judge = True break tmp_sum += data cycle_data = travel_map[result[i + 1] - 1][result[0] - 1] if cycle_data == 0 or judge: continue tmp_sum += cycle_data result_sum = min(result_sum, tmp_sum)print(result_sum)6. 후기 c++로 작성이 필요하거나 도움이 필요하시면 댓글을 작성해주세요.!! 기록용이라 설명이 자세하지 않습니다." }, { "title": "Baekjoon10819 - 차이를 최대로 (Python)", "url": "/posts/baekjoon10819/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, 순열", "date": "2022-08-12 04:02:00 +0900", "snippet": "백준 사이트 10819 - 차이를 최대로 문제입니다. 이 글을 보시기 전에 문제를 풀기 위해 충분한 생각을 하셨나요? 답을 안 보고 푸는게 최대한 고민하는게 가장 중요하다고 생각합니다.!!☑️ 1. 문제https://www.acmicpc.net/problem/10819☑️ 2. Input , Output 자세한건 링크 참조..☑️ 3. 분류 및 난이도코딩테스트 준비-기초 : 브루트포스 - 순열 문제입니다.☑️ 4. 생각한 것들 python의 permutations을 사용하면 어렵지 않게 풀 수 있습니다.5. codefrom itertools import permutationsn = int(input())li = list(map(int, input().split()))result_sum = 0for result in permutations(li): tmp_sum = 0 for i in range(n - 1): tmp_sum += abs(result[i] - result[i + 1]) result_sum = max(result_sum, tmp_sum)print(result_sum)6. 후기 c++로 작성이 필요하거나 도움이 필요하시면 댓글을 작성해주세요.!! 기록용이라 설명이 자세하지 않습니다." }, { "title": "Baekjoon10974 - 모든 순열(Python)", "url": "/posts/baekjoon10974/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, 순열", "date": "2022-08-12 03:02:00 +0900", "snippet": "백준 사이트 10974 - 모든 순열 문제입니다. 이 글을 보시기 전에 문제를 풀기 위해 충분한 생각을 하셨나요? 답을 안 보고 푸는게 최대한 고민하는게 가장 중요하다고 생각합니다.!!☑️ 1. 문제https://www.acmicpc.net/problem/10974☑️ 2. Input , Output 자세한건 링크 참조..☑️ 3. 분류 및 난이도코딩테스트 준비-기초 : 브루트포스 - 순열 문제입니다.☑️ 4. 생각한 것들 이전 문제를 통해 알고리즘을 습득하였습니다. 해당 알고리즘의 반대로만 진행해주면 어렵지 않게 풀 수 있습니다. 자세한건 다음순열 문제를 참고해주세요.5. codedef solution(origin, size): i = size - 1 while i &amp;gt; 0 and origin[i - 1] &amp;lt;= origin[i]: i -= 1 j = size - 1 while origin[j] &amp;gt;= origin[i - 1]: j -= 1 origin[i - 1], origin[j] = origin[j], origin[i - 1] j = size - 1 while (i &amp;lt; j): origin[i], origin[j] = origin[j], origin[i] i += 1 j -= 1 print(&#39; &#39;.join(map(str, origin)))n = int(input())input_str = list(map(int, input().split()))permu_list = [_x for _x in range(1, n + 1)]if input_str == permu_list: print(-1)else: size = len(permu_list) solution(input_str, size)6. 후기 c++로 작성이 필요하거나 도움이 필요하시면 댓글을 작성해주세요.!! 기록용이라 설명이 자세하지 않습니다." }, { "title": "Baekjoon10973 - 이전 순열(Python)", "url": "/posts/baekjoon10973/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, 순열", "date": "2022-08-12 02:02:00 +0900", "snippet": "백준 사이트 10973 - 이전 순열 문제입니다. 이 글을 보시기 전에 문제를 풀기 위해 충분한 생각을 하셨나요? 답을 안 보고 푸는게 최대한 고민하는게 가장 중요하다고 생각합니다.!!☑️ 1. 문제https://www.acmicpc.net/problem/10973☑️ 2. Input , Output 자세한건 링크 참조..☑️ 3. 분류 및 난이도코딩테스트 준비-기초 : 브루트포스 - 순열 문제입니다.☑️ 4. 생각한 것들 이전 문제를 통해 알고리즘을 습득하였습니다. 해당 알고리즘의 반대로만 진행해주면 어렵지 않게 풀 수 있습니다. 자세한건 다음순열 문제를 참고해주세요.5. codedef solution(origin, size): i = size - 1 while i &amp;gt; 0 and origin[i - 1] &amp;lt;= origin[i]: i -= 1 j = size - 1 while origin[j] &amp;gt;= origin[i - 1]: j -= 1 origin[i - 1], origin[j] = origin[j], origin[i - 1] j = size - 1 while (i &amp;lt; j): origin[i], origin[j] = origin[j], origin[i] i += 1 j -= 1 print(&#39; &#39;.join(map(str, origin)))n = int(input())input_str = list(map(int, input().split()))permu_list = [_x for _x in range(1, n + 1)]if input_str == permu_list: print(-1)else: size = len(permu_list) solution(input_str, size)6. 후기 c++로 작성이 필요하거나 도움이 필요하시면 댓글을 작성해주세요.!! 기록용이라 설명이 자세하지 않습니다." }, { "title": "Baekjoon10972 - 다음 순열(Python)", "url": "/posts/baekjoon10972/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, 순열", "date": "2022-08-12 01:02:00 +0900", "snippet": "백준 사이트 10972 - 다음 순열 문제입니다. 이 글을 보시기 전에 문제를 풀기 위해 충분한 생각을 하셨나요? 답을 안 보고 푸는게 최대한 고민하는게 가장 중요하다고 생각합니다.!!☑️ 1. 문제https://www.acmicpc.net/problem/10972☑️ 2. Input , Output 자세한건 링크 참조..☑️ 3. 분류 및 난이도코딩테스트 준비-기초 : 브루트포스 - 순열 문제입니다.☑️ 4. 생각한 것들 처음에는 런타임에러가 계속 뜨길래 의아했습니다. 나눗셈도 없었는데 말이죠. 찾아보니 순열을 찾는 재귀가 너무 깊어서 나느거일수도 있다고 합니다. 그래서 다음 순열을 직접 구해줘야하는데, 그건 구글에 검색하여 알고리즘을 학습하였습니다.https://blogshine.tistory.com/122를 참고하였습니다.5. codedef solution(origin, size): i = size - 1 while i &amp;gt; 0 and origin[i - 1] &amp;gt;= origin[i]: i -= 1 if i &amp;lt;= 0: return j = size - 1 while origin[j] &amp;lt;= origin[i - 1]: j -= 1 origin[i - 1], origin[j] = origin[j], origin[i - 1] j = size - 1 while (i &amp;lt; j): origin[i], origin[j] = origin[j], origin[i] i += 1 j -= 1 print(&#39; &#39;.join(map(str, origin)))n = int(input())input_str = list(map(int, input().split()))permu_list = [_x for _x in range(1, n + 1)]if list(input_str)[::-1] == permu_list: print(-1)else: size = len(permu_list) solution(input_str, size)6. 후기 사실 처음에 역 배열인 경우를 걸러주기 때문에 solution안의 if i&amp;lt;=0구문이 없어도 됩니다. 다른데서도 쓸 거 같아서 코드상에서는 냅두었습니다. c++로 작성이 필요하거나 도움이 필요하시면 댓글을 작성해주세요.!! 기록용이라 설명이 자세하지 않습니다." }, { "title": "Baekjoon16935 - 배열 돌리기 3(Python)", "url": "/posts/Baekjoon16935/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon", "date": "2022-08-11 01:02:00 +0900", "snippet": "백준 사이트 16935 - 배열 돌리기 3 문제입니다.☑️ 1. 문제https://www.acmicpc.net/problem/16935☑️ 2. Input , Output 자세한건 링크 참조..☑️ 3. 분류 및 난이도코딩테스트 준비 - 시뮬레이션과 구현 문제입니다.☑️ 4. 생각한 것들 구현문제라 그런지 노가다성이 좀 짙습니다. 외에는 큰 어려움은 없었습니다. 배열 인덱스 오류가 잘 뜨는데, 입력값에 따라 map의 크기가 달라질 수 있으므로 입력 받을때마다 크기를 업데이트 해줘야합니다.5. codedef one_solution(temp_map): temp_map = temp_map[::-1] return temp_mapdef two_solution(temp_map, size): for i in range(size): temp_map[i].reverse() return temp_mapdef three_solution(temp_map, row, col): new_map = [] for j in range(col): temp_list = [] for i in range(row - 1, -1, -1): temp_list.append(temp_map[i][j]) new_map.append(temp_list) return new_mapdef four_solution(temp_map, row, col): new_map = [] for j in range(col - 1, -1, -1): temp_list = [] for i in range(row): temp_list.append(temp_map[i][j]) new_map.append(temp_list) return new_mapdef five_solution(temp_map, row, col): new_map = [] row_cut = row // 2 col_cut = col // 2 up_step, down_step = temp_map[:row_cut], temp_map[row_cut:] one_step, two_step = [], [] three_step, four_step = [], [] for i in range(len(up_step)): one_step.append(up_step[i][:col_cut]) two_step.append(up_step[i][col_cut:]) for i in range(len(down_step)): three_step.append(down_step[i][col_cut:]) four_step.append(down_step[i][:col_cut]) for i in range(row_cut): new_map.append(four_step[i] + one_step[i]) for i in range(row_cut): new_map.append(three_step[i] + two_step[i]) return new_mapdef six_solution(temp_map, row, col): new_map = [] row_cut = row // 2 col_cut = col // 2 up_step, down_step = temp_map[:row_cut], temp_map[row_cut:] one_step, two_step = [], [] three_step, four_step = [], [] for i in range(len(up_step)): one_step.append(up_step[i][:col_cut]) two_step.append(up_step[i][col_cut:]) for i in range(len(down_step)): three_step.append(down_step[i][col_cut:]) four_step.append(down_step[i][:col_cut]) for i in range(row_cut): new_map.append(two_step[i] + three_step[i]) for i in range(row_cut): new_map.append(one_step[i] + four_step[i]) return new_mapinput_map = []n, m, r = map(int, input().split())for i in range(n): temp_list = list(map(int, input().split())) input_map.append(temp_list)commands = list(map(int, input().split()))for command in commands: row = len(input_map) col = len(input_map[0]) if command == 1: input_map = one_solution(input_map) elif command == 2: input_map = two_solution(input_map, row) elif command == 3: input_map = three_solution(input_map, row, col) elif command == 4: input_map = four_solution(input_map, row, col) elif command == 5: input_map = five_solution(input_map, row, col) else: input_map = six_solution(input_map, row, col)for i in range(len(input_map)): print(&#39; &#39;.join(map(str, input_map[i])))6. 후기 코드가 너무 거대하고 심지어 solution5, solution6함수는 쪼개는 작업에 더해주는 작업도 있어서 시간 효율성에서 통과 못할줄 알았는데.. 잘되네요. c++로 작성이 필요하거나 도움이 필요하시면 댓글을 작성해주세요.!! 기록용이라 설명이 자세하지 않습니다." }, { "title": "Baekjoon15655 - N과 M(6)(Python)", "url": "/posts/baekjoon15655/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon", "date": "2022-08-10 01:02:00 +0900", "snippet": "백준 사이트 15655 - N과 M(6) 문제입니다.☑️ 1. 문제https://www.acmicpc.net/problem/15655☑️ 2. Input , Output☑️ 3. 분류 및 난이도코딩테스트 준비 - 브루트 포스 - N과 M 문제입니다.☑️ 4. 생각한 것들 N과M의 6번째문제라 겹치는 내용이 많습니다. 앞에 나온 요소와 중복되지 않고 작지 않으면 됩니다.5. coden, m = map(int, input().split())data = list(map(int, input().split()))def solution(origin): pick = [] def recur(): if len(pick) == m: for num in pick: print(num, end=&quot; &quot;) print(&#39;&#39;) return for origin_data in origin: if len(pick) !=0 and pick[-1] &amp;gt;= origin_data: continue pick.append(origin_data) recur() pick.pop() recur()data.sort()solution(data)6. 후기 c++로 작성이 필요하거나 도움이 필요하시면 댓글을 작성해주세요.!! 기록용이라 설명이 자세하지 않습니다." }, { "title": "Baekjoon6064 - 카잉달력(Python)", "url": "/posts/baekjoon6064/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon", "date": "2022-08-09 01:02:00 +0900", "snippet": "백준 사이트 6064 - 카잉달력 문제입니다.☑️ 1. 문제https://www.acmicpc.net/problem/6064☑️ 2. Input , Output☑️ 3. 분류 및 난이도코딩테스트 준비 - 브루트 포스 문제입니다.☑️ 4. 생각한 것들 당연하게도 1부터 연산하면 제 시간안에 못 풀거라 생각했습니다. 반대로해도 되지만 x를 기준으로잡고 y를 M만큼 더해주고 N만큼 나눠준 나머지가 y자리에 올 값입니다. 매 번 나눠줘도 되지만 나누지않고 더하고 나머지만 확인해도 풀 수는 있습니다. 처음에 조건에 맞는 숫자가 들어올 수 있으므로 처음에도 분기문처리를 해주었습니다.5. codedef is_init(data): return True if data == 0 else FalseT = int(input())for i in range(T): M, N, x, y = map(int, input().split(&quot; &quot;)) dict = {} init_x, init_y = 1, 1 result = x init_x = x init_y = init_x % N if is_init(init_y): init_y = N while not (y == init_y): init_y = (init_y + M) % N if is_init(init_y): init_y = N if init_y in dict: result = -1 break dict[init_y] = 1 result += M print(result)6. 후기 3년 전엔 못 풀었는데 지금은 풀었다. c++로 작성이 필요하거나 도움이 필요하시면 댓글을 작성해주세요.!! 기록용이라 설명이 자세하지 않습니다." }, { "title": "Python Docker + Postgres 테스트", "url": "/posts/fastapi_test_postgres/", "categories": "Python, FastAPI", "tags": "FastAPI", "date": "2022-08-08 01:00:00 +0900", "snippet": "사이드 프로젝트에서 잘 진행되던 통합테스트가 펑펑 터져버렸다.이유인 즉슨, Docker로 띄운 PostgresCotainer가 여러 테스트함수에서 공유하다보니,데이터중복도 발생하고 정합성 등 문제가 발생했다.예를들어 test1()에서 User객체를 생성하면 이게 사라지지 않고 test2()에서도 존재하여 영향을 미친다는 것이다.일단 기존 Docker로 띄운 Postgres코드이다.패키지는 깃허브에 나와있다.깃허브 주소: “https://github.com/testcontainers/testcontainers-python”@pytest.fixture(scope=&quot;session&quot;, autouse=True)def db_container(session_mocker): with PostgresTestContainer(image=&quot;postgres:9.5&quot;, port=5432) as postgres: url = postgres.get_connection_url().replace(&quot;psycopg2&quot;, &quot;asyncpg&quot;) mock_os = os.environ | { &quot;SQLALCHEMY_DATABASE_URL&quot;: url, &quot;START_UP_DB_INIT&quot;: &quot;True&quot;, &quot;SECRET_KEY&quot;: &quot;yaguen&quot;, &quot;ALGORITHM&quot;: &quot;HS256&quot;, &quot;ACCESS_TOKEN_EXPIRE_MINUTES&quot;: &quot;10&quot;, &quot;MAIL_PASSWORD&quot;: os.environ.get(&quot;MAIL_PASSWORD&quot;) } session_mocker.patch.dict(os.environ, mock_os, clear=True) yield postgres@pytest.fixture(scope=&quot;session&quot;)def client() -&amp;gt; TestClient: with TestClient(app) as c: yield cscope범위를 session으로 지정하여 테스트가 끝날때까지 yield 밑으로 가질 않는다. 즉, 한 번 띄우면 모든 테스트가 끝날때까지 살아있다는 것.처음에는 scope범위를 function으로 줄였다.그러면 도커로 띄웠다가 내렸다가를 반복해서 테스트 시간이 엄청 오래걸렸다.‘통합테스트는 원래 오래 걸리는거 아냐?’ 하면서 걍 시도해봤는데..그 밑에 있는@pytest.fixture(scope=&quot;session&quot;)def client() -&amp;gt; TestClient: with TestClient(app) as c: yield c에서 문제가 발생했다.Os에러가 발생하였는데, 이를 어떻게 할까 하다가 fixture를 빼보기도 하고 그런 삽질을 하고 있었다.그러던 와중 PostgresTestContainer함수를 작성한 친구가 도커 띄우는데 오래걸리니까 일부러 db_container의 스코프를 session으로 해둔거라고 했다.그래서 결국 session으로 두고 데이터 정합성을 해결할 방법을 찾아봤는데..PostgresTestContainer에는 sql문을 실행할 수 있는 메서드가 있다고 친구가 그랬다.하지만, 결국 테이블이 많아지면 많아질수록 sql문을 매 번 수정해주는건 번거로워서 테스트 특성상 데이터를 다 날리는게 낫다고 생각했다.그래서 가장 먼저 든 생각은 truncate를 이용해서 테이블 데이터를 다 날릴 생각이었지만..연관관계가 또 깊어지면 truncate로 해결할 수 없을거라 생각했다.그래서 아예 초기상태로 만들어야하는 fixture가 필요했다.왜냐하면 함수가 실행될 때마다 테이블을 다 초기화시켜야하므로 fixture가 필요했고 scope범위는 function으로 두어야겠다고 생각했다.그래서 만든 함수는..@pytest.fixture()async def delete_container(db_container) -&amp;gt; None: from app.db.session import Base engine = create_async_engine(db_container.get_connection_url().replace(&quot;psycopg2&quot;, &quot;asyncpg&quot;)) async with engine.begin() as conn: await conn.run_sync(Base.metadata.drop_all) await conn.run_sync(Base.metadata.create_all)현재 잘돌아가긴하는데.. 더 좋은 방법이 없으려나 모르겠다.fixture에 있는 db_container를 받고, 그 url을 기준으로 테이블을 삭제하고 만들고 하는 코드다.문제점은 db_container내부에 있는 url = postgres.get_connection_url().replace(&quot;psycopg2&quot;, &quot;asyncpg&quot;)의 구문이 바뀌면 바뀐 url을 똑같이 매핑해줘야하지만 url이 바뀔 경우는 거의 없을거라 판단한다. fixture의 scope에 아무값도 없으면 function이 들어간다.이를 통해 박살나던 통합테스트를 다 돌아가게 해결하였다.✍️전체코드import osimport pytestfrom sqlalchemy.ext.asyncio import create_async_enginefrom testcontainers.postgres import PostgresContainerfrom starlette.testclient import TestClientfrom app.main import appclass PostgresTestContainer(PostgresContainer): def get_connection_url(self): # windows docker connection return super().get_connection_url().replace(&#39;localnpipe&#39;, &#39;localhost&#39;)@pytest.fixture(scope=&quot;session&quot;, autouse=True)def db_container(session_mocker): with PostgresTestContainer(image=&quot;postgres:9.5&quot;, port=5432) as postgres: url = postgres.get_connection_url().replace(&quot;psycopg2&quot;, &quot;asyncpg&quot;) mock_os = os.environ | { &quot;SQLALCHEMY_DATABASE_URL&quot;: url, &quot;START_UP_DB_INIT&quot;: &quot;True&quot;, &quot;SECRET_KEY&quot;: &quot;yaguen&quot;, &quot;ALGORITHM&quot;: &quot;HS256&quot;, &quot;ACCESS_TOKEN_EXPIRE_MINUTES&quot;: &quot;10&quot;, &quot;MAIL_PASSWORD&quot;: os.environ.get(&quot;MAIL_PASSWORD&quot;) } session_mocker.patch.dict(os.environ, mock_os, clear=True) yield postgres@pytest.fixture(scope=&quot;session&quot;)def client() -&amp;gt; TestClient: with TestClient(app) as c: yield c@pytest.fixture()async def delete_container(db_container) -&amp;gt; None: from app.db.session import Base engine = create_async_engine(db_container.get_connection_url().replace(&quot;psycopg2&quot;, &quot;asyncpg&quot;)) async with engine.begin() as conn: await conn.run_sync(Base.metadata.drop_all) await conn.run_sync(Base.metadata.create_all)" }, { "title": "Baekjoon15654-N과 M(5)", "url": "/posts/baekjoon15654/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon", "date": "2022-08-06 01:02:00 +0900", "snippet": "백준 사이트 15654 - N과 M(5) 문제입니다.☑️ 1. 문제https://www.acmicpc.net/problem/15654☑️ 2. Input , Output☑️ 3. 분류 및 난이도코딩테스트 준비 - 기초 문제입니다.☑️ 4. 생각한 것들 파이썬 라이브러리에 지원하는 기능이 없어서 직접 작성하기로 했습니다. 사전순으로 정렬을 해줘야합니다. input값을 int로 설정하지 않으면 string으로 받기때문에 list(map(int)~)코드를 넣었습니다.5. coden, m = map(int, input().split())data = list(map(int,input().split()))def solution(li, m): size = len(li) pick = [] def recur(): if (len(pick) == m): for idx in pick: print(idx, end=&quot; &quot;) print(&quot;\\n&quot;, end=&quot;&quot;) return for data in li: if data in pick: continue pick.append(data) recur() pick.pop() recur()data = sorted(data)solution(data, m)6. 후기 c++로 작성이 필요하거나 도움이 필요하시면 댓글을 작성해주세요.!! 기록용이라 설명이 자세하지 않습니다." }, { "title": "Baekjoon15652-N과 M(4)", "url": "/posts/baekjoon15652/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon", "date": "2022-08-05 01:02:00 +0900", "snippet": "백준 사이트 15652 - N과 M(4) 문제입니다.☑️ 1. 문제https://www.acmicpc.net/problem/15652☑️ 2. Input , Output☑️ 3. 분류 및 난이도코딩테스트 준비 - 기초 문제입니다.☑️ 4. 생각한 것들 파이썬 라이브러리에 지원하는 기능이 없어서 직접 작성하기로 했습니다. 이전문제와 비슷한 방식이지만 중복된 순열이 나오면 안된다는 조건이 추가되어 뒤에 추가되는 숫자가 앞의 숫자보다 작지 않게 조건을 걸어주어 해결했습니다.5. coden, m = map(int, input().split())def solution(li, m): size = len(li) pick = [] def recur(): if (len(pick) == m): for idx in pick: print(idx, end=&quot; &quot;) print(&quot;\\n&quot;, end=&quot;&quot;) return for i in range(1, size + 1): if len(pick) != 0: if pick[-1] &amp;gt; i: continue pick.append(i) recur() pick.pop() recur()li = list(range(1, n + 1))solution(li, m)6. 후기 c++로 작성이 필요하거나 도움이 필요하시면 댓글을 작성해주세요.!! 기록용이라 설명이 자세하지 않습니다." }, { "title": "FastAPI Jwt 로그인 인증 필터 구현", "url": "/posts/fastapi_dependencies/", "categories": "Python, FastAPI", "tags": "FastAPI", "date": "2022-08-03 01:00:00 +0900", "snippet": "사이드 프로젝트에서 게시글 CRUD를 제작하다가 겪은 난관이다.비회원과 회원 유저를 식별하고 비회원 유저인 경우 게시글의 password를 받아야했다.회원인 경우 jwt토큰을 통해 회원을 식별해야했다.그래서 java에서 쓰이는 Filter라는 것이 필요했다.하지만 FastAPI는 그런걸 지원해주지 않았고, 비슷하게나마 Depend를 통해 구현할 수 있었다.인증이 필요한 컨트롤러마다 전부 붙여주는건 매우 귀찮지만..더 좋은 방법이 있다면 또 포스팅을 해야겠다.# api/post.py @router.post( &quot;&quot;, status_code=status.HTTP_201_CREATED,)async def create( post: PostCreate = Body(..., embed=True, alias=&quot;post&quot;), user: Optional[User] = Depends(get_current_user_authorizer()), db: AsyncSession = Depends(get_db)): return await create_post( db=db, post=post, user=user, )컨트롤러 부분이다. 여기서 주목해야할건 get_current_user_authorizer이다.def get_current_user_authorizer( *, required: bool = False) -&amp;gt; Callable: return get_current_user if required else get_current_user_optional이런식으로 구현되어있다. required이 True면 인증받아야할 회원이 필연적으로 있어야하는거고 없으면 비회원 또는 회원 모두 접근가능한 서비스에 의한 호출을 의미한다.비회원이나 회원모두 requried를 주지 않는경우에 대해서는 get_current_user_optional를 호출할것이므로 해당 함수를 작성해보겠다.async def get_current_user_optional( db: AsyncSession = Depends(get_db), token: str = Depends(get_authorization_header_retriever(required=False)), jwt_config: JwtConfig = Depends(get_jwt_config),) -&amp;gt; Optional[User]: if token: return await get_current_user(db, token, jwt_config) return None여기서 만약 토큰이 있다면, get_current_user라는 현재 접속한 유저를 식별하는 로직으로 갈 것이고 없다면 None을 반환하여 비회원임을 나타낼것이다.# get_authorization_header_retrieverdef get_authorization_header_retriever( *, required: bool = False) -&amp;gt; Callable: return get_authorization_header if required else get_authorization_header_optional인증이 필요없는경우 에러를 발생시키면 안되므로 get_authorization_header_optional로 빠지게 설계해야 한다.async def get_authorization_header_optional( api_key: str = Security(GetAPIKeyHeader(name=HEADER_KEY)), jwt_config: JwtConfig = Depends(get_jwt_config),) -&amp;gt; str: if api_key: return get_authorization_header(api_key, jwt_config) return &quot;&quot;이렇게 하면 헤더에 인증키값이 없는경우 &quot;&quot;를 반환하고 만약 있다면 인증키값을 복호화할 것이다.def get_authorization_header( api_key: str = Security(GetAPIKeyHeader(name=HEADER_KEY)), jwt_config: JwtConfig = Depends(get_jwt_config),) -&amp;gt; str: try: token_prefix, token = api_key.split(&quot; &quot;) except ValueError: raise HTTPException( status_code=status.HTTP_401_UNAUTHORIZED, detail=&quot;Unknown Header&quot; ) if token_prefix != jwt_config.TOKEN_PREFIX: raise HTTPException( status_code=status.HTTP_401_UNAUTHORIZED, detail=&quot;Unknown Header&quot; ) return token그리고 이를 식별하는 GetAPIKeyHeader클래스 코드이다.class GetAPIKeyHeader(APIKeyHeader): async def __call__( self, request: requests.Request, ) -&amp;gt; Optional[str]: try: return await super().__call__(request) except StarletteHTTPException: return None전체 코드 get_db는 DataBase Session을 반환하고 jwt_config는 jwt에 필요한 알고리즘, 시크릿키, 만료시간 등을 가지고 있다.HEADER_KEY = &quot;Authorization&quot;class GetAPIKeyHeader(APIKeyHeader): async def __call__( self, request: requests.Request, ) -&amp;gt; Optional[str]: try: return await super().__call__(request) except StarletteHTTPException: return Nonedef get_current_user_authorizer( *, required: bool = False) -&amp;gt; Callable: return get_current_user if required else get_current_user_optionaldef get_authorization_header_retriever( *, required: bool = False) -&amp;gt; Callable: return get_authorization_header if required else get_authorization_header_optionaldef get_authorization_header( api_key: str = Security(GetAPIKeyHeader(name=HEADER_KEY)), jwt_config: JwtConfig = Depends(get_jwt_config),) -&amp;gt; str: try: token_prefix, token = api_key.split(&quot; &quot;) except ValueError: raise HTTPException( status_code=status.HTTP_401_UNAUTHORIZED, detail=&quot;Unknown Header&quot; ) if token_prefix != jwt_config.TOKEN_PREFIX: raise HTTPException( status_code=status.HTTP_401_UNAUTHORIZED, detail=&quot;Unknown Header&quot; ) return tokenasync def get_authorization_header_optional( api_key: str = Security(GetAPIKeyHeader(name=HEADER_KEY)), jwt_config: JwtConfig = Depends(get_jwt_config),) -&amp;gt; str: if api_key: return get_authorization_header(api_key, jwt_config) return &quot;&quot;async def get_current_user( db: AsyncSession = Depends(get_db), token: str = Depends(get_authorization_header_retriever()), jwt_config: JwtConfig = Depends(get_jwt_config),) -&amp;gt; User: try: email = get_email_from_token( token=token, jwt_config=jwt_config ) except ValueError: raise HTTPException( status_code=status.HTTP_401_UNAUTHORIZED, detail=&quot;Unknown token&quot; ) try: user = await get_user_by_email( db=db, email=email, ) except Exception: raise HTTPException( status_code=status.HTTP_401_UNAUTHORIZED, detail=&quot;Unknown token&quot; ) return userasync def get_current_user_optional( db: AsyncSession = Depends(get_db), token: str = Depends(get_authorization_header_retriever(required=False)), jwt_config: JwtConfig = Depends(get_jwt_config),) -&amp;gt; Optional[User]: if token: return await get_current_user(db, token, jwt_config) return None테스트1. 비로그인 회원이 글을 쓸 때curl -X &#39;POST&#39; \\ &#39;http://localhost:8000/post&#39; \\ -H &#39;accept: application/json&#39; \\ -H &#39;Content-Type: application/json&#39; \\ -d &#39;{ &quot;post&quot;: { &quot;title&quot;: &quot;string&quot;, &quot;content&quot;: &quot;string&quot;, &quot;password&quot;: &quot;string&quot; }}&#39;성공2. 로그인한 회원이 글을 쓸 때 (식별되지 않는 유저인 경우)curl -X &#39;POST&#39; \\ &#39;http://localhost:8000/post&#39; \\ -H &#39;accept: application/json&#39; \\ -H &#39;Authorization: Bearer 123&#39; \\ -H &#39;Content-Type: application/json&#39; \\ -d &#39;{ &quot;post&quot;: { &quot;title&quot;: &quot;string&quot;, &quot;content&quot;: &quot;string&quot;, &quot;password&quot;: &quot;string&quot; }}&#39;-H &#39;Authorization: Bearer 123&#39; \\이 부분을 주목하면 토큰값으로 ‘123’을 넘기고 있다.실패3. 로그인한 회원이 글을 쓸 때 (식별되는 경우)curl -X &#39;POST&#39; \\ &#39;http://localhost:8000/post&#39; \\ -H &#39;accept: application/json&#39; \\ -H &#39;Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6InVzZXJAZXhhbXBsZS5jb20iLCJpZCI6MSwiZXhwIjoxNjYyMDgxNzIyfQ.XTLA4qM4txDRqckkGnYePDAlwSaPnxPpywnKpxL2h_8&#39; \\ -H &#39;Content-Type: application/json&#39; \\ -d &#39;{ &quot;post&quot;: { &quot;title&quot;: &quot;string&quot;, &quot;content&quot;: &quot;string&quot;, &quot;password&quot;: &quot;string&quot; }}&#39; 로그인 컨트롤러를 통해 유저정보를 담고 있는 토큰값을 가지고 인증을 하고 있다.여러번 포스팅해도 해당 회원를 찾아 post테이블에 회원정보를 입력하는것을 확인할 수 있다." }, { "title": "Baekjoon15651-N과 M(3)", "url": "/posts/baekjoon15651/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon", "date": "2022-07-26 01:02:00 +0900", "snippet": "백준 사이트 15651 - N과 M(3) 문제입니다.☑️ 1. 문제https://www.acmicpc.net/problem/15651☑️ 2. Input , Output☑️ 3. 분류 및 난이도코딩테스트 준비 - 기초 문제입니다.☑️ 4. 생각한 것들 파이썬 라이브러리에 지원하는 기능이 없어서 직접 작성하기로 했습니다.5. coden, m = map(int, input().split())def solution(li, m): size = len(li) pick = [] def recur(): if (len(pick) == m): for idx in pick: print(idx, end=&quot; &quot;) print(&quot;\\n&quot;, end=&quot;&quot;) return for i in range(1, size + 1): pick.append(i) recur() pick.pop() recur()li = list(range(1, n + 1))solution(li, m)6. 후기 개선점은 출력문을 이쁘게 써볼 수 있게.. 전에도 그랬는데 c++로 작성이 필요하거나 도움이 필요하시면 댓글을 작성해주세요.!! 기록용이라 설명이 자세하지 않습니다." }, { "title": "FastAPI 공식문서 따라하기[29] - Dependencies - Dependencies in path operation decorators", "url": "/posts/fastapi29/", "categories": "Python, FastAPI", "tags": "FastAPI", "date": "2022-07-25 02:00:00 +0900", "snippet": " https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/ 공식문서 따라하는 글어떤 경우에는 컨트롤러가 리턴값을 반환하지 않거나 의존성함수가 리턴을 안 하는 경우가 있습니다.이러한 경우 Depends대신에 dependencies라는 list형태를 컨트롤러 decorator에 달아줄 수 있습니다.☑️ Add dependencies to the path operation decoratorfrom fastapi import Depends, FastAPI, Header, HTTPExceptionapp = FastAPI()async def verify_token(x_token: str = Header()): if x_token != &quot;fake-super-secret-token&quot;: raise HTTPException(status_code=400, detail=&quot;X-Token header invalid&quot;)async def verify_key(x_key: str = Header()): if x_key != &quot;fake-super-secret-key&quot;: raise HTTPException(status_code=400, detail=&quot;X-Key header invalid&quot;) return x_key@app.get(&quot;/items/&quot;, dependencies=[Depends(verify_token), Depends(verify_key)])async def read_items(): return [{&quot;item&quot;: &quot;Foo&quot;}, {&quot;item&quot;: &quot;Bar&quot;}]@app.get데코레이션을 보면 구문을 통해 의존성을 주입해주고 있습니다.실제로curl -X &#39;GET&#39; \\ &#39;http://localhost:8000/items/&#39; \\ -H &#39;accept: application/json&#39; \\ -H &#39;x-token: fake-super-secret-token&#39; \\ -H &#39;x-key: fake-super-secret-key&#39;이렇게 x-token값과 x-key값이 원하는 값을 맞춰주지 않는다면 컨트롤러에서 리턴하는 값들을 볼 수 없습니다.즉, 의존성함수들의 로직들은 실행되지만 의존성함수를 호출한 쪽으로 리턴값을 전달하지는 않습니다. 위의 예는 실제 JWT Token과 같이 헤더값으로 토큰을 받아야할 때 쓰이는 예제입니다.☑️ Dependencies errors and return valuesdependencis구문 속에 있는 의존성함수들도 여타 다른 함수들처럼 평범하게 작성하면 된다고 합니다.의존성함수들의 인자값들을 선언하지 않거나 위처럼 헤더, 또는 다른 의존성함수를 Depends구문에서 했던대로 넣을 수 있습니다.위의 예제에서는 verify_token은 raise를통해 예외를 발생시키고, verify_key는 return구문을 통해 값을 리턴하고 있습니다.그렇지만 return한 값은 사용되지 않지만 호출하는 다른 곳에서 리턴값이 필요한 경우 해당 함수를 재사용할 수도 있다는 점이 있습니다.☑️ Global Dependencies의존성을 애플리케이션 전체에 적용하고 싶을 때가 생길 수 있는데, 위와 비슷한 방식으로 의존성을 FastAPI 애플리케이션에 적용할 수 있습니다.from fastapi import Depends, FastAPI, Header, HTTPExceptionasync def verify_token(x_token: str = Header()): if x_token != &quot;fake-super-secret-token&quot;: raise HTTPException(status_code=400, detail=&quot;X-Token header invalid&quot;)async def verify_key(x_key: str = Header()): if x_key != &quot;fake-super-secret-key&quot;: raise HTTPException(status_code=400, detail=&quot;X-Key header invalid&quot;) return x_keyapp = FastAPI(dependencies=[Depends(verify_token), Depends(verify_key)])@app.get(&quot;/items/&quot;)async def read_items(): return [{&quot;item&quot;: &quot;Portal Gun&quot;}, {&quot;item&quot;: &quot;Plumbus&quot;}]@app.get(&quot;/users/&quot;)async def read_users(): return [{&quot;username&quot;: &quot;Rick&quot;}, {&quot;username&quot;: &quot;Morty&quot;}]이렇게 적용할 경우 모든 요청에 대해서 적용됩니다." }, { "title": "Baekjoon15650-N과 M(2)", "url": "/posts/baekjoon15650/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon", "date": "2022-07-25 01:02:00 +0900", "snippet": "백준 사이트 15650 - N과 M(2) 문제입니다.☑️ 1. 문제https://www.acmicpc.net/problem/15650☑️ 2. Input , Output☑️ 3. 분류 및 난이도코딩테스트 준비 - 기초 문제입니다.☑️ 4. 생각한 것들 조합 문제이고, Python라이브러리를 통해서 빠르게 풀 수 있을거라 생각했습니다. 출력을 좀 더 이쁘게 하고 싶은데.. 아쉽네요.5. codefrom itertools import combinationsn, m = map(int, input().split())li = [idx for idx in range(1, n + 1)]result = list(combinations(li, m))for item in result: for idx in item: print(idx, end=&quot; &quot;) print(&#39;\\n&#39;, end=&#39;&#39;)6. 후기 개선점은 출력문을 이쁘게 써볼 수 있게.. c++로 작성이 필요하거나 도움이 필요하시면 댓글을 작성해주세요.!! 기록용이라 설명이 자세하지 않습니다." }, { "title": "Baekjoon3085-사탕게임", "url": "/posts/baekjoon3085/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon", "date": "2022-07-24 02:02:00 +0900", "snippet": "백준 사이트 3085 - 사탕게임 문제입니다.☑️ 1. 문제https://www.acmicpc.net/problem/3085☑️ 2. Input , Output☑️ 3. 분류 및 난이도코딩테스트 준비 - 기초 문제입니다.☑️ 4. 생각한 것들 이 문제가 차라리 모든 경우의 수(단 한 번만 바꾸는 것이 아닌)것 같은 거였으면 더 어려웠을텐데 그러지는 않아서 실버3으로 책정된 문제라 생각했습니다. 그래도 탐색은 해줘야하고, 세로와 가로를 따로따로 해줘야했어서 이를 분리해서 하였습니다. 지나고 와서 생각해보면 반복되는 구문을 줄여서 좀 더 이쁘게 짤 수 있지만 알고리즘 문제에 그런 노고를 쓰지는 않고 싶습니다..5. code# 오후 10시 37분import copyimport sysfrom collections import dequen = int(sys.stdin.readline())map = [[0 for col in range(n)] for row in range(n)]dx = [0, 1, 0, -1]dy = [1, 0, -1, 0]answer = 0def BFS(map, x, y): v = [[False for col in range(n)] for row in range(n)] dq = deque() dq.append([x, y]) v[x][y] = True result = 0 count = 1 while dq: i, j = dq.popleft() result = max(result, count) for k in range(0,4,2): newx, newy = i + dx[k], j + dy[k] if 0 &amp;lt;= newx &amp;lt; n and 0 &amp;lt;= newy &amp;lt; n and v[newx][newy] == False and map[x][y] == map[newx][newy]: count+=1 dq.append((newx, newy)) v[newx][newy] = True dq.append([x, y]) result = max(result, count) count = 1 while dq: i, j = dq.popleft() result = max(result, count) for k in range(1,4,2): newx, newy = i + dx[k], j + dy[k] if 0 &amp;lt;= newx &amp;lt; n and 0 &amp;lt;= newy &amp;lt; n and v[newx][newy] == False and map[x][y] == map[newx][newy]: count+=1 dq.append((newx, newy)) v[newx][newy] = True return resultdef check_status(map, x, y): result = 0 for i in range(4): tempmap = copy.deepcopy(map) newx = x + dx[i] newy = y + dy[i] if 0 &amp;lt;= newx &amp;lt; n and 0 &amp;lt;= newy &amp;lt; n and map[x][y] != map[newx][newy]: tempmap[x][y], tempmap[newx][newy] = tempmap[newx][newy], tempmap[x][y] result = max(result, BFS(tempmap, x, y)) return resultfor i in range(n): inputstr = input().split() for j in range(n): convert = inputstr[0][j:j + 1] map[i][j] = convertfor i in range(n): for j in range(n): answer = max(BFS(map, i, j), check_status(map, i, j), answer)print(answer)6. 후기 개선점으로는 세로, 가로로 나눠서 함수를 작성하기 c++로 작성이 필요하거나 도움이 필요하시면 댓글을 작성해주세요.!! 기록용이라 설명이 자세하지 않습니다." }, { "title": "FastAPI 공식문서 따라하기[28] - Dependencies - Sub-dependencies", "url": "/posts/fastapi28/", "categories": "Python, FastAPI", "tags": "FastAPI", "date": "2022-07-24 01:00:00 +0900", "snippet": " https://fastapi.tiangolo.com/tutorial/dependencies/sub-dependencies/ 공식문서 따라하는 글FastAPI는 종속성을 갖 종속성함수 즉, 하위 종속성들을 정의하고 이를 처리해주는것을 도와줍니다.☑️ First dependency “dependable”from fastapi import Cookie, Depends, FastAPIapp = FastAPI()def query_extractor(q: str | None = None): return qdef query_or_cookie_extractor( q: str = Depends(query_extractor), last_query: str | None = Cookie(default=None)): if not q: return last_query return q@app.get(&quot;/items/&quot;)async def read_query(query_or_default: str = Depends(query_or_cookie_extractor)): return {&quot;q_or_cookie&quot;: query_or_default} 이 예제는 매우 직관적이라 실제 사용되기 어려운 예제이지만, 이해하는데 도움을 준다고 합니다.read_query()는 query_or_cookie_extractor()의 의존성을 갖고, query_or_cookie_extractor()는 query_extractor()의 의존성을 갖습니다.☑️ Second dependency, “dependable” and “dependant”query_or_cokkie_extractor()함수는 read_query이 호출하고 의존성으로 엮어있는데, 이러한 의존성 함수를 dependable라고 합니다. 또한 이 의존성 함수는 다시 의존성 함수 query_extractor를 호출합니다. 당연한 이야기겠지만 read_query는 query_or_cookie_extractor()를 호출합니다. 다만, FastAPI는 의존성을 해결하기 위해서 하위의존성인 query_extractor()를 제일 먼저 처리합니다.☑️ Using the same dependency multiple times 오역이 있을 수 있습니다. 틀린 정보라면 댓글을 달아주세요!!만약 여러 의존성 함수들이 하위 의존성 함수로 같은 함수의 값을 받는다면 FastAPI는 한 번 호출에 한 번 의존성 함수를 들립니다.이러한 동작방식은 최초 하위 의존성 함수에 들릴 때, cache를 통해 값을 저장하고 리턴합니다. 그리고 모든 상위 의존성 함수에 값을 전달합니다.만약 dependency를 사용하지 않고 해당 함수를 여러번 호출해야한다면, use_cache=False구문을 통해 매개변수를 설정해줄 수 있습니다.예제from fastapi import Cookie, Depends, FastAPIapp = FastAPI()def query_extractor(q: str | None = None): print(q) return qdef query_or_cookie_extractor( q: str = Depends(query_extractor), last_query: str | None = Cookie(default=None)): if not q: return last_query return qdef test_depend( q: str = Depends(query_extractor, use_cache=False)): return q@app.get(&quot;/items/&quot;)async def read_query( query_or_default: str = Depends(query_or_cookie_extractor), query_test: str = Depends(test_depend)): return {&quot;q_or_cookie&quot;: query_or_default, &quot;query_test&quot;: query_test}test_depend()를 보면 query_or_cookie_extractor()와 같이 같은 의존성함수인 query_extractor를 호출하고 있습니다. 만약, use_cache=False구문이 없다면 query_extractor가 단 한 번만 호출될 것입니다.use_cache=False가 없을 때use_cache=False가 있을 때" }, { "title": "FastAPI 공식문서 따라하기[27] - Dependencies - Classes as Dependencies", "url": "/posts/fastapi27/", "categories": "Python, FastAPI", "tags": "FastAPI", "date": "2022-07-16 02:00:00 +0900", "snippet": " https://fastapi.tiangolo.com/tutorial/dependencies/classes-as-dependencies/ 공식문서 따라하는 글이전 예제에서는 dict형태의 값을 의존성 함수에서 리턴했습니다.dict형태는 에디터에서 key와 value타입을 몰라 자동완성 지원을 못해줍니다..☑️ What makes a dependency의존성으로 callable를 주입할 수 있습니다.callable은 함수와 같이 어떻게든 호출할 수 있는 모든것을 말합니다.something이라는 객체가 있고 이를 호출할 수만 있으면 이러한 객체도 callable입니다. something = 1 은 객체지만 호출할 수 없으므로 callable이 아닙니다.☑️ Classes as dependenciesPython클래스의 인스턴스를 다음과 같이 만들 수 있습니다.class Cat: def __init__(self, name: str): self.name = namefluffy = Cat(name=&quot;Mr Fluffy&quot;) fluffy는 Cat클래스의 인스턴스입니다. fluffy를 만들어서 Cat을 호출할 수 있습니다. 이러한 Python 클래스를 callable이라고 합니다. FastAPI에서는 Python class의 의존성을 받을 수 있게 합니다.FastAPI는 callable객체인지 확인하고, 파라미터를 정의합니다.만약 callable한 객체를 의존성으로 넘기면, 파라미터를 분석하고 경로함수를 처리했던 방식대로 파라미터를 처리합니다.(이름이 같으면 자동으로 값을 넣어주는 등)이전 예제는 다음과 같이 클래스로 바꿀 수 있습니다.from fastapi import Depends, FastAPIapp = FastAPI()fake_items_db = [{&quot;item_name&quot;: &quot;Foo&quot;}, {&quot;item_name&quot;: &quot;Bar&quot;}, {&quot;item_name&quot;: &quot;Baz&quot;}]class CommonQueryParams: def __init__(self, q: str | None = None, skip: int = 0, limit: int = 100): self.q = q self.skip = skip self.limit = limit@app.get(&quot;/items/&quot;)async def read_items(commons: CommonQueryParams = Depends(CommonQueryParams)): response = {} if commons.q: response.update({&quot;q&quot;: commons.q}) items = fake_items_db[commons.skip : commons.skip + commons.limit] response.update({&quot;items&quot;: items}) return responsecommons: CommonQueryParams = Depends(CommonQueryParams) 구문을 통해 의존성을 설정해줄 수 있습니다. FastAPI는 설정된 클래스를 호출하고, 인스턴스를 생성하여 commons라는 파라미터에 넘겨버립니다.☑️ Type annotation vs Dependscommons: CommonQueryParams = Depends(CommonQueryParams)을 보면 CommonQueryParams을 중복해서 작성한걸 볼 수 있습니다.이를 해결하기 위해서 commons = Depends(CommonQueryParams)처럼 쓸수도 있습니다.하지만 결국 commons: CommonQueryParams처럼 타입을 지정하는 것에 대한 장점이 많기에 트레이드오프적으로 생각해봐야합니다.타입을 지정하면 에디터도 자료형에 대해 알아 자동완성 기능, 타입체크 등을 제공할 수 있습니다.또한, commons: CommonQueryParams = Depends()처럼 쓸 수도 있는데, 혼란을 가중시킬 수 있으므로 알아서 잘 판단해서 사용하도록 합시다." }, { "title": "Baekjoon17425-약수의 합", "url": "/posts/baekjoon17425/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon", "date": "2022-07-16 01:02:00 +0900", "snippet": "백준 사이트 17425 - 약수의 합 문제입니다.1. 문제https://www.acmicpc.net/problem/174252. Input , Output3. 분류 및 난이도코딩테스트 준비 - 기초 문제입니다.4. 생각한 것들 약수를 하나씩 구하면 당연히 시간초과가 날 것이라고 생각했습니다. 나름 시간복잡도를 고려해서 여러가지 방법을 사용했습니다. O(nlogn)으로 줄였지만, 극한으로 더 줄여야했습니다. 결국 다른 블로그를 참조하였고 똑같은 O(nlogn)이지만 출력부분만 다른걸 봐서 출력부분에서 시간을 더 줄인것 같습니다.5. codeMAX = 1000000dp = [1] * (MAX + 1)s = [0] * (MAX + 1)for i in range(2, MAX + 1): j = 1 while i * j &amp;lt;= MAX: dp[i * j] += i j+=1for i in range(1, MAX + 1): s[i] = s[i-1] + dp[i]iter = int(input())ans = []for k in range(iter): n = int(input()) ans.append(s[n])print(&#39;\\n&#39;.join(map(str,ans)) + &#39;\\n&#39;)6. 후기 이게 골드4?" }, { "title": "FastAPI 공식문서 따라하기[26] - Dependencies - First Steps", "url": "/posts/fastapi26/", "categories": "Python, FastAPI", "tags": "FastAPI", "date": "2022-07-16 01:00:00 +0900", "snippet": " https://fastapi.tiangolo.com/tutorial/dependencies/ 공식문서 따라하는 글☑️ Dependencies - FirstSteps FastAPI에서 제공하는 의존성 주입은 사용하기 편하고 다른 컴포넌트들을 통합하기 쉽게 만들어준다고 합니다.☑️ What is “Dependency Injection” 의존성 주입이란, 코드를 선언할때는 동작하고 사용하기 위해서는 ‘의존성’이 필요합니다. 프레임워크나 시스템들은 의존성이 필요한 코드들에 자동으로 의존성을 넣어줍니다. 이것을 의존성 주입이라고 합니다. 공식문서에서는 이렇게 설명하고 있지만, 개념적으로 다른 부분이 많이 있습니다. DIP를 검색해보는걸 추천합니다.의존성 주입을 통해 얻을 수 있는 강점으로는 로직을 공유할 수 있고 데이터베이스 커넥션을 공유할 수 있고 보안강화, 인증, 업무규칙 등에 사용할 수 있고 등..을 가지고 있습니다.☑️ First Steps간단한 예제를 주는데 공식문서에서는 사용하기에 좋지 않은 쓸모없는 예제라고 합니다. 그냥 어떻게 동작하는지 알기 위해 넣어놨다고 합니다.from fastapi import Depends, FastAPIapp = FastAPI()async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100): return {&quot;q&quot;: q, &quot;skip&quot;: skip, &quot;limit&quot;: limit}@app.get(&quot;/items/&quot;)async def read_items(commons: dict = Depends(common_parameters)): return commons@app.get(&quot;/users/&quot;)async def read_users(commons: dict = Depends(common_parameters)): return commonscommon_parametes함수를 보면 skip의 디폴트값은 0, limit의 디폴트값은 100입니다.Body,Query 등과 같이 파라미터에 넣어줄 수 있는데, 이것들과 Depends는 다르게 동작합니다.이렇게 함수를 넣어줘도 경로 함수랑 똑같이 작동합니다.즉, 해당 컨트롤러들은 q, skip, limit을 인자값으로 받아야합니다.만약 q: str | None = None에서 q: str로 바꿔 필수로 인자로 받게 설정하고 요청을 보내면이렇게 에러가 뜹니다.즉, common: dict = Depends(common_parameters)는 common_parameters에 있는 인자값을 컨트롤러에서 받도록 합니다.위 코드에서 새로운 요청이 들어오면 FastAPI는 다음과 같은 처리를 합니다. 설정한 dependency를 부르고 파라미터가 맞게 설정되었는지 확인합니다. 해당 함수에서 설정한 리턴값을 가져옵니다. 그 리턴값을 인자로 설정한 값(commons)에 주입합니다.이렇듯 items나 users컨트롤러는 common_parameters에 의존하게 됩니다. 함수가 바뀌면 두 컨트롤러도 바뀌게 됩니다. 그리고 컨트롤러는 본인이 의존성을 주입하는 것이 아닌 함수가 의존성을 주입하게 되므로, 이를 DIP의존성역전법칙을 만족하게 됩니다.☑️ To async or not to async의존성 함수를 정의할 때 async def나 def를 사용할 수 있습니다.async def의 의존성함수로 def를 지정할 수도 있고,def의 의존성함수로 async def를 지정할 수도 있습니다.FastAPI는 이를 감지하여 알아서 처리해줍니다.공식문서에서는 자신들이 만든 시스템에 대해서 굉장히 자랑을 하고 있는데 궁금하면 읽어보시길 바랍니다." }, { "title": "Baekjoon17427-약수의 합2", "url": "/posts/baekjoon17427/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon", "date": "2022-07-14 01:02:00 +0900", "snippet": "백준 사이트 17427 - 약수의 합2 문제입니다.1. 문제https://www.acmicpc.net/problem/174272. Input , Output3. 분류 및 난이도코딩테스트 준비 - 기초 문제입니다.4. 생각한 것들 약수를 하나씩 구하면 당연히 시간초과가 날 것이라고 생각했습니다. 1부터 n까지 가면서 배수마다 하나씩 더해주는 방법을 생각했습니다. (에라토스테네스의 체 방식 처럼)5. coden = int(input())memo = [1] * (n + 1)for i in range(2, n + 1): for j in range(i, n + 1, i): memo[j] = memo[j] + iprint(sum(memo) - 1)6. 후기 어제보다 더 쉬운 문제였습니다." }, { "title": "Docker - 컨테이너 로깅", "url": "/posts/Dockerlog04/", "categories": "Docker, CS", "tags": "Docker", "date": "2022-07-14 01:00:00 +0900", "snippet": " 시작하세요! 도커/쿠버네티스 책 정리글입니다.✍️ Json-file 로그 사용하기도커는 컨테이너의 표준 출력(StdOut)과 에러(stdErr)로그를 별도의 메타데이터 파일로 저장하낟고 합니다.간단한 로그를 남기기 위해docker run -d --name mysql \\-e MYSQL_ROOT_PASSWORD=1234 \\mysql:5.7해당 컨테이너는 백그라운드 모드로 실행되기에 실제로 mysql이 잘 돌아가는지 알 수가 없습니다.이를 확인하기 위해서는 docker logs &amp;lt;컨테이너명&amp;gt;명령어를 통해 볼 수 있습니다.docker logs mysql# 응용# 끝 두 줄만 출력docker logs --tail 2 mysql# 유닉스 시간을 입력해 특정 시간 이후의 로그 확인 가능docker logs --since 1474765979 mysql# -t 옵션을 통해 타임스탬프 표시가능docker logs -t mysql# -f 옵션을 통해 로그를 스트림으로 확인 가능docker logs -f mysql또한, 컨테이너 내부에서 bash 셸 등으로 입출력한 내용도 확인할 수 있습니다.컨테이너 로그는 JSON 형태로 도커 내부에 저장되는데, 이 파일들은/var/lib/docker/containers/${CONTaINER_ID}/${CONTAINER_ID}-json.log에 저장이 됩니다. cat, vi와 같은 명령어로 확인이 가능합니다.컨테이너의 출력이 너무 많아지면 호스트의 저장 공간을 많이 차지하게 되는데, 이를 방지하기 위해서 --log-opt옵션으로 파일의 최대 크기를 지정할 수 있습니다.docker run -it \\--log-opt max-size=10k --log-opt max-file=3 \\--name log-test ubuntu:14.04 max-size : json 로그 파일의 최대 크기 max-file : 로그 파일의 최대 개수위는 JSON 파일로 로그를 저장하지만 다른 방식들은 각종 로깅 드라이버를 사용하게 설정해 컨테이너 로그를 수집할 수 있게 도와줍니다.애플리케이션의 특징에 적합하게 로깅 드라이버를 선택해야하기에, 그 특징을 파악해야합니다. 로깅드라이버는 기본적으로 json-file로 설정되지만 도커 데몬 시작옵션에서 바꿀 수 있다고 합니다.✍️ syslog 로그두 번째방법인 syslog입니다.syslog란 유닉스 계열 대부분 운영체제에서 커널, 보안 등 로그를 수집하는 오래된 표준 중 하나라고 합니다. 인터페이스가 동일하기에 로그를 수집하고 분석하는데에 수월하다는 장점이 있습니다.다음 명령어를 통해 syslog에 로그를 저장하는 컨테이너를 생성합니다." }, { "title": "Baekjoon4375-1", "url": "/posts/baekjoon4375/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon", "date": "2022-07-13 06:02:00 +0900", "snippet": "백준 사이트 4375 - 1 문제입니다.1. 문제https://www.acmicpc.net/problem/43752. Input , Output3. 분류 및 난이도코딩테스트 준비 - 기초 문제입니다.4. 생각한 것들 일반적인 코드로는 시간초과가 납니다. 수학적으로 접근해야하는데, 분할해서 나눗셈을 해준다는 느낌으로 코드를 작성해주었습니다.5. codeimport sysinput = sys.stdin.readlinewhile (True): num = 1 result = 1 try: n = int(input().rstrip()) except: break while (True): if (num % n == 0): print(result) break else: num = (num % n) * 10 + 1 result+=16. 후기 쉬운 난이도는 아닌것 같습니다.. 정말 수학적 사고가 필요한" }, { "title": "Docker - 도커 네트워크", "url": "/posts/DockerNetwork/", "categories": "Docker, CS", "tags": "Docker", "date": "2022-07-13 04:00:00 +0900", "snippet": " 시작하세요! 도커/쿠버네티스 책 정리글입니다.📖 도커 네트워크컨테이너 내부에서 ifconfig을 입력하면 eth0과 lo 네트워크를 가지고 있는 것을 확인할 수 있습니다.도커는 컨테이너에 내부 IP를 순차적으로 할당하고, 이 IP는 컨테이너를 재시작 할 때마다 변경됩니다.이 IP들은 내부 망에서만 쓸 수 있기에 외부와 연결을 허용할 수 있게끔 바꿔주는 방법이 필요합니다.각 컨테이너는 시작될 때 도커 엔진이 veth라는 이름의 네트워크 인터페이스를 생성하고 이를 통해 외부와 통신할 수 있게 도와줍니다.도커가 설치된 호스트에서 ipconfig이나 ifconfig으로 네트워크들을 확인할 수 있습니다.그러면 veth로 시작하는 인터페이스들이 있는데 이것들은 각 컨테이너의 eth()와 연결되어있습니다.veth 인터페이스 뿐만 아니라 docker0라는 브리지도 존재하는데 각 veth 인터페이스와 바인딩 되어 호스트의 eth0인터페이스와 이어주는 역할을 합니다.그렇기에 다음과 같은 구조를 가집니다.의존성 도커 컨테이너내부[eth0, lo] -&amp;gt; 도커 컨테이너 외부, 호스트의[veth0] -&amp;gt; 호스트의[docker0] -&amp;gt; 호스트의[eth0]📖 도커 네트워크 기능docker0 브리지를 통해 외부와 통신할 수 있지만, 사용자의 선택에 따라 여러 네트워크 드라이브를 쓸 수 있다고 합니다. 브리지(bridge) 호스트(host) 논(none) 컨테이너(container) 오버레이(overlay)가 있습니다.```docker network ls`를 통해 도커에서 기본적으로 쓸 수 있는 네트워크를 확인할 수 있습니다.# docker network lsNETWORK ID NAME DRIVER SCOPE31a51219ee6e bridge bridge local9c37ea44edae host host local5db3d1df48b5 none null local브리지 네트워크는 컨테이너를 생성할때 자동으로 연결되는 docker0 브리지를 활용하도록 설정되어 있습니다.이 네트워크는 172.17.0.x IP대역을 순차적으로 할당합니다.docker network inspect bridge위 명령어를 통해 네트워크에 대한 정보를 확인할 수 있습니다.그 결과 서브넷은 172.17.0.0/16, 게이트웨이는 172.17.0.1로 설정되어 있는것을 확인할 수 있습니다.그리고 밑으로 내리다보면 Containers항목에서 해당 네트워크를 사용중인 컨테이너 목록을 확인할 수 있습니다.브리지 네트워크docker0의 브리지가 아닌 사용자 정의 브리지를 새로 생성해 컨테이너에 연결하는 네트워크 구조입니다.컨테이너는 연결된 브리지를 통해 외부와 통신할 수 있습니다.다음 명령어를 통해 새로운 브리지 네트워크를 생성할 수 있습니다.# docker network create --driver bridge kmsbridge537abe5b09fa282ab9becdb7c8140916be1ebe33906622e14a2b4e01ad4f5938그 다음 docker run 또는 create 명령어에 --net 옵션의 값을 설정하여 컨테이너가 해당 네트워크를 사용할 수 있게 설정할 수 있습니다.docker run -i -t --name network_bridge_container \\--net kmsbridge \\ubuntu:14.04# 접속후ifconfig172.18대역의 내부 IP가 할당되었습니다.이렇게 생성된 사용자 정의 네트워크는 유동적으로 붙였다, 떼었다 할 수 있다고 합니다.docker network disconnect kmsbridge network_bridge_containerdocker network connect kmsbridge network_bridge_container 논 네트워크, 호스트 네트워크 등과 같은 네트워크 모드에는 이렇게 붙였다 떼는 명령어를 쓸 수 없습니다.브리지 네트워크 또는 오버레이 네트워크와 같이 특정 IP 대역을 갖는 네트워크 모드에만 사용할 수 있습니다.만약 자동으로 설정된 네트워크가 아닌, 여러 정보를 임의로 설정하고 싶다면 다음과 같은 옵션을 설정할 수 있습니다.docker network create --driver=bridge \\--subnet=172.72.0.0/16 \\--ip-range=172.72.0.0/24 \\--gateway=172.72.0.1 \\my_custom_network호스트 네트워크호스트 네트워크로 설정하면 말 그대로 호스트의 네트워크를 그대로 쓸 수 있습니다.별도의 생성 없이 host라는 이름의 네트워크를 사용합니다.docker run -i -t --name network_host \\--net host \\ubuntu:14.04# 접속 후ifconfig접속 후 확인하면 호스트의 네트워크 환경과 같다는 것을 확인할 수 있습니다.별도의 포트 포워드 없이 외부에서 바로 접근이 가능합니다.예를 들어 호스트 모드를 쓰는 컨테이너에 tomcat를 구동한다면 호스트의 localhost:8080으로 접근이 가능합니다.논 네트워크말 그대로 아무런 네트워크를 사용하지 않습니다.docker run -i -t --name none_network_container \\--net none \\ubuntu:14.04# 접속 후ifconfig네트워크를 확인해보면 로컬호스트를 나타내는 lo 외에는 존재하지 않는 것을 확인할 수 있습니다.컨테이너 네트워크--net옵션으로 container를 입력하면 다른 컨테이너의 네트워크 환경을 공유할 수 있습니다.대표적으로 내부IP, 네트워크 인터페이스의 맥(MAC) 주소 등입니다.docker run -i -t -d --name network_container_1 ubuntu:14.04docker run -i -t -d --name network_container_2 \\--net container:network_container_1 \\ubuntu:14.04이렇게 network_container_2는 network_container_1와 같은 네트워크를 공유하게 됩니다.내부 IP를 할당받지 않으며 호스트에 veth로 시작하는 가상 네트워크 인터페이스도 생성되지 않습니다.다음 명령어를 통해 확인할 수 있습니다.docker exec network_container_1 ifconfig...docker exec network_container_2 ifconfig브리지 네트워크와 –net-alias브리지 타입의 네트워크와 run 명령어의 --net-alias 옵션을 함께 쓰면 특정 호스트 이름으로 컨테이너 여러 개에 접근이 가능하다고 합니다.무슨 말인지 알기 위해서 kmsbridge 네트워크를 사용한 컨테이너 3개를 만들어봅니다.# 1docker run -i -t -d --name network_alias_container1 \\--net kmsbridge \\--net-alias kms727 ubuntu:14.04# 2docker run -i -t -d --name network_alias_container2 \\--net kmsbridge \\--net-alias kms727 ubuntu:14.04# 3docker run -i -t -d --name network_alias_container3 \\--net kmsbridge \\--net-alias kms727 ubuntu:14.04# inspect 명령어로 각 컨테이너의 IP를 확인docker inspect network_alias_container1 | grep IPAddress&amp;gt;&amp;gt; &quot;SecondaryIPAddresses&quot;: null, &quot;IPAddress&quot;: &quot;&quot;, &quot;IPAddress&quot;: &quot;172.18.0.2&quot;,첫 번째 container의 주소가 172.18.0.2이므로 나머지 두 개 컨테이너의 주소는 172.18.0.3, 172.18.0.4여야 합니다.세 개의 컨테이너에 접근할 컨테이너를 생성한 뒤 kms727이라는 호스트 이름으로 ping요청을 전송해 보겠습니다.docker run -i -t --name network_alias_ping \\--net kmsbridge \\ubuntu:14.04컨테이너 3개의 IP로 ping이 전송되었습니다.라운드 로빈 방식으로 보내는 IP를 결정합니다.도커 엔진에 내장된 DNS가 kms727이라는 호스트 이름을 --net-alias에 의해 kms727로 설정한 컨테이너로 변환하기 때문입니다.컨테이너 IP가 변경이 되어도 도커 내장 DNS는 이를 찾아 관리합니다.도커는 사용자가 정의한 네트워크를 관리하는 127.0.0.11의 ip를 갖는 내장 DNS서버를 가지고, 컨테이너의 ID는 DNS 서버에 kms727(위의예제)로 등록됩니다.그리고 kmsbridge(위의 예제)에 속한 컨테이너에 kms727에 접근하면 도커 DNS서버는 라운드 로빈을 통하여 컨테이너의 IP리스트를 반환합니다.📖 MacVLAN 네트워크호스트의 네트워크 인터페이스 카드를 가상화해 물리 네트워크 환경을 컨테이너에 동일하게 제공하는 기술이 있습니다.따라서 컨테이너는 물리 네트워크상에서 가상의 맥(MAC)주소를 가집니다.이렇게 연결된 컨테이너들은 기본적으로 네트워크 장비의 IP를 할당받기 때문입니다.실제 테스트에는 물리적인 장비가 필요하기에 여기까지만 적겠습니다." }, { "title": "Docker - mac M1칩 컨테이너 띄우는법", "url": "/posts/dockerError/", "categories": "Docker, CS", "tags": "Docker", "date": "2022-07-13 02:00:00 +0900", "snippet": "운영체제가 달라서 여러가지로 애먹던 도중docker run --platform==linux/arm64이런 식으로 매 번 써주고 있었다.스택 오버 플로우를 보니 환경변수로 설정해서 쓸 수 있더라.export DOCKER_DEFAULT_PLATFORM=linux/amd64이후에는shelldocker run`만 해줘도 잘 된다." }, { "title": "Docker - 도커 볼륨", "url": "/posts/DockerStart03/", "categories": "Docker, CS", "tags": "Docker", "date": "2022-07-13 01:00:00 +0900", "snippet": " 시작하세요! 도커/쿠버네티스 책 정리글입니다.✍️ 도커 볼륨도커 이미지로 컨테이너를 생성하면 이미지는 읽기전용이 된다고 합니다.컨테이너의 변경이력이나 정보는 별도로 저장하는데, 컨테이너가 관리 합니다.만약에 mysql와 wordpress를 함께 쓰는 도커가 있다고 가정하면 mysql은 wordpress에서 작성한 정보들을 가지고 있을 것인데 그 정보들은 컨테이너에서 가지고 있고, 이미지는 mysql을 실행하기 위한 정보만을 가지고 있다고 합니다.문제는 mysql컨테이너를 삭제하면 컨테이너에서 가지고 있던 정보가 삭제 된다는 것 입니다.한 번 삭제하면 데이터 복구가 어려운 관계로 컨테이너를 삭제하지 않기 위해 컨테이너의 데이터를 영속적 데이터로 활용할 수 있는 방법이 몇 가지 방법을 제공하고 있습니다.가장 활용하기 쉬운 방법이 볼륨을 사용하는 것. 호스트와 볼륨을 공유 볼륨 컨테이너를 활용 도커가 관리하는 볼륨을 생성위 방법들을 활용하여 컨테이너를 삭제해도 데이터는 삭제되지 않도록 설정할 수 있다고 합니다.처음부터 차근차근히 알아보겠습니다.☝️ 1. 호스트 볼륨 공유M1칩 기준 다음 명령어로 mysql 데이터베이스 컨테이너와 워드프레스 웹 서버 컨테이너를 생성하겠습니다.# mysql M1docker run -d \\ --name wordpressdb_hostvolume \\-e MYSQL_ROOT_PASSWORD=password \\-e MYSQL_DATABASE=wordpress \\-v /tmp/wordpress_db:/var/lib/mysql \\mysql:5.7# wordpressdocker run -d \\-e WORDPRESS_DB_HOST=mysql \\-e WORDPRESS_DB_USER=root \\-e WORDPRESS_DB_PASSWORD=password \\--name wordpress_hostvolume \\--link wordpressdb_hostvolume:mysql \\-p 80 \\wordpress -v옵션은 호스트의 /tmp/wordpress_db 디렉터리와 컨테이너의 var/lib/mysql 디렉터리를 공유한다는 뜻입니다.그러면 /tmp/wordpress_db에는 다음과 같이 나오게 됩니다. var/lib/mysql은 mysql이 데이터베이스의 데이터를 저장하는 기본 디렉터리입니다.만약 컨테이너에 파일들이 존재하는데 이를 공유하는 시도를 한다면호스트 디렉터리에 있는 파일들이 엎어씌워집니다. -v옵션을 통한 호스트 볼륨 공유는 호스트의 디렉터리를 컨테이너의 디렉터리에 마운트 합니다.☝️ 2. 볼륨 컨테이너-v 옵션으로 볼륨을 사용하는 컨테이너를 다른 컨테이너와 공유하는 방법입니다.컨테이너를 생성할 때 --volumes-from옵션을 지정하면 -v, --volume옵션을 적용한 컨테이너의 볼륨과 공유할 수 있습니다.예를들어서 volume_overide라는 컨테이너는 위에서 작성한 /tmp/wordpress_db의 내용을 /home/testdir_2에 공유한다고 하면docker run -i -t \\&amp;gt; --name volumes_from_container \\&amp;gt; --volumes-from volume_overide \\&amp;gt; ubuntu:14.04명령어를 통해 voumes_from_container 컨테이너도 공유받을 수 있습니다.이를 통해서 여러 개의 컨테이너가 동일한 컨테이너에 볼륨을 공유해 사용할 수 있습니다.이러한 구조를 통해서 호스트에서 볼륨만 공유하고 별도의 역할은 각 컨테이너에 맡길 수 있습니다.☝️ 3. 도커 볼륨도커 자체가 제공하는 볼륨 기능입니다.docker volume으로 시작하며 docker volume create로 볼륨을 생성할 수 있습니다.docker volume create --name myvolumemyvolume이라는 볼륨을 생성했고, 다음 명령을 통해 확인할 수 있습니다.# docker volume lsDRIVER VOLUME NAMElocal myvolume해당 볼륨은 로컬호스트에 저장되며 도커 엔진에 의해 생성되고 삭제될 수 있습니다.그 다음 myvolume을 사용하는 컨테이너를 생성해야 합니다.docker run -i -t --name myvolume_1 \\-v myvolume:/root/ \\ubuntu:14.04# 접속 후echo hello,volume &amp;gt;&amp;gt; /root/volume이러면 /root/volume에 “hello,volume”이 쓰이게 됩니다.그리고 /root에 쓰이는 모든 것들은 myvolume에 같이 공유될 것입니다.이를 확인하기 위해 다른 컨테이너를 생성해 봐야합니다.docker run -i -t --name myvolume_2 \\-v myvolume:/root/ \\ubuntu:14.04# 접속 후cat /root/volume# 결과hello,volume실제 volume파일을 생성하지 않아도 컨테이너에 존재해 있고 확인도 가능합니다.이를 통해서 도커 볼륨도 여러 개의 컨테이너에 공유되어 활용될 수 있습니다.볼륨은 디렉터리 단위로서 도커 엔진에서 관리합니다.도커볼륨도 호스트 볼륨과 마찬가지로 호스트에 데이터를 보존하지만 파일이 실제 어디에 저장되는지는 사용자는 알 필요가 없다고 합니다.docker inspect명령어를 통해 실제 도커 볼륨이 어디에 저장되는지 알 수 있습니다. type을 사용한 것은 볼륨에 대한 정보를 알고 싶음을 명시적으로 표현한 것입니다. 뿐만 아니라 docker container inspect &amp;lt;cotainer name&amp;gt;, docker volume inspect &amp;lt;volume&amp;gt;와 같이 원하는 정보를 출력할 수 있습니다. 하지만 mac에서는 docker 동작방식이 달라 이 방식으로 확인이 불가능 합니다.매 번 docker volume create를 사용해 볼륨을 생성하고 공유하는 것은 번거로울 수 있습니다.때문에 -v 옵션을 입력할 때 이를 수행하도록 설정할 수 있습니다.docker run -i -t --name volume_auto \\-v /root \\ubuntu:14.04이렇게 하면 자동으로 이름을 정해서 볼륨을 만들어 줍니다.# docker volume lsDRIVER VOLUMENAMElocal d0b67fd9ece36c5296d022a46942a0ded6f862495bdf2c24302ab75f485f3640local myvolume대신 16진수로 들어가게 됩니다.때문에 컨테이너가 해당 볼륨을 확인하기 위해서는 docker container insepect가 필요합니다.docker container inspect volume_auto도커 볼륨을 생성하고 삭제하다보면 불필요한 볼륨이 남아있을 때가 있습니다.도커 볼륨을 사용하고 있는 컨테이너를 삭제해도 볼륨은 삭제되지 않기 때문입니다.사용되지 않는 볼륨을 한 번에 삭제하려면 docker volume prune를 사용합니다.docker volume prune위의 방식들처럼 컨테이너가 아닌 외부에 데이터를 저장하고 컨테이너는 그 데이터로 동작하게끔 설계하는 것을 stateless하다고 말합니다.컨테이너는 상태[데이터]를 외부로부터 주입받고 컨테이너가 삭제되어도 데이터는 보존되므로 이러한 컨테이너 설계는 도커를 사용할 때 매우 바람직한 설계라고 합니다.이와 반대로 컨테이너가 상태[데이터]를 자체적으로 저장하고 있는 경우 stateful하다고 합니다. 이러한 설계는 지양하는 편이 좋습니다. -v옵션 대신 --mount 옵션을 사용할 수 있습니다. 구문이 좀 더 명시적입니다. docker run -i -t --name mount_option_1 \\ --mount type=volume, source=myvolume, target=/root \\ubuntu:14.04호스트의 디렉터리를 컨테이너 내부에 마운트하는 경우 type에 bind를, source에는 호스트의 디렉터리 경로를 지정해야 합니다." }, { "title": "Clean Architecture (로버트 마틴 저) 독후감", "url": "/posts/book12/", "categories": "Book", "tags": "book", "date": "2022-07-12 01:00:00 +0900", "snippet": "클린 아키텍처를 정리했는데..사실 이 글은 다른 사람들에게 의미가 없다.내가 정리할 겸해서 정리한거지 절대 이 책은 교과서마냥 암기를 하면 안된다. 덤으로 클린 코드도 마찬가지다.일단 정리한 데까지는 올려봐야겠다.12장 이후부터 정리를 안 했는데, 정리하는데 드는 시간도 꽤 걸리고 뒤로 갈수록 흐름을 타야한다.하나의 스토리를 전부 이해해야 한다는 것클린아키텍처 - 1장 설계와 아키텍처는 같다. 생산성을 빠르게 하다보면 코드가 지저분해지는데 흔히 이걸 나중에 고치자 생각하고 늘리면 이끌려 다니는 자신을 발견할 수 있다. 처음부터 제대로 짜자. 2장 두 가지 가치에 대한 이야기 기능 : 긴급하지만 중요하지 않을 때도 있음 아키텍처 : 중요하지만 긴급하지 않음. 동작이 불가능하지만 변경이 쉬운 소프트웨어를 주었을때 이를 동작 시키는건 쉽지만 변경이 불가능하고 동작하는 소프트웨어를 주었을때 이를 고치는건 어렵다.3장 패러다임 개요.구조적 프로그래밍 : 제어의 흐름의 직접적인 전환에 규칙을 부여객체지향 프로그래밍 : 제어의 흐름의 간접적인 전환에 규칙을 부여함수형 프로그래밍 : 할당문이 대해 규칙을 부여4장 구조적 프로그래밍 구조적 프로그래밍의 goto문은 모듈을 분해하는데 방해한다. 데이스트라는 이를 증명하기 위해 싸웠고 승리 테스트를 통과했다고해서 결함이 없는것이 아니다. 5장 객체지향 프로그래밍 ‘세계를 모델링한다’ 가 무슨 의민데? 데이터와 함수의 구조도 아니다. 상속, 캡슐화는 객체지향이 아니여도 구현은 가능하다. 다형성을 손 쉽게 만들 수 있도록 도와줌. 이러한 방식 덕분에 의존성역전을 구현할 수 있었고, 의존성 역전을 통해 컴포넌트 단위로 배포하여 독립적인 역할을 수행할 수 있게함. 이것이 객체지향이 가진 힘. 6장 함수형 프로그래밍 함수형 언어에서 데이터는 바뀌지 않음. 바뀌려면 제약조건을 지켜야함. 그렇기에 불변성을 유 지할 수 있고 불변성 컴포넌트와 가변성 컴포넌트로 분리할 수 있음. 불변성을 가지면 동시성 문제를 해결할 수 있다.저장공간과 처리속도가 무한하다면 이벤트소싱을 통하여 모든것을 불변성으로 만들 수 있고 완전한 함수형으로 만들 수 있다.7장 SRP 단일책임원칙 단일책임원칙이란 하나의 모듈이 하나의 액터에 대해서만 책임을 갖는다.예를 들어 어떤 함수에서 돌아가는 알고리즘이 다른 분리된 서비스에서도 사용되어서 수정했을때 에러가 나면 안됨. 이를 분리해야함.여러개의 클래스로 나누거나 퍼사드 패턴을 사용하여 해결.8장 OCP 개방폐쇄의 원칙 개방폐쇄원칙이란 변경에 있어서 기존 코드에서 수정하는 것은 적어야하고 확장되는 코드만 있어야 된다는 것이다. 즉, 변경이 있어서 기존 코드를 수정할 일을 최소화해서 유연하게 작동해야한다.이를 지키기위해선 컴포넌트별로 중요도를 생각하여 배치하고 하위 중요도가 상위 중요도에 의존성을 가져 상위 컴포넌트에 대한 불변성을 지켜야한다.또한 인터페이스와같은 의존성역전을 통해 업무경계를 침범하지 않게하고, 추이종속성을 방지한다.9장 lsp 리스코프 치환 원칙 리스코프 치환 원칙이란 가능한한 상속 등을 통해서 의존성을 제거하는 것을 의미하는 것 같다.예를 들어 구글과 계약을 해서 서비스를 구글에서 dest/table/abc.pdf로 보냈다고 하고이게 표준이었다가 네이버에서는 실수로 destination/table/abc.pdf로 보낸다하면 if문으로 네이버와 구글을 분리할 것이 아니고 클래스로 분리하고 상속받거나 config를 추가해서 관리하는것.10장 isp 인터페이스 분리 원칙 상속 받은 클래스에서 필요없는 기능을 가진 상위 클래스가 있다면 이를 인터페이스로 분리하여 의존성을 제거하자는것. 그러지 않으면 상위 클래스가 변경되면 하위도 재 컴파일을 할 수도 있게 되기 때문이다.아키텍처적으로 프레임워크를 사용하는 개발자가 어떤 데이터베이스 모듈을 사용한다하면 프레임워크에 의존적이면서 데이터베이스에 의존덕이게 되어, 데이터베이스의 에러가 모든 곳에 정파되어 영향을 끼침 이를 해결하기 위해서는 과도한 의존성을 제거해야함.11장 dip 의존성 역전 법칙 제어흐름이 의존성과 반대인 경우를 말함.이를 코드수준에서 더 확실히 지키기 위해서는 구체 함수에 의존하지마라(오버라이드) 구체 클래스에 의존하지마라 구체 클래스에서 파생되지 마라. 가 있다.인터페이스를 통해 의존성 역전을 만들어낼 수 있다.하지만 결국 이렇게 만들어낸 구체 컴포넌트와 인터페이스의 집합인 추상 컴포넌트가 분리되다보면 하나의 구체 컴포넌트에서 모든 의존성이 쏠릴 수 있다. 이를 방지하기는 어려우며, 보통 main이라는 함수를 포함하는 컴포넌트가 이를 관리하도록 한다.모바일로 집가면서 메모한거라 이쁘게 정리는 안되었네.. 정리에는 소질이 없다.이 이후 부터는 정리를 하지 않았다.내가 이 책을 오히려 훼손하고 있다고 생각이 들었다.이 책은 암기서적이 아니고 이해를 하면서 넘어가야하는 서적이다. 꼭 읽으면서 이해해야한다.클린 아키텍처, 클린 코드를 읽으니 어떻게 하면 실용적이고 간편하게 코드를 짤 수 있을까 생각이 들었다.어제만 해도 테스트 코드만 4시간 짜고 있었다. 계속 지웠다 썼다 반복하였다.그리고 프레임워크를 공부하는것은 큰 의미가 없다고 생각이 들었다.지금은 fastapi로 사이드 프로젝트를 진행중이지만, 필요할때마다 도큐를 읽는게 좋고 도큐 자체를 공부하는건 내가 fastapi에 의존하게 된다는 것을 알았다.그게 중요한게 아니고 로직을 어떻게 짤지를 고민하는데, 클린 코드에 대해서 생각하는데에 시간을 쓰는게 더 낫겠더라.2회독으로 마무리했지만, 나중에 또 꺼내겠지.다음 책은 실용주의 프로그래머이다. 추천받았다." }, { "title": "FastAPI 공식문서 따라하기[25] - Body Updates", "url": "/posts/fastapi25/", "categories": "Python, FastAPI", "tags": "FastAPI", "date": "2022-07-10 01:00:00 +0900", "snippet": " https://fastapi.tiangolo.com/tutorial/body-updates/ 공식문서 따라하는 글☑️ Update Replacing with PUT보통 HTTP의 put라는 것을 통하여 객체를 수정할 수 있도록 한다.전의 포스팅에서 사용한 jsonable_encoder를 통해 들어온 값들에 대해 JSON 타입으로 바꿔 저장할 수 있다.from fastapi import FastAPIfrom fastapi.encoders import jsonable_encoderfrom pydantic import BaseModelapp = FastAPI()class Item(BaseModel): name: str | None = None description: str | None = None price: float | None = None tax: float = 10.5 tags: list[str] = []items = { &quot;foo&quot;: {&quot;name&quot;: &quot;Foo&quot;, &quot;price&quot;: 50.2}, &quot;bar&quot;: {&quot;name&quot;: &quot;Bar&quot;, &quot;description&quot;: &quot;The bartenders&quot;, &quot;price&quot;: 62, &quot;tax&quot;: 20.2}, &quot;baz&quot;: {&quot;name&quot;: &quot;Baz&quot;, &quot;description&quot;: None, &quot;price&quot;: 50.2, &quot;tax&quot;: 10.5, &quot;tags&quot;: []},}@app.get(&quot;/items/{item_id}&quot;, response_model=Item)async def read_item(item_id: str): return items[item_id]@app.put(&quot;/items/{item_id}&quot;, response_model=Item)async def update_item(item_id: str, item: Item): update_item_encoded = jsonable_encoder(item) items[item_id] = update_item_encoded return update_item_encoded@app.put을 통해 객체에 대한 정보를 바꿔쓸 수 있다.☑️ Warning about replacing만약 위의 “bar”객체를 다음과 같이 수정하고 싶어서 body에 다음 값을 넘겨본다고 가정하자.{{ &quot;name&quot;: &quot;barz&quot;, &quot;description&quot;: &quot;None&quot;, &quot;price&quot;: 3, &quot;tags&quot;: []}}문제는 “bar”에 설정된 tax필드에 대한 값(20.2)를 지정하지 않아서 default value인 10.5가 들어갈 것이다.결과값☑️ Partial updates with PATCHHTTP의 PATCH를 사용해서 사용자가 필요한 데이터만 수정하고 나머지는 그대로 유지할 수 있게 한다. PUT에 비해 PATCH는 인지도가 낮다. 흔히 PUT이 많이 사용되며, 부분적 업데이트에서도 사용된다.사용하는것은 자유지만, FastAPI는 어떠한 제한을 도입하지 않았다고 한다. 그래서 이번 챕터에서 왜 그렇게 제한을 두지 않았는지 알려준다고 한다.☑️ Using Pydantic’s exclude_unset parameter만약 부분적 업데이트가 필요하면 Pydantic’s model의 .dict()에 있는 exclude_unset를 이용하면 된다.from fastapi import FastAPIfrom fastapi.encoders import jsonable_encoderfrom pydantic import BaseModelapp = FastAPI()class Item(BaseModel): name: str | None = None description: str | None = None price: float | None = None tax: float = 10.5 tags: list[str] = []items = { &quot;foo&quot;: {&quot;name&quot;: &quot;Foo&quot;, &quot;price&quot;: 50.2}, &quot;bar&quot;: {&quot;name&quot;: &quot;Bar&quot;, &quot;description&quot;: &quot;The bartenders&quot;, &quot;price&quot;: 62, &quot;tax&quot;: 20.2}, &quot;baz&quot;: {&quot;name&quot;: &quot;Baz&quot;, &quot;description&quot;: None, &quot;price&quot;: 50.2, &quot;tax&quot;: 10.5, &quot;tags&quot;: []},}@app.get(&quot;/items/{item_id}&quot;, response_model=Item)async def read_item(item_id: str): return items[item_id]@app.patch(&quot;/items/{item_id}&quot;, response_model=Item)async def update_item(item_id: str, item: Item): stored_item_data = items[item_id] stored_item_model = Item(**stored_item_data) update_data = item.dict(exclude_unset=True) updated_item = stored_item_model.copy(update=update_data) items[item_id] = jsonable_encoder(updated_item) return updated_item이렇게 하면 default value는 제외하고 설정된 데이터만 가지고 dict자료형을 만든다.결과☑️ Using Pydantic’s update parameter위의 구문을 보면 stored_item_model.copy(update=update_data)에서 update는 Pydantic에서 제공하는 것이다.위의 내용들을 요약하자면 PATCH를 PUT대신 사용. 저장된 데이터를 찾음. Pydantic model에 저장된 데이터를 넣음. exclude_unset을 이용하여 dict을 default value를 제 하고 생성. 위의 Pydantic model의 Copy를 이용하여 속성값들을 부분적 업데이트(update구문 이용) jsonable_encoder를 이용하여 DB에 저장할 수 있는 자료형으로 바꿈. DB에 저장 수정된 객체를 반환." }, { "title": "Programmers_2022 KAKAO BLIND RECRUITMENT 주차 요금 계산", "url": "/posts/Programmers_park_billing_calcu/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2022-06-29 03:00:00 +0900", "snippet": "프로그래머스 2022 KAKAO BLIND RECRUITMENT - 주차 요금 계산 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/923412. 분류 및 난이도Programmers 문제입니다.2022 KAKAO BLIND RECRUITMENT 문제 입니다.Level 2난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 구현 문제치고는 어렵지 않습니다. 문자 함수들을 사용하지 않는게 더 편해보여서 그렇게 풀었습니다.4. 접근 방법을 적용한 코드from collections import dequefrom datetime import datetime,timedeltadef calcuBill(value,fees): if value &amp;lt; fees[0] : return fees[1] else: mod = (value-fees[0]) //fees[2] if (value-fees[0]) % fees[2] != 0: mod+=1 return fees[1] + mod * fees[3]def caclcuDifTime(in_time,out_time): return out_time - in_timedef dateFormat(time): hour,min = time.split(&#39;:&#39;) return int(hour) * 60 + int(min)def solution(fees, records): answer = [] dict = {} result = {} billing = deque() for info in records: time, carnum, status = info.split(&#39; &#39;) if carnum not in result: result[carnum] = 0 time = dateFormat(time) # 2번째 if carnum in dict: dif_t = caclcuDifTime(dict[carnum],time) del dict[carnum] result[carnum] += dif_t continue dict[carnum] =time for key,value in dict.items(): result[key] += (1439 - value) sorted_dict = sorted(result.items()) for key,value in sorted_dict: bill = calcuBill(value,fees) answer.append(bill) return answer5. 결과필요시. c++ 짜드리겠습니다. 설명이 필요시 댓글달아주세요." }, { "title": "Programmers_위클리 챌린지 모음사전", "url": "/posts/Programmers_vowels_dict/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2022-06-29 02:00:00 +0900", "snippet": "프로그래머스 위클리 챌린지 - 교점에 별 만들기 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/84512#2. 분류 및 난이도Programmers 문제입니다.위클리 챌린지 문제 입니다.Level 2난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 규칙을 찾으면 다음 배열이 어떻게 이어지는 잘 생각해서 해결하면 됩니다.4. 접근 방법을 적용한 코드def solution(word): answer = 0 dict = { 1 : 1, 2 : 6, 3 : 31, 4 : 156, 5 : 781 } word_list = [&#39;A&#39;,&#39;E&#39;,&#39;I&#39;,&#39;O&#39;,&#39;U&#39;] for index in range(len(word)): w = word[index] answer+=1 for j in range(len(word_list)): char = word_list[j] if char == w : answer += dict[5-index] * j return answer5. 결과필요시. c++ 짜드리겠습니다. 설명이 필요시 댓글달아주세요." }, { "title": "Programmers_위클리 챌린지 교점에 별 만들기", "url": "/posts/Programmer_make_star/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2022-06-29 01:00:00 +0900", "snippet": "프로그래머스 위클리 챌린지 - 교점에 별 만들기 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/87377#qna2. 분류 및 난이도Programmers 문제입니다.위클리 챌린지 문제 입니다.Level 2난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 구현이 좀 복잡합니다. 좌표계에서 굉장히 헷갈리는데, 교점 이동을 잘 해준다면 어렵지 않게 푸실 수 있을겁니다. 그리고 초기에 min,max값을 아예 높게 설정하지 않으면 28테케,29테케에서 에러가 납니다..왠지는 모름.4. 접근 방법을 적용한 코드from collections import dequedef solution(line): INF = float(&#39;inf&#39;) size = len(line) result = [] max_x,max_y,min_x,min_y = -INF,-INF,INF,INF st = set() for i in range(size): for j in range(i+1,size): A,B,E = line[i] C,D,F = line[j] low = A*D - B*C if low == 0: continue x = (B*F - E*D) / low y = (E*C - A*F) / low if x - int(x) or y - int(y): continue x = int(x) y = int(y) max_x = max(max_x,x) min_x = min(min_x,x) max_y = max(max_y,y) min_y = min(min_y,y) st.add((x,y)) result= list(st) # makeMap width = max_x - min_x + 1 height = max_y - min_y + 1 map = [[&#39;.&#39;]*width for i in range(height)] for x,y in result: map[max_y-y][x-min_x] = &quot;*&quot; return [&#39;&#39;.join(s) for s in map]5. 결과필요시. c++ 짜드리겠습니다. 설명이 필요시 댓글달아주세요." }, { "title": "Programmers_3xn 타일링", "url": "/posts/Programmers_3nTiles/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2022-06-28 02:00:00 +0900", "snippet": "프로그래머스 - 3 x n 타일링 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/12902#2. 분류 및 난이도Programmers 문제입니다.Level 2난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 대표적인 DP문제입니다. 홀수일때 채울 수 있는 경우의 수는 없습니다. 4일때 이후로는 새로운 모양이 2개씩 더 생기므로 그것을 고려하여 알고리즘을 작성해야합니다. 일반적인 경우는 [n-2] * 3을 통해 3가지 경우의 수를 곱해주면 되지만, 새로운 문양은 무조건 2가지가 생기고(d[0] * 2) 새로운 문양에 대해서 앞 뒤로(*2)붙일 수 있는 경우의 수가 생기므로 점화식은 다음과 같다. dp[n] = dp[n-2] * 3 + dp[0] * 2(새로운 모양) + dp[2] * 2(dp[n-2]의 새로운 모양에 대해서 dp[2]가앞 뒤로 붙음 ) …. dp[n-4]까지4. 접근 방법을 적용한 코드from collections import dequedef solution(n): dp = deque([0] * (n+1)) dp[0] = 1 if n &amp;gt;= 2: dp[2] = 3 for i in range(4,n+1, 2): dp[i] = dp[i-2] * 3 for j in range(0,i-3,2): dp[i] += dp[j] * 2 return dp[n] % 10000000075. 결과필요시. c++ 짜드리겠습니다. 설명이 필요시 댓글달아주세요." }, { "title": "Programmers_2021 카카오 채용연계형 인턴쉽_거리두기 확인하기", "url": "/posts/Programmers_distance_check/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2022-06-28 01:00:00 +0900", "snippet": "프로그래머스 카카오 채용 - 거리두기 확인하기 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/813022. 분류 및 난이도Programmers 문제입니다.2021 카카오 채용연계형 인턴쉽 문제입니다.Level 2난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 그리디하게 풀면 됩니다. 범위가 넓지 않아서 어렵지는 않습니다. 코드가 많이 더럽습니다.4. 접근 방법을 적용한 코드# 1. 사용자를 다 넣음.# 2. 서로 거리가 2 이하인 경우만 분리# 3. 주변을 보고 파티션이 있으면 1 없으면 0from collections import dequedef getPerson(row,col,places): result = deque() idx = 0 for idx in range(5): if(places[row][col][idx]==&quot;P&quot;): result.append([col,idx]) return resultdef getDistance(first,second,person_spot): judge = abs(person_spot[first][0] - person_spot[second][0]) + abs(person_spot[first][1] - person_spot[second][1]) return judgedef filterList(person_spot,filter_list): size = len(person_spot) result = deque() for i in range(size): for j in range(i+1,size): distance = getDistance(i,j,person_spot) if distance == 1: return [-1] elif distance == 2: filter_list.append((person_spot[i],person_spot[j])) return filter_listdef judgeDouble(first,second): if(first[0] + 2 == second[0]): return 1 elif(first[1] + 2 == second[1]): return 2 return 0def judgeCross(first,second): if(first[0] + 1 ==second[0] and first[1] + 1 == second[1]): return 1 elif(first[0] +1 == second[0] and first[1] - 1 ==second[1]): return 2def solution(places): answer = [1] * 5 row = 0 col = 0 for row in range(5): person_spot = deque() filter_list = deque() for col in range(5): person_spot += getPerson(row,col,places) judge = filterList(person_spot,filter_list) if(len(judge) !=0 and judge[0] == -1): answer[row] = 0 continue for idx in range(len(filter_list)): first, second = filter_list[idx] double_judge = judgeDouble(first,second) if(double_judge == 1): if (places[row][first[0] + 1][first[1]] != &#39;X&#39;): answer[row] = 0 break elif(double_judge==2): if(places[row][first[0]][first[1] + 1] != &#39;X&#39;): answer[row] = 0 break else: cross_judge = judgeCross(first,second) if cross_judge == 1: if(places[row][first[0] + 1][first[1]] != &#39;X&#39; or places[row][first[0]][first[1] + 1] !=&#39;X&#39;): answer[row]=0 break else: if(places[row][first[0]][first[1] - 1] != &#39;X&#39; or places[row][first[0] + 1][first[1]] !=&#39;X&#39;): answer[row]=0 break return answer5. 결과필요시. c++ 짜드리겠습니다. 설명이 필요시 댓글달아주세요." }, { "title": "Programmers_위클리 챌린지 최소직사각형", "url": "/posts/Programmers_min_rectangle/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2022-06-22 01:00:00 +0900", "snippet": "프로그래머스 위클리 챌린지 - 최소직사각형 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/86491?language=python32. 분류 및 난이도Programmers 문제입니다.프로그래머스 위클리 챌린지 문제입니다.Level 1난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 그리디하게 풀면 됩니다. 하나씩 늘려가면 직사각형의 넓이가 어떻게 될 지 생각하면 접근하기 쉽습니다.4. 접근 방법을 적용한 코드def solution(sizes): pointx, pointy = sizes[0] x = max(pointx,pointy) y = min(pointx,pointy) for i in range(1,len(sizes)): newx = max(sizes[i][0], sizes[i][1]) newy = min(sizes[i][0], sizes[i][1]) x = max(x,newx) y = max(y,newy) return x*y5. 결과필요시. c++ 짜드리겠습니다. 설명이 필요시 댓글달아주세요." }, { "title": "CleanCode (로버트 마틴 저) 독후감", "url": "/posts/book11/", "categories": "Book", "tags": "book", "date": "2022-06-21 01:00:00 +0900", "snippet": "2번 읽고도 시간이 꽤 지날정도로 정리를 안 했다.그 이유는 마지막에 따로 정리할 것들이 많아서 그것들을 정리하면 올릴 생각이었다..하지만 내가 카페가서는 개발 공부하고 출퇴근에는 그냥 책만 읽느라 따로 펜을 들 시간이 없더라.그래서 마지막장은 무시하고 내가 펜으로 다시 정리한 부분까지만 적어야겠다고 생각했다. 중복을 피하라,한 기능만 수행해라, 제대로 표현하라, 적게 추상화하라2장 이름 의도가 보이는 이름 쉬운 이름을 사용하라 클래스 이름과 객체 이름은 명사나 명사구 메서드 이름은 동사나 동사구 3장 함수 작게 만들어라 함수는 한 가지를 해야한다 그 한 거지를 잘 해야 한다 그 한 가지만을 해야 한다 내려가기 규칙 함수 인수는 0개가 이상적 단항 함수 쓰기 좋을 때 인수에게 질문을 던질 때 인수를 뭔가를 변환해 리턴할 때 플래그 인수는 쓰지말자 오류코드보다 예외를 사용하자 try catch는 별도의 함수로 뽑자 중복은 소프트웨어에서 모든 악의 근원이다 4장 주석 법적인 주석은 좋은 주석 의도를 설명하는 주석 의미를 명료하게 하는 주석 결과를 경고하는 주석 todo 주석 나쁜 주석 같은 이야기를 중복하는 주석 이력을 기록하는 주석 닫는 괄호에 다는 주석 공로를 돌리거나 저자를 표시하는 주석 주석으로 처리한 코드 html주석 전역정보 6장 객체와 자료구조 디미터법칙 : 모듈은 자신이 조작하는 객체의 내부를 몰라야 한다7장 오류처리 오류코드보다 예외를 사용하라 null을 반환하지 마라 더 나쁜건 null을 전달하는것 9장 단위테스트 깨끗한 테스트 코드 - 가독성 가독성 가독성 테스트당 assert 하나 테스트 Fast.Independent.Repeatable.Self Validating. Timely 10장 클래스 SRP12장 창발성 모든 테스트를 실행한다 중복을 없앤다 프로그래머 의도를 표현한다 클래스와 메서드 수를 최소로 줄인다 13 동시성 동기화하는 메서드 사이에 존재하는 의존성을 이해하라 동기화하는 부분을 작게 만들어라 올바른 종료 코드는 구현하기 어렵다 스레드 코드 테스트하기 마지막이 14장인데 그 부분은 하나하나 중요한 내용이기에 전부 다 적기에는 나의 시간이 아까워서 이렇게 정리하겠다.괜히 개발자의 필독서라고 하는게 아닌듯하다.나는 이를 내업무에 적용시키고 있다. 전부는 아니지만 지나고나면 왜 책에서 이렇게 하라했는지. 내가 코드짤 때 뭐를 더 조심해야겠는지를 알려주는 좋은 책이었다.다음 개발책은클린 아키텍처를 읽을 것이다." }, { "title": "변화하는 세계질서 (레이달리오 저) 독후감", "url": "/posts/book10/", "categories": "Book", "tags": "book", "date": "2022-06-20 01:00:00 +0900", "snippet": "내가 알기론 이 책에 대한 내용은 이미 레이달리오 아저씨가 유튜브에서 언급하고 미국에서 이미 발간된걸로 알고 있다이를 번역한것으로 내용은 꽤나 최신의 내용이다.(코로나 때도 다루고 있음)이 책은 일단 정리하기가 불가능하다.내용이 하나의 흐름을 잇고 있기에 맥락을 정리한다는게 어려웠다.내용자체도 쉽지는 않아서 2번을 읽어도 이해가 잘 안되는 부분이 있다.그럼에도 적어야하는것은 결국엔 나도 70%정도는 이 책을 이해했기 때문이라 생각한다. 100%는 가능한가..?이 책의 흐름은 비교적 간단한데, 전체적인 이야기는 하나이다.데이터로 봤을 때 미국은 쇠퇴하고 있고, 중국은 부상하고 있다는 것이다.이에 맞춰서 잘 대처하는것이 중요하고 잘 대처할 수 있게 알려주고, 그리고 왜 미국이 쇠퇴하고 있고, 중국은 부상하는지에 대해 알려준다.500년의 서방국가, 동아시아 국가들의 역사들을 언급하며 이것이 경제흐름에 어떻게 끼치고 각 국가에 어떤 영향을 끼쳤는지 알려준다.레이달리오 아저씨는 크게 18가지의 요인이 국가 경제침체의 원인으로 꼽았으며, 이는 서로 관계를 맺고 있다고 한다.옛날 네덜란드, 영국, 프랑스, 독일 등이 강대국이던 시점 이 강대국들이 왜 쇠퇴하고 왜 부상했는지를 토대로 미국과 중국도 비슷한 ‘사이클’을 걷고 있다고 한다.당연한 말일 수도 있다. 하지만 내용은 어려웠다.다만 아쉬운 것은 책이 레이달리오 아저씨가 준비한 도표나 표로 데이터를 나타내는데, 나는 이 마저도 별로 신빙성을 못가지고 공감하기 어려웠다.예를 들어서미국의 교육 수치를 1.8이라고 나타낸다면 왜 1.8인지는 모르겠다는 것. 책에서 설명은 대학시험점수, 대학교 레벨 등으로 따졌을때 1.8이라는 수치가 나왔다는데 그 과정을 모르니 이해가 잘 안되었다.그래서 전체적인 흐름만 읽고 수치에 대한 해석은 하지 않기로 했다.생각해보니 하나 딱 기억에 남는게 있다.돈을 많이 찍어내는것이 왜 그렇게 위험한건지는 알겠다." }, { "title": "FastAPI 공식문서 따라하기[24] - JSON Compatible Encoder", "url": "/posts/fastapi24/", "categories": "Python, FastAPI", "tags": "FastAPI", "date": "2022-06-16 01:00:00 +0900", "snippet": " https://fastapi.tiangolo.com/tutorial/encoder/ 공식문서 따라하는 글☑️ JSON Compatible Encoder¶어떤한 데이터를 JSON로 바꿔야할 때가 있을 것이다.FastAPI는 jsonable_encoder()를 제공하여 손쉽게 JSON변환을 도와준다.☑️ Using the jsonable_encoderfrom datetime import datetimefrom fastapi import FastAPIfrom fastapi.encoders import jsonable_encoderfrom pydantic import BaseModelfake_db = {}class Item(BaseModel): title: str timestamp: datetime description: str | None = Noneapp = FastAPI()@app.put(&quot;/items/{id}&quot;)def update_item(id: str, item: Item): print(&quot;original item : &quot;,type(item), &quot;original datetime : &quot;, type(item.timestamp)) # original item : &amp;lt;class &#39;main.Item&#39;&amp;gt; original datetime : &amp;lt;class &#39;datetime.datetime&#39;&amp;gt; json_compatible_item_data = jsonable_encoder(item) print(&quot;convert item : &quot;,type(json_compatible_item_data), &quot;convert datetime : &quot;,type(json_compatible_item_data[&#39;timestamp&#39;])) # convert item : &amp;lt;class &#39;dict&#39;&amp;gt; convert datetime : &amp;lt;class &#39;str&#39;&amp;gt; fake_db[id] = json_compatible_item_data return fake_db[id]만약 db가 JSON객체만을 받고 요청을 받아서 객체를 넣는다고 할 때 사용하면 좋다.저렇게 하면 좋은점이 뭘까?먼저 저 Item안에 있는 timestamp는 datetime타입이다. 이를 DB에 넣는데에는 위험이 있다.또한 Pydantic model타입의 Item도 바로 넣는건 위험하다.그렇기에 위의 구문을 통해 변환을 하면 자동으로 Pydantic model는 dict으로, datetime은 str로 변환해주어 데이터를 넣어주도록 한다." }, { "title": "fire(파이어) (강환국 저) 독후감", "url": "/posts/book9/", "categories": "Book", "tags": "book", "date": "2022-05-25 01:00:00 +0900", "snippet": "이 책을 알게 된 경로는 학교 동기의 추천으로 읽게 되었다.나는 이제 좋은 책들은 2번 읽고 정리하는 습관을 만들려 하는데, 이 책은 2번 읽지는 않았다.내용이 좋지 않아서가 아니라, 이미 다 알고 있는 내용이기 때문이다.먼저 이 책은 젊으면서 부자가된 사람들을 인터뷰하며 그들의 노하우를 공개하는건데.. 내가 봤을때 크게 3가지였다. 사업 코인 부동산 으로 부자가된 사람들이었다.사업으로 부자가된 사람들에게는 뭔가 나와는 다름을 느끼고 쫓아가려고 하려고 했다.하지만 코인에 대해서는 부정적인 생각이 들었다.나는 물론 코인 그자체는 좋게 보는데, 저기서 젊으면서 돈 많이 번 사람들 중 코인으로 번 사람들이 ‘코인’이라는것에 투자한 이유나 배경이 설명되지 않고 그냥 투자했다고만 나오니까 일확천금을 얻은 몇몇 소수의 사람을 인터뷰한 것 같았다.물론 운도 부자가 되는데 중요하지만 코인으로 부자가 된 그들이 어떤 노력을 했는지에 대한 설명이 부족하여 나의 공감을 이끌지는 못한것 같다.그리고 이 책에서는 단기 트레이더에 대해 전혀 아무런 위화감 없이 말하는것도 나와 다른 방향을 보고 있다고 생각했다.그렇기에 내가 2번 읽고 정리할만한 생각은 못 느꼈으며오히려 가장 먼저 이 책을 접하고 사람들이 단기 트레이드나 레버리지를 땡겨서 투자를 할까 걱정아닌 걱정도 생긴다.지금은 개발자의 교과서인 cleancode를 2번 읽고 정리하고 있다.그 다음은 ‘변화라는 세계질서’ 라는 책을 학교 동기의 추천으로 읽어볼 것이다." }, { "title": "pytest fixture의 scope에 대한 공부", "url": "/posts/pytest_Fixtures_Scope/", "categories": "Python, FastAPI", "tags": "FastAPI", "date": "2022-05-23 04:00:00 +0900", "snippet": "프로젝트를 수행하다가 pytest에서 사용하는 fixture의 scope가 궁금해졌다.총 5가지의 상태가 있다. (function, class, module, package, session)1. Function이 상태는 아무것도 명시해주지 않을때 자동적용되는 범위이다.함수가 단위로 실행된다. 즉, pytest에 작성한 함수를 실행할때마다 수행된다는 것이다.2. Class@pytest_asyncio.fixture(scope=&quot;class&quot;)def dummy_data(request): request.cls.num1 = 10 request.cls.num2 = 20 print(&quot;Execute fixture&quot;)class TestCalculatorClass: def test_distance(self, dummy_data): print(&quot;Test distance function&quot;) assert distance(self.num1, self.num2) == 10 def test_sum_of_square(self, dummy_data): print(&quot;Test sum of square function&quot;) assert sum_of_square(self.num1, self.num2) == 500# source codedef distance(num1, num2): return abs(num1 - num2)def sum_of_square(num1, num2): return num1 ** 2 + num2 ** 2Process finished with exit code 0Execute fixturePASSED [ 50%]Test distance functionPASSED [100%]Test sum of square function위의 코드를 보면 클래스 단위당 한 번호출 하는것을 알 수 있다.참고로@pytest_asyncio.fixture(scope=&quot;class&quot;)def dummy_data(request): request.cls.num1 = 10 request.cls.num2 = 20 print(&quot;Execute fixture&quot;)@pytest.mark.usefixtures(&quot;dummy_data&quot;)class TestCalculatorClass: def test_distance(self): print(&quot;Test distance function&quot;) assert distance(self.num1, self.num2) == 10 def test_sum_of_square(self): print(&quot;Test sum of square function&quot;) assert sum_of_square(self.num1, self.num2) == 500위에 @pytest.mark.usefixutres(&quot;fixture명&quot;)을 통해 인스턴스 함수 파라미터에 fixture를 적어서 지저분하게 만드는걸 방지할 수 있다.3. Module and package마찬가지로 모듈당 한 번, 패키지당 한 번 호출하는데 어떤 식이냐밑의 코드는 파일 여는것을 함수로 만들고, module을 적용하고, 두 함수에 이를 호출하였다.디폴트값인 function에서는 함수 호출때마다 파일을 열고 닫았지만@pytest.fixture(scope=&quot;module&quot;)def read_config(): with open(&quot;app.json&quot;) as f: config = json.load(f) logging.info(&quot;Read config&quot;) return configdef test1(read_config): logging.info(&quot;Test function 1&quot;) assert read_config == {}def test2(read_config): logging.info(&quot;Test function 2&quot;) assert read_config == {}# test/test_code.py::test1 # ----------- live log setup -----------# INFO root:test_code.py:88 Read config# ----------- live log call -----------# INFO root:test_code.py:93 Test function 1# PASSED [ 75%]# test/test_code.py::test2 # ----------- live log call -----------# INFO root:test_code.py:98 Test function 2# PASSED 로그를 보면 딱 한 번만 여는걸 알 수 있다.4. Session여기서 말하는 세션이란, pytest를 실행할때마다 하나의 세션을 얻는데, 이 세션을 말한다.즉, 실행할때마다 실행되는 것들이다. 이를 통해 테스트용 데이터베이스를 연결하거나 끊는데에 사용된다." }, { "title": "FastAPI 공식문서 따라하기[23] - Path Operation Configuration", "url": "/posts/fastapi23/", "categories": "Python, FastAPI", "tags": "FastAPI", "date": "2022-05-23 04:00:00 +0900", "snippet": " https://fastapi.tiangolo.com/tutorial/handling-errors/ 공식문서 따라하는 글☑️ Path Operation ConfigurationPath 경로에 몇 가지 기능을 더 넣을 수 있다고 한다.☑️ Response Status Codestatus_code를 이용하여 HTTP상태코드를 전다할 수 있다.from fastapi import FastAPI, statusfrom pydantic import BaseModelapp = FastAPI()class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None tags: set[str] = set()@app.post(&quot;/items/&quot;, response_model=Item, status_code=status.HTTP_201_CREATED)async def create_item(item: Item): return item이렇게 작성하고, post요청에 성공하면 201 HTTP상태값을 받을 수 있다. 참고로 import status를 fastapi에서 하나 starlette에서 하나 같다.☑️ Tagslist나 str형태의 tags를 PassParameter에 넘길 수 있다.from fastapi import FastAPIfrom pydantic import BaseModelapp = FastAPI()class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None tags: set[str] = set()@app.post(&quot;/items/&quot;, response_model=Item, tags=[&quot;items&quot;])async def create_item(item: Item): return item@app.get(&quot;/items/&quot;, tags=[&quot;items&quot;])async def read_items(): return [{&quot;name&quot;: &quot;Foo&quot;, &quot;price&quot;: 42}]@app.get(&quot;/users/&quot;, tags=[&quot;users&quot;])async def read_users(): return [{&quot;username&quot;: &quot;johndoe&quot;}]보면 tags지정한대로 분리해서 OpenAPI 인터페이스에 나타나는걸 볼 수 있다.또한, 큰 애플리케이션의 경우 Tags를 매번 지정하다간 헷갈릴수도 있고 하나로 관리하고 싶기에Enum을 사용해서 나타낼 수도 있다.from enum import Enumfrom fastapi import FastAPIapp = FastAPI()class Tags(Enum): items = &quot;items&quot; users = &quot;users&quot;@app.get(&quot;/items/&quot;, tags=[Tags.items])async def get_items(): return [&quot;Portal gun&quot;, &quot;Plumbus&quot;]@app.get(&quot;/users/&quot;, tags=[Tags.users])async def read_users(): return [&quot;Rick&quot;, &quot;Morty&quot;]☑️ Summary and descriptionsummary와 description도 파라미터에서 사용할 수 있는데 이는 무엇이냐..from fastapi import FastAPIfrom pydantic import BaseModelapp = FastAPI()class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None tags: set[str] = set()@app.post( &quot;/items/&quot;, response_model=Item, summary=&quot;Create an item&quot;, description=&quot;Create an item with all the information, name, description, price, tax and a set of unique tags&quot;,)async def create_item(item: Item): return item이렇게 설명과 간단한 타이틀을 설정할 수 있다.또한 markdown스타일로 설명을 적을 수 있다고 한다.from fastapi import FastAPIfrom pydantic import BaseModelapp = FastAPI()class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None tags: set[str] = set()@app.post(&quot;/items/&quot;, response_model=Item, summary=&quot;Create an item&quot;)async def create_item(item: Item): &quot;&quot;&quot; Create an item with all the information: - **name**: each item must have a name - **description**: a long description - **price**: required - **tax**: if the item doesn&#39;t have tax, you can omit this - **tags**: a set of unique tag strings for this item &quot;&quot;&quot; return item☑️ Response descriptionresponse_description을 통해 response description을 명시해줄 수 있다.from fastapi import FastAPIfrom pydantic import BaseModelapp = FastAPI()class Item(BaseModel): name: str description: str | None = None@app.post( &quot;/items/&quot;, response_model=Item, response_description=&quot;The created item&quot;,)async def create_item(item: Item): return item☑️ Deprecate a path operationdeprecated를 명시하여 해당 라우터의 기능을 사용하지 않는다고 명시할 수 있다.from fastapi import FastAPIapp = FastAPI()@app.get(&quot;/elements/&quot;, tags=[&quot;items&quot;], deprecated=True)async def read_elements(): return [{&quot;item_id&quot;: &quot;Foo&quot;}]하지만 요청을 하면 잘간다.OpenAPI에서 명시적으로 나타내주기 위해 사용하는 것 같다." }, { "title": "FastAPI 공식문서 따라하기[22] - Handling Errors", "url": "/posts/fastapi22/", "categories": "Python, FastAPI", "tags": "FastAPI", "date": "2022-05-23 03:00:00 +0900", "snippet": " https://fastapi.tiangolo.com/tutorial/handling-errors/ 공식문서 따라하는 글☑️ Handling Errors예외처리에 대한 내용이다. 만약 클라이언트가 접근할 수 없는 자원에 접근했거나 존재하지 않는 자원에서 접근을 원하거나 권한 자체가 없는 경우우리는 에러를 내야한다.일반적으로 400범위(400 ~ 499)의 에러를 내면서 클라이언트쪽에서 문제가 있음을 알려야 한다.☑️ Use HTTPException에러를 포함한 HTTP responses를 클라이언트한테 리턴해야할때가 있다.이를 리턴하기 위해서는 HTTPException을 임포트해야한다.from fastapi import FastAPI, HTTPException☑️ Raise an HTTPException in your code파이썬에서 에러를 직접 발생시키기 위해서는 return이 아닌, raise를 사용해야 한다.해당 구문을 사용하면서 보안이나 의존성 부분에 명시적으로 눈에 띄기에 더 효율적이다.다음 예제는 클라이언트가 item의 ID를 보냈는데, 만약 해당 item이 존재하지 않는다면 404에러를 발생시키는 예제이다.from fastapi import FastAPI, HTTPExceptionapp = FastAPI()items = {&quot;kms&quot; : &quot;Kms is Handsome guy&quot;}@app.get(&quot;/items/{item_id}&quot;)async def read_item(item_id : str): if item_id not in items: raise HTTPException(status_code=404, detail=&quot;Item not found by kms&quot;) return {&quot;item&quot;: items[item_id]}이렇게 작성하고 kms와 같은 잘못된 요청을 보냈을때는404에러가 뜰 것이다.detail안에 내용도 잘 써져있다. 해당 예제에서는 detail에 str값을 넣었지만, list나 dict같은 형태도 보낼 수 있다고 한다.☑️ Add custom headers어떤한 문제가 생겼을 경우 헤더에다가 HTTP error를 추가할 수 있다.위의 코드에서async def read_item(item_id : str): if item_id not in items: raise HTTPException(status_code=404, detail=&quot;Item not found by kms&quot;, headers={&quot;Kms-error&quot;: &quot;There goes KMS error&quot;},)라고 선언하고, 잘못된 내용을 입력할 경우이렇게 우리가 설정한 헤더가 들어간걸 볼 수 있다.☑️ Install custom exception handlers만약 예외처리를 내가 만들어서 처리하고 싶다면 @app.exception_handler()구문을 통해 처리할 수 있다.from fastapi import FastAPI, Requestfrom fastapi.responses import JSONResponseclass CustomException(Exception): def __init__(self,name: str): self.name = nameapp = FastAPI()items = {&quot;kms&quot; : &quot;Kms is Handsome guy&quot;}@app.exception_handler(CustomException)async def unvicorn_exception_handelr(request: Request, exc: CustomException): return JSONResponse( status_code=418, content={&quot;message&quot; : f&quot;Oops! {exc.name} did something.. There goes a rainbow&quot;}, )@app.get(&quot;/unicorns/{name}&quot;)async def read_unicorn(name: str): if name == &quot;yolo&quot;: raise CustomException(name=name) return {&quot;unicorn_name&quot;: name}만약 yolo를 요청으로 보내면 에러가 뜨는 코드이다.강제로 에러를 발생시키고 이를 exception_handler가 받아서 처리한다.☑️ Override the default excpetion heandlersFastAPI는 기본적인 예외처리 기능을 가지고 있다.유효하지 않은 요청을 받을때 raise를 통해 default JSON Responses를 포함한 HTTPException을 발생시킬 수 있다.만약 요청에 유효하지 않은 데이터가 포함되어 있다면, FastAPI는 내부적으로 RequestValidationError를 발생시킨다.RequestValidationError를 임포트하고, 이것을 사용하기 위해서는 @app.excpetion_handler(RequestValidationError)구문을 사용하면 된다.다음은 예제이다.from fastapi import FastAPI, HTTPExceptionfrom fastapi.exceptions import RequestValidationErrorfrom fastapi.responses import PlainTextResponseapp = FastAPI()@app.exception_handler(RequestValidationError)async def validation_exception_handler(request, exc): return PlainTextResponse(str(exc), status_code=400)@app.get(&quot;/items/{item_id}&quot;)async def read_item(item_id: int): if item_id == 3: raise HTTPException(status_code=418, detail=&quot;Nope! I don&#39;t like 3.&quot;) return {&quot;item_id&quot;: item_id}이렇게 작성하고, 아예 자료형이 다른 /items/kms같은 요청을 보내면 다음과 같이 뜬다.RequestValidationError는 Pydnantic의 ValidationError의 서브 클래스다.Pydantic의 response_model을 사용했는데, 데이터 에러가 발생할 시 로그를 통해 오류를 볼 수 있지만 클라이언트, 사용자는 이걸 볼 수 없다.대신에 500이라는 HTTP status code를 보게 된다. 이는 ValidationError가 코드 어딘가에 있기 때문이라고 한다.위의 오류에 해당하는 내용을 수정하는 동안에는 클라이언트/사용자는 오류에 대한 내부 정보에 접근할 수 없게 해야한다. 보안 취약성이 노출될 수 있기 때문이다.☑️ Override the HTTPException error handler위와 같은 방법으로 HTTPException을 오버라이딩 할 수 있다.from fastapi import FastAPI, HTTPExceptionfrom fastapi.responses import PlainTextResponsefrom starlette.exceptions import HTTPException as StarletteHTTPExceptionapp = FastAPI()@app.exception_handler(StarletteHTTPException)async def http_exception_handler(request, exc): return PlainTextResponse(str(exc.detail), status_code=exc.status_code)@app.get(&quot;/items/{item_id}&quot;)async def read_item(item_id: int): if item_id == 3: raise HTTPException(status_code=418, detail=&quot;Nope! I don&#39;t like 3.&quot;) return {&quot;item_id&quot;: item_id}똑같이 아예 자료형이 다른 /items/kms같은 요청을 보내면 다음과 같이 뜬다.☑️ Use the RequestValidationError body만약 RequestBody로 들어온 값에 유효하지 않은 데이터가 포함되어 있다면 RequestValidationError를 일으킨다.from fastapi import FastAPI, Request, statusfrom fastapi.encoders import jsonable_encoderfrom fastapi.exceptions import RequestValidationErrorfrom fastapi.responses import JSONResponsefrom pydantic import BaseModelapp = FastAPI()@app.exception_handler(RequestValidationError)async def validation_exception_handler(request: Request, exc: RequestValidationError): return JSONResponse( status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, content=jsonable_encoder({&quot;detail&quot;: exc.errors(), &quot;body&quot;: exc.body}), )class Item(BaseModel): title: str size: int@app.post(&quot;/items/&quot;)async def create_item(item: Item): return itemcurl -X &#39;POST&#39; \\ &#39;http://localhost:8000/items/&#39; \\ -H &#39;accept: application/json&#39; \\ -H &#39;Content-Type: application/json&#39; \\ -d &#39;{ &quot;title&quot;: &quot;kms&quot;, &quot;size&quot;: &quot;12d&quot;}&#39;이렇게 size에 str을 넣어서 예외를 발생시켜보면,요로콤 뜬다.FastAPI’s HTTPException vs Starlette’s HTTPExceptionFastAPI는 자체적인 HTTPException을 가지고 있다. 이것은 Starlette’s의 HTTPException을 상속받은 것이다.다른점은 FastAPI의 HTTPException은 response에 헤더를 추가하는것이 허용된다는 것이다.이는 OAuth 2.0이나 몇몇 보안 툴에 쓰인다고 한다.고로 FastAPI의 HTTPException을 사용하는게 좋다고 한다.그러나 만약 예외처리 핸들러가 필요하다면 Starlette’s의 HTTPException을 사용하라고 한다.왜냐하면 Starlett가 가지고 있는 내부코드나 외부 플러그인을 통해서 Starlette의 HTTPException을 발생시키는데, 이 과정에서 작성한 예외 핸들러를 찾고 실행할 수 있기 때문이라고 한다.☑️ Re-use FastAPI’s exception handlers만약 기본 예외처리기를 함께 예외를 사용하려면 from fastapi.exception_handlers를 통해 기본예외처리기를 사용할 수 있다.from fastapi import FastAPI, HTTPExceptionfrom fastapi.exception_handlers import ( http_exception_handler, request_validation_exception_handler,)from fastapi.exceptions import RequestValidationErrorfrom starlette.exceptions import HTTPException as StarletteHTTPExceptionapp = FastAPI()@app.exception_handler(StarletteHTTPException)async def custom_http_exception_handler(request, exc): print(f&quot;OMG! An HTTP error!: {repr(exc)}&quot;) return await http_exception_handler(request, exc)@app.exception_handler(RequestValidationError)async def validation_exception_handler(request, exc): print(f&quot;OMG! The client sent invalid data!: {exc}&quot;) return await request_validation_exception_handler(request, exc)@app.get(&quot;/items/{item_id}&quot;)async def read_item(item_id: int): if item_id == 3: raise HTTPException(status_code=418, detail=&quot;Nope! I don&#39;t like 3.&quot;) return {&quot;item_id&quot;: item_id}예외처리기를 만들고 그 안에서 또 기본 예외처리를 하고 있다.나는 어디에 쓰일지 크게 몰라서 적어만 둔다." }, { "title": "FastAPI 공식문서 따라하기[21] - Request Forms and Files", "url": "/posts/fastapi21/", "categories": "Python, FastAPI", "tags": "FastAPI", "date": "2022-05-23 02:00:00 +0900", "snippet": " https://fastapi.tiangolo.com/tutorial/request-forms-and-files/ 공식문서 따라하는 글☑️ Request Files이 장은 File과 Form을 같이 받을 수 있다는 것을 알려주는 챕터이다.from fastapi import FastAPI, File, Form, UploadFileapp = FastAPI()@app.post(&quot;/files/&quot;)async def create_file( file: bytes = File(), fileb: UploadFile = File(), token: str = Form()): return { &quot;file_size&quot;: len(file), &quot;token&quot;: token, &quot;fileb_content_type&quot;: fileb.content_type, }파일과 폼 필드에 있는 데이터를 다 받을 수 있다." }, { "title": "FastAPI 공식문서 따라하기[20] - Request Files", "url": "/posts/fastapi20/", "categories": "Python, FastAPI", "tags": "FastAPI", "date": "2022-05-23 01:00:00 +0900", "snippet": " https://fastapi.tiangolo.com/tutorial/request-files/ 공식문서 따라하는 글☑️ Request FilesFile이라는 것을 통해 파일업로드 요청을 받을 수 있다.두 가지 방식이 있다. pip install python-multipart를 통해 필요한 모듈을 받는다.from fastapi import FastAPI, File, UploadFileapp = FastAPI()@app.post(&quot;/files/&quot;)async def create_file(file: bytes = File()): return {&quot;file_size&quot;: len(file)} fastapi에서 UploadFile, File을 임포트 받는다. file: bytes = File()구문을 통해 파일을 받는다. 이렇게 명시해주지 않는다면 쿼리파라미터로 인식히거나 RequestBody로 인식할 수 있다. 이렇게 하면 파일은 폼데이터로 받아야한다고 한다. 위의 구문처럼 bytes로 자료형을 명시해주면 FastAPI는 파일을 읽고 bytes형태의 파일을 서버에 전달한다. 이 모든것은 메모리에 저장되므로 파일이 작을수록 더 잘 동작한다고 한다. 하지만 UploadFile을 사용하면 더 큰 혜택을 받을 수 있다.@app.post(&quot;/uploadfile/&quot;)async def create_upload_file(file: UploadFile): return {&quot;filename&quot;: file.filename}이렇게 사용하면 bytes로 받는것보다 이점이 있다. File()구문을 작성하지 않아도 된다. “spooled” file이다. 만약 파일의 크기가 메모리 사이즈 이상을 넘어가면 디스크에 저장한다고 한다. 이미지, 비디오, 큰 바이너리 파일 등과 같은 파일에 어울린다. 메타데이터 정보도 해당 구문을 통해 얻을 수 있다.☑️ UploadFile다음과 같은 속성을 갖는다. filename : 문자열 형태의 업로드 파일이름이다. content_type : 문자열 형태의 컨텐츠 타입을 말한다.(ex : image/jpeg) file : 객체 그자체를 말하는 것같다. 출력 해보면 다음과 같이 정보가 나온다.또한, 다음과 같은 메소드를 포함하고 있다. write(data) : str,bytes 형태의 데이터를 쓴다. read(size) : size만큼의 파일을 읽는다. seek(offset) : offset만큼의 바이트위치로 이동한다. close() : 파일을 닫는다.이 메소드를 사용하려면 async 구문에서는 “await”를 사용해야한다.async구문에서는 다음과 같이 작성해야하지만,contents = await.myfile.read()일반적인 함수(def)에서는 다음과 같이 작성할 수 있다.contents = myfile.file.read()☑️ Optional File UploadNone을 통해서 디폴트값을 설정할 수 있다.from fastapi import FastAPI, File, UploadFileapp = FastAPI()@app.post(&quot;/files/&quot;)async def create_file(file: bytes | None = File(default=None)): if not file: return {&quot;message&quot;: &quot;No file sent&quot;} else: return {&quot;file_size&quot;: len(file)}@app.post(&quot;/uploadfile/&quot;)async def create_upload_file(file: UploadFile | None = None): if not file: return {&quot;message&quot;: &quot;No upload file sent&quot;} else: return {&quot;filename&quot;: file.filename}☑️ UploadFile with Additional Metadata추가적인 메타데이터를 넣을 수 있다.from fastapi import FastAPI, File, UploadFileapp = FastAPI()@app.post(&quot;/files/&quot;)async def create_file(file: bytes = File(default=None, description=&quot;file read by kms&quot;)): if not file: return{&quot;message&quot; : &quot;no file sent&quot;} else: return {&quot;file_size&quot;: len(file)}@app.post(&quot;/uploadfile/&quot;)async def create_upload_file(file: UploadFile = File(default=None,description= &quot;upload file read by kms&quot;)): if not file: return{&quot;message&quot;: &quot;no upload file sent&quot;} else: return {&quot;filename&quot;: file.file}메타데이터가 추가된 것을 확인할 수 있다.☑️ Mutiple File Uploads같은 시간에 파일을 여러개 요청 받을 수 있다.대신 동일한 form field에서 form data를 받아야한다.bytes방식, UploadFile방식 둘 다 받을 수 있다.from fastapi import FastAPI, File, UploadFilefrom fastapi.responses import HTMLResponseapp = FastAPI()@app.post(&quot;/files&quot;)async def create_files(files: list[bytes] = File(default=None)): return {&quot;file_sizes&quot;: [len(file) for file in files]}@app.post(&quot;/uploadfiles/&quot;)async def create_upload_files(files: list[UploadFile]): return {&quot;filenames &quot; : [file.filename for file in files]}@app.get(&quot;/&quot;)async def main(): content = &quot;&quot;&quot;&amp;lt;body&amp;gt;&amp;lt;form action=&quot;/files/&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&amp;gt;&amp;lt;input name=&quot;files&quot; type=&quot;file&quot; multiple&amp;gt;&amp;lt;input type=&quot;submit&quot;&amp;gt;&amp;lt;/form&amp;gt;&amp;lt;form action=&quot;/uploadfiles/&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&amp;gt;&amp;lt;input name=&quot;files&quot; type=&quot;file&quot; multiple&amp;gt;&amp;lt;input type=&quot;submit&quot;&amp;gt;&amp;lt;/form&amp;gt;&amp;lt;/body&amp;gt; &quot;&quot;&quot; return HTMLResponse(content=content)http://localhost:8000/에 들어가면 다음과 같이 폼 양식이 뜬다.저기서 파일을 여러개 선택할 수 있다.먼저 파일 사이즈를 받는 첫번째 요청에 대한 값을 확인해보았다.다음은 여러 파일들의 이름을 반환하는 두 번째 요청를 테스트 해보았다.☑️ Multiple File Uploads with Additional Metadata파일을 여러개 받으면서 그에대한 메타정보도 추가로 작성할 수 있다.from fastapi import FastAPI, File, UploadFilefrom fastapi.responses import HTMLResponseapp = FastAPI()@app.post(&quot;/files/&quot;)async def create_files( files: list[bytes] = File(description=&quot;Multiple files as bytes&quot;),): return {&quot;file_sizes&quot;: [len(file) for file in files]}@app.post(&quot;/uploadfiles/&quot;)async def create_upload_files( files: list[UploadFile] = File(description=&quot;Multiple files as UploadFile&quot;),): return {&quot;filenames&quot;: [file.filename for file in files]}...그냥 이런것이 있구나 하고 넘어가면 될 것 같다." }, { "title": "FastAPI 공식문서 따라하기[19] - Form Data", "url": "/posts/fastapi19/", "categories": "Python, FastAPI", "tags": "FastAPI", "date": "2022-05-20 04:00:00 +0900", "snippet": " https://fastapi.tiangolo.com/tutorial/request-forms/ 공식문서 따라하는 글☑️ Form DataForm을 사용하면 JSON형식 대신 폼 필드로 들어온 데이터를 받을 수 있다.그 전에 pip install python-multipart를 통해 필요 패키지를 설치한다.from fastapi import FastAPI, Formapp = FastAPI()@app.post(&quot;/login/&quot;)async def login(username: str = Form(default={}), password: str = Form(default={})): return {&quot;username&quot;: username}예를 들어서 OAuth2를 사용한다고 하면, form을 통해서 username과 password를 보내기를 요구할 것이다.위의 예제는 JSON이 아닌, form fields를 통해 속성값들을 받고 있다. Form은 Body를 상속받은 클래스라고 한다.☑️ About “Form Fields”HTML forms(&amp;lt;form&amp;gt;&amp;lt;/form&amp;gt;)은 JSON과 달리 특이한 인코딩을 통해 데이터를 서버에 전달한다. 폼데이터는 “media type”으로 application/x-www-form-urlencoded형태로 인코딩 된다.만약 폼 데이터에 파일이 포함되어 있다면 이는 multipart/form-data로 인코딩 된다. 위의 예제에서는 Form를 여러개 사용해 데이터를 받고 있는데, JSON을 받는 Body와 혼합해서 사용할 수 없다. 이건 FastAPI가 제한하는게 아니고 HTTP protocol이 제한하는 것이다." }, { "title": "FastAPI 공식문서 따라하기[18] - Response Status Code", "url": "/posts/fastapi18/", "categories": "Python, FastAPI", "tags": "FastAPI", "date": "2022-05-20 03:00:00 +0900", "snippet": " https://fastapi.tiangolo.com/tutorial/response-status-code/ 공식문서 따라하는 글☑️ Response Status Coderesponse model을 선언했던것 처럼 status_code를 사용해서 HTTP 상태값을 반환할 수 있다.ex)from fastapi import FastAPIapp = FastAPI()@app.post(&quot;/items/&quot;, status_code=201)async def create_item(name: str): return {&quot;name&quot;: name}이렇게 선언하면 response객체에 상태값을 리턴할 수 있다. OpenAPI와 같은 문서에도 적용이 된다.☑️ About HTTP status codesHTTP 상태값의 의미에 대한 설명인데 알고 있으면 스킵하라고 하길래 나는 스킵 자세한건 공식문서 참조☑️ Shortcut to remember the namesFastAPI는 편의성을 또 제공한다.위처럼 status_code = 201이라고 하면 두 번의 생각을 거치게 된다. 201이 뭐더라? 아 Created지. Created가 뭐지? 아 어떤거구나이 두 번의 생각을 하나의 생각으로 줄이기 위해 fastapi.status를 제공한다.from fastapi import FastAPI,statusapp = FastAPI()@app.get(&quot;/items/&quot;, status_code=status.HTTP_200_OK)async def get_item(name: str): return {&quot;name&quot;: name}코드의 길이가 조금 늘어났지만, 직관적이게 바뀌었다.심지어 이는 editor에서는 자동완성 기는을 제공한다. from starlette import status도 사용할 수 있다. 별반 차이가 없다고한다." }, { "title": "FastAPI 공식문서 따라하기[17] - Extra Models", "url": "/posts/fastapi17/", "categories": "Python, FastAPI", "tags": "FastAPI", "date": "2022-05-20 02:00:00 +0900", "snippet": " https://fastapi.tiangolo.com/tutorial/extra-models/ 공식문서 따라하는 글☑️ Extra Models쉬어가는 챕터로, 이전 예제에서 추가적인 개발을 하는 문서 같다 input model은 password를 포함하고 있다. output model은 password를 포함하면 안된다. database model은 hashed password를 포함할 것이다.☑️ Multiple models모델을 설계할 것이다.from fastapi import FastAPIfrom pydantic import BaseModel, EmailStrapp = FastAPI()class UserIn(BaseModel): username: str password: str email: EmailStr full_name: str | None = Noneclass UserOut(BaseModel): username: str email: EmailStr full_name: str | None = Noneclass UserInDB(BaseModel): username: str hashed_password: str email: EmailStr full_name: str | None = Nonedef fake_password_hasher(raw_password: str): return &quot;supersecret&quot; + raw_passworddef fake_save_user(user_in: UserIn): hashed_password = fake_password_hasher(user_in.password) user_in_db = UserInDB(**user_in.dict(), hashed_password=hashed_password) print(&quot;User saved! ..not really&quot;) return user_in_db@app.post(&quot;/user/&quot;, response_model=UserOut)async def create_user(user_in: UserIn): user_saved = fake_save_user(user_in) return user_saved여기서의 문제점은 password를 그대로 가져오는것과 해시함수로 표현하지 않은것들인데, 예제에서는 복잡하지 않기 위해서 일단 그냥 넘기기로 했다.하나 신기한 문법이 있다.☑️ About **user_in.dict()Pydantics’s .dict()user_in은 UserIn라는 클래스의 Pydantic 모델이다.이 모델은 .dict()이라는 함수를 가지고 있는데, 모델을 dict자료형으로 바꾸는 기능을 한다.그렇기에user_in = UserIn(username=&quot;kms&quot;, password=&quot;secret&quot;, email=&quot;minseokkang@gmail,com&quot;)라고 생성된 Pydanticobject가 있다면 user_dict = user_in.dict()을 통해서 dict자료형으로 바꿀 수 있다.#바뀐 자료형{ &#39;username&#39;: &#39;kms&#39;, &#39;password&#39;: &#39;secret&#39;, &#39;email&#39;: &#39;minseokkang@gmail,com&#39;, &#39;full_name&#39;: None,}이렇게 생성된 데이터를 함수에 인자를 통해 넘기고 싶으면 **user_dict을 통해 넘길 수 있다. 이를 Python에서는 “unwrap”이라고 한다. 그렇기에 위의 함수에서 처럼 UserInDB(**user_dict)로 넘길 수 있다.이는 다음과 동등한 결과라고 한다.UserInDB( username=&quot;kms&quot;, password=&quot;secret&quot;, email = &#39;minseokkang@gmail,com&#39;, full_name=None,)또한UserInDB( username = user_dict[&quot;username&quot;], password = user_dict[&quot;password&quot;], email = user_dict[&quot;email&quot;], full_name = user_dict[&quot;full_name&quot;],)또한UserInDB(**user_in.dict()): user_in.dict()호출 -&amp;gt; `**`를 통한 &quot;unwrap&quot;하지만 위의 예제에서는 두 번째 인자가 있다. 바로 hashed_password=hashed_password인데,위의 코드는 다음과 동일하다고 한다.UserInDB( username = user_dict[&quot;username&quot;], password = user_dict[&quot;password&quot;], email = user_dict[&quot;email&quot;], full_name = user_dict[&quot;full_name&quot;], hashed_password = hashed_password,)☑️ Reduce duplicationFastAPI가 코드의 중복을 줄여준다고 한다.코드가 중복되면 예상치 못한 버그가 발생할 수 있고, 보안적인 이슈나 코드 동기화 문제도 있을 수 있다.위의 코드에는 데이터가 많고 속성값과 타입도 각 클래스마다 중복되는 것들이 있다.UserBase를 다른 클래스에서 상속받으면 해결이 될 것이다.password와 관련된 속성을 제외하면 모두 중복된 코드이므로 다음과 같이 작성할 수 있을 것이다.from fastapi import FastAPIfrom pydantic import BaseModel, EmailStrapp = FastAPI()class UserBase(BaseModel): username: str email: EmailStr full_name: str | None = Noneclass UserIn(UserBase): password: strclass UserOut(UserBase): passclass UserInDB(UserBase): hashed_password: strdef fake_password_hasher(raw_password: str): return &quot;supersecret&quot; + raw_passworddef fake_save_user(user_in: UserIn): hashed_password = fake_password_hasher(user_in.password) user_in_db = UserInDB(**user_in.dict(), hashed_password=hashed_password) print(&quot;User saved! ..not really&quot;) return user_in_db@app.post(&quot;/user/&quot;, response_model=UserOut)async def create_user(user_in: UserIn): user_saved = fake_save_user(user_in) return user_savedUserBase를 제외한 모든 클래스들은 UserBase를 상속받고 있음을 알자.☑️ Union or anyOfResponse모델에 Union이란 키워드를 통해 두가지 타입을 지정할 수 있는데, 그 둘 중 하나의 클래스의 오브젝트타입으로 리턴한다는 것이다. Union을 사용할 때 첫번째 타입은, 두 번째 타입보다 좀 더 중요하고 명시하고 싶은 타입을 선언한다. 밑의 예제는 PlaneItem이 CarItem보다 더 강조하고 싶다는 뜻이다.from typing import Unionfrom fastapi import FastAPIfrom pydantic import BaseModelapp = FastAPI()class BaseItem(BaseModel): description: str type: strclass CarItem(BaseItem): type = &quot;car&quot;class PlaneItem(BaseItem): type = &quot;plane&quot; size: intitems = { &quot;item1&quot;: {&quot;description&quot;: &quot;All my friends drive a low rider&quot;, &quot;type&quot;: &quot;car&quot;}, &quot;item2&quot;: { &quot;description&quot;: &quot;Music is my aeroplane, it&#39;s my aeroplane&quot;, &quot;type&quot;: &quot;planekms!!!!&quot;, &quot;size&quot;: 5, },}@app.get(&quot;/items/{item_id}&quot;, response_model=Union[PlaneItem, CarItem])async def read_item(item_id: str): return items[item_id]http://localhost:8000/items/item2로 접근하면{ &quot;description&quot;: &quot;Music is my aeroplane, it&#39;s my aeroplane&quot;, &quot;type&quot;: &quot;plane2&quot;, &quot;size&quot;: 5}라는 결과를 얻을 수 있다. 참고로 Union[PlanItem, CarItem]은 repsonse_model = PlaneItem | CarItem으로 바꿔 쓸 수 있다. 공식 문서에서는 이는 에러를 발생시킨다고 되어있지만.. 실제로 해보면 된다. 다음 내용은 사실 쓰지 말라는 내용인데, 나는 잘 되어서 그 부분에 대한 내용은 추가하지 않겠다.☑️ List of modelsrespone_model = List[Item]으로 선언이 가능하다는 얘기다.from typing import Listfrom fastapi import FastAPIfrom pydantic import BaseModelapp = FastAPI()class Item(BaseModel): name: str description: stritems = [ {&quot;name&quot;: &quot;Father&quot;, &quot;description&quot;: &quot;There comes my hero&quot;}, {&quot;name&quot;: &quot;Job&quot;, &quot;description&quot;: &quot;It&#39;s my Life&quot;},]@app.get(&quot;/items/&quot;, response_model=List[Item])async def read_items(): return items보아하면 반환타입은 Item 형태를 가진 List다.결과[ { &quot;name&quot;: 123.4, &quot;description&quot;: &quot;There comes my hero&quot; }, { &quot;name&quot;: 43.2, &quot;description&quot;: &quot;It&#39;s my Life&quot; }]☑️ Response with arbitray dict마찬가지로 dict타입으로 반환객체를 만들어줄 수 있다.Pydantic모델과 달리 dict 모델은 클래스의 속성이름을 알 필요가 없다.3.9 버전 이하에서는 from typing import Dict을 입력해야한다고 한다.from fastapi import FastAPIapp = FastAPI()@app.get(&quot;/keyword-weights/&quot;, response_model=dict[str, float])async def read_keyword_weights(): return {&quot;foo&quot;: 2.3, &quot;bar&quot;: 3.4}어려운 것은 없으므로 설명은 생략" }, { "title": "FastAPI 공식문서 따라하기[16] - Response Model", "url": "/posts/fastapi16/", "categories": "Python, FastAPI", "tags": "FastAPI", "date": "2022-05-19 05:00:00 +0900", "snippet": " https://fastapi.tiangolo.com/tutorial/response-model/ 공식문서 따라하는 글☑️ Response ModelResponse에 model을 담아 리턴할 수 있다 어떤 요청에 대해서도 가능하다.(@app.post(), @app.get(), @app.put(), @app.delete()…)from fastapi import FastAPIfrom pydantic import BaseModelapp = FastAPI()class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None tags: list[str] = []@app.post(&quot;/items/&quot;, response_model=Item)async def create_item(item: Item): return item코드를 보면, Item이라는 객체를 보내면 이를 받아 그대로 리턴해버린다.response_model에 리턴할 자료형을 입력해주었다.SwaggerUI에서도 확인이 가능하지만, 처음인만큼 뭔가 Postman으로 시험해보았다.그대로 리턴해준다. 공식문서에서 주의해야한다고 지적한 점은 위치이다. response_model은 인자에서 선언한 것이 아닌, decorator에서 선언했다. 리스트로도 받을 수 있다고 한다. ex) List[Item]response_model을 사용함으로써 다음과 같은 이점을 얻을 수 있다고 한다. 출력 데이터를 선언한 타입으로 변환할 수 있다. 그로인해서 데이터 검증을 하니까 데이터 검증은 덤이다. OpenAPI같은 문서도구에 JSON Schema를 만들어 등록한다.가장 중요한 점은출력 데이터 모델을 지정해줄 수 있다는 것이다.☑️ Return the same input data여기서 예제로 UserIn이라는 모델을 선언했다. 이 모델은 password라는 속성값을 str형식으로 받는다.from fastapi import FastAPIfrom pydantic import BaseModel, EmailStrapp = FastAPI()class UserIn(BaseModel): username: str password: str email: EmailStr full_name: str | None = None그리고 UserIn 모델을 받고, 그대로 리턴해버리는 코드다.from fastapi import FastAPIfrom pydantic import BaseModel, EmailStrapp = FastAPI()class UserIn(BaseModel): username: str password: str email: EmailStr full_name: str | None = None# Don&#39;t do this in production!# 추가@app.post(&quot;/user/&quot;, response_model=UserIn)async def create_user(user: UserIn): return user유저가 직접 password를 입력하는 경우에도 이 때는 문제가 생기지 않을 수 있다.하지만 만약 이 모델이 다른 요청들의 필요에 의해 그대로 넘겨버리면 항상 password를 전송하는 위험부담이 생겨버린다. 공식문서에서는 절대로 password값을 그대로 저장하지 말라고 써있다. 암호화는 필수다.☑️ Add an output modelpassword를 제외하고 데이터를 보내버리게 모델을 새로 만든다.from fastapi import FastAPIfrom pydantic import BaseModel, EmailStrapp = FastAPI()class UserIn(BaseModel): username: str password: str email: EmailStr full_name: str | None = Noneclass UserOut(BaseModel): username: str email: EmailStr full_name: str | None = None@app.post(&quot;/user/&quot;, response_model=UserOut)async def create_user(user: UserIn): return userUserOut은 password값을 포함하지 않고 response_model=UserOut을 통해 userOut모델을 보내버린다.어떻게 이런 일이? 요청에는 password를 보냈는데, 돌아온 값은 password가 포함되지 않았다. FastAPI는 Pydantic을 이용하여 내보낼 데이터에 포함되지 않은 속성값들을 필터하는 기능을 가진다고 한다.from fastapi import FastAPIfrom pydantic import BaseModelapp = FastAPI()class Item(BaseModel): name: str description: str| None = None price: float tax: float = 10.5 tags: list[str] = []items = { &quot;kms&quot;: {&quot;name&quot;: &quot;bag&quot;,&quot;price&quot; : 350}, &quot;bjh&quot;: {&quot;name&quot;: &quot;watch&quot;,&quot;price&quot;: 60, &quot;description&quot;: &quot;test des&quot;, &quot;tax&quot; : 25.3}, &quot;jyb&quot;: {&quot;name&quot;: &quot;neck&quot;, &quot;price&quot;:30, &quot;description&quot;: None,&quot;tags&quot;:[&quot;test tag&quot;,&quot;test2 tag2&quot;]}}@app.get(&quot;/items/{item_id}&quot;, response_model=Item, response_model_exclude_unset=True)async def read_item(item_id: str): return items[item_id]요청을 쿼리파라미터로 받기에http://localhost:8000/items/bjhhttp://localhost:8000/items/kmshttp://localhost:8000/items/jyb셋 중 하나로 보내면 그에 맞는 데이터값을 보내게 된다.위의 구문중 크게 어려운 문법은 없지만 response_model_exclude_unset은 다소 생소하다.☑️ Use the response_model_exclude_unset parameter뜻은 간단하다. 반환 모델에서 default value가 설정되지 않은 속성값들은 반환할 때 포함시키지 않는다. 즉, 설정된 값만 리턴한다.만약 kms로 요청을 보낸다면 이렇게 default value값이 설정된 것들(description,tags,tax)은 응답에 포함시키지 않는다.다른 속성값들은 필수로 채워줘야한다.결과{ &quot;name&quot;: &quot;bag&quot;, &quot;price&quot;: 350}또한 response_model_exclude_defaults=True response_model_exclude_none=True도 있다.여기서 헷갈리는 점이 있다.items와 Item과 어떤 연관관계가 있을까?없다. 그저 이름이 비슷할뿐이다. items를 test로 바꾸고 리턴값에 test[item_id]로 바꿔도 돌아간다.해당 옵션을 빼고 jyb요청을 보내면 default value를 설정한 tax가 포함되어있다.None으로 설정하지 않는다면 그 어떤값도 default value라고 판단하지 않고 보낸다.☑️ response_model_include and response_model_exclude이름에서 보면 유추할 수 있듯이, 어떤 값을 포함할지 안할지를 정할 수 있다. 공식문서에서는 이러한 방식을 추천한다기 보다는 새로운 클래스를 만들어서 반환하는 것을 추천한다. 그 이유는 결국 이렇게 데코레이션을 단 모델도, JSON Shcema를 생성할때 포함되기 때문이다. 또한 respone_model_by_alias도 마찬가지다.from fastapi import FastAPIfrom pydantic import BaseModelapp = FastAPI()class Item(BaseModel): name: str description: str | None = None price: float tax: float = 10.5items = { &quot;foo&quot;: {&quot;name&quot;: &quot;Foo&quot;, &quot;price&quot;: 50.2}, &quot;bar&quot;: {&quot;name&quot;: &quot;Bar&quot;, &quot;description&quot;: &quot;The Bar fighters&quot;, &quot;price&quot;: 62, &quot;tax&quot;: 20.2}, &quot;baz&quot;: { &quot;name&quot;: &quot;Baz&quot;, &quot;description&quot;: &quot;There goes my baz&quot;, &quot;price&quot;: 50.2, &quot;tax&quot;: 10.5, },}@app.get( &quot;/items/{item_id}/name&quot;, response_model=Item, response_model_include={&quot;name&quot;, &quot;description&quot;},)async def read_item_name(item_id: str): return items[item_id]@app.get(&quot;/items/{item_id}/public&quot;, response_model=Item, response_model_exclude={&quot;tax&quot;})async def read_item_public_data(item_id: str): return items[item_id]요청http://localhost:8000/items/baz/name결과{ &quot;name&quot;: &quot;Baz&quot;, &quot;description&quot;: &quot;There goes my baz&quot;}즉, response_model_include는, 지정된 값이 존재할 시 리턴한다. 없으면 null을 리턴한다.반대로 response_model_exclude는 위에서 지정한 tax만 제외하고 값이 있다면 전부 리턴한다. http://localhost:8000/items/foo/public로 요청을 보내면 foo에는 없는 description이 null로 입력되는데, 이는 respone_model=Item으로 리턴 모델을 지정해놔서 그렇다." }, { "title": "FastAPI 공식문서 따라하기[15] - Header Parameters", "url": "/posts/fastapi15/", "categories": "Python, FastAPI", "tags": "FastAPI", "date": "2022-05-19 05:00:00 +0900", "snippet": " https://fastapi.tiangolo.com/tutorial/header-params/ 공식문서 따라하는 글☑️ Header Parameters앞에서 QueryParameter, PathParameter, Cookie를 설정해준것처럼 Header를 설정할 수 있다.☑️ Import Header사용하기 위해선 fastapi에서 Header를 임포트 해야한다.from fastapi import FastAPI, Headerapp = FastAPI()@app.get(&quot;/items/&quot;)async def read_items(Host: str | None = Header(default=None)): return {&quot;Host&quot;: Host}개인적으로 확인할게 있어서 기본 예제를 바꿨다.기본 예제에는 Host변수로 인자를 받는게 아니고, user_agent를 인자로 받는다.위의 예제의 결과는{&quot;Host&quot;:&quot;localhost:8000&quot;}이렇게 뜨고, user_agent를 인자로 받는다면{&quot;user_agent&quot;:&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.54 Safari/537.36&quot;}이렇게 내 정보가 뜬다. Header는 Path,Query,Cookie처럼 Param클래스를 상속받았다고 한다.하지만 리턴하는 값은 모두 다 같은 값이 아니라는 사실을 알고 있어야 한다.☑️ Automatic conversion보통 헤더에는 -기호로 구분을 한다. user-agent처럼 말이다. 그러나 이러한 -값이 포함되어 있으면 Python에서는 인식하지 못한다.그렇기에 Header를 사용하면 -를 자동으로 _로 바꿔 인식한다.또한 HTTPheader들은 대소문자를 구문하지 않으므로 표준Python스타일로 선언할 수 있다.그렇기에 User_Agent같이 작성할 필요 없고 user_agent처럼 표준Python 명명규칙을 따를 수 있다. 파이썬 표준에 관해서는 여기를 참고 -&amp;gt; https://digital-play.tistory.com/46만약 그래도 어떠한 이유때문에 -를 _로 바꿔주는 자동 변환 기능을 꺼버리고 싶다면 다음과 같이 convert_underscores의 값을 False로 주면 된다.from fastapi import FastAPI, Headerapp = FastAPI()@app.get(&quot;/items/&quot;)async def read_items( strange_header: str | None = Header(default=None, convert_underscores=False)): return {&quot;strange_header&quot;: strange_header}☑️ Duplicate headers같은 헤더에 여러값이 있을때도 이를 받을 수 있다고 한다.이렇게 받으려면 list형식으로 인자를 받아야 한다.예를들면, Kms-Token이 있다고 하고 이에 여러값을 저장하여 받는다고 할 때from fastapi import FastAPI, Headerapp = FastAPI()@app.get(&quot;/items/&quot;)async def read_items(kms_token: list[str] | None = Header(default=None)): return {&quot;Kms_Token value&quot;: kms_token}이렇게 작성할 수 있고curl -X &#39;GET&#39; \\ &#39;http://localhost:8000/items/&#39; \\ -H &#39;accept: application/json&#39; \\ -H &#39;kms-token: hi?&#39; \\ -H &#39;kms-token: token2&#39;이렇게 요청을 보내 값을 확인할 수 있다." }, { "title": "FastAPI 공식문서 따라하기[14] - Cookie Parameters", "url": "/posts/fastapi14/", "categories": "Python, FastAPI", "tags": "FastAPI", "date": "2022-05-19 04:00:00 +0900", "snippet": " https://fastapi.tiangolo.com/tutorial/cookie-params/ 공식문서 따라하는 글☑️ Cookie ParametersQuery Paramter와 Path Paramter를 정의한것처럼 Cookie Parameter를 정의할 수 있다.☑️ Import CookieCookie를 사용하기 위해선 fastapi에서 Cookie를 임포트 해야한다.from fastapi import Cookie, FastAPIapp = FastAPI()@app.get(&quot;/items&quot;)async def read_items(ads_id: str | None = Cookie(default=None)): return {&quot;ads_id&quot;:ads_id}위의 구문을 해석해보자면,ads_id를 받는데, 이 값은 곧 쿠키의 값이 되고 만약 없다면 쿠키도 None이 된다.하지만 Swagger에서는 확인할 수 없는데, 이는 보안상의 문제가 아닐까 라고 생각한다.https://stackoverflow.com/questions/63788083/how-to-check-if-a-cookie-is-set-in-fastapi이를 확인 하는방법은 curl을 보내는 것이다.curl -X &#39;GET&#39; \\ &#39;http://localhost:8000/items/&#39; \\ -H &#39;accept: application/json&#39; \\ -H &#39;Cookie: ads_id=hi im kms?&#39;라고 보내버리면 응답은 이렇게 받을 것이다.{&quot;ads_id&quot;:&quot;hi im kms?&quot;}성공참고로 쿠키를 설정하는 것이 아닌 쿠키값을 받아오는 것이다." }, { "title": "FastAPI 공식문서 따라하기[13] - Extra Data Types", "url": "/posts/fastapi13/", "categories": "Python, FastAPI", "tags": "FastAPI", "date": "2022-05-18 03:00:00 +0900", "snippet": " https://fastapi.tiangolo.com/tutorial/extra-data-types/ 공식문서 따라하는 글☑️ Extra Data Types일반적인 데이터타입인 int,float,str,bool과 달리 좀 더 복잡한 데이터를 다루는 챕터이다.좀 더 복잡한 대신에 다음과 장점들을 갖고 있다. 에디터가 지원한다. 요청으로 해당 데이터가 들어오면 데이터 변환을 한다. 데이터 변환을 통해 응답에 반환할 수 있다. 데이터 검증이 가능 자동 문법검사와 문서화를 갖고 있다.☑️ Other data types다음과 같은 추가 데이터타입들이 있다. UUID : ‘Universally Unique Identifier”`라고 하는 것인데, 전세계적으로 고유한 값이다. 요청이나 응답에 대해서 str로 표현이 가능하다. datetime.datetime : 날짜, 시간 표준이 ISO 8601 포맷으로 표현이 가능하다. 예를 들어서 2008-09-15T15:53:00+0:00처럼 말이다. datatime.date : 마찬가지로 ISO 8601표준으로 사용이 가능하다. ex) 2008-09-15 datatime.time : 마찬가지로 ISO 8601표준으로 사용이 가능하다. ex) 14:23:55.003 datetime.timedelta : 요청이나 응답을 보낼때에는 float형태의 초로 표현할 수 있다. frozenset : 요청이나 응답을 보낼때 set처럼 사용할 수 있다. 요청으로 리스트를 읽는데, 중복된 값을 제거하고 set으로 바꿔버린다. 응답에서는 set이 list로 바뀐다. 스키마를 만들때는 set으로 만들어진다. byte : 요청이나 응답에서는 str로 다뤄진다. 문서화될 때에는 binary값으로 포맷된 str이 된다. Decimal : 요청이나 응답에서 float로 다뤄진다. 참고 : https://pydantic-docs.helpmanual.io/usage/types☑️ Examplefrom datetime import datetime, time, timedeltafrom uuid import UUIDfrom fastapi import Body, FastAPIapp = FastAPI()@app.put(&quot;/items/{item_id}&quot;)async def read_items( item_id: UUID, start_datetime: datetime | None = Body(default=None), end_datetime: datetime | None = Body(default = None), repeat_at: time | None = Body(default=None), process_after: timedelta | None = Body(default=None),): start_process = start_datetime + process_after duration = end_datetime - start_process return { &quot;item_id&quot; : item_id, &quot;start_datetime&quot;: start_datetime, &quot;end_datetime&quot;: end_datetime, &quot;repeat_at&quot; : repeat_at, &quot;process_after&quot;: process_after, &quot;start_process&quot;: start_process, &quot;duration&quot;: duration }UUID가 고유한 값이라 파라미터 값으로2ed822bd-9945-4a82-bdbb-79fc178fd507를 넣고 body에는{ &quot;start_datetime&quot;: &quot;2022-05-19T05:29:21.847Z&quot;, &quot;end_datetime&quot;: &quot;2022-05-19T05:29:21.847Z&quot;, &quot;repeat_at&quot;: &quot;14:23:55.003&quot;, &quot;process_after&quot;: 0.4}이렇게 넣으면 결과값은요로콤 나온다." }, { "title": "FastAPI 공식문서 따라하기[12] - Declare Request Example Data", "url": "/posts/fastapi12/", "categories": "Python, FastAPI", "tags": "FastAPI", "date": "2022-05-18 02:00:00 +0900", "snippet": " https://fastapi.tiangolo.com/tutorial/schema-extra-example/ 공식문서 따라하는 글☑️ Declare Request Example Data임의로 데이터를 만들어서 요청을 받을 수 있다.☑️ Pydantic schema_extraPydantic모델의 Config와 schema_extra를 사용해서 더미데이터를 만들 수 있다.from fastapi import FastAPIfrom pydantic import BaseModelapp = FastAPI()class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None class Config: schema_extra = { &quot;example&quot;: { &quot;name&quot;: &quot;kms&quot;, &quot;description&quot;: &quot;kms is handsome&quot;, &quot;price&quot;: 10000.0, &quot;tax&quot;: 0.2 } }@app.put(&quot;/items/{item_id}&quot;)async def update_item(item_id: int, item: Item): results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item} return resultsextra는 JSON Schema형태의 값을 만들어내고 Swagger와 같은 docs에서 확인할 수 있다. exmaple이라는 것을 그대로 명시해야한다. 저 변수명(?)은 사용자가 임의로 조작하면 더미 데이터인지를 인지하지 못한다.☑️ Field additional argumentsField()를 사용하면 위에서처럼 더미데이터를 만들 수 있다.from fastapi import FastAPIfrom pydantic import BaseModel,Fieldapp = FastAPI()class Item(BaseModel): name: str = Field(example=&quot;Kms&quot;) description: str | None = Field(default = None, example=&quot;Kms is Handsome guy&quot;) price: float = Field(example=10000.5) tax: float | None = Field(default = None, example= 0.5)@app.put(&quot;/items/{item_id}&quot;)async def update_item(item_id: int, item: Item): results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item} return results 이러한 값들은 유효성을 추가하는것이 아니고, 더미데이터라는 정보만 전달한다. 즉, 문서화의 목적으로 사용하는 것이다.☑️ example and examples in OpenAPI Path() Query() Header() Cookie() Body() Form() File()을 통해서 exmaples이나 example을 선언할 수 있다고 한다.Body를 사용한 example 코드이다.from fastapi import Body, FastAPIfrom pydantic import BaseModelapp = FastAPI()class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None@app.put(&quot;/items/{item_id}&quot;)async def update_item( item_id: int, item: Item = Body( example={ &quot;name&quot;: &quot;Foo&quot;, &quot;description&quot;: &quot;A very nice Item&quot;, &quot;price&quot;: 35.4, &quot;tax&quot;: 3.2, }, ),): results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item} return resultsTypeError: Body() missing 1 required positional argument: &#39;default&#39;에러가 뜬다.TypeError: Body() missing 1 required positional argument: ‘default’ 해결법사실 다음 도큐문서를 보면 바로 나오는데, Body(default = ~)로 쓰면 바로 해결된다.from fastapi import Body, FastAPIfrom pydantic import BaseModelapp = FastAPI()class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None@app.put(&quot;/items/{item_id}&quot;)async def update_item( item_id: int, item: Item = Body( default={ &quot;name&quot;: &quot;Kms&quot;, &quot;description&quot;: &quot;Handsome Guy&quot;, &quot;price&quot;: 10234.2, &quot;tax&quot;: 7.27, }, ),): results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item} return results즉 example={}를 default={}로 바꾸면 된다.또는item: Item = Body( default={}, example={ &quot;name&quot;: &quot;Kms&quot;, &quot;description&quot;: &quot;Handsome Guy&quot;, &quot;price&quot;: 10234.2, &quot;tax&quot;: 7.27, }, ),default={}를 선언하고, example에 값을 넣으면 된다.고로 다시 진행하겠다.☑️ Body with multiple examplesdict형태로 여러개의 더미데이터를 생성할 수 있다.또한 추가적인 기능을 가지고 있는데, summary : 더미데이터의 설명 description : 더미데이터의 설명이지만 길 때, Markdown문법도 지원한다. value : 실제로 보여줄 더미데이터 값 externalValue : value와 달리, URL을 가르킨다는데.. 그리고 value와 달리 많은 도구들에서 지원하지는 않는다고 함.from fastapi import Body, FastAPIfrom pydantic import BaseModelapp = FastAPI()class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None@app.put(&quot;/items/{item_id}&quot;)async def update_item( *, item_id: int, item: Item = Body( default={}, examples={ &quot;kms_Example1&quot;: { &quot;summary&quot;: &quot;Example One by Kms&quot;, &quot;description&quot;: &quot;A **normal** item works correctly.&quot;, &quot;value&quot;: { &quot;name&quot;: &quot;Foo&quot;, &quot;description&quot;: &quot;A very nice Item&quot;, &quot;price&quot;: 35.4, &quot;tax&quot;: 3.2, }, }, &quot;kms_Example2&quot;: { &quot;summary&quot;: &quot;Example Two by Kms&quot;, &quot;description&quot;: &quot;FastAPI can convert price `strings` to actual `numbers` automatically&quot;, &quot;value&quot;: { &quot;name&quot;: &quot;Bar&quot;, &quot;price&quot;: &quot;35.4&quot;, }, }, &quot;kms_Example3&quot;: { &quot;summary&quot;: &quot;Example Three by Kms&quot;, &quot;value&quot;: { &quot;name&quot;: &quot;Baz&quot;, &quot;price&quot;: &quot;thirty five point four&quot;, }, }, }, ),): results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item} return results공식 문서와 예제가 좀 다른데, 마찬가지로 body의 첫 파라미터는 무조건 default를 인자로 넣어줘야한다해서 내가 임의로 바꿔보았다. 실행하면 잘 된다. description에 MarkDown문법을 사용할 수 있다." }, { "title": "FastAPI 공식문서 따라하기[11] - Body - Nested Models", "url": "/posts/fastapi11/", "categories": "Python, FastAPI", "tags": "FastAPI", "date": "2022-05-18 01:00:00 +0900", "snippet": " https://fastapi.tiangolo.com/tutorial/body-nested-models/ 공식문서 따라하는 글☑️ Body Nested ModelsPydantic를 이용한 FastAPI는 좀 더 복잡한 모델의 자료형에 대해 검증, 정의, 문서화 및 사용할 수 있게한다.☑️ List fields바로 코드예제로 보겠다.from fastapi import FastAPIfrom pydantic import BaseModelapp = FastAPI()class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None tags: list = []@app.put(&quot;/items/{item_id}&quot;)async def update_item(item_id: int, item: Item): results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item} return resultstags속성을 보면 리스트로 되어 있다.☑️ List fields with type parameterlist에 타입을 명시하고 싶다면 어떻게 해야할까?Python3.9 버전 ~ Python 3.6 버전에서는 List를 typing에서 임포트해야한다.from typing import List, Union이렇게 하면 list,dict,tuple에 자료형을 명시할 수 있다.#python3.9 abovemy_list: list[str]#python3.6 ~ 3.9from typing import List,Unionmy_list: List[str]이로써 자료구조에 타입을 명시할 수 있게 되었다.☑️ Set types데이터가 중복이 되면 안되는 유니크한 값이라면 set을 사용하고 싶을 것이다. 다행스럽게도 set을 지원하는데, 다음과 같이 쓰면 된다.# Python 3.6 abovefrom typing import Set,Unionmy_set: Set[str] = set()# Python 3.9 abovemy_set: set[str] = set()☑️ Nested ModelsPydantic의 속성들은 데이터 타입이 있다.Pydantic의 모델들은 다른 Pydantic의 속성값이 될 수 있다.그렇기에 복잡하게 얽힌 JSON object들의 각 속성들도 잘 명시되어 있으면 데이터 검증을 통해서 다른 모델의 속성값이 될 수 있다.예를들어서 이렇게 모델을 정의할 수 있을 것이다.from fastapi import FastAPIfrom pydantic import BaseModelapp = FastAPI()class Image(BaseModel): url: str name: strBaseModel을 상속받은 Image는 다른 클래스에서 쓰일 수 있다.from fastapi import FastAPIfrom pydantic import BaseModelapp = FastAPI()class Image(BaseModel): url: str name: strclass Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None tags: set[str] = set() # image: Image | None = NoneItem의 image라는 속성은 Image객체를 받거나 None값을 받는다.그러면 RequestBody에 이렇게 담아야 할 것이다.{ &quot;name&quot;: &quot;Foo&quot;, &quot;description&quot;: &quot;The pretender&quot;, &quot;price&quot;: 42.0, &quot;tax&quot;: 3.2, &quot;tags&quot;: [&quot;rock&quot;, &quot;metal&quot;, &quot;bar&quot;], &quot;image&quot;: { &quot;url&quot;: &quot;http://example.com/baz.jpg&quot;, &quot;name&quot;: &quot;The Foo live&quot; }}☑️ Speical types and validationstr,int,float같은 일반적인 자료형 말고, 조금더 복잡한 자료형을 상속받은 str을 사용해보겠다.위의 Image라는 모델에서 url이라는 속성을 str형태로 정의했는데, 이 대신에 Pydantic이 가지고 있는 HttpUrl을 사용할 수 있다.from fastapi import FastAPIfrom pydantic import BaseModel,HttpUrlapp = FastAPI()class Image(BaseModel): # url: HttpUrl name: strclass Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None tags: set[str] = set() image: Image | None = None@app.put(&quot;/items/{item_id}&quot;)async def update_item(item_id: int, item: Item): results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item} return results저렇게 선언하면 Swagger와 같은 문서들이 URL의 형태인지 확인한다. 만약 아니라면{ &quot;detail&quot;: [ { &quot;loc&quot;: [ &quot;body&quot;, &quot;image&quot;, &quot;url&quot; ], &quot;msg&quot;: &quot;invalid or missing URL scheme&quot;, &quot;type&quot;: &quot;value_error.url.scheme&quot; } ]}라며 422 에러를 발생시킨다.☑️ Attributes with lists of submodelslist나 set을 Pydantic모델의 자료형으로 선언할 수 있다.from fastapi import FastAPIfrom pydantic import BaseModel, HttpUrlapp = FastAPI()class Image(BaseModel): url: HttpUrl name: strclass Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None tags: set[str] = set() # images: list[Image] | None = None@app.put(&quot;/items/{item_id}&quot;)async def update_item(item_id: int, item: Item): results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item} return results이렇게 선언하면 RequestBody에 다음과 같이 데이터를 넘길 수 있다.{ &quot;name&quot;: &quot;Foo&quot;, &quot;description&quot;: &quot;The pretender&quot;, &quot;price&quot;: 42.0, &quot;tax&quot;: 3.2, &quot;tags&quot;: [ &quot;rock&quot;, &quot;metal&quot;, &quot;bar&quot; ], &quot;images&quot;: [ { &quot;url&quot;: &quot;http://example.com/baz.jpg&quot;, &quot;name&quot;: &quot;The Foo live&quot; }, { &quot;url&quot;: &quot;http://example.com/dave.jpg&quot;, &quot;name&quot;: &quot;The Baz&quot; } ]}☑️ Deeply nested models¶2중으로 중첩해서 모델을 담을 수 있다.from fastapi import FastAPIfrom pydantic import BaseModel, HttpUrlapp = FastAPI()class Image(BaseModel): url: HttpUrl name: strclass Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None tags: set[str] = set() images: list[Image] | None = Noneclass Offer(BaseModel): name: str description: str | None = None price: float items: list[Item]@app.post(&quot;/offers/&quot;)async def create_offer(offer: Offer): return offer코드를 보면 Offer는 Item객체를 리스트로 담고 있는데, Item객체는 Image를 리스트로 담고 있다.☑️ Bodies of pure lists요청함수 파라미터로 list형태를 받을 수 있다.from fastapi import FastAPIfrom pydantic import BaseModel, HttpUrlapp = FastAPI()class Image(BaseModel): url: HttpUrl name: str@app.post(&quot;/images/multiple/&quot;)async def create_multiple_images(images: list[Image]): return images데이터는 다음처럼 넣어서 확인하면 된다.[ { &quot;url&quot;: &quot;http://item1.com&quot;, &quot;name&quot;: &quot;item1&quot; }, { &quot;url&quot;: &quot;http://item2.com&quot;, &quot;name&quot;: &quot;item2&quot; }]☑️ Bodies of arbitrary dicts¶dict형태의 값도 요청함수 파라미터로 받을 수 있다.from fastapi import FastAPIapp = FastAPI()@app.post(&quot;/index-weights/&quot;)async def create_index_weights(weights: dict[int, float]): return weights{&quot;1&quot; : 0.4,&quot;2&quot; : 4.3}이런식으로 키값을 넣어주면 되는데, 의문점이 생길 것이다. key값을 str자료형으로 넘겼는데 에러가 뜨지 않는다. JSON은 오로지 str형태의 키값을 가진다. Pydantic은 자동적으로 데이터 자료형을 변환시켜주는데 이로 인해서 str형태로 키를 넘겨도 이를 자동으로 integers로 변환해준다." }, { "title": "FastAPI 공식문서 따라하기 번외[10][2]끝 - Alchemy연동", "url": "/posts/fastapiAlchemy03/", "categories": "Python, FastAPI", "tags": "FastAPI", "date": "2022-05-16 01:00:00 +0900", "snippet": " https://fastapi.tiangolo.com/tutorial/sql-databases/?h=sql 공식문서 따라하는 글☑️ 5.1. Main FastAPI appsql_app/main.py을 작성할 것이고, 작성한 다른 문서들을 통합하여 사용할 것이다.☑️ 5.2. Create the database tablesdatabase tables을 만든느건 매우매우 쉽다고 한다.from fastapi import Depends, FastAPI, HTTPExceptionfrom sqlalchemy.orm import Sessionfrom . import crud, models, schemasfrom .database import SessionLocal, engine#만드는 부분models.Base.metadata.create_all(bind=engine)app = FastAPI()데이터베이스를 migration하기 위해서는 Alembic이라는것을 대표적으로 사용한다.migrationmigration은 SQLAlchemy모델에서 속성을 추가하거나 같이 구조가 바뀌거나, database의 값들을 복제하여 바꾸거나 새로운 컬럼을 넣거나 테이블을 넣거나 하는 등의 작업들을 말한다.☑️ 5.3. Create a dependencysql_app/database.py에서 작성한 SessionLocal을 불러와서 의존성을 주입할 것이다.요청마다 독립적인 세션과 데이터베이스 커넥션을 가져야하기 때문에, 같은 세션을 통하여 모든 요청을 처리하고 요청이 처리된 후 커넥션을 닫아야 한다.그리고 다음 요청을 위해서 새로운 세션이 생성되어야 한다.yield이라는 키워드를 통해 새로운 의존성을 만들어 줄것이다. 이에 대한 설명은 https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-with-yield/에 있다고 한다.. 나중에 저 글도 읽어볼 것이다.우리가 만든 의존성은 SessionLocal을 사용하여 하나의 요청을 받고 요청이 끝나면 닫을 것이다.from fastapi import Depends, FastAPI, HTTPExceptionfrom sqlalchemy.orm import Sessionfrom . import crud, models, schemasfrom .database import SessionLocal, enginemodels.Base.metadata.create_all(bind=engine)app = FastAPI()# Dependencydef get_db(): db = SessionLocal() try: yield db finally: db.close() try에서 SessionLocal을 변수에 넣고 이를 통해 요청값들을 다룰 것이다.그리고 finally에서 해당 커넥션을 닫을 것이다. 이러한 방식을 통해 요청이 끝나면 세션은 항상 닫히게 되며, 요청에서 에러가 터져도 닫히도록 설계 했다.공식문서에서는 예외처리를 해주고 싶다면 https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-with-yield/#dependencies-with-yield-and-httpexception여기를 참고하라고 하였다.path operation function에 있는dependency를 통해 Session타입의 변수를 선언할 수 있다. Session의 기능 통해서 함수내에 동작구문들을 많이 간소화할 수 있다는데.. 한 번 보자.from fastapi import Depends, FastAPI, HTTPExceptionfrom sqlalchemy.orm import Sessionfrom . import crud, models, schemasfrom .database import SessionLocal, enginemodels.Base.metadata.create_all(bind=engine)app = FastAPI()# Dependencydef get_db(): db = SessionLocal() try: yield db finally: db.close()@app.post(&quot;/users/&quot;, response_model=schemas.User)def create_user(user: schemas.UserCreate, db: Session = Depends(get_db)): #추후 공개@app.get(&quot;/users/&quot;, response_model=list[schemas.User])def read_users(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)): #추후 공개@app.get(&quot;/users/{user_id}&quot;, response_model=schemas.User)def read_user(user_id: int, db: Session = Depends(get_db)): #추후 공개@app.post(&quot;/users/{user_id}/items/&quot;, response_model=schemas.Item)def create_item_for_user( user_id: int, item: schemas.ItemCreate, db: Session = Depends(get_db)): #추후 공개@app.get(&quot;/items/&quot;, response_model=list[schemas.Item])def read_items(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)): #추후 공개 파라미터인 db는 SessionLocal타입이고 이 타입은 sessionmaker()를 통해 만들어졌다. 그렇기에 이는 SQLAlchemy Session의 proxy이고, 그렇기에 에디터는 어떤 함수를 제공하는 지 몰라도 된다.만약 Session타입으로 파라미터를 넣었다면, 에디터는 .add(),.query(),.commit()같은 함수를 알고 있어야 한다. :{. prompt-info}☑️ 5.4. Create your FastAPI path operationsAPI를 만들 것이다.from fastapi import Depends, FastAPI, HTTPExceptionfrom sqlalchemy.orm import Sessionfrom . import crud, models, schemasfrom .database import SessionLocal, enginemodels.Base.metadata.create_all(bind=engine)app = FastAPI()# Dependencydef get_db(): db = SessionLocal() try: yield db finally: db.close()@app.post(&quot;/users/&quot;, response_model=schemas.User)def create_user(user: schemas.UserCreate, db: Session = Depends(get_db)): db_user = crud.get_user_by_email(db, email=user.email) if db_user: raise HTTPException(status_code=400, detail=&quot;Email already registered&quot;) return crud.create_user(db=db, user=user)@app.get(&quot;/users/&quot;, response_model=list[schemas.User])def read_users(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)): users = crud.get_users(db, skip=skip, limit=limit) return users@app.get(&quot;/users/{user_id}&quot;, response_model=schemas.User)def read_user(user_id: int, db: Session = Depends(get_db)): db_user = crud.get_user(db, user_id=user_id) if db_user is None: raise HTTPException(status_code=404, detail=&quot;User not found&quot;) return db_user@app.post(&quot;/users/{user_id}/items/&quot;, response_model=schemas.Item)def create_item_for_user( user_id: int, item: schemas.ItemCreate, db: Session = Depends(get_db)): return crud.create_user_item(db=db, item=item, user_id=user_id)@app.get(&quot;/items/&quot;, response_model=list[schemas.Item])def read_items(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)): items = crud.get_items(db, skip=skip, limit=limit) return items☑️ 6.1. About def vs async def요청에 응답을 기다려야 한다면 다음과 같이 작성할 수 있다.user = await db.query(User).first()#oruser = db.query(User).first()이렇게 작성하면 함수 작성시 async def를 쓰면 안되고 def로 작성해야 한다.@app.get(&quot;/users/{user_id}&quot;, response_model=schemas.User)def read_user(user_id: int, db: Session = Depends(get_db)): db_user = crud.get_user(db, user_id=user_id) ...이렇게 말이다. 만약 비동기로 데이터베이스와 연결하고 싶다면 https://fastapi.tiangolo.com/advanced/async-sql-databases/를 참고async def와 def를 다루는 것에 대해 기술적으로 궁금하다면 https://fastapi.tiangolo.com/advanced/async-sql-databases/☑️ 7. Check it이제 코드를 테스트해볼 것이다.pip install sqlalchemySQLAlchemy 를 설치해주고sql_app이 있는 루트 디렉토리로 가서 다음과 같이 명령어를 쳐준다.uvicorn sql_app.main:app --reload이렇게 뜨면 성공이다.이제Sqlite가 없다면 설치를 해줘야한다.나는 mac이므로 Homebrew로 설치하겠다.brew install --cask db-browser-for-sqliteSqlite를 열고 루트 디렉터리에 저장되어 있는 sql_app.db을 열면다음과 같이 뜰 것이다.성공!!☑️ 8. Alternative DB session with middlewareyield 키워드를 사용하지 않고 싶다면 middleware를 설정할 수 있다.#main.pyfrom fastapi import Depends, FastAPI, HTTPException, Request, Responsefrom sqlalchemy.orm import Sessionfrom . import crud, models, schemasfrom .database import SessionLocal, enginemodels.Base.metadata.create_all(bind=engine)app = FastAPI()@app.middleware(&quot;http&quot;)async def db_session_middleware(request: Request, call_next): response = Response(&quot;Internal server error&quot;, status_code=500) try: request.state.db = SessionLocal() response = await call_next(request) finally: request.state.db.close() return response# Dependencydef get_db(request: Request): return request.state.db...request.state는 Request의 속성이다.데이터베이스 세션 같은 임의의 오브젝트를 request자체에 저장시키는데, 더 자세히 알아보고 싶다면 https://www.starlette.io/requests/#other-state☑️ 9. Dependencies with yield or middlewaremiddleware를 사용하면 yield를 사용하는것과 비슷하지만 몇 가지 다르다. 코드량이 늘어나고, 조금 복잡해진다. async함수를 사용할 수 있다. “wait”이라고 사용하면 이것은 “block”이 되면 성능이 약간 저하 될 수 있다. SQLAlchemy을 사용하면 그다지 큰 문제가 아니라고 한다. 당연하겠지만 많은 양의 I/O waiting이 있다면 그것은 문제가 될 것이다. middleware는 모든 요청에 대해 반응한다. 그렇기에 모든 요청에 대해 커넥션을 만들게 될 것이다. 심지어 요청이 DB 접근이 필요하지 않을지라도 커넥션을 맺는다. 공식문서에서는 yield에 대한 이해도가 있는 경우 yield를 사용하는것이 더 좋다고 한다." }, { "title": "FastAPI 공식문서 따라하기 번외[10][1] - Alchemy연동", "url": "/posts/fastapiAlchemy02/", "categories": "Python, FastAPI", "tags": "FastAPI", "date": "2022-05-15 01:00:00 +0900", "snippet": " https://fastapi.tiangolo.com/tutorial/sql-databases/?h=sql 공식문서 따라하는 글☑️ 3.1. Create the Pydantic modelssql_app/schemas.py에 작성할 것이다. SQLAlchemy 과 Pydantic에서 설명하는 models을 혼동하면 안 된다. models.py에 있는 것은 SQLAlchemy의 모델이고, schemas.py은 Pydantic의 모델이다. Pydantic 모델은 schema라고 불러질 수 있다.☑️ 3.2. Create initial Pydantic models / schemasItemBase와 UserBase라는 Pydantic 모델을 만들 것이다. 공식문서에서는 모델대신에 스키마라고 명명하기에 나도 스키마라고 설정할 것이다.속성을 만들거나 읽는용도의 오브젝트이다.ItemCreate와 UserCreate라는 클래스는 위의 클래스들을 상속 받을 것이고(같은 속성을 갖습니다.), 추가적인 속성이 필요하다면 그 속성값을 만들 것이다.밑의 예제에서는 password라는 속성값을 만든다.하지만, 보안적으로 password라는 값은 다른 Pydantic모델에는 존재하지 말아야한다. 왜냐하면 user를 읽을때 API가 password를 보내면 안 되기 때문이다.SQLAlchemy 모델은 속성을 정의할 때 =연산자를 사용하고, Column에 파라미터를 넣어서 넘긴다.name = Column(String)반면 Pydantic 모델은 :을 이용한다.name: str따라서 =와 :을 현혹하면 안된다.☑️ 3.3. Create Pydantic models/ schemas for reading / returning위에서 Pydantic 모델을 만들었기에 이를 이용해서 데이터를 읽고, API를 통해 받아올 데이터가 있으면 받아올 것이다.item을 만들기 전에는, 우리는 어떤 데이터에 ID를 할당할지는 중요하지 않지만 우리가 데이터를 읽을 때에는 ID를 알고 있어야 한다.같은 방식으로 user라는 데이터를 읽기 위해서는 우리는 user 안에 items를 선언해야 한다.items를 읽기 위해서는 items의 ID 뿐만 아니라 모든 데이터를 Pydantic 모델인 Item에 정의해야 한다.from pydantic import BaseModelclass ItemBase(BaseModel): title: str description: str | None = Noneclass ItemCreate(ItemBase): passclass Item(ItemBase): id: int owner_id: intclass UserBase(BaseModel): email: strclass UserCreate(UserBase): password: strclass User(UserBase): id: int is_active: bool items: list[Item] = []☑️ 3.4. Use Pydantic’s orm_modePydantic모델인 Item과 User를 읽기 위해서는 추가적인 설정이 필요하다. 이를 configclass라고 지을 것이다.위의 코드에서 추가되는 부분이 있다.from pydantic import BaseModelclass ItemBase(BaseModel): title: str description: str | None = Noneclass ItemCreate(ItemBase): passclass Item(ItemBase): id: int owner_id: int #추가된 부분 class Config: orm_mode = Trueclass UserBase(BaseModel): email: strclass UserCreate(UserBase): password: strclass User(UserBase): id: int is_active: bool items: list[Item] = [] #추가된 부분 class Config: orm_mode = True orm_mode = True 구문을 보면 =를 사용하여 할당하였다. :는 타입을 선언할 때 쓰는것이고 config value는 타입을 선언하는 것이 아니다.orm_mode는 Pydantic 모델을 읽는데, dict타입 뿐만 아니라 ORM모델일지라도 읽어버린다.만약 id라는 값을 dict에서 가져오고 싶다면id = data[&quot;id&quot;]로 쓸수 있지만 또한,id = data.id로도 쓸 수 있다.이런 방식으로 Pydantic 모델은 ORM와 양립할 수 있고, path operation에다가 response_model을 선선할 수 있다.데이터베이스 모델을 리턴할 수 있고, 그 데이터를 읽을 수 있게 도와준다고 한다.Techinal Details about ORM modeSQLAlchemy은 lazy loading을 사용하는데, 간단히 말하면 데이터를 한 번에 다 받아오는 것이 아니고 관계없는 데이터는 그때 받아오는 것을 의미한다.예를들어서 items에 다음과 같이 접근한다고 가정하자.current_user.itemsSQLAlchemy은 items 테이블에 가서 user에 맞는 items를 가져오는데, 접근하지 않으면 가져올 일이 없다는 것이다. 이렇게 설명하는게 맞나?.. 해석을 잘못한거 같음orm_mode가 없는데 SQLAlchemy모델을 path operation에서 리턴 받았다면 그 모델은 연관관계를 설정했음에도 불구하고 연관관계 데이터를 포함하지 않았을 것이라고 한다.즉,ORM mode에서는, Pydantic에 접근하고 사용자가 원하는 데이터 명시하여 데이터를 얻을 수 있다.☑️ 4.1. CRUD utilssql_app/crud.py에 CRUD관련 사항을 작성할 것이다.공식문서에서는 CR까지만 작성한다고 한다.☑️ 4.2. Read Datasqlalchemy.orm에서 Session을 임포트해야 한다.Session은 db라는 타입을 파라미터에 선언할 수 있게 하여 타입체크를 더 효율적으로 하게 해준다.models(SQLAlchemy models)과 schemas(Pydantic models) 또한 임포트 해야한다.공식 문서에서 명세를 알려줬는데.. ID와 email을 통해 user 한 명을 읽을 것이다. 여러 users를 읽을 것이다. 여러 items를 읽을 것이다.라고 합니다.from sqlalchemy.orm import Sessionfrom . import models, schemasdef get_user(db: Session, user_id: int): return db.query(models.User).filter(models.User.id == user_id).first()def get_user_by_email(db: Session, email: str): return db.query(models.User).filter(models.User.email == email).first()def get_users(db: Session, skip: int = 0, limit: int = 100): return db.query(models.User).offset(skip).limit(limit).all()def get_items(db: Session, skip: int = 0, limit: int = 100): return db.query(models.Item).offset(skip).limit(limit).all()☑️ 4.2. Create Data SQLAlchemy모델의 인스턴스를 만들것이다. database session에 만든 인스턴스를 add할 것이다. 바뀐 database정보를 commit할 것이다. refresh해서 데이터베이스에 새로운 데이터가 들어왔는지 확인한다.from sqlalchemy.orm import Sessionfrom . import models, schemasdef create_user(db: Session, user: schemas.UserCreate): fake_hashed_password = user.password + &quot;notreallyhashed&quot; db_user = models.User(email=user.email, hashed_password=fake_hashed_password) db.add(db_user) db.commit() db.refresh(db_user) return db_userdef create_user_item(db: Session, item: schemas.ItemCreate, user_id: int): db_item = models.Item(**item.dict(), owner_id=user_id) db.add(db_item) db.commit() db.refresh(db_item) return db_item fake_hashed_password는 보이는것 처럼 해쉬함수를 password에 더해 안전한 값으로 바꿔버린다.예제에서는 간단하게 보여주기 위해 진짜 해쉬함수로 넣지 않았다. 만약 클라이언트에서 암호화되지 않은 패스워드를 넘기면, 그값으로 해쉬함수로 만들고 저장해야한다. dict 자료형으로 Pydanticmodel을 담아야 Item의 각 속성값을 읽을 수 있다. item.dict()처럼 말이다.만약 dict의 key-value쌍으로 SQLAlchemy모델인 Item에 넘기고 싶다면 Item(**item.dict())처럼 사용하면 된다.owner_id는 Pydantic모델에서 제공하지 않기에 Item(**item.dict(), owner_id=user_id)로 넘겨야 한다." }, { "title": "FastAPI 공식문서 따라하기 번외[10] - Alchemy연동", "url": "/posts/fastapiAlchemy01/", "categories": "Python, FastAPI", "tags": "FastAPI", "date": "2022-05-14 01:00:00 +0900", "snippet": " https://fastapi.tiangolo.com/tutorial/sql-databases/?h=sql 공식문서 따라하는 글SQLAlchemy를 사용해보겠다. 공식문서에서는 SQLite를 사용하였으므로 SQLite를 DBserver로 두겠다.☑️ 1.1. ORMFastAPI는 어떤 database와도 잘 작옹한다.흔히 ORM(object-relational mapping Library)라는 패턴을 사용한다.ORM에는 object의 code와 database tables을 “map“으로 바꾸는 기능을 가지고 있다.ORM을 사용하면 class로 표현되는 테이블을 만들수 있는데, 해당 클래스의 각 속성값은 이름(name)과 타입(type)이 있는 column으로 표현된다.예를들어 orion_cat(Pet의 인스턴스)이라는 오브젝트가 있다고 치면, 이 오브젝트는 orion_cat.type이라는 속성값을 type이라는 컬럼에 가지고 있다. 그리고 cat이라는 속성값을 가질 수 있다.ORM은 또한 table과 entites의 연관관계를 구성하는데 도와주고, 커넥션을 만드는데 도와준다.이러한 방식을 통해 orion_cat은 orion_cat.owner라는 속성값을 가질 수 있고 owner는 owners라는 테이블의 값이고 pet의 owner라는 데이터를 포함할 수 있다.또한, 이를 통해 orion_cat.owner.name은 owners 테이블의 name이라는 속성값으로 접근할 수 있다.이렇게 ORM은 사용자가 pet이라는 오브젝트에 접근하여 해당pet의 owner를 찾을 수 있게 owneers테이블에서 알맞은 owner를 찾는다.이러한 ORM의 종류로는 Django-ORM, SQLalchemy ORM, Peewee 등이 있다.공식 문서에서는 SQLAlchemy ORM을 사용하여 예제를 작성할 것이다. 공식문서에서는 Peewee를 사용한 것도 해당 문서에서 나타내고 있다고 한다.☑️ 1.2. File structure공식문서에서는 파일구조를 다음과 같이 나타냈다..└── sql_app ├── __init__.py ├── crud.py ├── database.py ├── main.py ├── models.py └── schemas.pymkdir sql_appcd sql_apptouch __init__.pytouch crud.pytouch database.pytouch main.pytouch models.pytouch schemas.py를 통해 디렉터리 구성을 똑같이 해주었다.☑️ 1.3. Create the SQLAlchemy partssql_app/databse.py파일이다.from sqlalchemy import create_enginefrom sqlalchemy.ext.declarative import declarative_basefrom sqlalchemy.orm import sessionmakerSQLALCHEMY_DATABASE_URL = &quot;sqlite:///./sql_app.db&quot;#Postgres 사용을 원할경우# SQLALCHEMY_DATABASE_URL = &quot;postgresql://user:password@postgresserver/db&quot;engine = create_engine( SQLALCHEMY_DATABASE_URL, connect_args={&quot;check_same_thread&quot;: False})SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)Base = declarative_base() 이 예제는 SQLiteDB에 connection을 맺고 있다. sql_app.db는 같은 디렉터리에 있어야 한다.(./sql_app.db로 끝냈기에)☑️ 1.4. Create the SQLAlchemy engine위의 코드에서engine = create_engine( SQLALCHEMY_DATABASE_URL, connect_args={&quot;check_same_thread&quot;: False})이부분이 SQLAlchemy의 engine을 만드는 부분이다.맨 처음에는 engine을 만들어야한다.connect_args={&quot;check_same_thread&quot;: False}이 부분은 SQLite에서만 사용하는 구문이라고 한다. SQLite는 각 스레드가 독립적인 요청을 처리할 때 하나의 스레드만 SQLite와 통신을 할 수 있다.이는 다른 스레드들이 동일한 db커넥션을 접근하는 것을 방지하기 위해서이다. 그러나 FastAPI에서는 일반 함수(def)를 사용하면 동일한 요청에 대해 두 개 이상의 스레드가 데이터베이스와 상호작용을 할 수 있으므로 SQLite에서 connect_args={&quot;check_same_thread&quot;: False}를 허용해야 한다. 또한 각 요청이 독립적인 하나만의 db커넥션 세션을 가져야하는것을 보장해야하는데, 그러기에 해당 구문을 안 쓴 default값이 필요하지 않는다고 한다.:{. prompt-info}☑️ 1.5. Create a SessionLocal classSessionLocal클래스 각 인스턴스는 database의 session이 된다고 한다.무슨 말인지 모르겠지만 일단 더 알아보겠다.클래스 자체만으로는 database session이 아니라고 한다.그러나 SessionLocal클래스의 인스턴스를 만들면 그 인스턴스는 database session이 된다.예제에서는 Session이라는 것이 나중에 SQLAlchemy에서 임포트 되므로 이름이 겹치지 않게 SessionLocal이라는 변수로 지었다고 한다.sessionmaker라는 함수를 통해 SessionLocal 클래스를 만들 것이다.위의 코드에서SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)☑️ 1.6. Create a Base classdeclarative_base()라는 함수의 리턴값을 통해 Base를 만들것이다.나중 예제에서 이 클래스를 상속하여 ORM model형태를 가진 데이터베이스 모델이나 클래스로 만들어질 것이라고 합니다.위의 코드에서Base = declarative_base()☑️ 2.1. Create the database modelssql_app/models.py를 작성한다고 한다.Base 클래스를 통해서 SQLAlchemy models을 만들것이다.SQLAlchemy models을 만들려면 Base 클래스가 사용되어야 한다고 한다. SQLAlchemy에서 사용하는 model이라는 단어는 데이터베이스와 연관된 클래스나 인스턴스을 지칭한다.그러나 Pydantic에서 사용하는 model이라는 단어는 data validation, conversion, Swagger에서나 redoc에서 사용하는 클래스나 인스턴스를 말한다.예제에서 작성한 database.py에서 Base를 임포트 하고 그 클래스를 상속받은 클래스를 만들어야한다. 만들어진 클래스는 SQLAlchemy models이 될 것이다.from sqlalchemy import Boolean, Column, ForeignKey, Integer, Stringfrom sqlalchemy.orm import relationshipfrom .database import Baseclass User(Base): __tablename__ = &quot;users&quot; ...class Item(Base): __tablename__ = &quot;items&quot; ...이렇게 Base를 상속받고, 상속받기위해 from .database import Base구문을 작성한걸 볼 수 있다.__tablename__ 속성은 사용하고 있는 데이터베이스의 각 모델에 해당하는 테이블의 이름이고 곧, SQLAlchemy의 형태 값이다.☑️ 2.2. Create model attributes/columnsmodel의 속성값을 만들 것이다.각 속성값들은 데이터베이스 테이블의 컬럼에 해당하는 값들이다.SQLAlchemy의 Column을 통하여 default value를 설정할 수 있다.또한 Integer, String, Boolean같은 “type”을 지정해줄 수 있다. 데이터베이스에서 정의된 타입을 써야한다.from sqlalchemy import Boolean, Column, ForeignKey, Integer, Stringfrom sqlalchemy.orm import relationshipfrom .database import Baseclass User(Base): __tablename__ = &quot;users&quot; #추가된부분 id = Column(Integer, primary_key=True, index=True) email = Column(String, unique=True, index=True) hashed_password = Column(String) is_active = Column(Boolean, default=True)class Item(Base): __tablename__ = &quot;items&quot; #추가된부분 id = Column(Integer, primary_key=True, index=True) title = Column(String, index=True) description = Column(String, index=True) owner_id = Column(Integer, ForeignKey(&quot;users.id&quot;))☑️ 2.3. Create the relationshipsSQlAlchemy ORM을 통해 relationship을 사용할 수 있다.이것을 통해 한 속성과 연관된 다른 테이블들의 속성값들을 포함하게 할 수 있다.from sqlalchemy import Boolean, Column, ForeignKey, Integer, Stringfrom sqlalchemy.orm import relationshipfrom .database import Baseclass User(Base): __tablename__ = &quot;users&quot; id = Column(Integer, primary_key=True, index=True) email = Column(String, unique=True, index=True) hashed_password = Column(String) is_active = Column(Boolean, default=True) #추가된부분 items = relationship(&quot;Item&quot;, back_populates=&quot;owner&quot;)class Item(Base): __tablename__ = &quot;items&quot; id = Column(Integer, primary_key=True, index=True) title = Column(String, index=True) description = Column(String, index=True) owner_id = Column(Integer, ForeignKey(&quot;users.id&quot;)) #추가된부분 owner = relationship(&quot;User&quot;, back_populates=&quot;items&quot;)my_user.items와 라는 구문으로 User가 가지고 있는 items라는 속성값에 접근을 시도할 때, users테이블에 지정된 foreign key를 통해 SQLAlchemy models형태의 Item리스트에 접근합니다.my_user.items라는 구문으로 속성값에 접근하면 SQLAlchemy는 데이터베이스에서 items테이블과 그 테이블의 정보들을 가져와서 값을 채운다.만약 Item에 있는 owner속성에 접근하면, users 테이블에 있는 User라는 SQLAlchemy model을 포함 시키게 된다. foregin key와 owner_id이라는 속성/컬럼을 통해 users테이블에서 가져올 record값을 알 수 있다.2부는 다음에.. 영어 번역 어렵다." }, { "title": "SQL Alchemy[1] - 개요 읽기", "url": "/posts/sqlalchemy01/", "categories": "Python, SQLAlchemy", "tags": "SQLAlchemy", "date": "2022-05-13 03:00:00 +0900", "snippet": " https://docs.sqlalchemy.org/en/14/intro.html 공식문서 따라하는 글SQLAlchemy를 사용하게되는 이유는 앞으로 사이드 프로젝트에서 사용해보자는 이야기가 나와서이다. 비동기로 처리하는 방법을 알아오라고 해서 이것 또한 document를 읽게 되었다.☑️ 개요SQL Toolkit과 Objct Relational Mapper가 Python 의 DataBase환경에서도 잘 작동할 수 있게 도와주는 툴이다.SQL Alchemy는 여러가지 영역이 기능별로 구분되는데, 이 영역들은 개별적으로 사용되거나 혼합하여 사용할 수 있다.SQL Alchemy의 주로 구성되는 요소는 밑의 그림과 같다.SQLAlchemy ORM, SQLAlchemyCore라는 두 영역이 있다.Core는 SQLAlchemy의 SQL의 중요 부분을 포함하고 있다.또한, database 통합과 description services를 제공한다. Core의 가장 중요한 부분은 SQL Expression Language라는 것이다.☑️ SQL Expression Language SQL Expression Language는 ORM패키지에 의존적이지 않아 독립적이고, 컴파일 가능한 객체로 표현되는 SQL표현식을 구성하는 시스템을 제공한다. Inserts, updates 와 delete는 각 문과 함께 사용할 매개 변수를 나타내는 dictionaries와 함께 이러한 문을 나타내는 SQL로 표현된 개체를 전달함으로써 수행된다. database schema에 매핑된 도메일 모델이 동작되기 위해서 ORM은 Core 기반으로 빌드를 하게 된다. ORM을 사용하면 대부분의 경우에는 Core를 사용할때 동일한 방식으로 SQL표현식을 구성한다. 하지만 데이터베이스에 있는 business objects의 영속성을 나타내는 DML은 unit of work라는 패턴을 사용하여 변화 가능한 오브젝트에 대한 변환구문을 자동화한다. unit of work라는 패턴은 가변 객체에 대한 상태 변화를 INSERT, UPDATE, DELETE 구조체로 변환하는데, 그런 다음 사용자의 필요에 의해 호출 되어진다. SELECT문은 ORM의 자동화와 객체중심의 쿼리에 의해 성능이 올라갔다. Core의 SQL Expression Language에 의해 불변성을 중심으로 하는 프로그래밍 패러다임인 스키마 중심의 데이터베이스 뷰를 제공하는 반면, ORM은 객체지향적이고 가변가능한 객체에 대해 효과적인 프로그래밍 패러다임을 가진 도메인 중심의 데이터베이스 뷰를 제공한다. 관계형 데이터베이스는 가변이 가능한 서비스 이다. 때문에 ORM은 상태지향적인것을 처리하니까 Core/SQL Expression Language는 명령지향적으로 처리한다. " }, { "title": "FastAPI 공식문서 따라하기[9] - Body Fields", "url": "/posts/fastapi09/", "categories": "Python, FastAPI", "tags": "FastAPI", "date": "2022-05-13 02:00:00 +0900", "snippet": " https://fastapi.tiangolo.com/ko/ 공식문서 따라하는 글☑️ 1. Body-FieldsPydantic에서 제공하는 Field를 사용할 것이다.지금까지는 FastAPI에서 제공하는 Body, Query, Path를 사용했다.Field를 이용하면 Pydantic의 model 변수선언에 제약조건을 걸 수가 있다.Field를 pydantic에서 import하자.from fastapi import FastAPI,Bodyfrom pydantic import BaseModel, Fieldapp = FastAPI()class Item(BaseModel) : name : str description : str | None = Field( None, title=&quot;The description of the item&quot;,max_length=300 ) price : float = Field(..., gt=0,description=&quot;The price must be greater than zero&quot;) tax: float | None = None@app.put(&quot;/items/{item_id}&quot;)async def update_item(item_id: int, item: Item=Body(...,embed=True)): results = {&quot;item_id&quot;: item_id,&quot;item&quot;:item} return results Item에 선언된 속성들에 제약조건을 달았다. Query,Path 등은 Param이라는 클래스의 오브젝트를 리턴하는데, 이것은 또한 Pydnatic의 FieldInfo의 서브클래스이다. 또한 Field역시 FieldInfo의 인스턴스를 리턴하게 된다.Body의 경우에도 마찬가지로 FieldInfo타입의 서브클래스를 리턴한다. 공식doc에서는 fastapi에서 import하는 Query,Path가 특별한 클래스를 리턴한다는 기능이 있다는걸 알고 있으면 좋겠다고 한다. Field에 있는 기능들은 OpenAPI schema를 만들어내어 해당 docs에서 볼 수 있게 한다. 하지만 몇가지 기능들은 OpenAPI 명세에 포함되지 않을 수 있기에 만들어낸 스키마가 OpenAPI 툴에서 작동하지 않을 수 있다.☑️ 정리 Pydantic의 Field를 이용해 model속성값의 검증을하고 메타데이터를 생성하였다. JSON Schema metadata를 넘길때 예외적으로 발생할 수 있는 상황에 대해서 학습하였다." }, { "title": "FastAPI 공식문서 따라하기[8] - Body Multiple Parameters", "url": "/posts/fastapi08/", "categories": "Python, FastAPI", "tags": "FastAPI", "date": "2022-05-13 01:00:00 +0900", "snippet": " https://fastapi.tiangolo.com/ko/ 공식문서 따라하는 글☑️ 1. Body Multiple ParametersRequestBody값에 Path와 Query를 적용해볼 것이다.다음 예제는 QueryParameter와 PathParameter와 RequestBody를 같이 사용하는 예제다.from fastapi import FastAPI, Pathfrom pydantic import BaseModelapp = FastAPI()class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None@app.put(&quot;/items/{item_id}&quot;)async def update_item( *, item_id: int = Path(..., title=&quot;The ID of the item to get&quot;, ge=0, le=1000), q: str | None = None, item: Item | None = None,): results = {&quot;item_id&quot;: item_id} if q: results.update({&quot;q&quot;: q}) if item: results.update({&quot;item&quot;: item}) return results 위의 코드에서 item는 None을 default value로 받을 수 있다는 것에 주목하자.☑️ 2. Multiple body parameters이번에는 RequestBody에 여러 객체가 들어온다고 가정을 했을때 받아오는지 확인하는 예제이다.from fastapi import FastAPI, Pathfrom pydantic import BaseModelapp = FastAPI()class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = Noneclass User(BaseModel): username: str full_name: str | None = None@app.put(&quot;/items/{item_id}&quot;)async def update_item(item_id : int, item: Item, user:User): results = {&quot;item_id&quot; : item_id} if q: results.update({&quot;q&quot;:q}) if item: results.update({&quot;item&quot;: item}) return results결과Inputresult FastAPI는 자동으로 요청 파라미터값을 검사해서 알맞은 자료형으로 바꿔준다. 이러한 데이터의 유효성 검사를 수행하고 OpenAPI와 같이 문서화한다.☑️ 3. Singular values in body QueryParameter에서는 Query로, PathParameter에서는 Path로 제어했듯이 RequestBody는 Body로 제어한다.from fastapi import Body, FastAPIfrom pydantic import BaseModelapp = FastAPI()class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = Noneclass User(BaseModel): username: str full_name: str | None = None@app.put(&quot;/items/{item_id}&quot;)async def update_item( item_id: int, item: Item, user: User, importance: int = Body(...)): results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item, &quot;user&quot;: user, &quot;importance&quot;: importance} return results importance라는 변수에 Body(...)라는 구문을 줘서 해당 변수가 RequestBody에 포함된 값임을 명시한다. 만약 사용하지 않는다면 QueryParameter로 인지할 것이다. 즉, 해당 구문을 사용하면 data types, validate, document에 대한 정보를 변환한다.☑️ 4. Multiple body params and query추가적으로 Query를 명시하지 않아도 RequestBody와 함께 쓴다면 singular values는 자동으로 QueryParameter로 해석한다는 내용이다.from fastapi import Body, FastAPIfrom pydantic import BaseModelapp = FastAPI()class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = Noneclass User(BaseModel): username: str full_name: str | None = None@app.put(&quot;/items/{item_id}&quot;)async def update_item( *, item_id: int, item: Item, user: User, importance: int = Body(..., gt=0), q: str | None = None): results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item, &quot;user&quot;: user, &quot;importance&quot;: importance} if q: results.update({&quot;q&quot;: q}) return resultsOpenAPI(Swagger)에서 테스트가 가능하다. Body를 보면 gt=0과 같이 추가적인 validation이 가능하다.☑️ 5. Embed a single body parameter만약 RequestBody내에 객체가 하나라면 FastAPI는 따로 key값을 요청하지 않는다.예를 들면from fastapi import Body, FastAPIfrom pydantic import BaseModelapp = FastAPI()class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None@app.put(&quot;/items/{item_id}&quot;)async def update_item(item_id: int, item: Item = Body(...)): results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item} return results이렇게 Item이 하나만 들어온다하면,RequestBody는{ &quot;name&quot;: &quot;Foo&quot;, &quot;description&quot;: &quot;The pretender&quot;, &quot;price&quot;: 42.0, &quot;tax&quot;: 3.2}이렇게 요청을 보내야하지만, 만약 내가 key을 명시한것을 요청으로 받고 싶다면 embed=True구문을 사용하면 된다.from fastapi import Body, FastAPIfrom pydantic import BaseModelapp = FastAPI()class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None@app.put(&quot;/items/{item_id}&quot;)async def update_item(item_id: int, item: Item = Body(..., embed=True)): results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item} return results이렇게 embed=True를 입력하면{ &quot;item&quot;: { &quot;name&quot;: &quot;Foo&quot;, &quot;description&quot;: &quot;The pretender&quot;, &quot;price&quot;: 42.0, &quot;tax&quot;: 3.2 }}이렇게 body를 만들어서 보내야한다. 이렇게 보내지 않으면 error를 발생시킨다.☑️ 정리 경로에 여러 bodyParameter를 선언하는 방법 singular values를 body데이터로 받는 방법 embed를 이용하여 key값으로 요청 받는 방법" }, { "title": "돈 뜨겁게 사랑하고 차갑게 다루어라(앙드레 코스톨라니 저) 독후감", "url": "/posts/book8/", "categories": "Book", "tags": "book", "date": "2022-05-13 01:00:00 +0900", "snippet": "이 책을 알게 된건 음.. 그냥 서점에서 끌렸다.나는 총 2번 독해했고처음 읽을때는 정리하지 않고 2번째 읽었을때 정리를 시작했다.부자가 되는법 3가지 32p 부자와 결혼 유망한 사업 투자 이 글에서는 투자가 제일 쉽다함투자는 과학이 아니라 예술이다​p34때로는 물구나무 서야할때도 있다P56주식시장에 단기 투자자가 많을수록 증권시장은 커지고 유동적이게 된다P66.일부 경제학자들은 눈가리개를 하고 살고, 거시적으로 생각하지도 못하면서 아는 척하는 사람들이다.P88원자재 투자는 사실 그 리스크를 제대로 알고 손실을 감당할 수 있는 노련한 투자자만을 위한 것이다원자재와 전혀 관련없는 투자자라면 원자재 투자에서 행운을 찾으려는 생각을 버리라고 조언하고 싶다P108내가 어리석은 사람들을 좋아해서가 아니라 그들과 정반대로 행동하기 위해서였다P110주식시장은 현재 상황도 앞으로 다가올 미래의 경제 흐름도 보여주지 않는다 그렇다고해서 서로 간의 상호작용 없다는 의미도 아니다P140투자자가 인플레이션을 주의 깊게 살펴봐야한다는 것에는 이론의 여지가 없다.더불어 인플레이션에 대처하는 각 나라 중앙은행의 방안도 예측할 수 있어야한다P154증권시장이 얼마나 민감하게 반응하는지 그 여부는 전부 대중의 ‘심리’에 달려 있다P1574g gold돈 gedanken생각 geduld인내 gluck 운어떠한 상황이라도 빚을 내서 주식을 사는 것은 금물P188유행 뒤에 한 차례의 후퇴는 피할 수 없다P217대중의 히스테리에 휘말리지 않으려면 훈련을 거듭해야 하고 냉정한 것을 넘어 냉소적이어야 한다P240뉴스는 투자자의 도구다P275주가가 1천 퍼센트가 올랐어도 아직 살 가치가 있는 주식이 있고, 80 퍼센트가 하락했음에도 사지 말아야할 주식이 있다2번 읽을 정도로 내용이 정말 알찼다.처음 읽고 이건 정리해야겠다고 생각 들어 정리한 것이므로..말이다." }, { "title": "FastAPI 공식문서 따라하기[7] - Path Parameters and String Validations", "url": "/posts/fastapi07/", "categories": "Python, FastAPI", "tags": "FastAPI", "date": "2022-05-12 01:00:00 +0900", "snippet": " https://fastapi.tiangolo.com/ko/ 공식문서 따라하는 글☑️ 1. Path Parameters and String Validations저번 포스팅에서는 쿼리파라미터로 요청이 들어올때를 봤고 이번 포스트에서는 Path Parameter, 즉 경로 매개변수로 들어올때 처리하는 방법에 대해 포스팅하게 될 것 같다.fastapi에서 Path를 임포트 해야한다.from fastapi import FastAPI, Path, Query#main.pyfrom fastapi import FastAPI, Path, Queryapp = FastAPI()@app.get(&quot;/items/{item_id}&quot;)async def read_items(item_id : int = Path(...,title=&quot;The ID of the item to get&quot;), q: str | None = Query(None,alias=&quot;item-query&quot;),): results = {&quot;item_id&quot; : item_id} if q: results.update({&quot;q&quot; : q}) return results title 메타데이터 값을 PathParameter의 item_id에 선언하였다. PathParameter는 언제나 경로의 일부여야하므로 필수값이다. 때문에 ...을 통해 필수임을 나타내는 것이 좋다. 그럼에도 None으로 선언하거나 기본값을 지정하더라도 아무 영향을 끼치지 않는다. ☑️ 2. Order the parameters as you need필요한 경우에 의해 매개변수를 정렬할 수 있다.파이썬은 default 값을 포함한 매개변수를 선언할때는 순서를 지켜줘야하는데, FastAPI에서는 그 순서를 고려하지 않아도 된다는 것이다.from fastapi import FastAPI, Pathapp = FastAPI()@app.get(&quot;/items/{item_id}&quot;)async def read_items( q: str, item_id: int = Path(..., title=&quot;The ID of the item to get&quot;)): results = {&quot;item_id&quot;: item_id} if q: results.update({&quot;q&quot;: q}) return results☑️ 3. Number validations: greater than or equalQuery와Path를 사용하여 제약조건을 걸 수가 있다.item_id에 1과 같거나 커야한다라는 제약조건을 걸어보는 예제다.from fastapi import FastAPI, Pathapp = FastAPI()@app.get(&quot;/items/{item_id}&quot;)async def read_items( *, item_id: int = Path(..., title=&quot;The ID of the item to get&quot;, ge=1), q: str): results = {&quot;item_id&quot;: item_id} if q: results.update({&quot;q&quot;: q}) return results OpenAPI docs에서도 확인할 수 있다. ge : greater than or equal다음은 0보다 크고 1000보다 작거나 같다라는 제약조건을 거는 예제다.from fastapi import FastAPI, Pathapp = FastAPI()@app.get(&quot;/items/{item_id}&quot;)async def read_items( *, item_id: int = Path(..., title=&quot;The ID of the item to get&quot;, gt=5, le=1000), q: str,): results = {&quot;item_id&quot;: item_id} if q: results.update({&quot;q&quot;: q}) return results gt : greater than le : less than or equal다음은 Query문을 이용하여 float자료형에 10.5보다 작다는 제약조건을 거는 예제다.from fastapi import FastAPI, Path, Queryapp = FastAPI()@app.get(&quot;/items/{item_id}&quot;)async def read_items( *, item_id: int = Path(..., title=&quot;The ID of the item to get&quot;, ge=0, le=1000), q: str, size: float = Query(..., gt=0, lt=10.5)): results = {&quot;item_id&quot;: item_id} if q: results.update({&quot;q&quot;: q}) return results어려운 내용은 아니니 설명은 하지 않는다." }, { "title": "FastAPI 공식문서 따라하기[6] - Query Parameters and String Validations", "url": "/posts/fastapi06/", "categories": "Python, FastAPI", "tags": "FastAPI", "date": "2022-05-11 06:00:00 +0900", "snippet": " https://fastapi.tiangolo.com/ko/ 공식문서 따라하는 글☑️ 1. Query Parameters and String ValidationsFastAPI는 파라미터에 유효성 검사나 추가적인 정보를 추가할 수 있다.from typing import Optionalfrom fastapi import FastAPIapp = FastAPI()@app.get(&quot;/items/&quot;)async def read_items(q: Optional[str] = None) : results = {&quot;items&quot;: [{&quot;item_id&quot; : &quot;kms&quot;}, {&quot;item_id&quot; : &quot;jyb&quot;}]} if q: results.update({&quot;q&quot;:q}) return resultsquery parameter인 q는 Optional[str] = None을 주어서 q의 타입은 str이거나 None으로 지정할 수 있게 하였다. 값이 없을경우 None이 되고 FastAPI는 이 값이 필수값이 아닌것을 알 수 있게 된다.☑️ 2. Additional validation 글자수를 제한 할 수 있다.먼저 Query를 Import해야 한다.from typing import Optionalfrom fastapi import FastAPI, Queryapp = FastAPI()@app.get(&quot;/items/&quot;)async def read_items(q: Optional[str] = Query(None, max_length=50)) : results = {&quot;items&quot; : [{&quot;item_id&quot;: &quot;kms&quot;},{&quot;item_id&quot; : &quot;jyb&quot;}]} if q : results.update({&quot;q&quot; : q}) return results50자를 넘겼을 경우 Query의 첫 번째 파라미터인 Query(None)을 통하여 default value를 지정해줄 수 있다.즉q: Optional[str] = Query(None) 와q: Optional[str] = None은 같은 기능을 수행합니다. Query의 두 번째 파라미터인 max_length는 문자열에 적용된다. 만약 문자열이 아니라면 오류를 냅니다.☑️ 3. Add reuglar expressions 파라미터에 정규 표현식을 사용할 수 있다.from typing import Optionalfrom fastapi import FastAPI, Queryapp = FastAPI()@app.get(&quot;/items/&quot;)async def read_items( q: Optional[str] = Query(None,min_length=3,max_length=50, regex=&quot;^fixedquery$&quot;)): results = {&quot;items&quot; : [{&quot;item_id&quot; : &quot;Kms&quot;}, {&quot;item_id&quot; : &quot;Bar&quot;}]} if q: results.update({&quot;q&quot; : q}) return results정규표현식^와 $에 의하여 query parameter는 fixedquery라는 고정된 값이 들어오거나 None이어야한다. ^ : 무조건 ^다음에 단어로 시작해야한다. ^앞에 단어가 있으면 안 된다. $ : 문자열의 끝을 알리기에, $다음에 문자가 나오면 안된다.즉 들어와야할 q는 fixedquery라는 문자열만 가능하다는 것이다.문서에서는 정규표현식을 몰라도 되고, 혹여 나중에 공부를 한다면 FastAPI에서는 이미 정규표현식을 지원을하고 있음을 알리고 있다.☑️ 4. Default values여태까지는 None으로 Default값을 설정하였지만, 다른 값으로도 설정이 가능하다는 것이다.query parameter로 들어오는 값은 최소 3글자 이상이어야하고, 값이 들어오지 않는다면 MyProjectIsDia로 바꿔보겠다.from fastapi import FastAPI, Queryapp = FastAPI()@app.get(&quot;/items/&quot;)async def read_items(q: str = Query(&quot;MyProjectIsDia&quot;,min_length=3)) : results = {&quot;items&quot; : [{&quot;item_id&quot;: &quot;Kms&quot;}, {&quot;item_id&quot;: &quot;Test&quot;}]} if q: results.update({&quot;q&quot; : q}) return results Default value:MyProjectIsDia로 지정되어 있는걸 확인할 수 있다.☑️ 5. Make it required Query Parameter를 필수값으로 받게 할 수 있다.물론 q: str을 통해 필수값으로 바꿀 수 있었지만, Query를 통해서 바꾸려면 어떻게 해야할까? 그것은 바로 첫 파라미터에 ...을 넣으면 된다.from fastapi import FastAPI, Queryapp = FastAPI()@app.get(&quot;/items/&quot;)async def read_items(q: str = Query(...,min_length=3)) : results = {&quot;items&quot; : [{&quot;item_id&quot;: &quot;Kms&quot;}, {&quot;item_id&quot;: &quot;Test&quot;}]} if q: results.update({&quot;q&quot; : q}) return results requried가 붙고 minLength:3도 붙은걸 볼 수 있다.☑️ 6. Query parameter list/ multiple values list도 Query Parameter로 지원합니다.from fastapi import FastAPI, Queryapp = FastAPI()@app.get(&quot;/items/&quot;)async def read_items(q: list[str] | None = Query(None)): query_items = {&quot;q&quot;: q} return query_itemshttp://127.0.0.1:8000/items/?q=test&amp;amp;q=kms이렇게 테스트할 수 있다.결과{&quot;q&quot;:[&quot;test&quot;,&quot;kms&quot;]} 만약 list타입으로 QueryParameter를 선언하면 python 코드에서는 Query를 명시적으로 달아줘야합니다. 그러지 않으면 FastAPI requestbody로 해석합니다.List의 Default값을 설정하려면?async def read_items(q: list[str] = Query([&quot;test&quot;,&quot;kms&quot;])):이렇게 해주면 된다.결과http://127.0.0.1:8000/items/{&quot;q&quot;:[&quot;test&quot;,&quot;kms&quot;]}async def read_items(q:list = Query([])):이렇게 선언도 가능하다. 하지만 자료형을 명시해주지 않았다.확인해보니 str형으로 받긴 하는데☑️ 7. Declare more metadata 추가적으로 쿼리파라미터를 조작할 수 있다title과 description사용 예제from fastapi import FastAPI, Queryapp = FastAPI()@app.get(&quot;/items/&quot;)async def read_items( q: str | None = Query( None, title=&quot;Query string&quot;, description=&quot;Query string for the items to search in the database that have a good match&quot;, min_length=3, )): results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]} if q: results.update({&quot;q&quot;: q}) return results공식문서에서는 다음과 같이 얘기한다. title : 사용 API의 이름 description : 사용 API의 설명☑️ 8. Alias parameters만약 item-query를 parameter로 받고 싶은 경우가 있을 수 있다.하지만 python에서는 -이 포함된 변수이름을 지원하지 않고 item_query로 대체해야한다.그래도 item-query로 사용하고 싶다면 alias를 사용하면 된다.from fastapi import FastAPI, Queryapp = FastAPI()@app.get(&quot;/items/&quot;)async def read_items(q: str | None = Query(None, alias=&quot;item-query&quot;)): results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]} if q: results.update({&quot;q&quot;: q}) return results또한 deprecated=True와 같은 값을 파라미터로 넘겨주면, OpenAPI docs에서 deprecated를 명시해줄 수 있다.요청을 보내면 가므로 docs관리용☑️ 9. Exclude from OpenAPIfrom fastapi import FastAPI, Queryapp = FastAPI()@app.get(&quot;/items/&quot;)async def read_items(hidden_query: str | None = Query(None, include_in_schema=False)): if hidden_query: return {&quot;hidden_query&quot;: hidden_query} else: return {&quot;hidden_query&quot;: &quot;Not found&quot;}이렇게 include_in_schema=False옵션을 주면 OpenAPI docs에서 해당 파라미터를 제외할 수 있다.docs에서만 제외되므로 실제 요청은 간다.http://localhost:8000/items/?hidden_query=hi결과" }, { "title": "FastAPI 공식문서 따라하기[5] - Request Body", "url": "/posts/fastsapi05/", "categories": "Python, FastAPI", "tags": "FastAPI", "date": "2022-05-11 05:00:00 +0900", "snippet": " https://fastapi.tiangolo.com/ko/ 공식문서 따라하는 글☑️ 1. Request Body client가 server쪽으로 보내는 데이터를 requestbody라고 한다. responsebody는 server가 client쪽으로 보내는 데이터를 말한다. request body는 Pydantic이 가지고 있는 혜택을 통해 더 유연하게 동작할 수 있다. 데이터를 보낼땐 GET 을 쓰지 않는것이 좋습니다. GET을 조회용으로만 쓰는것이 HTTP 명세입니다.☑️ 2. Import Pydantic’s BaseModelfrom typing import Optionalfrom fastapi import FastAPIfrom pydantic import BaseModelclass Item(BaseModel): name: str description: Optional[str] = None price: float tax: Optional[float] = Noneapp = FastAPI()@app.post(&quot;/items/&quot;)async def create_item(item: Item): return itemItem라고 선언한 클래스는 BaseModel에 의해 상속받고 있다. None이라고 초기값을 준 것은 필수로 받아야하는 값이 아니다. 그러나 None을 명시하지 않으면 그 값은 필수로 받아야한다.즉 다음과 같은 데이터도 허용한다는 것이다.{ &quot;name&quot; : &quot;kms&quot; &quot;price&quot; : 45.2} description 속성과 tax속성에는 아무값도 주지 않아도 된다는 것이다.☑️ 3. 결과FastAPI는 다음과 같이 프로세스를 진행한다. request에서 JSON으로 데이터를 읽는다, 데이터의 형식에 맞게 타입을 변환한다.(필요시) 데이터를 검증한다 만약 데이터가 유효하지 않다면 clear error를 리턴하며 정확히 어떤 데이터가 문제인지 명시해준다 파라미터에 있는 item을 받아 온다. 만약 Item의 매개변수들을 선언하였다면, 편집기에서 자동완성 기능을 사용할 수 있다. 프로그래머가 작성한 클래스 모델에 맞춰 JSON Schema를 만들어 낸다. 이 schemas는 생성된 OpenAPI schema의 일부가 되고, Swagger와 같은 자동완성 문서에 사용된다.☑️ 4. Model 활용법정의한 클래스의 속성값에 맞게 접근 할 수 있다.from typing import Optionalfrom fastapi import FastAPIfrom pydantic import BaseModelclass Item(BaseModel): name: str description: Optional[str] = None price: float tax: Optional[float] = Noneapp = FastAPI()@app.post(&quot;/items/&quot;)async def create_item(item: Item): #이부분 item_dict = item.dict() if item.tax: price_with_tax = item.price * item.tax item_dict.update({&quot;item price with tax : &quot; : price_with_tax}) return item_dict☑️ 5. Request Body + path parameterrequest body와 path parameter를 같이 사용할 수 있다.FastAPI를 사용할때 path parameter는 경로에서 받아야하고 model을 받을때는 request body에서 받아야합니다.from typing import Optionalfrom fastapi import FastAPIfrom pydantic import BaseModelclass Item(BaseModel): name: str description: Optional[str] = None price: float tax: Optional[float] = Noneapp = FastAPI()@app.put(&quot;/items/{item_id}&quot;)async def create_item(item_id: int, item: Item): return {&quot;item_id&quot;: item_id, **item.dict()}결과Swagger에서 테스트 진행.#curlcurl -X &#39;PUT&#39; \\ &#39;http://localhost:8000/items/5&#39; \\ -H &#39;accept: application/json&#39; \\ -H &#39;Content-Type: application/json&#39; \\ -d &#39;{ &quot;name&quot;: &quot;string&quot;, &quot;description&quot;: &quot;string&quot;, &quot;price&quot;: 0, &quot;tax&quot;: 0}&#39;{ &quot;item_id&quot;: 5, &quot;name&quot;: &quot;string&quot;, &quot;description&quot;: &quot;string&quot;, &quot;price&quot;: 0, &quot;tax&quot;: 0}☑️ 6. Request Body + path parameter + query parameters세 가지를 짬뽕하면 어떻게 해야할까from typing import Optionalfrom fastapi import FastAPIfrom pydantic import BaseModelclass Item(BaseModel): name: str description: Optional[str] = None price: float tax: Optional[float] = Noneapp = FastAPI()@app.put(&quot;/items/{item_id}&quot;)async def create_item(item_id: int, item: Item, q: Optional[str] = None) : result = {&quot;item_id&quot; : item_id,**item.dict()} if q: result.update({&quot;q&quot; : q}) return resultFastAPI는 놀랍게도 이 모든것을 정확하게 인지하고 데이터를 넣어준다.어떻게 하는걸까? 만약 경로에 파라미터가 선언되어있다면 이는 path parameter로 인지한다. 만약 sigular type(int,float등..)타입이면 query parameter로 인지한다. 만약 Pydantic model타입으로 파라미터가 선언되어 있으면 이는 request body로 인지한다.Pydantic model을 사용하지 않는다면 Body Parametes에 넣는 방법도 있다.https://fastapi.tiangolo.com/ko/tutorial/body-multiple-params/#singular-values-in-body" }, { "title": "FastAPI 공식문서 따라하기[4] - 쿼리 매개변수", "url": "/posts/fastapi04/", "categories": "Python, FastAPI", "tags": "FastAPI", "date": "2022-05-11 04:00:00 +0900", "snippet": " https://fastapi.tiangolo.com/ko/ 공식문서 따라하는 글☑️ 1. 쿼리 매개변수기본적으로 함수에 매개변수를 선언할 때에 query param으로 인식하여 처리한다.예제from fastapi import FastAPIquery_param_app = FastAPI()dia_bemember_db = [{&quot;name&quot; : &quot;ksw&quot;}, {&quot;name&quot; : &quot;gg&quot;},{&quot;name&quot; : &quot;kms&quot;},{&quot;name:&quot; : &quot;wj&quot;}]@query_param_app.get(&quot;/members/&quot;)async def read_mem(skip: int = 0, limit: int = 10): return dia_bemember_db[skip : skip + limit]이 예제에서 ‘default’값인http://127.0.0.1:8000/members는http://127.0.0.1:8000/members/?skip=0&amp;amp;limit=10와 같은 파라미터로 처리되어 들어간다. 쿼리파라미터에 대해 다루지는 않겠지만.. 살짝 적자면 &amp;amp;을 구분자로 ?을 통해 다음 문구가 쿼리파라미터라는 것을 알려준다.FastAPI는 다음과 같은 프로세스를 수행한다. 편집기 자동완성 데이터 파싱 데이터 검증 자동 문서화 -&amp;gt; Swagger, ReDoc☑️ 2. 기본 값기본값은 Request QueryParam 관한 내용이므로 자세히 다루지 않겠다.http://127.0.0.1:8000/members/ =&amp;gt; 1.skip, limit값은?http://127.0.0.1:8000/members/?skip=0&amp;amp;limit=2 =&amp;gt; skip, limit값은?http://127.0.0.1:8000/members/?skip=20 =&amp;gt; skip, limit값은? 1 : skip=0, limit=10 2 : skip=0, limit=2 3 : skip=20, limit=10이유를 모르겠다면 QueryParam에 대해 학습이 필요하다.☑️ 3. 선택적 매개변수Optional을 통해 매개변수 필수값 여부를 설정해줄 수 있다.예제from typing import Optionalfrom fastapi import FastAPIquery_param_app = FastAPI()@query_param_app.get(&quot;/members/{member_name}&quot;)async def read_memone(member_name: str, member_age : Optional[int] = None) : if(member_age) : return{&quot;name&quot; : member_name, &quot;age : &quot; : member_age} return {&quot;name&quot; : member_name}실행http://127.0.0.1:8000/members/kms?member_age=25http://127.0.0.1:8000/members/kms여기서 member_age가 Optional = None으로 지정되어, 필수값이 아니기에 둘다 요청에 성공한다.만약 Optional[int]로만 지정하고 http://127.0.0.1:8000/members/kms에 접근한다면?결과member_age값도 입력하라고 나온다.☑️ 4. 쿼리 매개변수 형변환bool타입은 어떻게 처리할까?from typing import Optionalfrom fastapi import FastAPIquery_param_app = FastAPI()@query_param_app.get(&quot;/members/{member_name}&quot;)async def read_membool(member_name: str, query: Optional[str] = None, iskms: bool = False): name = {&quot;member_name&quot;: member_name} if query: name.update({&quot;query&quot;: query}) if not iskms: name.update( {&quot;description&quot;: &quot;iskms is false how are you?&quot;} ) return name http://127.0.0.1:8000/members/kms?iskms=1 http://127.0.0.1:8000/members/kms?iskms=True http://127.0.0.1:8000/members/kms?iskms=true http://127.0.0.1:8000/members/kms?iskms=on http://127.0.0.1:8000/members/kms?iskms=yes http://127.0.0.1:8000/members/kms?iskms=y전부 True처리 한다. 참고로 .update()는 해당 객체 뒤에 내용을 추가합니다.☑️ 5. 여러 경로/쿼리 매개변수여러 경로 매개변수와 쿼리 매개변수를 동시에 선언할 경우 FastAPI는 이를 감지한다. 매개변수 이름으로 감지한다.@query_param_app.get(&quot;/members/{member_name}/items/{item_id}&quot;)async def read_membool(member_name: str,item_id: str, query: Optional[str] = None, iskms: bool = False): name = {&quot;member_name&quot;: member_name, &quot;have item_id &quot; : item_id} if query: name.update({&quot;query&quot;: query}) if not iskms: name.update( {&quot;description&quot;: &quot;iskms is false how are you?&quot;} ) return name실행http://127.0.0.1:8000/members/kms/items/345?iskms=true결과☑️ 6. 여러 경로/쿼리 매개변수쿼리 매개변수도 필수값으로 지정할 수 있다는 것.from typing import Optionalfrom fastapi import FastAPIquery_param_app = FastAPI()@query_param_app.get(&quot;/members/{member_name}&quot;)async def read_member(member_name : str, iskms : bool): member = {&quot;name&quot; : member_name, &quot;iskms?&quot; : iskms} return member성공한 테스트http://127.0.0.1:8000/members/kms?iskms=y실패한 테스트http://127.0.0.1:8000/members/kms이 경우는 필수 값인 iskms를 매개변수로 넣지 않았으므로{&quot;detail&quot;:[{&quot;loc&quot;:[&quot;query&quot;,&quot;iskms&quot;],&quot;msg&quot;:&quot;field required&quot;,&quot;type&quot;:&quot;value_error.missing&quot;}]}라는 메세지를 볼 수 있다." }, { "title": "FastAPI 공식문서 따라하기[3] - 경로 매개변수", "url": "/posts/fastapi03/", "categories": "Python, FastAPI", "tags": "FastAPI", "date": "2022-05-11 03:00:00 +0900", "snippet": " https://fastapi.tiangolo.com/ko/ 공식문서 따라하는 글☑️ 1. 경로 매개변수 매개변수를 경로안에 선언할 수 있다. SpringMVC와 비슷한 문법#main.pyfrom fastapi import FastAPIkmsapp = FastAPI()@kmsapp.get(&quot;/computers/{computer_id}&quot;)async def read_com(computer_id) : return {&quot;computer_id : &quot; : computer_id}실행uvicorn main:kmsapp --reloadhttp://127.0.0.1:8000/computers/123결과☑️ 2. 타입이 있는 매개변수 타입을 선언할 수 있다.from fastapi import FastAPIkmsapp = FastAPI()@kmsapp.get(&quot;/computers/{computer_id}&quot;)#바뀐 부분async def read_com(computer_id : int) : return {&quot;computer_id : &quot; : computer_id}computer_id는 int로 선언이 되었다. 여기서 문자열로 입력할 시 FastAPI가 타입을 검증하여 에러를 리턴한다.결과http://127.0.0.1:8000/computers/4 1번과 달리 &quot;4&quot;가 아닌 4로 되어있는걸 확인할 수 있다.만약 파라미터로 4.2를 넘기면http://127.0.0.1:8000/computers/4.2{&quot;detail&quot;:[{&quot;loc&quot;:[&quot;path&quot;,&quot;computer_id&quot;],&quot;msg&quot;:&quot;value is not a valid integer&quot;,&quot;type&quot;:&quot;type_error.integer&quot;}]}메시지를 볼 수 있다.☑️ 3. Pydantic 모든 데이터 검증은 Pydantic에서 내부적으로 수행한다.순서 문제만약 /computers/kmscom이라는 경로와 /computers/{computer_name}이라는 경로가 있다면 뭐부터 선언해야할까?당연할 수 있지만 상세히 명시한 /computers/kmscom을 먼저 선언해야한다. 그렇지 않으면 computers/{computer_name}에 kmscom이 매핑이 될 것이다.예제첫 상황from fastapi import FastAPIkmsapp = FastAPI()@kmsapp.get(&quot;/computers/kmscom&quot;)async def read_comkms(): return {&quot;kmscomputer&quot;}@kmsapp.get(&quot;/computers/{computer_name}&quot;)async def read_com(computer_name : str) : return {&quot;computer_name : &quot; : computer_name}확인http://127.0.0.1:8000/computers/kmscom결과두번째 상황from fastapi import FastAPIkmsapp = FastAPI()@kmsapp.get(&quot;/computers/{computer_name}&quot;)async def read_com(computer_name : str) : return {&quot;computer_name : &quot; : computer_name}@kmsapp.get(&quot;/computers/kmscom&quot;)async def read_comkms(): return {&quot;kmscomputer&quot;}확인http://127.0.0.1:8000/computers/kmscom결과☑️ 4. 사전정의 값 Enum을 사용할 수 있다.from enum import Enumfrom fastapi import FastAPIkmsapp = FastAPI()class Animal(str, Enum): cat = &quot;cat&quot; dog = &quot;dog&quot; lion = &quot;lion&quot; tiger = &quot;tiger&quot;@kmsapp.get(&quot;/animals/{animal_name}&quot;)async def getanimal(animal : Animal): #열거형 멤버비교 if animal == Animal.cat : return {&quot;animal_name &quot; : animal, &quot;type&quot; : &quot;goyang-i&quot;} #열거형 값 가져오기 if animal.value == &quot;dog&quot; : return {&quot;animal_name &quot; : animal, &quot;type&quot; : &quot;gae&quot;} #열거형 멤버 반환 return {&quot;animal_name&quot; : animal, &quot;type&quot; : &quot;tiger | lion&quot;} Enum은 python 3.4이후로 사용이 가능하다.if문에 비교 대상들을 어떻게 지정하고 있는지 봐야한다.Swagger에서 테스트 하면 된다. 이런Enum 보는것도 지원한다니..&amp;lt;localhost:8000/docs&amp;gt;결과 Animal.cat.value로도 접근이 가능하다.☑️ 5. 파일 경로를 포함하는 경우Starlette에서 제공하는 옵션을 사용하면 path를 포함하는 경로 매개변수를 선언 할 수 있다./files/{file_path:path}예제from fastapi import FastAPIkmsapp = FastAPI()@kmsapp.get(&quot;/files/{file_path:path}&quot;)async def read_file(file_path: str): return {&quot;file_path&quot;: file_path}명시적으로 알려주는 것이다. 왜냐하면 저렇게 명시하지 않는다면 JSON으로 값을 받아올텐데, 명시한다면 Form Data로 받아오기 때문이다." }, { "title": "FastAPI 공식문서 따라하기[2] - 첫걸음", "url": "/posts/fastapi02/", "categories": "Python, FastAPI", "tags": "FastAPI", "date": "2022-05-11 02:00:00 +0900", "snippet": " https://fastapi.tiangolo.com/ko/ 공식문서 따라하는 글☑️ 1. 기초# main.pyfrom fastapi import FastAPIapp = FastAPI()@app.get(&quot;/&quot;)def read_root() : return {&quot;Im&quot; : &quot;kms first_step!!&quot;}$ uvicorn main:app --reload이전 포스트에서 설명했으므로 설명은 스킵☑️ 2. OpenAPIFastAPI는 API를 정의하기 위한 OpenAPI 표준을 이용해 스키마를 생성. API스키마 : API경로, 가능한 매개변수 등을 포함. Data스키마 : JSon처럼 어떤 데이터의 형태http://127.0.0.1:8000/openapi.json 을 통해 스키마를 확인할 수 있다.☑️ 3. 리뷰위의 코드# main.py1 from fastapi import FastAPI2 app = FastAPI()3 @app.get(&quot;/&quot;)4 def read_root() :5 return {&quot;Im&quot; : &quot;kms first_step!!&quot;}를 기준으로 한줄 한줄 설명 합니다. 1 FastAPI import : FastAPI는 Starlette를 직접 상속하는 클래스로, Starlette의 모든 기능을 사용할 수 있다. 2 FastAPI Instance 생성 : 만약 app = FastAPI()를 mytestapp = FastAPI()로 바꾼다면uvicorn main:app --reload #에서uvicorn main:mytestapp --reload로 바꿔 써야한다. 3 경로 : (Post, Get, Put, Delete …) 여기에 쓰인 @app.get(&quot;/&quot;)처럼 @가 달린것을 데코레이터라고 불림. @app.post(), @app.put(), @app.delete, @app.option(), @app.head(), @app.patch(), @app.trace() 등 지원. 4 경로 동작 함수 정의 : 경로 : ‘/’ 동작 : ‘get’ 함수 : @app.get(&quot;/&quot;) 아래에 있는 기능들. async 사용가능. 5 콘텐츠 반환 : dict, list, str 등.. 반환 가능. " }, { "title": "FastAPI 공식문서 따라하기[1] - FastAPI", "url": "/posts/fastapi01/", "categories": "Python, FastAPI", "tags": "FastAPI", "date": "2022-05-11 01:00:00 +0900", "snippet": " https://fastapi.tiangolo.com/ko/ 공식문서 따라하는 글1. FastAPI의 특징 빠르다. 개발속도 증가 버그가 적다. 자동완성 기능, 적은 디버깅 시간, 직관적 쉽다 코드 중복을 최소화시켜 짧다. 견고하다. 표준기반2. 요구사항 Python3.6+ Starlette, Pydantic필요설치pip install fastapi# 프러덕션을 위해pip install uvicorn[standard] #orpip install uvicorn3. 예제#main.pyfrom typing import Optionalfrom fastapi import FastAPIapp = FastAPI()@app.get(&quot;/&quot;)def read_root() : return {&quot;Im&quot; : &quot;KMS!!&quot;}@app.get(&quot;/user/{user_id}&quot;)def read_item(user_id : int, name: Optional[str] = None) : return { &quot;user_id &quot; : user_id,&quot;name&quot; : name}실행하기uvicorn main:app --reload&amp;gt;INFO: Will watch for changes in these directories: [&#39;/Users/kms/Code/Python/fastapi_doc&#39;]INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)INFO: Started reloader process [25857] using statreloadINFO: Started server process [25859]INFO: Waiting for application startup.INFO: Application startup complete. main : main.py 파일 (파이썬 ‘모듈’) app : app = FastAPI()한 app오브젝트 . --reload : 코드가 변경된후 서버 재시작하기. 개발환경에서만 권장확인하기http://127.0.0.1:8000http://127.0.0.1:8000/user/95?name=kms4. Swagger UI 확인http://127.0.0.1:8000/docs5. ReDoc UI 확인http://127.0.0.1:8000/redoc6. 심화과정from typing import Optionalfrom fastapi import FastAPIfrom pydantic import BaseModelapp = FastAPI()class User(BaseModel) : age : int name : str kms : Optional[bool] = None@app.get(&quot;/&quot;)def read_root() : return {&quot;Im&quot; : &quot;KMS!!&quot;}@app.get(&quot;/user/{user_id}&quot;)def read_item(user_id : int, name: Optional[str] = None) : return { &quot;user_id &quot; : user_id,&quot;name&quot; : name}@app.put(&quot;/users/{user_id}&quot;)def update_user(user_id : int, user: User) : return{&quot;user_name&quot;: user.name, &quot;user_id : &quot;: user_id}확인하기http://127.0.0.1:8000/docs에서 나같은 경우는 user_id 는 1로 age는 28로 name은 kms kms는 true값을 줬다. 나는 kms니까결과http://127.0.0.1:8000/redoc에서도 확인할 수 있다.7. 결론age : int 선언하나로 자동완성, 타입검사 기능을 얻을 수 있다. 자동완성이란 vscode같은곳에서 변수명을 쓸 때 자동으로 입력하게끔 도와주는 것을 말한다. 타입검사란 int형인지 타입이 제대로 들어맞는지 검사. 데이터 검증 데이터가 유효하지 않을때 자동으로 생성하는 에러 JSON객체 유효성 검사 검증 방식은 형식에 맞지 않는 데이터를 넣는것으로 확인 가능 입력 데이터 반환 JSON, 쿼리 매개변수, 경로 매개변수,Cookie,Header,Form,File형태의 자료를 읽을 수 있다고 한다. 출력 데이터 반환 Python Type(str, int, float, bool, list 등), datetime, UUID객체, DataBaseModel … 등 반환 JSON형식으로 반환 가능. Swagger UI, Redoc지원8. 리뷰코드 분석을 하는데 GET 및 PUT 요청에 user_id가 경로에 있는지 검증. GET 및 PUT 요청에 user_id가 int 타입인지 검증. 그렇지 않다면 클라이언트는 에러를 볼 수 있다. GET 요청에 name이라는 선택적인 쿼리 매개변수가 검사(http://127.0.0.1:8000/user/95?name=kms처럼). name 매개변수는 = None으로 선언되었기 때문에 선택사항입니다. None이 없다면 필수사항입니다(PUT의 경우와 마찬가지로). /user/{user_id}으로의 PUT 요청은 본문을 JSON으로 읽음: age을 필수 속성으로 갖고 int 형인지 검사. name을 필수 속성으로 갖고 str 형인지 검사. 만약 주어진다면, kms를 선택 속성으로 갖고 bool 형인지 검사. JSON을 변환하거나 JSON으로 변환하는 것을 자동화. 다음에서 사용할 수 있는 모든 것을 OpenAPI로 문서화: 2개의 대화형 문서 웹 인터페이스를 직접 제공.(Swagger, ReDoc)" }, { "title": "시작하세요! 도커/쿠버네티스(2) - 도커엔진(1)", "url": "/posts/DocekrStart02/", "categories": "Docker, CS", "tags": "Docker", "date": "2022-05-09 02:00:00 +0900", "snippet": " 시작하세요! 도커/쿠버네티스 책 정리글입니다.2. 도커 이미지와 컨테이너도커의 이미지와 컨테이너는 도커 엔진의 핵심.2.1 도커 이미지이미지는 기존 가상머신에서 사용한 iso파일과 비슷한데, 컨테이너를 생성하고 실행할 때 읽기 전용으로 사용 된다.이미지의 양식은 다음과 같습니다.[저장소 이름]/[이미지 이름]:[태그]로 구성되어 있습니다.kms/ubuntu:14.04또는ubuntu:latest 저장소 이름(Repository) : 이미지가 저장된 장소. 이미지 생성시 저장소 이름을 명시할 필요가 없으므로 생략하는 경우가 있습니다. 이미지 이름 : 해당 이미지가 어떤 역할을 하는지 나타냄. 반드시 설정해야 합니다. 태그 : 이미지의 버전 관리, 혹은 리버전(Revision) 관리에 사용 합니다.2.1.2 도커 컨테이너도커의 이미지는 OS, MySQL같은 DB애플리케이션, 하둡, 스파크 등 다양한 것들이 존재합니다.이러한 이미지로 컨테이너를 생성하면 해당 이미지의 목적에 맞는 파일이 들어 있는 파일시스템과 격리된 시스템 자원 및 네트워크를 사용할 수 있는 독립된 공간이 생성되고, 이를 도커 컨테이너라고 부릅니다.컨테이너는 이미지를 읽기 전용으로 사용하되 이미지에서 변경 사항은 컨테이너 계층에서 저장하므로 컨테이너에서 무엇을 하든지 원래 이미지에 영향을 주지 않습니다. 컨테이너는 각 독립된 파일시스템을 제공 받으며 호스트와 분리돼 있어서 어떤 애플리케이션을 설치하거나 삭제해도 다른 컨테이너와 호스트 변화가 없습니다.즉 리눅스 도커 이미지로 두 개의 컨테이너를 생성한 뒤 A 컨테이너에 MySql을, B 컨테이너에 톰캣을 설치해도 각 컨테이너는 영향을 주지 않을뿐더러 호스트에도 영향을 주지 있지 않습니다.2.2 도커 컨테이너 다루기도커 버전을 확인.docker -v&amp;gt; Docker version 20.10.14, build a224086첫 번째 컨테이너를 생성합니다.docker run -i -t ubuntu:14.04 -i, -t 옵션은 컨테이너와 상호(interactive) 입출력을 가능하게 합니다. -i는 상호 입출력, -t는 tty를 활성화해서 배시(bash)셸을 사용하도록 컨테이너를 설정합니다.와 같이 shell에 변화가 있다면 됩니다. 기본 사용자는 root이고 호스트 이름은 무작위 16진수 해시값입니다. 컨테이너를 종료할때 exit나 Ctrl + D를 쓰지만 이는 컨테이너를 중지시켜버립니다. Ctrl + P, Q를 이용하면 컨테이너는 살리고 빠져나오므로 개발시에는 해당 커맨드를 애용합시다.centos:7 이미지를 내려 받기 연습.docker pull centos:7&amp;gt; 7: Pulling from library/centos6717b8ec66cd: Pull complete Digest: sha256:c73f515d06b0fa07bb18d8202035e739a494ce760aa73129f60f4bf2bd22b407Status: Downloaded newer image for centos:7docker.io/library/centos:7docker images를 통해 존재 확인.docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEcentos 7 c9a1fdca3387 2 months ago 301MBubuntu 14.04 7304c635fe52 6 months ago 187MBdocker create를 통해 이미지로 컨테이너 생성docker create -i -t --name kmsCentos centos:7&amp;gt; 233ab6341d888ceab9ee04296c8fb70858bfae8547cbaa0f78a9d4b5391453d2 --name옵션을 통해 컨테이너의 이름을 설정할 수 있습니다. 저같은 경우는 ‘kmsCentos’로 지었습니다.create 명령어는 컨테이너를 생성할 뿐 내부로 들어가지는 않습니다.docker start, docker attach를 통해 컨테이너를 시작하고 내부로 들어가야 합니다.% docker start kmsCentos&amp;gt; kmsCentos% docker attach kmsCentos[root@233ab6341d88 /]# docker run 명령어는 컨테이너를 생성함과 동시에 시작하기에 더 자주 사용 됩니다.2.2.2 컨테이너 목록 확인docker pskms@kmsui-MacBookPro tomcat_exam % docker ps&amp;gt; CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES233ab6341d88 centos:7 &quot;/bin/bash&quot; 8 minutes ago Up 6 minutes kmsCentos정지되지 않은 컨테이너만 출력하기에 Ctrl + P, Q로 입력해 빠져나온 kmsCentos컨테이너는 목록에 찍히게 됩니다. -a옵션을 통하여 정지되지 않은 컨테이너도 출력할 수 있습니다. CONTAINER ID : 컨테이너에게 자동으로 할당되는 고유한 ID, docker inspect 명령어를 통해 전체 ID를 확인할 수 있습니다. IMAGE : 컨테이너를 생성할 때 사용된 이미지의 이름. COMMAND : 컨테이너가 시작될 때 실행될 명령어. CREATED : 컨테이너가 생성되고 난 뒤 흐른 시간 STATUS : 컨테이너의 상태를 나타냄. 실행중up, 종료Exited, 일시중지Pause등이 있습니다. PORTS : 컨테이너가 개방한 포트와 호스트에 연결한 포트. 아무것도 설정하지 않으면 보이지 않습니다. NAMES : 컨테이너의 고유한 이름입니다. 지정해줄 수 있고, 지정하지 않는다면 도커 엔진이 임의로 이름을 설정합니다. docker rename 명령어를 통해 이름을 바꿀 수 있습니다.2.2.3 컨테이너 삭제한 번 삭제한 컨테이너는 복구할 수 없으므로 신중을 기해야합니다.docker stop kmsCentos&amp;gt; 실행중인 컨테이너는 삭제할 수 없으므로 중지 시켜야합니다. `-f`옵션을 통해 강제로 삭제할 수 있습니다.docker rm kmsCentos&amp;gt; kmsCentos docker container prune 명령어를 통해 모든 컨테이너를 삭제할 수 있습니다.2.2.4 컨테이너를 외부에 노출컨테이너는 가상 IP주소를 할당 받는데, 도커의 경우는 172.17.0.x의 IP를 순차적으로 할당합니다.docker run -i -t --name kms_network_test ubuntu:14.04root@91816fd6e66d:/# ifconfigeth0 Link encap:Ethernet HWaddr 02:42:ac:11:00:02 inet addr:172.17.0.2 Bcast:172.17.255.255 Mask:255.255.0.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:9 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:806 (806.0 B) TX bytes:0 (0.0 B)lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:0 (0.0 B) TX bytes:0 (0.0 B)172.17.0.2를 할당받은 eth0 인터페이스와 로컬 호스트인 lo 인터페이스가 있습니다.아무런 설정을 하지 않으면 외부에서 접근이 불가능 하므로 eth0의 IP와 포트를 호스트의 IP와 포트에 바인딩해야 합니다.docker run -i -t --name kms_webServer -p 80:80 ubuntu:14.04&amp;gt; root@f1bfd6065963:/# -p옵션의 [호스트포트]:[컨테이너포트] 이 양식을 통해 포트를 바인딩 해줍니다.docker run -i -t -p 8080:8080 -p 192.168.0.1:6666:80 ubuntu:14.04&amp;gt; -p옵션을 많이 쓸 수 있고, 호스트의 &#39;6666&#39;포트를 컨테이너의 &#39;80&#39;포트와 바인딩 한다는 의미도 내포root@f1bfd6065963: /# apt-get updateroot@f1bfd6065963: /# apt-get install apache2 -yroot@f1bfd6065963: /# service apache2 start이후 [도커 엔진 호스트의 IP]:80 또는 localhost:80에 접근하면 아파치 웹 서버에 접근 할 수 있습니다.아파치 웹 서버는 포트80으로 통신을 하기에 -p 80:81처럼 컨테이너 포트를 81로 지정해버리면 웹 서버에 접근하지 못하게 됩니다.2.2.5. 컨테이너 애플리케이션 구축한 컨테이너에 데이터베이스 + 웹 서버를 넣을 수 있고, 두 컨테이너로 나눠서 하나는 데이터베이스 하나는 웹 서버로 넣을 수 있겠습니다.후자의 경우처럼 컨테이너를 구분하는 것이 도커 이미지를 관리하고 컴포넌트의 독립성을 유지하기 쉽습니다. 도커 공식 홈페이지에서도 권장하고 있고, 한 컨테이너에 하나의 프로세스만 실행하는 것이 도커의 철학이기 때문입니다.데이터베이스 + 워드프레스 웹 서버 컨테이너 연동mac M1인 경우 기존 명령어로 설치가 되지 않기에 명령어를 바꿔야한다.# 기존docker run -d \\--name wordpressdb \\-e MYSQL_ROOT_PASSWORD=password \\-e MYSQL_DATABASE=wordpress \\mysql:5.7#M1docker run --platform linux/amd64 \\--name wordpressdb \\-e MYSQL_ROOT_PASSWORD=password \\-e MYSQL_DATABASE=wordpress \\mysql:5.7mySQL 컨테이너를 생성했으므로 워드프레스 웹 서버 컨테이너를 생성합니다.docker run -d \\-e WORDPRESS_DB_HOST=mysql \\-e WORDPRESS_DB_USER=root \\-e WORDPRESS_DB_PASSWORD=password \\--name wordpress \\--link wordpressdb:mysql \\-p 80 \\wordpress-p 80옵션을 통해 호스트의 임의의 포트와 컨테이너의 80포트를 연결하였습니다.docker ps 명령어를 통해 어느 포트에 연결 되었는지 확인합니다.docker ps&amp;gt; CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESbd85e97e8c0d wordpress &quot;docker-entrypoint.s…&quot; 35 seconds ago Up 33 seconds 0.0.0.0:50953-&amp;gt;80/tcp wordpress50953포트에 연결되었습니다. docekr port wordpress처럼 “docker port ‘컨테이너 명’“을 입력하면 해당 컨테이너가 사용중인 호스트의 포트가 출력 됩니다.-d옵션을 넣어서 run을 실행하면 입출력이 없는 상태로 컨테이너를 실행합니다. 이렇게 하면 컨테이너 내부에서 프로그램이 터미널을 차지하는 포그라운드로 실행되어, 사용자의 입력을 받지 않습니다.만약 해당 옵션을 사용하지 않는다면 하나의 터미널을 먹는 mysqld이 열리면서 단순히 프로그램이 포그라운드 모드로 동작하는 것만 지켜볼 수 있습니다.-e옵션은 컨테이너 내부의 환경변수를 설정합니다.환경변수를 확인하려면echo ${ENVIROMENT_NAME}을 사용하면 됩니다.새로 만든 wordpressdb 컨테이너에 적용된 환경변수를 출력하려면 2가지 방법이 있습니다.#1 exec -t -i 활용 터미널이 살아있음.docker exec -i -t wordpressdb /bin/bashroot@f95d669519ce:/# echo $MYSQL_ROOT_PASSWORDpassword#2 docker exec 만 활용 결과값만 반환docker exec wordpress ls /# 결과값들 리턴실제로 환경변수가 적용되었는지 컨테이너속 mysql로 이동합니다.# 이동하는 명령어docker exec -i -t wordpressdb /bin/bash# mysql 확인mysql -u root -p&amp;gt; Enter password: Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 7Server version: 5.7.38 MySQL Community Server (GPL)Copyright (c) 2000, 2022, Oracle and/or its affiliates.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &#39;help;&#39; or &#39;\\h&#39; for help. Type &#39;\\c&#39; to clear the current input statement.mysql&amp;gt; --link옵션은 컨테이너끼리 접근 하는 방법중 하나입니다.원래는 NAT로 할당받은 IP로 접근할 수 있지만, 무작위성이 강하여 매 번 변경되는 컨테이너의 IP로 접근하기 어렵습니다. 하지만 --link옵션은 내부 IP를 알 필요 없이 컨테이너에 별명(alias)으로 접근하도록 설정합니다. 또한, 의존성도 정의해주므로 실행순서도 정해줍니다.예를들면 위의 경우 wordpressdb와 wordpress 컨테이너를 중지하고, 다시 wordpress를 실행시키면 다음과 같이 에러가 나옵니다.docker start wordpress&amp;gt; Error response from daemon: Cannot link to a non running container: /wordpressdb AS /wordpress/mysqlError: failed to start containers: wordpress하지만 --link옵션은 현재 ‘deprecated’된 옵션이며 추후 삭제될 가능성이 있습니다. 도커 브리지 네트워크를 사용하면 --link 옵션과 동일한 기능을 더욱 손쉽게 사용할 수 있으므로 브리지 네트워크를 사용하는것을 권장한다고 합니다." }, { "title": "시작하세요! 도커/쿠버네티스(1) - 도커란?", "url": "/posts/DockerStart01/", "categories": "Docker, CS", "tags": "Docker", "date": "2022-05-09 01:00:00 +0900", "snippet": " 시작하세요! 도커/쿠버네티스 책 정리글입니다.1. 도커란? 도커(Docker)는 리눅스 컨테이너에 여러 기능을 추가함으로써 애플리케이션을 컨테이너로서 좀 더 쉽게 사용할 수 있게 만들어진 오픈소스 프로젝트 Go언어로 작성. 도커와 관련된 프로젝트는 도커 컴포즈(Docker Compose), 레지스트리(Private Registry), 도커 허브(Docker Hub), 등 여러가지가 있지만 일반적으로 말하는 도커는 도커 엔진(Docker Engine)이나 도커의 모든 프로젝트를 의미한다.1.1 가상머신과 도커 컨테이너가상화 기술 : 호스트 OS + 게스트 OS = 무겁다. -&amp;gt; 배포할때 무겁기에 오래 걸리고 성능또한 떨어진다. VMware,VirtualBox, 등..도커 : 리눅스의 자체 기능인 chroot, namespace, cgroup을 사용함으로써 프로세스 단위의 격리 환경을 만들어 성능의 손실이 거의 없음. 컨테이너에 필요한 커널은 호스트의 커널을 공유해 사용. 컨테이너 안에는 애플리케이션을 구동하는 데 필요한 라이브러리 및 실행 파일만 존재하기에 이미지의 용량이 대폭 줄어듦.따라서 배포시간이 가상머신에 비해 빠르며 성능손실도 줄어진다는 장점이 있다.1.2 도커를 왜 사용하는가? 애플리케이션의 개발과 배포가 편해짐. 도커는 호스트 OS 위에서 실행되는 격리된 공간이기에 컨테이너 자체에 특별한 권한을 주지 않는 한, 컨테이너 내부에 수많은 소프트웨어를 설치하고 설정 파일을 수정해도 호스트OS에는 영향이 없다. 즉, 독립된 개발환경. 만약 배포하려고 한다면, 컨테이너에 사용되던 패키지들을 따로 운영서버에서 설치할 필요도 없으며, 각종 라이브러리의 의존성도 생각할 필요가 없다. 도커는 도커 이미지라는 것을 통해 컨테이너를 일종의 패키지로 만들어 개발 환경을 똑같이 복제하여 운영서버로 넘길수 있기 때문이다. 도커는 가상 머신과 달리 커널을 포함하고 있지 않아 이미지 크기가 크지 않다. 여러 애플리케이션의 독립성과 확장성이 높아짐. msa구조에서 가장 많이 사용되고 있는 가상화 기술임. 데이터베이스 컨테이너와 웹 서버 컨테이너로 분리할 수 있고, 부하시에는 동적으로 컨테이너를 늘려 부하를 분산시킬 수 있다는 장점이 있다. 1.3 도커 엔진 설치도커는 리눅스 컨테이너를 제어하는 API를 GO언어로 작성한 libcontainer를 사용하기에 대부분의 리눅스와 호환이 됨.맥 OS X 경우 xhyve기술을 이용해 리눅스 커널 기능과 도커 엔진 환경을 구성. 하지만 완벽히 호환될 수 없을 수 있어서 완전한 리눅스 환경을 추천. docker info | grep Kernel 명령을 통해 가상 환경에서 실행되는 도커 엔진이 사용하는 커널 버전을 확인 할 수 있습니다." }, { "title": "Docker(3) - Docker로 nginx 띄우기", "url": "/posts/Docker_nginx/", "categories": "Docker, CS", "tags": "Docker", "date": "2022-05-08 03:00:00 +0900", "snippet": "안 쓰는 폴더를 만들어서 Dockerfile을 만들어줍시다.#DockerfileFROM ubuntu:latestRUN apt-get updateRUN apt-get install -y nginxRUN echo &quot;\\ndaemon off;&quot; &amp;gt;&amp;gt; /etc/nginx/nginx.confRUN chown -R www-data:www-data /var/lib/nginxVOLUME [&quot;/data&quot;, &quot;/etc/nginx/site-enabled&quot;, &quot;/var/log/nginx&quot;]WORKDIR /etc/nginxCMD [&quot;nginx&quot;]EXPOSE 80EXPOSE 443" }, { "title": "Docker(2) - Docker Command 기초", "url": "/posts/DockerCommand/", "categories": "Docker, CS", "tags": "Docker", "date": "2022-05-08 02:00:00 +0900", "snippet": "1. Serachdocker search redis ... docker serach 이미지명은 Docker Hub에 등록된 이미지들을 찾는 역할을 합니다.2. Pulldocker pull ubuntu:latest ... docker pull 이미지명:태그명은 Docker Hub에 등록된 이미지를 로컬 레포지토리로 가져옵니다.3. Imagesdocker images docker images는 모든 이미지 목록을 출력합니다. docker images ubuntu라고 하면 ubuntu에서 태그만 다른 값들을 출력합니다.4. Rundocker run -i -t --name kms ubuntu:latest /bin/bash docker run &amp;lt;옵션명&amp;gt; &amp;lt;이름명&amp;gt; &amp;lt;이미지명&amp;gt; &amp;lt;실행할 파일&amp;gt; 의 형식을 갖는 run 명령어는 다음과 같이 해석할 수 있습니다. -i, -t : 선택된 bash셸에 입력및 출력이 가능. --name : 이름 입력이 가능. 위의 경우 kms로 지정. 지정하지 않으면 Docker가 알아서 지정.exit명령어로 빠져나올 수 있습니다.5. Psdocker ps -a docker ps &amp;lt;option&amp;gt;은 실행되고 있는 컨테이너 또는 모든 컨테이너 목록을 출력합니다.6. Startdocker start kms docker start &amp;lt;컨테이너 이름&amp;gt;으로 구성된 명령어는 입력한 컨테이너를 찾아 실행합니다.7. Restartdocker restart kms docker restart &amp;lt;컨테이너 이름&amp;gt;으로 구성된 명령어는 해당 컨테이너를 재시작합니다.8. Attachdocker attach kms docker attach &amp;lt;컨테이너 이름&amp;gt;으로 구성된 명령어는 해당 컨테이너에 접속이 가능해집니다.9. Execdocker exec kms echo &quot;hi docker im kms&quot; docker exec &amp;lt;컨테이너이름&amp;gt; &amp;lt;명령어&amp;gt; &amp;lt;매개변수&amp;gt;로 이루어진 명령어는 실행중인 컨테이너에 사용자가 지정한 명령어를 외부에서 보내 실행하게 합니다.10. Stopdocker stop kms docker stop &amp;lt;컨테이너 이름&amp;gt;은 해당 컨테이너를 중지시킵니다.11. Rmdocker rm kms docker rm &amp;lt;컨테이너 이름&amp;gt;은 해당 컨테이너를 삭제합니다.12. Rmidocker rmi ubuntu:latest docker rmi &amp;lt;이미지명&amp;gt;:&amp;lt;태그명&amp;gt;은 해당 이미지를 삭제합니다." }, { "title": "Docker(1) - Mac OS X Docker설치", "url": "/posts/DockerInstall/", "categories": "Docker, CS", "tags": "Docker", "date": "2022-05-08 01:00:00 +0900", "snippet": "https://www.docker.com/products/docker-desktop/에서 Mac with Apple Chip으로 된 것을 클릭.dmg파일이 생기는데, 이를 드래그해서 Applications으로 옮기고 LaunchPad에서 실행. Accept를 클릭하여 동의하고 설치하면 완료. 질문은 댓글을 남겨주세요." }, { "title": "내 blog 버전별 업데이트 로그 정리 ~Version 4까지", "url": "/posts/themeversionReview02/", "categories": "Blogging, Tutorial", "tags": "start git blog", "date": "2022-05-04 02:00:00 +0900", "snippet": " 원본은 https://github.com/cotes2020/jekyll-theme-chirpy/releases?page=2에 있습니다.!!v4.0.0New local에서 배포할때의 pageview를 지원하게 되었습니다. shadow옵션을 이미지 첨부할 때 추가할 수 있도록 하였습니다. 팝업 이미지를 추가하였습니다.Improved PWA cache storage를 줄였습니다. gem installation에서 요구하는 외부 파일들을 줄였습니다. favicon을 간단하게 하였습니다. &amp;gt; 정확히는 모르겠습니다. new tablets에서의 디자인 반응을 개선하였습니다. ios에서 safari 브라우저로 들어왔을때 검색창을 확대할 수 있는것을 방지하였습니다. panel의 텍스트컬러를 통합하였습니다. sidebar의 스크롤바를 숨겼습니다.Fixed 사이트를 업데이트한 후 Service Worker가 event error를 가져옵니다. 몇몇 CDN URL이 헤더에 포함되지 않는 것을 고쳤습니다. RSS 템플릿의 author를 수정할 수 없던 것을 고쳤습니다.v4.0.1Hotfix gem에 있는 몇몇 의존성 파일들이 누락되었던 것을 고쳤습니다.v4.0.2Hotfix Ruby의 양립할 수 없는 공용버전 범위를 제한하였습니다.v4.1.0New localization 레이아웃을 지원합니다. &amp;gt; 이해못했스빈다. hook에 SCSS variables을 커스텀할 수 있게 추가하였습니다. 모바일환경에서 paginator를 재디자인 하였습니다. (페이지 1,2,3…12 이런식으로 넘어가는 부분)Improved 이미지나 post가 로딩중일때 레이아웃이 옮겨지는 것을 방지하였습니다. 로딩중일때 code language badge가 꺼지는 현상을 방지하였습니다. lazy-loaded를 선택한 이미지인 경우 서서히 사라지는것을 추가하였습니다.Fixed pagination의 bread-crumb이 정확하지 않은것을 수정하였습니다. The items of .gitignore &amp;gt; ???? 몇몇 docs에서 Typo에 실수를 했던것을 고쳤습니다. &amp;gt; ..?v4.1.1Hotfix 새로운 탭 페이지의 default name이 부정확한것을 수정하였습니다. site config에서 불필요한 변수는 제거하였습니다. 몇몇 문서의 markdown 문법이 에러가 있는것을 고쳤습니다.v4.2.0New Disqus 테마가 자동으로 바뀌게 설정하였습니다. macOs 스타일의 스크롤바를 생성하였습니다. code block title option을 제작할 수 있게 하였습니다. line number를 숨길 수 있게 하였습니다. 클립보드에 복사하는 버튼을 추가하였습니다. Improved full-text 검색을 가능하게 하였습니다. Locale stuff &amp;gt; ??Fixed 몇몇 경우 Tab의 이름이 부적절한 것을 수정하였습니다.v4.2.1Hotfix 실수로 삭제된 post 복사링크를 복구하였습니다. Safari에서 code block의 line number가 복사되는 것을 방지하였습니다.v4.3.0New 사이드바의 디자인을 수정하였습니다. code block의 상단 아이콘을 추가하였습니다. syntax language의 별칭을 공식 이름으로 수정하였습니다. ? &amp;gt; Convert the alias of the syntax language to the official name Ruby 3.0 의존성을 추가하였습니다.Improved color scheme의 디자인을 개선하였습니다. tips의 code button을 숨깁니다. code block의 스크롤바를 자동으로 숨김처리 하였습니다. code block버튼의 웹 접근성을 강화하였습니다. 깃허브 액션이 자동으로 테마를 업그레이드하는것을 방지하였습니다. 자동배포에 필요한 파일을 줄였습니다.Fixed comment block이 로딩시간동안 jumping..?넘어가는것을 방지하였습니다.v4.3.4Hotfix NPM의 lock-file이 웹사이트 결과값에 포함되어 복사되는 것을 수정하였습니다. json,plaintext 등 몇몇 언어들이 code block에서 제대로 바뀌지 않는 것을 수정하였습니다. 다수의 footnote가 서서히 사라지는것을 수정하였습니다. &amp;gt; Multiple reverse footnote will overlap (#439) 영어공부 열심히 해야겠다.." }, { "title": "jekyll Blog giscus 추가하기 repo-id가 뭐야?", "url": "/posts/Blogaddgiscus/", "categories": "Blogging, Tutorial", "tags": "start git blog", "date": "2022-05-03 11:00:00 +0900", "snippet": " https://giscus.app/ko/이를 참고하여 작성한 글입니다.기존에 discus를 썼는데, giscus가 더 깔끔하고 보기 좋다고 생각하였다.하지만, github계정이 있어야 한다는 점은 오히려 접근성이 더 떨어질 수 있다고도 생각하였지만..개발자라면?..깃허브 다 있잖아?!그래서 넣기로 하였다.위의 사이트에서 설정값을 다음과 같이 주었다. Discussion 제목이 페이지 경로를 연결하기 카테고리는 Announcements 이 카테고리에서만 discussion 찾기 체크 테마는 취향로 체크하고 스크롤을 내리면giscus 활성화가 있다.&amp;lt;script src=&quot;https://giscus.app/client.js&quot; data-repo=&quot;[ENTER REPO HERE]&quot; data-repo-id=&quot;[ENTER REPO ID HERE]&quot; data-category=&quot;[ENTER CATEGORY NAME HERE]&quot; data-category-id=&quot;[ENTER CATEGORY ID HERE]&quot; data-mapping=&quot;pathname&quot; data-reactions-enabled=&quot;1&quot; data-emit-metadata=&quot;0&quot; data-input-position=&quot;bottom&quot; data-theme=&quot;light&quot; data-lang=&quot;ko&quot; crossorigin=&quot;anonymous&quot; async&amp;gt;&amp;lt;/script&amp;gt;라고 되어있는데, 위의 항목중에서 저장소의 이름을 알맞게 넣어주고 카테고리값도 넣어주면Enter ~로 된 항목들이 해당 선택값으로 바뀌어 있을 것이다.그리고 나같은 경우 blog의 _config.yml의 파일이giscus: repo: # &amp;lt;gh-username&amp;gt;/&amp;lt;repo&amp;gt; repo_id: category: category_id: mapping: # optional, default to &#39;pathname&#39; input_position: # optional, default to &#39;bottom&#39; lang: # optional, default to the value of `site.lang`와 같이 되어 있어서giscus: repo: &#39;kkminseok/kkminseok.github.io&#39; # &amp;lt;gh-username&amp;gt;/&amp;lt;repo&amp;gt; repo_id: &#39;MDEwOllmasdmn,kzNDUwNzI2OTM=&#39; category: &#39;Announcements&#39; category_id: &#39;DIC_kwDOFssazxkNxzckzjxc-J&#39; mapping: # optional, default to &#39;pathname&#39; input_position: # optional, default to &#39;bottom&#39; lang: # optional, default to the value of `site.lang`처럼 giscus가 알려준 값으로 수정하니 잘 되었다.궁금한점은 댓글을 남겨주세요." }, { "title": "jekyll Blog 테스트 문법", "url": "/posts/jekylls_viewPage/", "categories": "Blogging, Tutorial", "tags": "start git blog", "date": "2022-05-02 13:00:00 +0900", "snippet": " https://chirpy.cotes.page/posts/enable-google-pv/여기서 따온 글입니다. https://console.cloud.google.com/apis/library/browse?authuser=1&amp;amp;project=blogview&amp;amp;q=google%20analytics%20api에 접속한다. API 및 서비스 -&amp;gt; 사용 설정된 API 및 서비스 -&amp;gt; API 및 서비스 사용 설정 -&amp;gt; google analytics api 검색 -&amp;gt; 사용 선택 oauth 동의 화면 선택 -&amp;gt; 외부 선택사실 https://chirpy.cotes.page/posts/enable-google-pv/ 이 글대로 따라 쓰려했으나시간 부족으로 추후에 하기로 함.일단 블로그 새롭게 바뀐거 문법 테스트" }, { "title": "내 blog 버전별 업데이트 로그 정리 ~Version 3까지", "url": "/posts/blogVersionReview/", "categories": "Blogging, Tutorial", "tags": "start git blog", "date": "2022-05-02 02:00:00 +0900", "snippet": "내가 기존에 썼던 버전은 3.1.0 언저리였다. 그 기준으로 업데이트 로그를 작성하겠다. 원본은 https://github.com/cotes2020/jekyll-theme-chirpy/releases?page=2에 있습니다.!!v3.1.0New post preview image 설정에 alt기능을 추가하였습니다. site 설정 부분에 lang을 추가하였습니다. -&amp;gt; 방문자 유입 국적에 따라 언어가 바뀌게 보임.Improved _config.yml에서 breadcrumb?를 삭제하여 유연하게 breadcrumb을 생성할 수 있게 하였습니다. /tabs/를 tabs에서 제거하였습니다. gemspec 파일을 output에서 제거하였습니다. Gemfile의 중복을 제거하였습니다.Fixed latest/oldest post의 nav button을 복구하였습니다. post의 image bottom margin을 고쳤습니다.v3.2.0Improved 코드블록을 최적화하였습니다. 사이트 제외 목록에 정규식을 사용하였습니다. travis job을 도입하였습니다. 검색 결과 항목의 최소 너비를 향상시켰습니다. 문서에 분기를 추가하였습니다.Fixed 가이드라인을 수정하였습니다.v3.2.1Hotfix 게시공유 옵션 버튼을 복구하였습니다.v3.2.2Hotfix 코너에 있는 latest/oldest post의 navigation buttons을 고쳤습니다. list속에 있는 image의 넓이를 수정하였습니다.v3.3.0New math에서 TeX와LaTex단위를 추가하였습니다.Improved 깃허브 액션에서 ruby setup부분을 업데이트 하였습니다. site.author를 제거하였습니다. timeago를 개선하고, 포스트 정렬 알고리즘을 개선하였습니다. bump tool을 향상시켰습니다.Fixed 서비스 제공자가 Post로 요청온 값을 캐시 키로 저장하여 발생한 PWA 에러를 수정하였습니다.v3.3.1Hotfix math에서 Tex와LaTex설정이 배포버전에서 잘못되어 수정하였습니다.(오역 가능성)v3.3.2Hotfix 로컬 캐시가 없는 경우 PV 결과를 failure로 나타내는 경우를 수정하였습니다. 검색 결과의 link color를 수정하였습니다." }, { "title": "2번 읽는 Modern Java In Action - Chapter06 스트림으로 데이터 수집", "url": "/posts/2023-05-02-Modern-Java-In-action/", "categories": "Java, Modern Java In Action", "tags": "Modern Java In Action", "date": "2022-05-02 01:02:00 +0900", "snippet": "🔅 개요이전 챕터에서는 collect메서드로 Collector인터페이스 구현을 전달하였는데, 해당 인터페이스는 스트림의 요소를 어떤 식으로 도출할지를 지정해준다.함수형 프로그래밍은 무엇을 원하는지 직접 명시할 수 있어서 명령형 프로그래밍과 다르게 코드가 좀 더 간결하고 가독성이 향상된다. 자바에서 제공하는 함수형 API를 살펴볼 챕터인것 같다.컬렉터의 메소드로 스트림의 갯수를 셀 수 있으며,@Test@DisplayName(&quot;리듀스 카운트 예제&quot;)void test_reduce_counting() { long result = menu.stream().count(); System.out.println(result);}컬렉션의 메소드로 스트림의 최댓값 최솟값을 구할 수 있다.@Test@DisplayName(&quot;리듀스 최댓값 최솟값 예제&quot;)void test_reduce_max_min(){ Comparator&amp;lt;Dish&amp;gt; dishComparator = Comparator.comparingInt(Dish::getCalories); Optional&amp;lt;Dish&amp;gt; mostCaloriesDish = menu.stream().collect(Collectors.maxBy(dishComparator)); Assertions.assertEquals(mostCaloriesDish.get().getCalories(), 400);}컬렉션에서 제공하는 메소드중 요약팩토리 메서드를 제공하는데, 이를통해 스트림의 합계나 평균값, 등을 계산할 수 있다.@Test@DisplayName(&quot;리듀스 요약 연산 예제&quot;)void test_reduce_summing(){ Integer totalCalories = menu.stream().collect(Collectors.summingInt(Dish::getCalories)); Assertions.assertEquals(totalCalories, 1029); double avgCalories = menu.stream().collect(Collectors.averagingInt(Dish::getCalories)); Assertions.assertEquals((int)avgCalories, (int)totalCalories / menu.stream().count());}또한 위의 정보를 모은 ~Statistics() 메서드를 통해 정보들을 확인할 수 있다.@Test@DisplayName(&quot;리듀스 summary 예제&quot;)void test_reduce_summary(){ IntSummaryStatistics menuStatistics = menu.stream().collect(Collectors.summarizingInt(Dish::getCalories)); //IntSummaryStatistics{count=4, sum=1029, min=199, average=257.250000, max=400} System.out.println(menuStatistics);}문자열도 연결할 수 있다.@Test@DisplayName(&quot;문자열 연결 예제&quot;)void test_join_string(){ String shortMenu = menu.stream().map(Dish::getName).collect(Collectors.joining()); //chickenpork Choppork Loinsalad System.out.println(shortMenu); //구분자를 넣음 shortMenu = menu.stream().map(Dish::getName).collect(Collectors.joining(&quot;, &quot;)); //chicken, pork Chop, pork Loin, salad System.out.println(shortMenu);}" }, { "title": "백엔드 웹 개발 노트6.6 - Spring MVC Message Converter", "url": "/posts/basicSpring6_6/", "categories": "Java, 6_Spring_김영한_스프링MVC 1편", "tags": "Spring", "date": "2022-04-28 17:50:50 +0900", "snippet": "메시지 컨버터뷰 템플릿으로 HTML을 생성해서 응답하는것이 아니라, HTTP API 처럼 JSON같은 데이터로 응답을 보낼때 메시지 컨버터를 사용하면 편하다.@ResponseBody의 호출 구조는 이렇다. 출처 : 김영한 선생님 강의 자료흐름을 따라가보자. 요청이 들어오면 Controller 호출 Controller에 @ResponseBody를 보고 viewResolver 대신 HttpMessageConverter가 동작 들어온 데이터를 보고 JSONConvert, StringConverter, 등등을 파악함.(밑에서 설명) 요청 데이터와 헤더 등을 조합하여 새로운 메시지를 생성하고 반환.여기서 무엇을 보고 판단할까? 일단 메시지를 반환할 때는 클라이언트의 Accept 헤더와 서버 컨트롤러의 반환 타입을 보고 판단한다.클라이언트의 Accept는 헤더는 서버에게 요구되는 데이터 방식인데, 당연하게도 클라이언트가 요구하는 데이터가 아니면 안되지 않겠는가.아무튼 스프링MVC는 다음의 경우에 HTTP 메시지 컨버터를 적용한다. HTTP 요청 : @RequestBody, HttpEntity(RequestEntity) HTTP 응답 : @ResponseBody, HttpEntity(ResponseEntity)메시지 컨버터의 인터페이스 코드를 보자.package org.springframework.http.converter;public interface HttpMessageConverter&amp;lt;T&amp;gt; { boolean canRead(Class&amp;lt;?&amp;gt; clazz, @Nullable MediaType mediaType); boolean canWrite(Class&amp;lt;?&amp;gt; clazz, @Nullable MediaType mediaType); List&amp;lt;MediaType&amp;gt; getSupportedMediaTypes();T read(Class&amp;lt;? extends T&amp;gt; clazz, HttpInputMessage inputMessage)throws IOException, HttpMessageNotReadableException;void write(T t, @Nullable MediaType contentType, HttpOutputMessageoutputMessage)throws IOException, HttpMessageNotWritableException;}당연하게도 can~은 읽을 수 있는지, 쓸 수 있는지에 대한 판단 여부이고 read, write는 데이터를 읽고 쓴다는 것일것이다.그럼 이 can~이 먼저 동작될 때 나름의 판단 기준이 있을텐데, 그 판단기준을 보자.(일부 생략)0 = ByteArrayHttpMessageConverter1 = StringHttpMessageConverter2 = MappingJackson2HttpMessageConverter이것도 직관적이다. 0순위는 배열인지, 1순위는 문자열인지, 2순위로 JSON형태인지 확인한다.그래. 그러면 이게 배열이고 문자열이고 JSON이고는 어떻게 판단할까?그건 요청으로 들어온 데이터와 헤더값 중 ‘미디어 타입’에 따라서 달라진다. ByteArrayHttpMessageConverter 클래스 타입이 ‘byte[]’이고, 미디어 타입이 ‘/’ 인 경우 요청 예) @RequestBody byte[] data 응답 예) @ResponseBody byte[] data 이 경우 반환 미디어 타입 = application/octet-stream StringHttpMessageConverter 클래스 타입이 ‘String’이고, 미디어 타입이 ‘/‘인 경우 요청 예) @RequestBody String data 응답 예) @ResponseBody return “ok”; 이 경우 반환 미디어 타입 = text/plain MappingJackson2HttpMessageConverter 클래스 타입이 ‘객체 또는 HashMap’, 미디어 타입이 ‘application/json’관련 경우 요청 예) @RequestBody BmiData data 응답 예) @ResponseBody bmidata 이 경우 반환 미디어 타입 = application/json 예를 들어보자.content-type: application/json@RequestMappingvoid hello(@RequetsBody String data) {}이런 요청이 들어오면 어떤것을 선택해야할까? 당연히 StringHttpMessageConverter이다.왜냐하면 들어온 데이터의 타입이 String이고, 미디어 타입도 /에 포함되는 application/json이기 때문이다.또 다른 예를 들어보자.content-type: application/json@RequestMappingvoid hello(@RequetsBody BmiData data) {}이건 MappingJackson2HttpMessageConverter가 호출되는걸 알 것이다.이 경우는 어떨까?content-type:text/html@RequestMappingvoid hello(@RequestBody BmiData data) {}당연히 아무것도 호출되지 않는다. content-type이 json관련이 아니지 않는가.이를 토대로 처음부터의 흐름을 다시 정리하겠다. HTTP 요청 데이터를 읽음. 컨트롤러에서 @ResponseBody, HttpEntity 파라미터를 사용한다? 만약 사용한다면 메시지 컨버터가 메시지를 읽을 수 있는지 확인하기 위해 canRead()를 호출. HTTP 요청의 데이터 자료형을 확인 HTTP 요청의 Content-Type 미디어 타입을 지원하는가? canRead()의 조건을 만족하면 read()를 호출해서 객체를 생성하고, 반환한다.응답 데이터를 생성할 때 컨트롤러에서 @ResponseBody, HttpEntity로 값이 반환된다? 메시지 컨버터가 메시지를 쓸 수 있는지 확인하기 위해 canWrite()가 호출 대상 클래스 타입을 지원하는가? (데이터 타입) HTTP 요청의 Accept 미디어 타입을 지원하는가? canWrite() 조건을 만족하면 write()를 호출해서 HTTP 응답 메시지 바디에 데이터를 전달!메시지 컨버터의 위치어딨는걸까?스프링MVC구조를 보자. 출처 : 김영한 선생님 강의 노트어딨음?잘 생각해보면 뻔하다.결국 핸들러 어댑터에서 컨트롤러에 등록된 함수들을 실행할텐데 그 함수들에는 애노테이션이 덕지덕지 붙어있을 것 아닌가? 그래서 핸들러 어댑터와 핸들러 사이에 위치해있다. 출처 : 김영한 선생님 강의 노트그렇다. 저 중간에서 애노테이션들을 보고 요청값에 따른, 리턴값을 정해주고 데이터를 처리해준다.ArgumentResolverArgumentResolver가 요청에 대한 파라미터들을 처리해버려서 컨트롤러가 필요로 하는 다양한 파라미터 값의 객체를 생성해서 컨트롤러에 넘겨준다.동작방식ArgumentResolver안에 있는 supportParameter()를 호출해서 파라미터에 대한 객체를 생성할 수 있는지 여부를 확인한다.생성할 수 있으면 객체를 생성해서 컨트롤러에 넘겨준다.원한다면 개발자가 커스텀마이징을 할 수 있다.!ReturnValueHandler정식명칭은 HandlerMethodReturnValueHandler인데 줄여서 ReturnValueHandler라고 한다.간단하게 응답값을 생성해내는데, 컨트롤러에서 String으로 뷰 이름을 반환해도 웹이 띄워지게 되는게 이 놈 덕분이다.생각해보면 메시지 컨버터는 아직 어딨는지 모르겠다.도대체 어딨어?결국 저 두 놈도 객체를 생성할때 누군가의 도움이 필요하다. 저 두 놈이 여러 요청 파라미터에 대해서 여러 객체를 생성할텐데 객체를 생성할때 메시지 컨버터가 도와준다.따라서 여기에 있다.흐름을 다시 보자.요청의 경우는 @Requestbody를 처리하는 ArgumentResolver가 있고, HttpEntity를 처리하는 ArgumentResolver가 있을 것이다. 이 ArgumentResolver 들이 HTTP 메시지 컨버터를 사용해서 필요한 객체를 생성하는 것이다.응답의 경우는 @ResponseBody를 처리하는 ReturnValueHandler가 있고, HttpEntity를 처리하는 ReturnValueHandler가 있을 것이다.여기에 HTTP 메시지 컨버터를 호출해서 응답결과를 만든다. 참고 : 스프링 MVC는 @RequestBody @ResponseBody 가 있으면 RequestResponseBodyMethodProcessor (ArgumentResolver) HttpEntity 가 있으면 HttpEntityMethodProcessor (ArgumentResolver)를 사용한다.확장스프링은 위에서 말한 HttpMessageConverter,HandlerMethodArgumentResovler, HandlerReturnValueHandler를 인터페이스로 제공한다.확장이 가능하다는 것이다.기능 확장은 WebMvcConfiguer를 상속받아서 가능하다. 여기서 다루지는 않을 것이다.!!필요할때 찾자 ㅎ" }, { "title": "백엔드 웹 개발 노트6.5 - Spring MVC HTTP Response", "url": "/posts/basicSpring6_5/", "categories": "Java, 6_Spring_김영한_스프링MVC 1편", "tags": "Spring", "date": "2022-04-28 16:50:50 +0900", "snippet": "1. HTTP Response - 정적 리소스,뷰 템플릿스프링에서 응답(데이터)를 만드는 방법은 크게 3가지이다. 정적 리소스 HTML, CSS, js 등 뷰 템플릿 사용 동직인 HTML HTTP 메시지 사용 HTTP API를 제공하는 경우에는 HTML이 아닌 데이터를 실어 넣어야하므로 HTTP 메시지 바디에 JSON같은 형식의 데이터를 실어서 보냄. 1.1 정적 리소스Spring boot에서 정적 리소스 경로는 정해져있다./static 또는/public 또는/resources 또는/META-INF/resources 로 정해져있다. src/main/resources는 리소스를 보관하는 곳이고, 또 클래스패스의 시작경로이다.따라서 다음 디렉토리에 리소스를 넣어두면 스프링 부트가 정적 리소스로 서비스를 제공한다.src/main/resources/static다음 경로에 파일이 들어있다고 치면src/main/resources/static/basic/kms-form.html&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;form action=&quot;/kms-request-param-v1&quot; method=&quot;post&quot;&amp;gt; username: &amp;lt;input type=&quot;text&quot; name=&quot;username&quot; /&amp;gt; height: &amp;lt;input type=&quot;text&quot; name=&quot;height&quot; /&amp;gt; &amp;lt;button type=&quot;submit&quot;&amp;gt;전송&amp;lt;/button&amp;gt;&amp;lt;/form&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&amp;lt;localhost:8080/basic/kms-form.html&amp;gt;으로 접근이 가능하다. 경로 URL1.2 뷰 템플릿뷰 템플릿을 거쳐서 HTML이 생성되고, 뷰가 응답을 만들어서 전달한다.일반적으로 HTML을 동적으로 생성하는 용도로 사용하지만, 다른 것들도 가능하다. 뷰 템플릿이 만들 수있는 것이라면 뭐든지 가능하다.뷰 템플릿 경로src/main/resources/templates해당 경로에 있는 thymeleaf템플릿을 사용한 html code&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;p th:text=&quot;${data}&quot;&amp;gt;empty&amp;lt;/p&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;이제 3가지 방법을 통해 컨트롤러에서 저 페이지를 띄워볼 것이다.1.2.1 ModelAndView를 사용하기package hello.springmvc;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;@Controllerpublic class thymeleafTest { @RequestMapping(&quot;/kms-response-v1&quot;) public ModelAndView view1(){ ModelAndView modelAndView = new ModelAndView(&quot;/kms-thymeleaf&quot;) .addObject(&quot;data&quot;, &quot;kms가 만든 페이지&quot;); return modelAndView; }}3가지 방법을 쓰면서 지켜봐야할건 return 타입과, 인자다.ModelAndView 방식은 객체를 반환하게 되어있다. 따라서 새로운 객체를 생성해서 View이름과 데이터를 넣어준것이다.1.2.2 인자에 Model 사용하기package hello.springmvc;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;@Controllerpublic class thymeleafTest { @RequestMapping(&quot;/kms-response-v2&quot;) public String view2(Model model){ model.addAttribute(&quot;data&quot;,&quot;kms가 model을 이용해서 넘긴 페이지&quot;); return &quot;/kms-thymeleaf&quot;; }}리턴값은 String으로 뷰 이름을 넘겼다. 또한, 인자는 Model을 적어서 보내는 데이터를 추가하였다.마지막은 추천하지 않지만 소개를 하셨기에 소개하겠다.1.2.3 논리적 뷰와 요청 url의 경로가 같다면..생략이 가능하다.package hello.springmvc;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;@Controllerpublic class thymeleafTest { @RequestMapping(&quot;/kms-thymeleaf&quot;) public void view3(Model model){ model.addAttribute(&quot;data&quot;,&quot;kms가 만든 페이지\\n 이렇게 하면 void 타입으로 반환이 가능하다.&quot;); }}반환 타입이 없다.때로는 너무 명시적이지 않다면 협업시 의사소통이 별도로 필요해서 불편할 때가 있다.이러한 상황이다. 그리고 보안적으로 위험하다고 생각이 든다.참고로 이미 추가되어 있을 수 있지만, build.gradle 에서 다음과 같이 추가하면`implementation &#39;org.springframework.boot:spring-boot-starter-thymeleaf&#39;`스프링 부트가 자동으로 ThymeleafViewResolver와 필요한 스프링 빈들을 등록한다.또한, application.properties에 대한 설정도 자동으로 해준다.//application.propertiesspring.thymeleaf.prefix=classpath:/templates/spring.thymeleaf.suffix=.html따라서 논리적 뷰를 반환할 때 뒤에 .html을 안 붙여도 되는 이유이다.2. HTTP Response - HTTP API, 메시지 바디에 직접 입력앞에서 했던 내용들이지만 복습해야한다.응답메시지를 보낼때 뷰나 템플릿을 거치지 않고 직접 HTTP 응답 메시지를 작성하는 방법들이다.2.1 원시적인 방법 - HTTPServlet 사용package hello.springmvc.basic.response;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@Controllerpublic class ResponseController { @GetMapping(&quot;/kms-response-string-v1&quot;) public void responseBodyV1(HttpServletRequest request, HttpServletResponse response)throws IOException { response.getWriter().write(&quot;V1 ok&quot;); }}2.2 ResponseEntity&amp;lt;&amp;gt; 사용.package hello.springmvc.basic.response;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@Controllerpublic class ResponseController { @GetMapping(&quot;/kms-response-string-v2&quot;) public ResponseEntity&amp;lt;String&amp;gt; responseBodyV2(){ return new ResponseEntity&amp;lt;&amp;gt;(&quot;V2 ok&quot;, HttpStatus.OK); }}여기서 주목해야할 점은 내가 직접 HTTP 상태값을 바꿀 수 있다는 것이다. 즉 분기에 따라서 상태값들을 바꾸기 용이하다는 것이다.2.3 @ResponseBody 사용package hello.springmvc.basic.response;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@Controllerpublic class ResponseController { @ResponseBody @GetMapping(&quot;/kms-response-string-v3&quot;) public String responseBodyV3(){ return &quot;V3 ok&quot;; }}2.4 JSON 넘기기 - ResponseEntity 객체 사용package hello.springmvc.basic.response;import hello.springmvc.basic.BmiData;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@Controllerpublic class ResponseController { @GetMapping(&quot;/kms-response-json-v1&quot;) public ResponseEntity&amp;lt;BmiData&amp;gt; responseJsonV1(){ BmiData bmiData = new BmiData(); bmiData.setName(&quot;kms&quot;); bmiData.setHeight(178); bmiData.setWeight(74); return new ResponseEntity&amp;lt;&amp;gt;(bmiData,HttpStatus.OK); }}직접 객체를 만들고 그 객체에 값을 넣어서 반환한다.2.5 JSON 넘기기 - @ResponseBody 사용.package hello.springmvc.basic.response;import hello.springmvc.basic.BmiData;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@Controllerpublic class ResponseController { @ResponseBody @GetMapping(&quot;/kms-response-json-v2&quot;) public BmiData responseJsonV2(){ BmiData bmiData = new BmiData(); bmiData.setName(&quot;jyb&quot;); bmiData.setHeight(160); bmiData.setWeight(47); return bmiData; }}사실 이렇게만 보면 ResponseEntity가 더 좋아보인다. 왜? ResponseEntity는 개발자가 상태코드를 넣어줄 수 있었기 때문이다.@ResponseBody 는 그런 기능을 제공 안하는걸까? 그렇다. 대신 @ResponseStatus(HttpStatus.OK) 를 넣어주면 된다.요로콤 @ResponseStatus(HttpStatus.OK) @ResponseBody @GetMapping(&quot;/kms-response-json-v2&quot;) public BmiData responseJsonV2(){ BmiData bmiData = new BmiData(); bmiData.setName(&quot;jyb&quot;); bmiData.setHeight(160); bmiData.setWeight(47); return bmiData; }근데 이 역시도 한계가 있다. 코드 내에서 분기별로 상태코드를 줘야할 때 그러지 못한다는 점이다.2.6 @RestController@RestController@Controller 대신에 @RestController 애노테이션을 사용하면, 해당 컨트롤러에 모두@ResponseBody 가 적용되는 효과가 있다.따라서 뷰 템플릿을 사용하는 것이 아니라, HTTP 메시지 바디에 직접 데이터를 입력한다.이름 그대로 Rest API(HTTP API)를 만들 때 사용하는 컨트롤러이다.참고로 @ResponseBody 는 클래스 레벨에 두면 전체에 메서드에 적용되는데, @RestController에노테이션 안에 @ResponseBody 가 적용되어 있다.즉 위의코드의 통합본으로 밑과 같이 작성하면 전부 잘 동작한다는 것이다.무한으로 _@ResponseBody_를 쓰는 것을 줄여주고, 모든 메소드에 적용되기 때문에 API에 적합하다는 것이다. 어느 한 군데는 view를 반환해야한다면 쓸 수가 없기 때문이다.!package hello.springmvc.basic.response;import hello.springmvc.basic.BmiData;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.bind.annotation.ResponseStatus;import org.springframework.web.bind.annotation.RestController;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;//@Controller + @ResponseBody = @RestController@RestControllerpublic class ResponseController { @GetMapping(&quot;/kms-response-string-v1&quot;) public void responseBodyV1(HttpServletRequest request, HttpServletResponse response)throws IOException { response.getWriter().write(&quot;V1 ok&quot;); } @GetMapping(&quot;/kms-response-string-v2&quot;) public ResponseEntity&amp;lt;String&amp;gt; responseBodyV2(){ return new ResponseEntity&amp;lt;&amp;gt;(&quot;V2 ok&quot;, HttpStatus.OK); } @GetMapping(&quot;/kms-response-string-v3&quot;) public String responseBodyV3(){ return &quot;V3 ok&quot;; } @GetMapping(&quot;/kms-response-json-v1&quot;) public ResponseEntity&amp;lt;BmiData&amp;gt; responseJsonV1(){ BmiData bmiData = new BmiData(); bmiData.setName(&quot;kms&quot;); bmiData.setHeight(178); bmiData.setWeight(74); return new ResponseEntity&amp;lt;&amp;gt;(bmiData,HttpStatus.OK); } @ResponseStatus(HttpStatus.OK) @GetMapping(&quot;/kms-response-json-v2&quot;) public BmiData responseJsonV2(){ BmiData bmiData = new BmiData(); bmiData.setName(&quot;jyb&quot;); bmiData.setHeight(160); bmiData.setWeight(47); return bmiData; }}" }, { "title": "백엔드 웹 개발 노트6.4 - Spring MVC HTTP RequestBody", "url": "/posts/basicSpring6_4/", "categories": "Java, 6_Spring_김영한_스프링MVC 1편", "tags": "Spring", "date": "2022-04-28 15:50:50 +0900", "snippet": "HTTP Request BodyHTTP Request Message - 단순 텍스트요청 파라미터와 다르게 HTTP 바디를 통해서 데이터가 직접 데이터로 넘어오는 경우는 @RequestParam, _@ModelAttribute_를 사용할 수 없다.가장 원초적인 방법으로 텍스트를 읽는법을 알아보자.1. InputStream을 사용한 방법.package hello.springmvc.basic.request;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Controller;import org.springframework.util.StreamUtils;import org.springframework.web.bind.annotation.PostMapping;import javax.servlet.ServletInputStream;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.nio.charset.StandardCharsets;@Slf4j@Controllerpublic class RequestBodyController { @PostMapping(&quot;kms-request-body-mappingV1&quot;) public void requestbodyV1(HttpServletRequest request, HttpServletResponse response) throws IOException { ServletInputStream inputStream = request.getInputStream(); String messagebody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8); log.info(&quot;messagebody = {}&quot;,messagebody); response.getWriter().write(&quot;ok&quot;); }}결과불편한점이 있다. 클래스들의 이름이 너무 길다. 설정도 해줘야하고.. Spring에서는 이러한 설정들을 본인들이 직접하여 개발자가 편리하게 messagebody를 다룰 수 있도록 도와준다.2. InputStream, Writer를 이용한 방법.package hello.springmvc.basic.request;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Controller;import org.springframework.util.StreamUtils;import org.springframework.web.bind.annotation.PostMapping;import javax.servlet.ServletInputStream;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.InputStream;import java.io.Writer;import java.nio.charset.StandardCharsets;@Slf4j@Controllerpublic class RequestBodyController { @PostMapping(&quot;/kms-request-body-mappingV2&quot;) public void requestbodyV2(InputStream inputStream, Writer writer) throws IOException { String messagebody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8); log.info(&quot;v2 messagebody = {}&quot;,messagebody); writer.write(&quot;ok&quot;); }}스프링 MVC는 다음 파라미터를 지원한다. InputStream(Reader): HTTP 요청 메시지 바디의 내용을 직접 조회 OutputStream(Writer): HTTP 응답 메시지의 바디에 직접 결과 출력v1에서는 request에서 직접 꺼내서 썼다면, v2에서는 아예 꺼낸 Stream을 인자로 받아서 쓰고 있다는 점이다. 더 줄일 수 있을까? 있다.!!3. HttpEntity&amp;lt;&amp;gt; 이용한 방법.package hello.springmvc.basic.request;import lombok.extern.slf4j.Slf4j;import org.springframework.http.HttpEntity;import org.springframework.stereotype.Controller;import org.springframework.util.StreamUtils;import org.springframework.web.bind.annotation.PostMapping;import javax.servlet.ServletInputStream;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.InputStream;import java.io.Writer;import java.nio.charset.StandardCharsets;@Slf4j@Controllerpublic class RequestBodyController { @PostMapping(&quot;/kms-request-body-mappingV3&quot;) public HttpEntity&amp;lt;String&amp;gt; requestbodyV3(HttpEntity&amp;lt;String&amp;gt; httpEntity) { String messagebody = httpEntity.getBody(); log.info(&quot;v3 messagebody = {}&quot;,messagebody); return new HttpEntity&amp;lt;&amp;gt;(&quot;im kms OK&quot;); }}스프링 MVC가 지원하는 기능이다. HTTPEntity&amp;lt;&amp;gt;는 HTTP Header,body를 좀 더 편히 조회할 수 있게 도와준다. HTTPEntity&amp;lt;&amp;gt;는 응답용으로도 사용될 수 있다.HTTPEntity를 상속받은 객체들이 있는데, 이는 더 개발자가 요구하는 바를 더 명확하게 밝히고 기능이 강화되어있다.4. HttpEntity&amp;lt;&amp;gt;를 상속받은 RequestEntity, ResponseEntity객체package hello.springmvc.basic.request;import lombok.extern.slf4j.Slf4j;import org.springframework.http.HttpEntity;import org.springframework.http.HttpStatus;import org.springframework.http.RequestEntity;import org.springframework.http.ResponseEntity;import org.springframework.stereotype.Controller;import org.springframework.util.StreamUtils;import org.springframework.web.bind.annotation.PostMapping;import javax.servlet.ServletInputStream;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.InputStream;import java.io.Writer;import java.nio.charset.StandardCharsets;@Slf4j@Controllerpublic class RequestBodyController { @PostMapping(&quot;/kms-request-body-mappingV4&quot;) public HttpEntity&amp;lt;String&amp;gt; requestbodyV4(RequestEntity&amp;lt;String&amp;gt; requestEntity){ String messagebody = requestEntity.getBody(); log.info(&quot;v4 messagebody = {}&quot;,messagebody); return new ResponseEntity&amp;lt;String&amp;gt;(&quot;ok&quot;, HttpStatus.CREATED); }}이마저도 코드가 길어서 복잡하자. 더 줄여보자.5. @ResponseBody, @RequestBody 사용package hello.springmvc.basic.request;import lombok.extern.slf4j.Slf4j;import org.springframework.http.HttpEntity;import org.springframework.http.HttpStatus;import org.springframework.http.RequestEntity;import org.springframework.http.ResponseEntity;import org.springframework.stereotype.Controller;import org.springframework.util.StreamUtils;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.ServletInputStream;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.InputStream;import java.io.Writer;import java.nio.charset.StandardCharsets;@Slf4j@Controllerpublic class RequestBodyController { @ResponseBody @PostMapping(&quot;/kms-request-body-mappingV5&quot;) public String requestV5(@RequestBody String messagebody){ log.info(&quot;v5 messagebody = {}&quot;, messagebody); return &quot;v5 ok!!&quot;; }}코드가 굉장히 간결해졌다.이게 요즘 방식이다. @RequestBody@RequestBody 를 사용하면 HTTP 메시지 바디 정보를 편리하게 조회할 수 있다.참고로 헤더 정보가 필요하다면 HttpEntity 를 사용하거나 @RequestHeader 를 사용하면 된다.이렇게 메시지 바디를 직접 조회하는 기능은 요청 파라미터를 조회하는 @RequestParam ,@ModelAttribute 와는 전혀 관계가 없다. 요청 파라미터 vs HTTP 메시지 바디요청 파라미터를 조회하는 기능: @RequestParam , @ModelAttributeHTTP 메시지 바디를 직접 조회하는 기능: @RequestBody @ResponseBody @ResponseBody 를 사용하면 응답 결과를 HTTP 메시지 바디에 직접 담아서 전달할 수 있다.물론 이 경우에도 view를 사용하지 않는다.HTTP Request Message - JSONJSON 형태를 조회하는 방법을 알아볼 것이다.먼저 원시적인 방법을 보겠다.1. Servlet방식으로 JSON 조회package hello.springmvc.basic.request;import com.fasterxml.jackson.databind.ObjectMapper;import hello.springmvc.basic.BmiData;import lombok.extern.slf4j.Slf4j;import org.apache.catalina.mapper.Mapper;import org.springframework.stereotype.Controller;import org.springframework.util.StreamUtils;import org.springframework.web.bind.annotation.PostMapping;import javax.servlet.ServletInputStream;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.Writer;import java.nio.charset.StandardCharsets;@Slf4j@Controllerpublic class RequestBodyJSONController { private ObjectMapper mapper = new ObjectMapper(); @PostMapping(&quot;/kms-request-body-json-v1&quot;) public void requestBodyJsonV1(HttpServletRequest request, HttpServletResponse response) throws IOException{ ServletInputStream inputStream = request.getInputStream(); String messagebody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8); log.info(&quot;message = {}&quot;,messagebody); BmiData data = mapper.readValue(messagebody,BmiData.class); log.info(&quot;name = {}, height = {}, weight = {}&quot;,data.getName(),data.getHeight(),data.getWeight()); response.getWriter().write(&quot;ok&quot;); }}2. ResponseBody, RequestBody 사용.전통적인 방식이다. mapper를 통해 데이터를 넣고 그 데이터를 출력한다.줄이자.package hello.springmvc.basic.request;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import hello.springmvc.basic.BmiData;import lombok.extern.slf4j.Slf4j;import org.apache.catalina.mapper.Mapper;import org.springframework.stereotype.Controller;import org.springframework.util.StreamUtils;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.ServletInputStream;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.Writer;import java.nio.charset.StandardCharsets;@Slf4j@Controllerpublic class RequestBodyJSONController { private ObjectMapper mapper = new ObjectMapper(); @ResponseBody @PostMapping(&quot;/kms-request-body-json-v2&quot;) public String requestBodyJsonV2(@RequestBody String messagebody) throws JsonProcessingException { log.info(&quot;message = {}&quot;, messagebody); BmiData data = mapper.readValue(messagebody, BmiData.class); log.info(&quot;name = {}, height = {}, weight = {}&quot;,data.getName(),data.getHeight(),data.getWeight()); return &quot;json v2 ok&quot;; }}리턴값을 String으로 바꾸고 메소드 앞에 @ResponseBody 를달아줬다.또한, 파라미터에는 @RequestBody 를 달아줘서 body값을 직접 가져오도록 하였다.근데 이것도 불편하다. mapper에 너무 의존적이다. mapper를 안 쓸순 없을까? 있다.package hello.springmvc.basic.request;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import hello.springmvc.basic.BmiData;import lombok.extern.slf4j.Slf4j;import org.apache.catalina.mapper.Mapper;import org.springframework.stereotype.Controller;import org.springframework.util.StreamUtils;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.ServletInputStream;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.Writer;import java.nio.charset.StandardCharsets;@Slf4j@Controllerpublic class RequestBodyJSONController { @ResponseBody @PostMapping(&quot;/kms-request-body-json-v3&quot;) public String requestBodyJsonV3(@RequestBody BmiData data) { log.info(&quot;name = {}, height = {}, weight = {}&quot;,data.getName(),data.getHeight(),data.getWeight()); return &quot;json v3 ok&quot;; }}이처럼 @RequestBody 안에 객체를 넣어버리는 것이다. 단, 요청으로 들어오는 JSON Key의 이름과 객체의 필드 이름이 같아야 Spring의 HTTP 메시지컨버터가 이를 찾고 매핑해준다.참고로 @RequestBody 를 생략해버리면 스프링의 규칙에 따라 @ModelAttribute 가 적용된다. 즉 생략하면 HTTP 메시지 바디가 아니라 요청 파라미터로 처리해버린다. 요청을 일단 받았지만 모두 NULL의 형태가 들어감.3. HTTPEntity로 받기.package hello.springmvc.basic.request;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import hello.springmvc.basic.BmiData;import lombok.extern.slf4j.Slf4j;import org.apache.catalina.mapper.Mapper;import org.springframework.http.HttpEntity;import org.springframework.stereotype.Controller;import org.springframework.util.StreamUtils;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.ServletInputStream;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.Writer;import java.nio.charset.StandardCharsets;@Slf4j@Controllerpublic class RequestBodyJSONController { @ResponseBody @PostMapping(&quot;/kms-request-body-json-v4&quot;) public String requestBodyJsonV4(HttpEntity&amp;lt;BmiData&amp;gt; data) { BmiData body = data.getBody(); log.info(&quot;name = {}, height = {}, weight = {}&quot;,body.getName(),body.getHeight(),body.getWeight()); return &quot;json v4 ok&quot;; }}만약 JSON형태로 그대로 반환하고 싶으면 어떻게 할까?package hello.springmvc.basic.request;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import hello.springmvc.basic.BmiData;import lombok.extern.slf4j.Slf4j;import org.apache.catalina.mapper.Mapper;import org.springframework.http.HttpEntity;import org.springframework.stereotype.Controller;import org.springframework.util.StreamUtils;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.ServletInputStream;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.Writer;import java.nio.charset.StandardCharsets;@Slf4j@Controllerpublic class RequestBodyJSONController { @ResponseBody @PostMapping(&quot;/kms-request-body-json-v5&quot;) public BmiData requestBodyJsonV5(@RequestBody BmiData data) { log.info(&quot;name = {}, height = {}, weight = {}&quot;,data.getName(),data.getHeight(),data.getWeight()); return data; }}이렇게 리턴값에 클래스명과 리턴값으로 그냥 넘겨버리면 된다. @RequestBody 요청JSON 요청 -&amp;gt; HTTP 메시지 컨버터 -&amp;gt; 객체 @ResponseBody 응답객체 -&amp;gt; HTTP 메시지 컨버터 -&amp;gt; JSON 응답즉, HTTP 메시지 컨버터가 중간에서 원하는 데이터의 형태로 바꿔주는 역할을 한다.요청을 보낼때는 Content-Type이 application/json 이어야하고, 응답을 보낼때에는 Accept가 application/json이어야 한다.!!!" }, { "title": "백엔드 웹 개발 노트6.3 - Spring MVC HTTP Request", "url": "/posts/basicSpring6_3/", "categories": "Java, 6_Spring_김영한_스프링MVC 1편", "tags": "Spring", "date": "2022-04-28 14:50:50 +0900", "snippet": "1. HTTP 요청 파라미터 - 쿼리파라미터, HTML FORM클라이언트에서 서버로 요청 데이터를 전달할 때는 주로 다음 3가지 방법을 사용한다. GET - 쿼리 파라미터 메시지 바디 없이, URL의 쿼리 파라미터에 데이터를 포함해서 전달 /url?username=kms&amp;amp;hegiht=178 POST - HTML Form content-type:application/x-www-form-urlencoded 메시지 바디에 쿼리 파라미터 형식으로 전달함. HTTP message body에 데이터를 직접 담아서 요청 HTTP API에 주로 사용된다. JSON, XML, TEXT 데이터 형식은 주로 JSON이 사용된다. 1.1 GET,쿼리 파라미터로 전송.자바 파일을 만들자.package hello.springmvc.basic.request;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@Slf4j@Controllerpublic class RequestParamController { //기본적인 형태 @RequestMapping(&quot;/kms-request-param-v1&quot;) public void requestParamv1(HttpServletRequest request, HttpServletResponse response) throws IOException { String username = request.getParameter(&quot;username&quot;); int height = Integer.parseInt(request.getParameter(&quot;height&quot;)); log.info(&quot;username = {} , height = {}&quot;,username,height); response.getWriter().write(&quot;ok&quot;); }}기본적인 예제이다. http://localhost:8080/kms-request-param-v1?username=kms&amp;amp;height=178 으로 들어가면 된다.1.2 Post로 Form 전송전송하기 위해 html 파일을 만들어야한다.경로는 main/resources/static/basic/kms-from.html 이다.&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;form action=&quot;/kms-request-param-v1&quot; method=&quot;post&quot;&amp;gt; username: &amp;lt;input type=&quot;text&quot; name=&quot;username&quot; /&amp;gt; height: &amp;lt;input type=&quot;text&quot; name=&quot;height&quot; /&amp;gt; &amp;lt;button type=&quot;submit&quot;&amp;gt;전송&amp;lt;/button&amp;gt;&amp;lt;/form&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&amp;lt;localhost:8080/kms-request-param-v1&amp;gt; 으로 가면 입력폼에 입력하고 전송 버튼을 누르면위에서 작성한 java에서 요청값을 받아 로그에 잘 찍고 잘 받아온다.쿼리 파라미터와 다른 점은 뭘까?url에 데이터를 넣냐 html에 데이터 넣냐의 차이다.보안적으로 GET Query보다는 Post Form이 더 좋아보이지 않는가?GET은 데이터를 보낸다는 것 보다는 조회목적으로 쓰자.2. HTTP 요청 파라미터 - @RequestParam@RequestParam 애노테이션을 이용해서 요청 파라미터를 관리해보자.가장 기본적인 형태는 다음과 같다.package hello.springmvc.basic.request;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@Slf4j@Controllerpublic class RequestParamController { @ResponseBody @RequestMapping(&quot;/kms-request-param-v2&quot;) public String requestParamV2( @RequestParam(&quot;username&quot;) String myname, @RequestParam(&quot;height&quot;) int myheight ){ log.info(&quot;username = {} , height = {}&quot;,myname,myheight); return &quot;ok&quot;; }}@ResponseBody 를 사용해준 이유는 @Controller 애노테이션 때문에 리턴값으로 지정한 “ok”를 논리적 뷰 이름으로 판단하지 않게끔 하기 위해서이다. 이렇게 설정하면 @RestController 처럼 HTTP message body에 리턴값을 넣어버려 반환한다.뒤에서 설명할것!!만약 HTTP 요청 파라미터 이름이 변수 이름과 같다면 @RequestParam() 속성값을 생략할 수 있다.package hello.springmvc.basic.request;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@Slf4j@Controllerpublic class RequestParamController { @ResponseBody @RequestMapping(&quot;/kms-request-param-v3&quot;) public String requestParamV3( @RequestParam String username, @RequestParam int height ){ log.info(&quot;username = {} , height = {}&quot;,username,height); return &quot;ok&quot;; }}즉 url에서 요청을 보낼때 http://localhost:8080/kms-request-param-v3?username=kms&amp;amp;height=178 이런식으로 파라미터 이름과 @RequestParam 의 변수값이 같아야 한다.심지어 위와 같은 상황에서 @RequestParam 을 생략할수 있다. package hello.springmvc.basic.request;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@Slf4j@Controllerpublic class RequestParamController { @ResponseBody @RequestMapping(&quot;/kms-request-param-v4&quot;) public String requestParamV4(String username,int height){ log.info(&quot;username = {} , height = {}&quot;,username,height); return &quot;ok&quot;; }}이러한 방식은 팀원들끼리 협의가 되어있어야 한다. 너무 줄여서 헷갈릴수 있기 때문이다. @RequestParam 을 명시하여 요청 파라미터에서 데이터를 읽는 다는 것을 알 수 있다.2.1 파라미터 필수 여부 - requestParamRequiredpackage hello.springmvc.basic.request;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@Slf4j@Controllerpublic class RequestParamController { @ResponseBody @RequestMapping(&quot;/kms-request-param-required&quot;) public String requestParamRequired( @RequestParam(required = true) String username, @RequestParam(required = false) int height ){ log.info(&quot;username = {} , height = {}&quot;,username,height); return &quot;ok&quot;; }}@RequestParam 의 속성 값으로 ‘required = true’, ‘required = false’가 있다.딱봐도 username은 꼭 요청파라미터로 들어와야하고, height는 요청 파라미터로 없어도 된다는걸 알수 있다.다만, 여기서 주의할 점이 있다.요청 파라미터로,username=&amp;amp;height=178username&amp;amp;height=178라는 값이 들어오면 400(Bad request)가 뜰까??“ok”가 뜬다. 빈문자로 넣어버리기 때문이다.만약 height도 required = true로 놓고 ‘height=’나 ‘height’까지만 넣으면 어떻게 될까?400 error가 뜬다. 이유는 int로 선언해서 그렇다. int로 선언한 변수에는 NULL값을 넣지 못한다.여기서 필요한건 requestParamDefault 이다.2.1.1 기본값 적용 - requestParamDefaultpackage hello.springmvc.basic.request;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@Slf4j@Controllerpublic class RequestParamController { @ResponseBody @RequestMapping(&quot;/kms-request-param-required&quot;) public String requestParamRequired( @RequestParam(required = true, defaultValue =&quot;jyb&quot;) String username, @RequestParam(required = false, defaultValue = &quot;-1&quot;) int height ){ log.info(&quot;username = {} , height = {}&quot;,username,height); return &quot;ok&quot;; }}어떤 의미인지 직관적으로 알수 있다.요청 파라미터가 비어있다(NULL)면 username에는 ‘jyb’를 넣어주고, height에는 ‘-1’를 넣어준다.또한 파라미터를 Map으로 조회할 수 있다.2.2 requestParamMappackage hello.springmvc.basic.request;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.Map;@Slf4j@Controllerpublic class RequestParamController { @ResponseBody @RequestMapping(&quot;/kms-request-param-map&quot;) public String requestParamMap(@RequestParam Map&amp;lt;String,Object&amp;gt; paramMap){ log.info(&quot;username = {} , height = {}&quot;,paramMap.get(&quot;username&quot;),paramMap.get(&quot;height&quot;)); return &quot;ok&quot;; }}파라미터의 값이 1개가 확실하다면 Map 을 사용해도 되지만, 그렇지 않다면 MultiValueMap 을 사용하자.!3. HTTP 요청 파라미터 - @ModelAttribute실제 개발을 하다보면 요청파라미터를 받아서 필요한 객체를 만들고 그 객체에 값을 넣어줘야 한다. 보통 다음과 같이 코드를 작성할 것이다.package hello.springmvc.basic;import lombok.Data;@Datapublic class BmiData { private String name; private int height; private int weight;}BMI계산에 필요한 user객체이다.3.1 @Data 롬복에서 제공하는 애노테이션으로 @Getter, @Setter, @ToString, @EqualsAndHashCode, @RequiredArgsConstructor를 자동으로 제공한다.@ModelAttribute를 적용하면 더 편리하게 파라미터를 받을수 있다.package hello.springmvc.basic.request;import hello.springmvc.basic.BmiData;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.ModelAttribute;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.Map;@Slf4j@Controllerpublic class RequestParamController { @ResponseBody @RequestMapping(&quot;/kms-model-attribute-v1&quot;) public String modelAttributeV1(@ModelAttribute BmiData bmiData){ log.info(&quot;username = {} , height = {} , weight = {}&quot;,bmiData.getName(),bmiData.getHeight(),bmiData.getWeight()); return &quot;ok&quot;; }}결과보기에 너무 간편하지만 좀 더 직접적인 이유가 없을까?만약 저 3가지 변수를 RequestParam으로 받아온다면 코드가 얼마나 길어질지 감이 잡히는가?그렇기에 객체에 자동으로 넣어주는 @ModelAttribute 가 편한것이다.참고로 스프링 MVC는 @ModelAttribute 가 있으면 다음과 같이 실행한다. BmiData 객체 생성 요청 파라미터의 이름으로 BmiData 객체의 프로퍼티를 찾는다. 해당 프로퍼티의 setter를 호출해서 파라미터의 값을 바인딩한다.또한, 객체의 값을 수정하면 set~()함수가 호출되고 값을 조회하면 get~()함수가 호출된다.심지어 위 코드에서 @ModelAttribute 를 생략할 수 있다.@RequestParam 도 생략이 가능해서 스프링은 생략시 다음과 같은 규칙을 적용한다. String, int, Integer 같은 단순 타입 = @RequestParam 지정. 나머지는 @ModelAttribute(단, argument resolver로 지정해둔 타입 외 ex] HttpServeltResponse 등)" }, { "title": "백엔드 웹 개발 노트6.2 - 매핑", "url": "/posts/basicSpring6_2/", "categories": "Java, 6_Spring_김영한_스프링MVC 1편", "tags": "Spring", "date": "2022-04-28 13:50:50 +0900", "snippet": "1. 요청 매핑1.1 기본 매핑기본적인 형태의 매핑 방식이다.저번에 작성한 양식이랑 같다.package hello.springmvc.basic.reqeustmapping;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class MappingController { private Logger log = LoggerFactory.getLogger(getClass()); @RequestMapping(&quot;/kms-basic-request&quot;) public String basicreq(){ log.info(&quot;basic reqeust kms&quot;); return &quot;ok&quot;; }}그냥 “/kms-basic-reqeust”로 요청이 들어오면 로그로 string을 찍어주고 _@RestController_로 인해 웹에 ok를 뿌려주는 간단한 로직이다. 참고로 대부분의 속성을 배열[]로 제공하므로 다중 설정이 가능하다. ex) “/kms-basic-request , /kms-basic-requestMap” 다음 두 요청은 다른 URL이지만 스프링은 같은 요청으로 매핑한다. ex) “/kms-basic-request”, “/kms-basic-request/”1.2 HTTP 메서드 매핑 * method 특정 HTTP 메서드 요청만 허용 * GET, HEAD, POST, PUT, PATCH, DELETE */ @RequestMapping(value = &quot;/kms-mapping-get-v1&quot;, method = RequestMethod.GET) public String mappingGetv1(){ log.info(&quot;mappingGetv1&quot;); return &quot;ok&quot;; }애노테이션 값안에 method 파라미터를 달아줘서 요청을 지정해줄수 있다.즉 저 URL로 POST요청이 오면 스프링 MVC는 HTTP 405(Method Not Allowed)를 반환한다.사진을 보면 POST 요청을 보냈을 때 로그가 Warn로 해당 메서드는 지원하지 않는다고 로그를 찍는걸 볼수 있다.위에 로그들은 GET요청을 보냈을 때 정상적으로 로직이 수행된 것이다.1.3 HTTP 메서드 축약 /** * 편리한 축약 애노테이션 * @GetMapping * @PostMapping * @PutMapping * @DeleteMapping * @PatchMapping */ @GetMapping(value = &quot;/kms/mapping-get-v2&quot;) public String mappingGetv2(){ log.info(&quot;mappingGetv2&quot;); return &quot;ok&quot;; }즉, 위처럼 GetMapping 라는 애노테이션을 달아주면 @RequestMapping 에 method = RequestMethod.GET 을 써준거나 똑같아진다.1.4 PathVariable(경로 변수)최근 HTTP API는 리소스 경로에 식별자를 넣는 스타일을 선호한다. /mapping/userA (userA는 변수) /users/1 (1은 변수)이렇게 말이다.이렇게 경로에 변수가 있을때 꺼내게 해주는 애노테이션이 있다. /** * PathVariable 사용. * @param id * @return */ @GetMapping(&quot;/kms/mapping/{userId}&quot;) public String mappingPath(@PathVariable(&quot;userId&quot;) String id){ log.info(&quot;mapping path userId = {}&quot;,id); return &quot;ok&quot;; }@GetMapping 안에는 ‘{}’에 변수 값이 들어온다는 것을 알려주고 _@PathVariable 속성값으로 변수를 받아올 수 있다.참고로 @PathVariable 의 이름과 파라미터 이름이 같으면 생략할 수 있다.1.5 PathVariable 사용 - 다중 @GetMapping(&quot;/kms/mapping/{userId}/champion/{chamname}&quot;) public String mappingPath(@PathVariable String userId, @PathVariable String chamname){ log.info(&quot;mapping path userId = {}, champion name = {}&quot;,userId,chamname); return &quot;ok&quot;; }@PathVariable을 다중으로 사용했을때, 파라미터 이름이 같으면 속성값을 생략할 수 있다는 것을 보여주기 위해 만든 예제이다.자알된다.1.6 특정 파라미터 조건 매핑 /** * 파라미터로 추가 매핑 * parmas = &quot;lang&quot; * params =&quot;!lang&quot; * params = &quot;lang=java&quot; * params = &quot;lang!=java&quot; * params = {&quot;lang=java&quot;,&quot;name=&quot;kms&quot;} * 위와 같은 표현도 가능하다는 것. */ @GetMapping(value = &quot;/kms-mapping-param&quot;,params = &quot;lang=java&quot;) public String mappingParam(){ log.info(&quot;mappingParam&quot;); return &quot;ok&quot;; }이런식으로 작성하면 요청값에 꼭 “lang=java”라는 특정 파라미터 값이 들어와야한다.보다시피 ‘kms=kms’라는 쓰잘데기 없는 값을 추가해도 “ok”가 떨어진다.특정 파라미터 값이라는 ‘lang=java’를 없애보겠다.400에러뜬다.이런 기능이다.1.7 특정 헤더 조건 매핑 /** * 특정 헤더로 추가 매핑 * headers = &quot;champion&quot; * headers = &quot;!champion&quot; * headers = &quot;champion = vayne&quot; * headers = &quot;champion != vayne&quot; */ @GetMapping(value = &quot;/kms-mapping-headers&quot;, headers = &quot;champion=vayne&quot;) public String mappingHeader(){ log.info(&quot;mappingHeader&quot;); return &quot;ok&quot;; }파라미터 매핑과 비슷하지만, HTTP 헤더를 사용한다.champion 헤더와 그 값으로 vayne을 갖는 헤더를 추가해서 요청하면 ‘ok’가 떨어진다.1.8 미디어 타입 조건 매핑 - ContentType, consume /** * Content-Type 헤더 기반 추가 매핑 Media Type * consumes = &quot;application/json&quot; * consumes = &quot;!application/json&quot; * consumes = &quot;aplication/*&quot; * consumes = &quot;*\\/*&quot; * MediaType.APPLICATION_JSON_VALUE */ @PostMapping(value = &quot;/kms-mapping-consume&quot;, consumes = &quot;application/json&quot;) public String mappingConsumes(){ log.info(&quot;mappingConsumes&quot;); return &quot;ok&quot;; }1.9 미디어 타입 조건 매핑 Accept, produce /** * Accept 헤더 기반 Media Type * produces = &quot;text/html&quot; * produces = &quot;!text/html&quot; * produces = &quot;text/*&quot; * produces = &quot;*\\/*&quot; */ @PostMapping(value = &quot;/kms-mapping-produce&quot;, produces = &quot;text/html&quot;) public String mappingProduces() { log.info(&quot;mappingProduces&quot;); return &quot;ok&quot;; }consume과 비슷하게 produce는 Accept헤더를 보고 작동한다.1.9.1 Accept, Conent-Type Accept은 클라이언트가 선호하는 표현을 요청한다. 즉, 클라이언트 입장에서 응답을 받을때, Accept 헤더에 있는 데이터 타입이 오지 않으면 거절한다. 즉, 서버입장에서는 생성(produce)한 데이터 타입이 맞지 않으면 거절. Content-Type은 해당 헤더에 있는 데이터가 오지 않았을 경우 서버 입장에서 요청 거부 즉 서버는 헤더요청을 소비(consume)함. 2. 요청 매핑 - API 예시나는 롤을 많이했으므로 롤에 대해 예시를 들겠다.롤 챔피언 관리를 HTTP API로 만든다 생각하고 매핑을 어떻게 하는지 보자. 챔피언 목록 조회 : GET /champions 챔피언 등록 : POST /champions 챔피언 조회 : GET /champions/{championId} 챔피언 수정 : PATCH /champions/{championId} 챔피언 삭제 : DELETE /champions/{championId}package hello.springmvc.basic.reqeustmapping;import org.springframework.web.bind.annotation.*;@RestController@RequestMapping(&quot;/kms-mapping/champions&quot;)public class ChampionController { /** * GET /kms-mapping/champions */ @GetMapping public String champions(){ return &quot;get champions&quot;; } /** * POST /kms-mapping/champions */ @PostMapping public String addChampions(){ return &quot;post champions&quot;; } /** * GET /kms-mapping/champions/{champions} */ @GetMapping(&quot;/{championId}&quot;) public String findChampion(@PathVariable String championId){ return &quot;get championId :&quot; + championId; } /** * PATCH /kms-mapping/champions/{champions} */ @PatchMapping(&quot;/{championId}&quot;) public String updateChampion(@PathVariable String championId){ return &quot;patch championId : &quot; + championId; } /** * DELETE /kms-mapping */ @DeleteMapping(&quot;/{championId}&quot;) public String deleteChampion(@PathVariable String championId){ return &quot;delete championId : &quot; + championId; }}Postman으로 다 테스트하면 다 잘된다.3. 요청 매핑 - 기본, 헤더 조회이번에는 HTTP 헤더를 조회하는 방법을 알아보자.직관적이다.package hello.springmvc.basic.reqeustmapping;import lombok.extern.slf4j.Slf4j;import org.springframework.http.HttpMethod;import org.springframework.util.MultiValueMap;import org.springframework.web.bind.annotation.CookieValue;import org.springframework.web.bind.annotation.RequestHeader;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.Locale;@Slf4j@RestControllerpublic class RequestHeaderController { @RequestMapping(&quot;/headers&quot;) public String headers(HttpServletRequest request, HttpServletResponse response, HttpMethod httpMethod, Locale locale, @RequestHeader MultiValueMap&amp;lt;String,String&amp;gt; headerMap, @RequestHeader(&quot;host&quot;) String host, @CookieValue(value = &quot;kms-cookie&quot;,required = false) String cookie){ log.info(&quot;request = {}&quot;,request); log.info(&quot;response = {}&quot;,response); log.info(&quot;httpMethod = {}&quot;,httpMethod); log.info(&quot;Locale = {}&quot;,locale); log.info(&quot;headerMap = {}&quot;,headerMap); log.info(&quot;header host = {}&quot;,host); log.info(&quot;kms-cookie = {}&quot;,cookie); return &quot;ok&quot;; }}결과설명할 부분이 많지는 않다. 먼저, @RequestHeader MultiValueMap&amp;lt;String,String&amp;gt; headerMap 이부분에서 MultiValueMap이 뭔지 궁금하다. 크게 다른건 없다. 하나의 key와 여러 value를 갖는 맵이다. @RequestHeader(“host”) String host 는 특정 HTTP 헤더를 조회한다. @CookieValue 또한 특정 쿠키를 조회한다. 코드에는 쿠키설정 을 안 해줘서 null로 나온다." }, { "title": "백엔드 웹 개발 노트6.1 - 로깅", "url": "/posts/basicSpring6_1/", "categories": "Java, 6_Spring_김영한_스프링MVC 1편", "tags": "Spring", "date": "2022-04-28 12:50:50 +0900", "snippet": "로깅로그를 왜 사용할까?보통 운영 시스템에서는 System.out.println() 같은 시스템 콘솔을 사용해서 정보를 출력하지 않고 로깅 라이브러리를 사용해서 로그를 출력한다.스프링 부트 로깅 라이브러리는 기본으로 SLF4J, Logback이라는 로깅 라이브러리를 사용한다.로그 라이브러리는 Logback, Log4J, Log4J2 등 수많은 라이브러리가 있는데, 그것을 통합해서 인터페이스로 제공하는 것이 SLF4J이다.Logback을 사용해보자.테스트 컨트롤러를 하나 작성하겠다.package hello.springmvc.basic;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class LogTestController { private final Logger log = LoggerFactory.getLogger(getClass()); @RequestMapping(&quot;/log-test&quot;) public String logTest(){ String name = &quot;Log test Project by Kms&quot;; log.trace(&quot;trace log ={}&quot;,name); log.debug(&quot;debug log ={}&quot;,name); log.info(&quot;info log = {}&quot;,name); log.warn(&quot;info log = {}&quot;,name); log.error(&quot;error log = {}&quot;,name); //다른 방식. 이런식으로 사용하지 말자. 계산 로직이 먼저 실행되어서 불필요한 CPU, 메모리 사용으로 이어질 수 있다. log.debug(&quot;String concat log = &quot; + name); return &quot;ok&quot;; }}하나하나 설명하겠다.RestController @Controller와 달리 리턴 String이 뷰 이름이 아닌 HTTP 메시지 바디에 바로 입력해버린다. 그렇기에 실행 결과로 “ok”가 출력된 것.log.debug 연산 log.debug(“String concat log = “ + name) 의 코드를 봐라. 이런식으로 짜면 안 된다. 로그를 출력하기 전에 먼저 저 문자열을 합쳐버리는 연산을 수행하기 때문이다.결과보면, info ~ / warn ~ / error ~ 로 로그가 정상출력된 것을 볼 수 있다.로그 출력 포맷을 보면 시간 + 로그 레벨 + 프로세스 ID + 쓰레드 이름 + 클래스명 + 로그메시지 순으로 보여준다.보통 개발 서버는 debug 수준, 운영 서버는 info 수준으로 로그를 출력한다.여기서 debug 수준 infd 수준이라고 함은 로그 레벨을 설정해줄 수 있고 출력범위를 지정해줄 수 있다.TRACE &amp;gt; DEBUG &amp;gt; INFO &amp;gt; WARN &amp;gt; ERROR 순으로 로그 레벨이 포괄적이다.WARN로 설정하면 ERROR와 WARN만 보여주고, INFO로 설정하면 INFO와 WARN, ERROR를 보여주는 것이다.설정 파일을 건드려서 log 레벨을 지정해줄 수 있다.#전체 로그 레벨 설정(기본 infologging.level.root=info#내가 만든 패키지와 그 하위 로그 레벨 설정.logging.level.hello.springmvc=debug참고로 밑의 경로가 더 세부적이라 우선순위는 밑의 설정을 따른다.보면 Debug수준의 로그까지 보여주는걸 볼 수 있다.자 로그를 왜 쓸까? 쓰레드 정보, 클래스 이름 같은 부가 정보를 볼 수 있고, 출력 모양을 조정할 수 있다. 로그 레벨에 따라 출력을 지정할 수 있으므로 상황에 따라 유연하게 조절 가능하다. 로그의 기능 중 따로 파일에 저장하는 기능도 있는데, 해당 기능을 통하여 네트워크 등 로그를 별도의 위치에 남길 수 있다. 또한 파일이 커지면 자동으로 분할 및 압축시켜버릴 수도 있다. 그냥 성능이 System.out보다 더 좋다. (내부 버퍼링, 멀티 쓰레드 등등) 그래서 실무에서는 꼭 로그를 사용해야 한다." }, { "title": "백엔드 웹 개발 노트5.4 - 스프링MVC 기초", "url": "/posts/basicSpring5_4/", "categories": "Java, 6_Spring_김영한_스프링MVC 1편", "tags": "Spring", "date": "2022-04-28 11:50:50 +0900", "snippet": "스프링MVC 스타트스프링이 제공하는 컨트롤러는 애노테이션 기반으로 동작한다. 매우 유연하고 실용적임.옛날에는 스프링 프레임워크가 MVC부분이 약해서 스프링을 사용하더라도 MVC 웹 기술은 스트럿츠 같은 다른 프레임워크를 사용했다고 한다.하지만, @RequestMapping 기반의 애노테이션 컨트롤러가 등장하면서 MVC도 스프링의 완승으로 끝나버렸다.@RequestMapping이 애노테이션은 RequestMappingHandlerMapping 과 RequestMappingHandlerAdapter 를 포함한다.한 번 기존 코드를 바꿔보도록 하겠다.1. SpringMemberFormController - 회원 등록 폼package hello.servlet.web.v1;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;@Controllerpublic class SpringMemberFormControllerV1 { @RequestMapping(&quot;/kms/springmvc/v1/members/new-form&quot;) public ModelAndView process(){ return new ModelAndView(&quot;new-form&quot;); }}참고로 위의 논리뷰에 해당되는 페이지는 작성이 되어 있어야 한다.이런 식으로new-form.jsp파일.&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt; &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;!-- 상대경로 사용할 것. 계속 수정해줄 것임. --&amp;gt;&amp;lt;form action=&quot;save&quot; method=&quot;post&quot;&amp;gt; username : &amp;lt;input type=&quot;text&quot; name=&quot;username&quot;&amp;gt; height : &amp;lt;input type=&quot;text&quot; name=&quot;height&quot;&amp;gt; weight : &amp;lt;input type=&quot;text&quot; name=&quot;weight&quot;&amp;gt; &amp;lt;button type=&quot;submit&quot;&amp;gt;전송&amp;lt;/button&amp;gt;&amp;lt;/form&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;아무튼 실행하면 성공이다.@Controller 스프링이 자동으로 스프링 빈으로 등록한다. (내부에 @Component 애노테이션이 있어서 컴포넌트 스캔의 대상이 된다.!) 스프링MVC에서 애노테이션 기반 컨트롤러로 인식(저번에 설명한 우선순위가 높다는 뜻)@RequestMapping 요청 정보를 매핑한다. 해당 URL이 호출되면 이 메서드가 호출된다. 애노테이션 기반으로 동작하기 때문에, 메서드의 이름은 임의로 지으면 된다.ModelAndVeiw 모델과 뷰 정보를 담아서 반환한다.참고로 RequestMappingHandlerMapping 은 스프링 빈 중에서 @RequestMapping 또는 @Controller 가 클래스 레벨에 붙어있는 경우에 매핑 정보로 인식.따라서 다음 코드도 동일하게 작동한다.package hello.servlet.web.v1;import org.springframework.stereotype.Component;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;@Component@RequestMappingpublic class SpringMemberFormControllerV1 { @RequestMapping(&quot;/kms/springmvc/v1/members/new-form&quot;) public ModelAndView process(){ return new ModelAndView(&quot;new-form&quot;); }}또한, 컴포넌트 스캔을 안 쓰고 직접 빈에 등록해도 동작한다.다음은 기존에 작성했던 회원 저장 폼을 바꿔보겠다.2. SpringMemberSaveController - 회원 저장package hello.servlet.web.v1;import hello.servlet.basic.domain.Member;import hello.servlet.basic.domain.MemberRepository;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@Controllerpublic class SpringMemberSaveControllerV1 { private MemberRepository memberRepository = MemberRepository.getInstance(); @RequestMapping(&quot;/kms/springmvc/v1/members/save&quot;) public ModelAndView process(HttpServletRequest request, HttpServletResponse response){ //요청 정보를 가져옴. String username = request.getParameter(&quot;username&quot;); int height = Integer.parseInt(request.getParameter(&quot;height&quot;)); int weight = Integer.parseInt(request.getParameter(&quot;weight&quot;)); Member member = new Member(username,height,weight); memberRepository.save(member); ModelAndView mv = new ModelAndView(&quot;save-result&quot;); //객체를 넣음 mv.addObject(&quot;member&quot;,member); return mv; }}객체를 넣고 ModelAndView 객체를 반환한다는 것 말고는 특이 사항이 없다. 파라미터 값으로 request와 response를 받는다.3. SpringMemberListControllerV1 - 회원 목록package hello.servlet.web.v1;import hello.servlet.basic.domain.Member;import hello.servlet.basic.domain.MemberRepository;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import java.util.List;@Controllerpublic class SpringMemberListControllerV1 { private MemberRepository memberRepository = MemberRepository.getInstance(); @RequestMapping(&quot;/kms/springmvc/v1/members&quot;) public ModelAndView process(){ List&amp;lt;Member&amp;gt; members = memberRepository.findByAll(); ModelAndView mv = new ModelAndView(&quot;members&quot;); mv.addObject(&quot;members&quot;,members); return mv; }}어려운 내용은 없다.다만, List코드에서 mv를 반환했는데, 어떤 동작방식으로 흘러가길래 뷰까지 처리하는걸까? 뒤에서 알아볼 것이다.일단 하나의 컨트롤러에 몰아넣어보자.컨트롤러 통합 ControllerV2package hello.servlet.web.v2;import hello.servlet.basic.domain.Member;import hello.servlet.basic.domain.MemberRepository;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.List;@Controllerpublic class SpringMemberControllerV2 { private MemberRepository memberRepository = MemberRepository.getInstance(); @RequestMapping(&quot;/kms/springmvc/v2/members/new-form&quot;) public ModelAndView newform(){ return new ModelAndView(&quot;new-form&quot;); } @RequestMapping(&quot;/kms/springmvc/v2/members&quot;) public ModelAndView members(){ List&amp;lt;Member&amp;gt; members = memberRepository.findByAll(); ModelAndView mv = new ModelAndView(&quot;members&quot;); mv.addObject(&quot;members&quot;,members); return mv; } @RequestMapping(&quot;/kms/springmvc/v2/members/save&quot;) public ModelAndView save(HttpServletRequest request, HttpServletResponse response){ //요청 정보를 가져옴. String username = request.getParameter(&quot;username&quot;); int height = Integer.parseInt(request.getParameter(&quot;height&quot;)); int weight = Integer.parseInt(request.getParameter(&quot;weight&quot;)); Member member = new Member(username,height,weight); memberRepository.save(member); ModelAndView mv = new ModelAndView(&quot;save-result&quot;); //객체를 넣음 mv.addObject(&quot;member&quot;,member); return mv; }}그냥 다 복붙했다. 물론 URL경로는 수정해주었다.확인해볼 것도 없이 잘 돌아간다.하지만, 매 번 RequestMapping()을 넣는건 번거롭다. 클래스단위로 바꿔서 수정해보자.@Controller@RequestMapping(&quot;/kms/springmvc/v2/members&quot;)public class SpringMemberControllerV2 {@RequestMapping(&quot;/new-form&quot;) public ModelAndView newform(){ ... } @RequestMapping() public ModelAndView members(){ ... } @RequestMapping(&quot;/save&quot;) public ModelAndView save(HttpServletRequest request, HttpServletResponse response){ ... }}요로콤 수정해주면 잘 돌아간다.결국 근데 코드에서 ModelAndView라는 객체를 매 번 생성해줘서 작업을 해주고 있다.이를 바꿔볼 것이다.새로운 자바 코드를 만들어서 다음과 같이 수정하자.컨트롤러 리팩토링 ControllerV3@Controller@RequestMapping(&quot;/kms/springmvc/v3/members&quot;)public class SpringMemberControllerV3 { private MemberRepository memberRepository = MemberRepository.getInstance(); @RequestMapping(&quot;/new-form&quot;) public String newform(){ return &quot;new-form&quot;; } @RequestMapping() public String members(Model model){ List&amp;lt;Member&amp;gt; members = memberRepository.findByAll(); model.addAttribute(&quot;members&quot;,members); return &quot;members&quot;; } @RequestMapping(&quot;/save&quot;) public String save( @RequestParam(&quot;username&quot;) String username, @RequestParam(&quot;height&quot;) int height, @RequestParam(&quot;weight&quot;) int weight, Model model ){ Member member = new Member(username,height,weight); memberRepository.save(member); model.addAttribute(&quot;member&quot;,member); return &quot;save-result&quot;; }}먼저, 기존에 리턴값이 ModelAndView인거와 달리 String으로 논리적 뷰 이름을 전달하게 바꾸었다.또한, Model이라는 객체를 통해 ModelAndView를 따로 생성하지 않게 되었다.@RequestParam 이라는 애노테이션 덕분에 request, response객체를 파라미터로 넘길 필요가 없어졌고, 형변환또한 스프링에게 맡길 수 있게 되었다.결과를 보자.잘된다.근데 이것도 불편한 부분이 있다.요청을 아무거나 받는다는 것이다.Restful하게 짜려면 어떤 요청에 대해서 Get만 받고, Post만 받는건 당연한건데 위의 방식은 Get이고 Post고 뭐고 요청만 보내면 다 받아버린다는 것이다.이렇게 해결하자.@RequestMapping 애노테이션에 명시를 해주는 것이다. @RequestMapping(value = &quot;/new-form&quot; ,method = RequestMethod.GET) public String newform(){ ... } @RequestMapping(method = RequestMethod.GET) public String members(Model model){ ... } @RequestMapping(value = &quot;/save&quot;,method = RequestMethod.POST) public String save( @RequestParam(&quot;username&quot;) String username, @RequestParam(&quot;height&quot;) int height, @RequestParam(&quot;weight&quot;) int weight, Model model ){ ... }요로콤 method 를 작성해주면 아무요청이나 받지않는다. Postman에서 확인할 수 있다.근데 이 마저도 불편한 점이 있다.@RequestMapping 의 구문이 길어져서 치기 힘들다는 것이다. 이것도 고쳐버리자. @GetMapping(value = &quot;/new-form&quot;) public String newform(){ ... } @GetMapping public String members(Model model){ ... } @PostMapping(value = &quot;/save&quot;) public String save( @RequestParam(&quot;username&quot;) String username, @RequestParam(&quot;height&quot;) int height, @RequestParam(&quot;weight&quot;) int weight, Model model ){ ... }@GetMapping 과 @PostMapping 를 사용해서 더 편리하게 코드를 작성할 수 있다.참고로 @GetMapping 에 들어가보면 다음과 같이 따로 적어뒀던 구문이 애노테이션으로 적혀있다." }, { "title": "백엔드 웹 개발 노트5.3 - 뷰 리졸버", "url": "/posts/basicSpring5_3/", "categories": "Java, 6_Spring_김영한_스프링MVC 1편", "tags": "Spring", "date": "2022-04-28 11:50:50 +0900", "snippet": "뷰 리졸버전에 작성한 OldController를 View를 조회할 수 있게 수정할 것이다.System.out.println(&quot;OldController.handlerRequest&quot;);return new ModelAndView(&quot;new-form&quot;);리턴값만 수정해주었다. 다시 실행해보면 ‘Whitelabel Error Page’가 뜨면서 콘솔에는 문자열이 찍힐 것이다.application.properties에서 다음과 같이 코드를 추가해주면?spring.mvc.view.prefix=/WEB-INF/views/spring.mvc.view.suffix=.jsp다시 실행해보면내가 예전에 작성한 페이지가 뜬다.왜 그런걸까?스프링 부트는 InternalResourceViewResolver라는 뷰 리졸버를 자동으로 등록하는데, 이때 application.properties에 등록한 spring.mvc.view.prefix, spring.mvc.view.suffix 설정정보를 사용해서 등록한다.권장하지 않지만 사실상 이렇게 경로를 주어도 동작은한다.return new ModelAndView(&quot;/WEB-INF/views/new-form.jsp&quot;);뷰 리졸버도 우선순위에 따라 스프링 부트가 찾는다.(생략된 부분이 많다.)1 = BeanNameViewResolver : 빈 이름으로 뷰를 찾아서 반환한다.2 = InternalResourceViewResolver : JSP를 처리할 수 있는 뷰를 반환한다.위 코드같은 경우 빈 이름을 지정해주지 않았으므로 2번인 InternalResourceViewResolver에서 찾게 된다.흐름을 알아보자. 핸들러 어댑터를 통해 new-form이라는 논리 뷰 이름을 획득. new-form이라는 뷰 이름으로 viewResolver를 순서대로 호출하는데, 빈 이름으로 등록되지 않았으므로 타고타고 내려가다가 InternalResourceViewResolver가 호출 InternalResourceViewResolver는 InternalResourceView를 반환한다. InternalResourceView는 JSP처럼 forward()를 호출해서 처리할 수 있는 경우에 사용한다. view.render()가 호출되고, InternalResourceView는 forward()를 사용해서 JSP를 실행한다.참고로 JSP를 제외한 나머지 뷰 템플릿들은 forward() 과정 없이 바로 렌더링된다." }, { "title": "백엔드 웹 개발 노트5.2 - 핸들러 매핑과 핸들러 어댑터", "url": "/posts/basicSpring5_2/", "categories": "Java, 6_Spring_김영한_스프링MVC 1편", "tags": "Spring", "date": "2022-04-28 10:50:50 +0900", "snippet": "핸들러 매핑과 핸들러 어댑터과거에 주로 사용했던 스프링이 제공하는 간단한 컨트롤러로 핸들러 매핑과 어댑터를 이해해보도록 하겠다.과거 버전 스프링 컨트롤러코드를 하나 작성하자.package hello.servlet.web.Controller;import org.springframework.stereotype.Component;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.Controller;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;//스프링빈에 등록함.@Component(&quot;/springmvc/old-controller&quot;)public class OldController implements Controller { @Override public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception { System.out.println(&quot;OldController.handlerRequest&quot;); return null; }}참고로 상속받은 Controller는 @Controller와 다르다.!실행하고 해당 url로 가면 다음과 같이 공백이 화면 공백이 뜨면 성공이다.디버그창에 우리가 콘솔에 출력한게 찍힌다.왜 이런 일이 벌어진걸까?컨트롤러가 호출되려면 2가지가 필요하다. HandlerMapping(핸들러 매핑) HandlerAdapter(핸들러 어댑터)그럼 먼저, 핸들러 매핑은 어떻게 핸들러를 찾을까?많은 방법이 있지만 짤막하게 다음과 같은 우선순위를 갖는다.0 = RequestMappingHandlerMapping : 애노테이션 기반 컨트롤러인 @RequestMapping에서 찾는다.1 = BeanNameUrlHandlerMapping : 스프링 빈의 이름으로 핸들러를 찾는다.Component로 스프링 빈의 이름을 url을 지정했다. 그렇기에 핸들러 매핑을 할 수 있었던 것이다. 따라서 작성한 OldController가 반환된다.핸들러 어댑터를 조회하는 방식에도 다음과 같은 우선순위를 갖는다.0 = RequestMappingHandlerAdapter : 애노테이션 기반 컨트롤러인 @RequestMapping에서 찾는다.1 = HttpReqeustHandlerAdapter : HttpRequestHandler 처리2 = SimpleControllerHandlerAdapter : Controller 인터페이스 처리즉 우리는 2번인 SimpleControllerHandlerAdapter룰의 따라 핸들러 어댑터를 조회할 수 있다.디스패처 서블릿이 조회한 SimpleControllerHandlerAdapter를 실행하면서 핸들러 정보도 함께 넘겨준다. SimpleControllerHandlerAdapter는 핸들러인 OldController를 내부에서 실행하고, 그 결과를 반환한다. 즉, 우리는 콘솔에 문자를 찍었으므로 문자를 찍는다.HttpRequestHandler라는 핸들러도 알아보자. 이 핸들러는 서블릿과 가장 유사한 형태의 핸들러라고 한다.코드는 다음과 같이 되어있다.public interface HttpRequestHandler {void handleRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException;}이제 구현하기 위해 간단한 자바파일을 만들자.!!HttpRequestHandler 구현package hello.servlet.web.old;import org.springframework.stereotype.Component;import org.springframework.web.HttpRequestHandler;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@Component(&quot;/springmvc/kms_request-handler&quot;)public class MyHttpRequestHandler implements HttpRequestHandler { @Override public void handleRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(&quot;MyHttpRequestHandler.handleReqeust!!!!!&quot;); }}실행방법이나 확인방법은 위의 과거 스프링컨트롤러 방식과 같으므로 따로 첨부하지는 않겠다.위의 컨트롤러에서 흐름을 따라간것 처럼 따라가 보겠다. HandlerMapping을 순서대로 실행해서 핸들러를 찾아야한다. 이 경우 RequestMapping도 없고 우선순위에 밀려서 빈의 이름으로 핸들러를 찾게 되는데 ‘BeanNameUrlHandlerMapping’이 실행에 성공하고 핸들러인 MyHttpRequestHandler를 반환한다. HandlerAdapter의 support()를 순서대로 호출한다. 이때 ‘HttpRequestHandlerAdapter’가 HttpRequestHandler 인터페이스를 지원하므로 대상이 된다. 디스패처 서블릿이 조회한 HttpRequestHandlerAdapter를 싱행하면서 핸들러 정보도 함께 넘겨준다. HttpRequestHandlerAdapter는 핸들러인 MyHttpRequestHandler를 내부에서 실행하여 내가 작성한 코드인 콘솔에 문자를 찍고 그 결과를 반환한다.결론하지만 결국 우선순위가 가장 높은 핸들러 매핑과 핸들러 어댑터는RequestMappingHandlerMapping RequestMappingHandlerAdatper이다." }, { "title": "백엔드 웹 개발 노트5.1 - 스프링MVC전체구조", "url": "/posts/basicSpring5_1/", "categories": "Java, 6_Spring_김영한_스프링MVC 1편", "tags": "Spring", "date": "2022-04-28 09:50:50 +0900", "snippet": "스프링 MVC 구조보면은 여태까지 작성한 구조와 비슷하다.다음과 같이 매칭된다. FrontController -&amp;gt; DispatcherServlet handlerMappingMap -&amp;gt; HandlerMapping MyHandlerAdapter -&amp;gt; HandlerAdapter Modelview -&amp;gt; ModelAndView viewResolver -&amp;gt; ViewResolver MyView -&amp;gt; View결국 핵심은 DsipathcerServlet인데, 이 서블릿은 부모 클래스에서 HttpServlet을 상속 받아서 사용되기에 서블릿으로 동작된다.스프링부트는 자동으로 DispatcherServlet을 서블릿으로 자동으로 등록하면서 urlPattern=”/”에 대해서 매핑한다.!이 스프링MVC의 요청흐름은 직접 작성한 코드와 비슷하게 동작한다. HttpServlet이 제공하는 service()가 호출 근데, DispatcherServelt의 부모에서 service()를 오버라이드 했기에 이를 호출. 오버라이드된 service()가 호출되면서 여러 메서드가 호출되는데 DispatcherServlet.doDispatch()가 호출됨. doDispatch()는 직접 작성한 코드와 비슷하게 동작한다는 것이다.한 번 봐보길 바란다. 원래 한 곳에 뭉쳐 있었지만, 최근 코드를 보니 렌더부분을 따로 나눠버렸다.위의 그림과 아무튼 비슷하게 동작한다는 것.회사에서 강의 보고 다시 정리하려니 좀 귀찮네.." }, { "title": "백엔드 웹 개발 노트4.5 - MVC 역사5 Adapter", "url": "/posts/basicSpring4_5/", "categories": "Java, 6_Spring_김영한_스프링MVC 1편", "tags": "Spring", "date": "2022-04-28 08:50:50 +0900", "snippet": "Adapter 패턴 구현 v3Controller를 다형성을 이용해서 다양한 Controller를 호출할 수 있게 하자. 출처 김영한 선생님 강의 핸들러 어댑터 : 중간에 어댑터 역할을 하는 어댑터이다. 다양한 종류의 컨트롤러를 호출할 수 있게 한다. 핸들러 : 컨트롤러의 이름을 더 넓은 범위인 핸들러로 변경.먼저 어댑터 인터페이스를 만들어주자.1. MyHandlerAdapterpackage hello.servlet.web.frontcontroller.v5;import hello.servlet.web.frontcontroller.ModelView;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public interface MyHandlerAdapter { boolean supports(Object handler); ModelView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws ServletException, IOException;}앞에서 구현했던 ControllerV3을 지원하는 어댑터를 만들 것이다.2. ControllerV3HandlerAdapterpackage hello.servlet.web.frontcontroller.v5.adapter;import hello.servlet.web.frontcontroller.ModelView;import hello.servlet.web.frontcontroller.v3.ControllerV3;import hello.servlet.web.frontcontroller.v5.MyHandlerAdapter;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.HashMap;import java.util.Map;public class ControllerV3HandlerAdapter implements MyHandlerAdapter { @Override public boolean supports(Object handler) { return (handler instanceof ControllerV3); } @Override public ModelView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws ServletException, IOException { ControllerV3 controller = (ControllerV3) handler; Map&amp;lt;String,String&amp;gt; paramMap = createParamMap(request); ModelView mv = controller.process(paramMap); return mv; } private Map&amp;lt;String, String&amp;gt; createParamMap(HttpServletRequest request) { Map&amp;lt;String,String&amp;gt; paramMap = new HashMap&amp;lt;&amp;gt;(); request.getParameterNames().asIterator() .forEachRemaining(paramName -&amp;gt; paramMap.put(paramName,request.getParameter(paramName))); return paramMap; }}3. FrontControllerServletV5package hello.servlet.web.frontcontroller.v5;import hello.servlet.web.frontcontroller.ModelView;import hello.servlet.web.frontcontroller.MyView;import hello.servlet.web.frontcontroller.v1.ControllerV1;import hello.servlet.web.frontcontroller.v3.ControllerV3;import hello.servlet.web.frontcontroller.v3.controller.MemberFormControllerV3;import hello.servlet.web.frontcontroller.v3.controller.MemberListControllerV3;import hello.servlet.web.frontcontroller.v3.controller.MemberSaveControllerV3;import hello.servlet.web.frontcontroller.v5.adapter.ControllerV3HandlerAdapter;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;@WebServlet(name = &quot;frontControllerServletV5&quot;, urlPatterns = &quot;/front-controller/v5/*&quot;)public class FrontControllerServletV5 extends HttpServlet { private final Map&amp;lt;String,Object&amp;gt; handlerMappingMap = new HashMap&amp;lt;&amp;gt;(); private final List&amp;lt;MyHandlerAdapter&amp;gt; handlerAdapters = new ArrayList&amp;lt;&amp;gt;(); //생성자 public FrontControllerServletV5() { initHandlerMappingMap(); initHandlerAdapters(); } private void initHandlerMappingMap(){ handlerMappingMap.put(&quot;/front-controller/v5/v3/members/new-form&quot;,new MemberFormControllerV3()); handlerMappingMap.put(&quot;/front-controller/v5/v3/members/save&quot;,new MemberSaveControllerV3()); handlerMappingMap.put(&quot;/front-controller/v5/v3/members&quot; ,new MemberListControllerV3()); } private void initHandlerAdapters() { handlerAdapters.add(new ControllerV3HandlerAdapter()); } @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { Object handler = getHandler(request); if(handler == null){ response.setStatus(HttpServletResponse.SC_NOT_FOUND); return; } MyHandlerAdapter adapter = getHandlerAdapter(handler); ModelView mv = adapter.handle(request, response, handler); MyView view = viewResolver(mv.getViewName()); view.render(mv.getModel(),request,response); } private Object getHandler(HttpServletRequest request){ String requestURI = request.getRequestURI(); return handlerMappingMap.get(requestURI); } private MyHandlerAdapter getHandlerAdapter(Object handler) { for (MyHandlerAdapter adapter : handlerAdapters) { if(adapter.supports(handler)) return adapter; } throw new IllegalArgumentException(&quot;handler adapter를 찾을 수 없습니다. handler = &quot; + handler); } private MyView viewResolver(String viewName) { return new MyView(&quot;/WEB-INF/views/&quot; + viewName + &quot;.jsp&quot;); }}정리는 마지막에 이 챕터를 마무리하고 추가하겠다.일단 진행하겠다.!!Adapter 패턴 구현 v4어댑터의 힘을 느껴보자.FrontControllerServletV5생성자에 V4에 대한 정보만 추가해주면 된다.private void initHandlerMappingMap(){ handlerMappingMap.put(&quot;/front-controller/v5/v3/members/new-form&quot;,new MemberFormControllerV3()); handlerMappingMap.put(&quot;/front-controller/v5/v3/members/save&quot;,new MemberSaveControllerV3()); handlerMappingMap.put(&quot;/front-controller/v5/v3/members&quot; ,new MemberListControllerV3()); //v4 추가 handlerMappingMap.put(&quot;/front-controller/v5/v4/members/new-form&quot;,new MemberFormControllerV4()); handlerMappingMap.put(&quot;/front-controller/v5/v4/members/save&quot;,new MemberSaveControllerV4()); handlerMappingMap.put(&quot;/front-controller/v5/v4/members&quot; ,new MemberListControllerV4());}private void initHandlerAdapters() { handlerAdapters.add(new ControllerV3HandlerAdapter()); //추가 handlerAdapters.add(new ControllerV4HandlerAdapter()); }V4 어댑터에 관한 코드를 추가해주기 위해 새로운 자바 파일을 만들자.ControllerV4HandlerAdapterpackage hello.servlet.web.frontcontroller.v5.adapter;import hello.servlet.web.frontcontroller.ModelView;import hello.servlet.web.frontcontroller.v4.ControllerV4;import hello.servlet.web.frontcontroller.v5.MyHandlerAdapter;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.HashMap;import java.util.Map;public class ControllerV4HandlerAdapter implements MyHandlerAdapter { @Override public boolean supports(Object handler) { return (handler instanceof ControllerV4); } @Override public ModelView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws ServletException, IOException { ControllerV4 controller = (ControllerV4) handler; Map&amp;lt;String,String&amp;gt; paraMap = createParamMap(request); Map&amp;lt;String,Object&amp;gt; model = new HashMap&amp;lt;&amp;gt;(); String viewName = controller.process(paraMap, model); ModelView mv = new ModelView(viewName); mv.setModel(model); return mv; } private Map&amp;lt;String, String&amp;gt; createParamMap(HttpServletRequest request) { Map&amp;lt;String,String&amp;gt; paramMap = new HashMap&amp;lt;&amp;gt;(); request.getParameterNames().asIterator() .forEachRemaining(paramName -&amp;gt; paramMap.put(paramName,request.getParameter(paramName))); return paramMap; }}이제 실행해보자.잘 된다.!!정리는 그림을 그려서 따로 하겠다.정리 (추가예정)중요한건 어댑터를 통해 새로운 객체를 넣을때 프론트 컨트롤러 코드는 몇개 추가 안해주었다는 것이다.또한 스프링MVC는 결국 이러한 과정을 통해 만들어졌다는 것이다." }, { "title": "백엔드 웹 개발 노트4.4 - MVC 역사4 Model2편", "url": "/posts/basicSpring4_4/", "categories": "Java, 6_Spring_김영한_스프링MVC 1편", "tags": "Spring", "date": "2022-04-28 07:50:50 +0900", "snippet": "프론트 컨트롤러 업그레이드단순한 아이디어를 적용할 것이다. Controller인터페이스의 process함수의 리턴값을 String으로 바꾸어 ViewName을 리턴하고, 파라미터로 Map&amp;lt;String,Object&amp;gt; model을 넘길 것이다.1. Controller Interface//기존 코드ModelView processs(Map&amp;lt;String,String&amp;gt; paramMap)//바뀐 코드String process(Map&amp;lt;String,String&amp;gt; paramMap,Map&amp;lt;String,Object&amp;gt; model);리턴값이 String이고, 파라미터에 model라는 map객체가 추가되었다.2. MemberFormController 회원 등록폼 수정//기존 코드@Overridepublic ModelView process(Map&amp;lt;String,String&amp;gt; paramMap){ return new ModelView(&quot;new-form&quot;);}//바뀐 코드@Overridepublic String process(Map&amp;lt;String, String&amp;gt; paramMap, Map&amp;lt;String, Object&amp;gt; model){ return &quot;new-form&quot;;}객체에 담을 필요없이, 논리적 주소만 반환시켜주면 된다.3. MemberSaveController 회원 저장폼 수정//기존 코드ModelView mv = new ModelView(&quot;save-result&quot;);mv.getModel().put(&quot;member&quot;, member);return mv;//바뀐 코드model.put(&quot;member&quot;,member);return &quot;save-result&quot;;4. MemberListController 회원 조회 수정//기존 코드List&amp;lt;Member&amp;gt; members = memberRepository.findByAll();ModelView mv = new ModelView(&quot;members&quot;);mv.getModel().put(&quot;members&quot;,members);return mv;//바뀐 코드List&amp;lt;Member&amp;gt; members = memberRepository.findByAll();model.put(&quot;members&quot;,members);return &quot;members&quot;;상당히 간결해졌다.5. FrontControllerServlet 수정//기존 코드Map&amp;lt;String, String&amp;gt; paramMap = createMap(request);ModelView mv = controllerV3.process(paramMap);String viewName = mv.getViewName();MyView myView = viewResolver(viewName);myView.render(mv.getModel(),request,response);//바뀐 코드Map&amp;lt;String, String&amp;gt; paramMap = createMap(request);Map&amp;lt;String,Object&amp;gt; model = new HashMap&amp;lt;&amp;gt;();String viewName = controllerV4.process(paramMap,model);MyView myView = viewResolver(viewName);myView.render(model,request,response);조금 더 직관적이게 바뀌었다고 생각한다.결과결론v4sms 이전 버전과 크게 다르지 않다. process()함수가 논리적 뷰의 이름을 반환하고 model을 추가적으로 파라미터로 넘긴다는 것 말고는 다른 것이 없다고 봐도 무방하다.이런 사소한 아이디어가 개발자의 편의성을 증대시켜준다.한계이 모델은 군더더기 없지만 아쉬운 점이 있다.유연하지 않다는 것이다. 유연하다는 것은 뭘까? 내가 지금까지 작성한 코드들 중 어느 모델이 제일 낫다고는 할 수 없을 수 있다. 파라미터에 모델을 넘기는 버전4보다 버전3가 편할 수도 있고, 버전1이 편할 수도 있다. 이를 개발자가 하여금 맞춰 끼고 싶은데 아직까지는 불가능하다. 이를 가능토록 다음에 학습할 것이다. 즉, 프론트 컨트롤러가 다양한 방식의 컨트롤러를 처리할 수 있도록 변경할 것이다.!!" }, { "title": "백엔드 웹 개발 노트4.3 - MVC 역사3 Model", "url": "/posts/basicSpring4_3/", "categories": "Java, 6_Spring_김영한_스프링MVC 1편", "tags": "Spring", "date": "2022-04-28 06:50:50 +0900", "snippet": "Model 추가 v32가지를 바꿀 것이다. 컨트롤러 입장에서는 HttpServletRequest, HttpServletResponse가 필요 없을 수 있다. 그렇기에 Model이라는 객체를 만들어서 반환할 것이다. 뷰 이름 중복을 제거할 것이다. 앞에서 언급했던 ‘WEB-INF/views’라는 접두사와 ‘.jsp’라는 접미사를 따로 처리할 것이다. 이렇게 해두면 향후 뷰의 폴더 위치가 함께 이동해도 프론트 컨트롤러만 고치면 된다. (각 컨트롤러를 고칠 필요가 없다는 이야기) 즉 프론트 컨트롤러에 역할을 더 많이 추가하여 유지보수에서 있어서 프론트 컨트롤러만 건들게끔 만들 것이다. url 요청을 받고 해당 컨트롤러를 꺼내오는 컨트롤러 조회를 함. 꺼내온 컨트롤러를 통해 비즈니스로직을 수행하고, 뷰의 이름과 뷰를 렌더링할 때 필요한 model 객체를 가지고 있는 Model View를 리턴함. 가져온 Model View를 프론트 컨트롤러가 View Resolver라는 곳에 보냄. View Resolver는 전달받은 뷰 이름을 물리뷰 경로로 바꿔주는 역할을 수행한다. 그리고 MyView라는 객체를 반환. 받은 MyView를 통해 render를 함.먼저 ModelView가 새로 추가되므로 모델의 이름과 정보를 담는 Modelview를 작성하자.1. ModelView classpackage hello.servlet.web.frontcontroller;import java.util.HashMap;import java.util.Map;public class ModelView { private String viewName; private Map&amp;lt;String,Object&amp;gt; model = new HashMap&amp;lt;&amp;gt;(); public String getViewName() { return viewName; } public void setViewName(String viewName) { this.viewName = viewName; } public Map&amp;lt;String, Object&amp;gt; getModel() { return model; } public void setModel(Map&amp;lt;String, Object&amp;gt; model) { this.model = model; }}그 다음은 controller 인터페이스를 수정해주자.2. Controller Interface//기존 코드MyView process(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException;//새로운 코드ModelView process(Map&amp;lt;String,String&amp;gt; paramMap);//서블릿 기술을 전혀 사용하지 않게 된다. 따라서 구현이 쉬워진다.HttpServletRequest가 제공하는 파라미터는 프론트 컨트롤러가 paramMap에 담아서 호출해줄 것이다. 응답 결과로 뷰 이름과 뷰에 전달할 Model 데이터를 포함하는 Modelview객체를 반환 받을 것이다.각 컨트롤러도 수정해주자.3. MemberFormController - 회원 등록//기존 코드@Overridepublic MyView process(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { return new MyView(&quot;/WEB-INF/views/new-form.jsp&quot;);}//새로운 코드@Overridepublic ModelView process(Map&amp;lt;String,String&amp;gt; paramMap){ return new ModelView(&quot;new-form&quot;);}여기서 ‘new-form’은 논리적 명칭이다. 아무렇게나 지어도 된다. 사용자가 짓고싶은대로 짓되, 나중에 찾을때 기억하면 된다.4. MemberSaveController - 회원 저장//기존 코드MemberRepository memberRepository = MemberRepository.getInstance();@Overridepublic MyView process(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException{ String username = request.getParameter(&quot;username&quot;); int height = Integer.parseInt(request.getParameter(&quot;height&quot;)); int weight = Integer.parseInt(request.getParameter(&quot;weight&quot;)); Member member = new Member(username,height,weight); memberRepository.save(member); //모델 등록 request.setAttribute(&quot;member&quot;,member); return new MyView(&quot;/WEB-INF/views/save-result.jsp&quot;);}//바뀐 코드MemberRepository memberRepository = MemberRepository.getInstance();@Overridepublic ModelView process(Map&amp;lt;String,String&amp;gt; paramMap){ //요청 정보를 가져옴. String username = paramMap.get(&quot;username&quot;); int height = Integer.parseInt(paramMap.get(&quot;height&quot;)); int weight = Integer.parseInt(paramMap.get(&quot;weight&quot;)); Member member = new Member(username,height,weight); memberRepository.save(member); //뷰에 대한 이름을 논리적으로 명시함. ModelView mv = new ModelView(&quot;save-result&quot;); //저장된 객체의 정보를 넘김. mv.getModel().put(&quot;member&quot;, member); return mv;}paramMap이 Request객체를 대신한다고 보면 된다.5. MemberListController - 회원 목록//기존 코드MemberRepository memberRepository = MemberRepository.getInstance();@Overridepublic MyView process(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { List&amp;lt;Member&amp;gt; members = memberRepository.findByAll(); request.setAttribute(&quot;members&quot;,members); return new MyView(&quot;/WEB-INF/views/members.jsp&quot;);}//바뀐 코드MemberRepository memberRepository= MemberRepository.getInstance();@Overridepublic ModelView process(Map&amp;lt;String,String&amp;gt; paramMap){ List&amp;lt;Member&amp;gt; members = memberRepository.findByAll(); ModelView mv = new ModelView(&quot;members&quot;); mv.getModel().put(&quot;members&quot;,members); return mv;}마찬가지로 객체에 대한 정보를 ModeView 객체에 뷰 이름과 함께 넣어준다.5. FrontControllerServlet프론트 컨트롤러에 많은 역할을 위임할 것이다.//이전 코드 Service() 메소드 속MyView myView = controllerV2.process(request, response);myView.render(request,response);//바뀐코드Map&amp;lt;String, String&amp;gt; paramMap = createMap(request);ModelView mv = controllerV3.process(paramMap);String viewName = mv.getViewName();MyView myView = viewResolver(viewName);myView.render(mv.getModel(),request,response);//createMap()private Map&amp;lt;String,String&amp;gt; createMap(HttpServletRequest request) { Map&amp;lt;String,String&amp;gt; paramMap = new HashMap&amp;lt;&amp;gt;(); request.getParameterNames().asIterator() .forEachRemaining(paramname -&amp;gt; paramMap.put(paramname, request.getParameter(paramname))); return paramMap;}//viewResolver()private MyView viewResolver(String viewName) { return new MyView(&quot;/WEB-INF/views/&quot; + viewName + &quot;.jsp&quot;);}추가로 view.render()함수도 바뀌어서 추가해줘야한다.MyView class 추가해야할 부분public void render(Map&amp;lt;String, Object&amp;gt; model, HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { modelToRequestAttribute(model, request); RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath); dispatcher.forward(request,response);}private void modelToRequestAttribute(Map&amp;lt;String, Object&amp;gt; model, HttpServletRequest request) { model.forEach((key, value) -&amp;gt; request.setAttribute(key,value));}동작방식 설명이번에 굉장히 많이 추가해서 나도 헷갈리는 부분이 많았다. 그래서 따로 로직을 그려가며 순서를 기억했다.직접 경로를 그려가며 따라가는게 제일 좋은 것 같다. Client가 ‘localhost:8080/front-controller/v3/new-form’ 요청 Server가 요청을 받고 Servlet컨테이너를 검사. Front-Controller에 달린 ‘/front-controller/v3/*‘를 보고 로직 수행 service()함수 실행 requestURI에 reuqest.getURI()[“/front-controller/v3/new-form”]을 담음 해당 URI을 통해 Controller를 ControllerMap에서 찾음. 저장된 URI이므로 MemberFormController를 리턴 리턴값이 NULL이 아니므로 404에러를 내지 않고 로직 수행 request정보를 담고있는 paramMap을 createParamMap()를 통해 담음. 해당 컨트롤러에서는 request에 값을 담지 않았으므로 아무것도 담기지 않을 것임. MemberFormController에 있는 process()를 실행. 파라미터에 저장된 paramMap을 사용할 일은 없음. mv에 저장된 값은 ViewName(“new-form”)과 아무것도 담지 않은 model을 담은 ModelView 객체 반환. mv 객체에 저장된 논리적 주소인 “new-form”을 ViewName에 저장. MyView 객체인 view에는 viewResolver()함수를 이용한 뷰의 절대경로를 반환. view.render()수행. mv.getModel()에 아무것도 들어있지 않은 상태. request, response는 스펙을 맞추기 위함.이런식으로 save로직, list로직을 따라가면 쉽다.NULL로 저장된 mv변수 내의 Model객체는 save로직과 list로직에는 NULL이아니게 되고 쌓여서 사용된다.결국 request.setAttribute()했던 것들은 paramMap에 담아서 수행되다가(save로직에서는 member객체로 만들어서 ModelView객체의 Map에 추가 등) 마지막에 render()부분에서 request에 담아서 사용됨." }, { "title": "백엔드 웹 개발 노트4.2 - MVC 역사2 view", "url": "/posts/basicSpring4_2/", "categories": "Java, 6_Spring_김영한_스프링MVC 1편", "tags": "Spring", "date": "2022-04-28 05:50:50 +0900", "snippet": "1. View 분리 - v2기존 코드를 보면 뷰를 이렇게 출력해줬다.String viewPath = &quot;/WEB-INF/views/new-form.jsp&quot;;RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath);dispatcher.forward(request,response);이 부분을 깔끔하게 분리하기 위해 별도로 뷰를 처리하는 객체를 만들어보자.구조는 다음과 같다.Controller가 이제 View에 대한 정보를 가진 MyView 객체를 반환할 것이다.그러므로 MyView객체를 만들어보자.package hello.servlet.web.frontcontroller;import javax.servlet.RequestDispatcher;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class MyView { private String viewPath; public MyView(String viewPath) { this.viewPath = viewPath; } public void render(HttpServletRequest request,HttpServletResponse response) throws IOException, ServletException{ RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath); dispatcher.forward(request,response); }}render()라는 함수가 중복되는 dispatcher부분을 담당하였다.우리는 이 객체를 반환하기로 했으므로 Controller 인터페이스도 바꿔주자.//이전 코드void process(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException;//바뀐 코드MyView process(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException;이제 각 컨트롤러도 수정해주자.1.1 MemberFormController 수정 - 회원 등록폼 @Overridepublic MyView process(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { return new MyView(&quot;/WEB-INF/views/new-form.jsp&quot;);}굉장히 간결해졌다.1.2 MemberSaveController 수정 - 회원 저장 @Override public MyView process(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException{ String username = request.getParameter(&quot;username&quot;); int height = Integer.parseInt(request.getParameter(&quot;height&quot;)); int weight = Integer.parseInt(request.getParameter(&quot;weight&quot;)); Member member = new Member(username,height,weight); memberRepository.save(member); //모델 등록 request.setAttribute(&quot;member&quot;,member); //수정한 부분 return new MyView(&quot;/WEB-INF/views/save-result.jsp&quot;); }마찬가지로 View부분만 수정해주면 된다.1.3 MemberListController 수정 - 회원 목록 @Override public MyView process(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { List&amp;lt;Member&amp;gt; members = memberRepository.findByAll(); request.setAttribute(&quot;members&quot;,members); return new MyView(&quot;/WEB-INF/views/members.jsp&quot;); }3줄로 줄었다.마지막으로 프론트 컨트롤러를 고쳐주자.1.4 프론트 컨트롤러 수정이 부분도 크게 다를건 없다.//기존 코드controllerV1.process(request,response);//바뀐 코드MyView myView = controllerV2.process(request, response);myView.render(request,response);결과를 확인해보자.나의 경우 URL을 따로 지정해서 v2/~로 시작하게 된다. url을 수정하지 않았다면 v1/~로 나오는게 정상이다.!!2. 한계 서블릿 종속성을 제거 view에 관한 정보만 리턴하는 MemberFormController의 경우는 HttpServletRequest, HttpServletResponse객체가 필요가 없다. 어떻게 해결할 수 있을까? 뷰 이름 중복 제거 ‘/WEB-INF/views/~’ 는 중복된 url이다. 다음에 이를 고쳐보도록 하겠다. " }, { "title": "백엔드 웹 개발 노트4.1 - MVC 역사1 소개", "url": "/posts/basicSpring4_1/", "categories": "Java, 6_Spring_김영한_스프링MVC 1편", "tags": "Spring", "date": "2022-04-28 04:50:50 +0900", "snippet": "1. 프론트 컨트롤러 도입 - v1먼저 구조를 바꿔볼 것이다.각자의 역할을 하는 컨트롤러의 인터페이스 만들어보자.1.2 프로젝트 구조1.3 ControllerV1 Interfacepackage hello.servlet.web.frontcontroller.v1;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public interface ControllerV1 { void process(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException;}이제 필요한 컨트롤러는 이 인터페이스를 이용해서 구현하면 된다.먼저 회원 등록 컨트롤러를 만들어보자.1.4 MemberFormControllerV1 - 회원 등록 컨트롤러package hello.servlet.web.frontcontroller.v1.controller;import hello.servlet.web.frontcontroller.v1.ControllerV1;import javax.servlet.RequestDispatcher;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class MemberFormControllerV1 implements ControllerV1 { @Override public void process(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String viewPath = &quot;/WEB-INF/views/new-form.jsp&quot;; //다른 서블릿이나 JSP로 이동할 수 있는 기능. 리다이렉션이 아닌 서부 내부에서 호출이 발생한다. RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath); dispatcher.forward(request,response); }}내부 코드는 Servlet-mvc에서 작성한 코드랑 동일하다.1.5 MemberSaveControllerV1 - 회원 저장 컨트롤러package hello.servlet.web.frontcontroller.v1.controller;import hello.servlet.basic.domain.Member;import hello.servlet.basic.domain.MemberRepository;import hello.servlet.web.frontcontroller.v1.ControllerV1;import javax.servlet.RequestDispatcher;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class MemberSaveControllerV1 implements ControllerV1 { MemberRepository memberRepository = MemberRepository.getInstance(); @Override public void process(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException{ String username = request.getParameter(&quot;username&quot;); int height = Integer.parseInt(request.getParameter(&quot;height&quot;)); int weight = Integer.parseInt(request.getParameter(&quot;weight&quot;)); Member member = new Member(username,height,weight); memberRepository.save(member); //모델 등록 request.setAttribute(&quot;member&quot;,member); //forward String viewPath = &quot;/WEB-INF/views/save-result.jsp&quot;; RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath); dispatcher.forward(request,response); }}마찬가지로 앞에서 작성한 servlet-mvc의 save코드와 다른게 없다.1.6 MemberListControllerV1 - 회원 목록 컨트롤러package hello.servlet.web.frontcontroller.v1.controller;import hello.servlet.basic.domain.Member;import hello.servlet.basic.domain.MemberRepository;import hello.servlet.web.frontcontroller.v1.ControllerV1;import javax.servlet.RequestDispatcher;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.List;public class MemberListControllerV1 implements ControllerV1 { MemberRepository memberRepository = MemberRepository.getInstance(); @Override public void process(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { List&amp;lt;Member&amp;gt; members = memberRepository.findByAll(); request.setAttribute(&quot;members&quot;,members); String viewPath = &quot;/WEB-INF/views/members.jsp&quot;; RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath); dispatcher.forward(request,response); }}마찬가지다. 코드는 동일하다.프론트 컨트롤러를 만들어볼 것이다.1.7 FrontControllerServletV1 - 프론트 컨트롤러package hello.servlet.web.frontcontroller.v1;import hello.servlet.web.frontcontroller.v1.controller.MemberFormControllerV1;import hello.servlet.web.frontcontroller.v1.controller.MemberListControllerV1;import hello.servlet.web.frontcontroller.v1.controller.MemberSaveControllerV1;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.HashMap;import java.util.Map;//url을 보면 v1으로 들어오는 url은 모두 이 서블릿을 거치게 되어있다.@WebServlet(name = &quot;frontControllerServletV1&quot;, urlPatterns = &quot;/front-controller/v1/*&quot;)public class FrontControllerServletV1 extends HttpServlet { private Map&amp;lt;String,ControllerV1&amp;gt; controllerV1Map = new HashMap&amp;lt;&amp;gt;(); //생성자 public FrontControllerServletV1() { controllerV1Map.put(&quot;/front-controller/v1/members/new-form&quot;,new MemberFormControllerV1()); controllerV1Map.put(&quot;/front-controller/v1/members/save&quot;,new MemberSaveControllerV1()); controllerV1Map.put(&quot;/front-controller/v1/members&quot;,new MemberListControllerV1()); } @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { StringBuffer requestURL = request.getRequestURL(); //요청 url로 들어온 컨트롤러를 꺼냄 ControllerV1 controllerV1 = controllerV1Map.get(requestURL); //만약 컨트롤러가 없다면 if(controllerV1 == null){ response.setStatus(HttpServletResponse.SC_NOT_FOUND); return; } //있다면 함수 실행. controllerV1.process(request,response); }}map에 컨트롤러 객체들을 넣고 꺼내서 쓴다.나는 전부 잘 된다.코드를 수정한 부분이 없어서 잘 되는게 맞다.이렇게 컨트롤러를 인터페이스로 구현하니까 앞에 진입점이 생긴다는 점과 1개의 서블릿을 구현한다는 것은 매력적이다.하지만 매 번 컨트롤러가 생길때마다 Map 자료구조에 넣어주는 반복적인 코드가 발생한다는 것을 알게 되었다.그리고 ‘viewPath’관련한 코드는 여전히 중복이므로 이를 개선할만한 방법이 있을거라 생각한다.점점 바꿔나가 결국 SpringMVC형태로 갖춰진다는데 궁금하다." }, { "title": "백엔드 웹 개발 노트3.4 - MVC패턴이란?", "url": "/posts/basicSpring3_4/", "categories": "Java, 6_Spring_김영한_스프링MVC 1편", "tags": "Spring", "date": "2022-04-28 03:50:50 +0900", "snippet": "1. MVC 패턴 개요 서블릿과 JSP만으로 비즈니스 로직과 뷰 렌더링까지 모두 처리하게 되는 것은 너무 많은 역할을 맡기고, 유지보수도 어려워진다. 버튼 하나 옮기는 작업에 Java코드가 섞인 JSP파일을 본다면 머리가 어질어질할 것이다. 마찬가지로 비즈니스 로직을 바꾸려고 Java코드를 건드려야 하는데 HTML 코드가 수백줄이라고 하면 머리가 띵할 것이다. JSP 같은 뷰 템플릿은 화면을 렌더링 하는데 최적화 되어 있기 때문에 이 부분의 업무만 담당하는 것이 효과적이다.1.1 MVC Model : 뷰에 출력할 데이터를 담아놓음. 뷰가 필요한 데이터를 모두 모델에 담아서 전달해주는 덕분에 뷰는 비즈니스 로직이나 데이터 접근을 몰라도 되고, 화면을 렌더링 하는 일에 집중할 수 있음. View : 모델에 담겨있는 데이터를 사용해서 화면을 그리는 일에 집중한다. HTML을 생성하는 부분을 말함. Controller : HTTP 요청을 받아서 파라미터를 검증하고, 비즈니스 로직을 실행하는 부분. 그리고 뷰에 전달할 결과 데이터를 모델에 담음.2. MVC패턴 적용.request.setAttribute(), request.getAttribute()를 사용할 것이다.먼저 컨트롤러를 만들어보자.2.1 회원등록 컨트롤러 MvcMemberFormServletpackage hello.servlet.web.servletmvc;import hello.servlet.basic.domain.MemberRepository;import javax.servlet.RequestDispatcher;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(name=&quot;mvcMemberFormServlet&quot;,urlPatterns = &quot;/servlet-mvc/members/new-form&quot;)public class MvcMemberFormServlet extends HttpServlet { @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String viewPath = &quot;/WEB-INF/views/new-form.jsp&quot;; //다른 서블릿이나 JSP로 이동할 수 있는 기능. 리다이렉션이 아닌 서부 내부에서 호출이 발생한다. RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath); dispatcher.forward(request,response); }}‘/WEB-INF/views/new-form.jsp’에 있는 jsp파일을 보여달라고 했으니 해당 파일을 만들어보자.그 전에 /WEB_INF가 뭘까?2.1.1 /WEB_INF 일종의 약속이다. 이 경로안에 JSP가 있으면 외부에서 직접 JSP를 호출할 수 없다. 즉 컨트롤러를 통해서 JSP를 호출하도록 한다.2.1.2 redirect vs forward리다이렉트는 호출이 2번 일어난다. 왜일까? 클라이언트 -&amp;gt; 서버로 최초 한 번 서버가 리다이렉션 302를 클라이언트에 보내면 해당 페이지에 대한 요청을 클라이언트가 다시 한 번 서버에 요청해서 2번 일어나는 것이다.따라서 클라이언트가 인지할 수 있고, URL 경로도 실제로 변경된다. 반면에 forward는 서버 내부에서 일어나는 호출이기 때문에 클라이언트가 전혀 인지하지 못한다.2.2 회원등록 폼 (main/webapp/WEB_INF/views/new-form.jsp)&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt; &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;!-- 상대경로 사용할 것. 계속 수정해줄 것임. --&amp;gt;&amp;lt;form action=&quot;save&quot; method=&quot;post&quot;&amp;gt; username : &amp;lt;input type=&quot;text&quot; name=&quot;username&quot;&amp;gt; height : &amp;lt;input type=&quot;text&quot; name=&quot;height&quot;&amp;gt; weight : &amp;lt;input type=&quot;text&quot; name=&quot;weight&quot;&amp;gt; &amp;lt;button type=&quot;submit&quot;&amp;gt;전송&amp;lt;/button&amp;gt;&amp;lt;/form&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;실행해보자.성공이다.이제 전송경로인 ‘/servlet-mvc/members/save’에 대한 컨트롤러를 작성해보겠다.2.3 회원저장 컨트롤러 MvcMemberSaveServletpackage hello.servlet.web.servletmvc;import hello.servlet.basic.domain.Member;import hello.servlet.basic.domain.MemberRepository;import javax.servlet.RequestDispatcher;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(name = &quot;mvcMemberSaveServlet&quot;,urlPatterns = &quot;/servlet-mvc/members/save&quot;)public class MvcMemberSaveServlet extends HttpServlet { MemberRepository memberRepository = MemberRepository.getInstance(); @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String username = request.getParameter(&quot;username&quot;); int height = Integer.parseInt(request.getParameter(&quot;height&quot;)); int weight = Integer.parseInt(request.getParameter(&quot;weight&quot;)); Member member = new Member(username,height,weight); memberRepository.save(member); //모델 등록 request.setAttribute(&quot;member&quot;,member); //forward String viewPath = &quot;/WEB-INF/views/save-result.jsp&quot;; RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath); dispatcher.forward(request,response); }}‘/WEB-INF/views/save-result.jsp’로 화면을 그려야하므로 해당경로에 jsp파일을 생성하자2.4 회원저장 뷰 save-result.jsp&amp;lt;%@ page import=&quot;hello.servlet.basic.domain.Member&quot; %&amp;gt;&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;ul&amp;gt; &amp;lt;!-- 정석으로 꺼내는 법--&amp;gt; &amp;lt;li&amp;gt;id : &amp;lt;%=((Member)request.getAttribute(&quot;member&quot;)).getId()%&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;username : ${member.username}&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;height : ${member.height}&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;weight : ${member.weight}&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;bmi : ${member.getBmi()}&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;&amp;lt;a href=&quot;/index.html&quot;&amp;gt;메인&amp;lt;/a&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;이 부분은 봐야할 것이 많다. 정석으로 꺼내는 법과, ${}문법을 사용해서 변수와 함수를 사용하는 법을 배울 수 있다.마지막으로 전체리스트를 조회하는 컨트롤러, 뷰를 작성하자.2.5 회원 목록 조회 - 컨트롤러 MvcMemberListServletpackage hello.servlet.web.servletmvc;import hello.servlet.basic.domain.Member;import hello.servlet.basic.domain.MemberRepository;import javax.servlet.RequestDispatcher;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.List;@WebServlet(name = &quot;mvcMemberListServlet&quot;,urlPatterns = &quot;/servlet-mvc/members&quot;)public class MvcMemberListServlet extends HttpServlet { MemberRepository memberRepository = MemberRepository.getInstance(); @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { List&amp;lt;Member&amp;gt; members = memberRepository.findByAll(); request.setAttribute(&quot;members&quot;,members); String viewPath = &quot;/WEB-INF/views/members.jsp&quot;; RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath); dispatcher.forward(request,response); }}이쯤되면 viewPath 작성하는 코드부터 반복되는 코드가 있다는 것을 알 수 있다.추후 Spring MVC를 배우면 해결될 것이다.그리고 List도 request.setAttribute()를 통해서 저장되는 것을 알 수 있다.2.6 회원 목록 조회 뷰 (main/webapp/WEB-INF/views/members.jsp)&amp;lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&amp;gt;&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;a href=&quot;/index.html&quot;&amp;gt;메인&amp;lt;/a&amp;gt;&amp;lt;table&amp;gt; &amp;lt;thead&amp;gt; &amp;lt;th&amp;gt;id&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;username&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;height&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;weight&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;bmi&amp;lt;/th&amp;gt; &amp;lt;/thead&amp;gt; &amp;lt;tbody&amp;gt; &amp;lt;!-- for문 사용하는것을 보자!--&amp;gt; &amp;lt;c:forEach var=&quot;item&quot; items=&quot;${members}&quot;&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td&amp;gt;${item.id}&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;${item.username}&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;${item.height}&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;${item.weight}&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;${item.bmi}&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;/c:forEach&amp;gt; &amp;lt;/tbody&amp;gt;&amp;lt;/table&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;for문을 저렇게 사용하려면 첫 번째줄의 설정을 넣어줘야한다. members 리스트에서 member를 순서대로 꺼내서 item 변수에 담고, 출력하는 과정을 반복한다.성공3. MVC 패턴의 한계3.1 중복 코드가 너무 많다.뷰는 잘 분리하였지만, 컨트롤러에 불필요한 중복이 너무 많다. 포워드 중복 RequestDispathcer dispatcher = request.getrequestDispatcher(viewPath);dispatcher.forward(request,response); 이 코드를 컨트롤러 3개에 전부 작성하였다. 사용자 메서드로 만들어도 결국 그 메서드를 반복 사용해야한다는 것은 똑같다. ViewPath의 중복 String viewPath = &quot;/WEB-INF/views/new-form.jsp&quot; 접두사인 ‘WEB-INF/view’와 접미사인 ‘.jsp’의 중복이 있다. 사용하지 않는 코드컨트롤러에서 ‘response’객체는 단 한 번도 사용되지 않았다. 공통 처리의 어려움세 컨트롤러에 어떠한 메소드를 추가한다고 하면 컨트롤러마다 추가해줘야하는 번거로움이 있다. 해결할 수 없을까?그래서 나온 것이 프론트 컨트롤러(Front Controller) 패턴이다.프론트 컨트롤러는 컨트롤러 호출 전에 먼저 공통 기능을 처리하는 수문장 역할을 하게하는 패턴이다.다음 시간에는 프론트 컨트롤러에 대해 학습하겠다." }, { "title": "백엔드 웹 개발 노트3.3 - Jsp Web 예제", "url": "/posts/basicSpring3_3/", "categories": "Java, 6_Spring_김영한_스프링MVC 1편", "tags": "Spring", "date": "2022-04-28 02:50:50 +0900", "snippet": "1. JSP로 웹 어플리케이션 만들기Servlet으로 웹 어플리케이션을 만들기는 굉장히 비효율적이라는 것을 알았다.JSP로 만들어보자.&amp;lt;% %&amp;gt;이 안에 코드를 넣으면 자바문법을 사용할 수 있다.&amp;lt;%= %&amp;gt;이 안에 값을 넣으면 출력한다는 의미이다.먼저 JSP 라이브러리를 추가해야한다.build.gradle에 다음과 같이 추가하자.//JSP 추가 시작implementation &#39;org.apache.tomcat.embed:tomcat-embed-jasper&#39;implementation &#39;javax.servlet:jstl&#39;//JSP 추가 끝gradle을 다시 빌드해주자.프로젝트 구성은 다음과 같다.위처럼 3가지 파일을 만들어줄 것이다.1.1 회원 등록 폼 JSP (main/webapp/jsp/members/new-form.jsp)&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt; &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; &amp;lt;form action=&quot;/jsp/members/save.jsp&quot; method=&quot;post&quot;&amp;gt; username: &amp;lt;input type=&quot;text&quot; name=&quot;username&quot; /&amp;gt; height: &amp;lt;input type=&quot;text&quot; name=&quot;height&quot; /&amp;gt; weight: &amp;lt;input type=&quot;text&quot; name=&quot;weight&quot; /&amp;gt; &amp;lt;button type=&quot;submit&quot;&amp;gt;전송&amp;lt;/button&amp;gt; &amp;lt;/form&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;url로 접근해보자.참고로 &amp;lt;%@ ~ %&amp;gt; 문법은 설정을 명시하는 것이다. jsp가 가장 먼저 읽는 부분이다.이제 Post로 보낸 데이터를 받아 출력하는 페이지를 작성한다.1.2 회원 저장 JSP (main/webapp/jsp/members/save.jsp)&amp;lt;%@ page import=&quot;hello.servlet.basic.domain.MemberRepository&quot; %&amp;gt;&amp;lt;%@ page import=&quot;hello.servlet.basic.domain.Member&quot; %&amp;gt;&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;&amp;lt;% MemberRepository memberRepository = MemberRepository.getInstance(); //확인용 System.out.println(&quot;save.jsp&quot;); String username = request.getParameter(&quot;username&quot;); int height = Integer.parseInt(request.getParameter(&quot;height&quot;)); int weight = Integer.parseInt(request.getParameter(&quot;weight&quot;)); Member member = new Member(username,height,weight); memberRepository.save(member);%&amp;gt;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;성공&amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;id = &amp;lt;%=member.getId()%&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;username = &amp;lt;%=member.getUsername()%&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;height = &amp;lt;%=member.getHeight()%&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;weight = &amp;lt;%=member.getWeight()%&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;BMI = &amp;lt;%=member.getBmi()%&amp;gt;&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;결과화면이 다음과 같이 뜨면 성공이다.마지막으로 회원 목록을 조회하는 JSP를 작성해보겠다.1.3 회원 목록 JSP (main/webapp/jsp/members.jsp)&amp;lt;%@ page import=&quot;hello.servlet.basic.domain.MemberRepository&quot; %&amp;gt;&amp;lt;%@ page import=&quot;hello.servlet.basic.domain.Member&quot; %&amp;gt;&amp;lt;%@ page import=&quot;java.util.List&quot; %&amp;gt;&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;&amp;lt;% MemberRepository memberRepository = MemberRepository.getInstance(); List&amp;lt;Member&amp;gt; members = memberRepository.findByAll();%&amp;gt;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; &amp;lt;a href=&quot;/index.html&quot;&amp;gt;메인&amp;lt;/a&amp;gt; &amp;lt;table&amp;gt; &amp;lt;thead&amp;gt; &amp;lt;th&amp;gt;ID&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;Username&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;Height&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;Weight&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;Bmi&amp;lt;/th&amp;gt; &amp;lt;/thead&amp;gt; &amp;lt;tbody&amp;gt; &amp;lt;% for(Member member : members){ out.write(&quot; &amp;lt;tr&amp;gt;\\n&quot;); out.write(&quot; &amp;lt;td&amp;gt;&quot; + member.getId() + &quot;&amp;lt;/td&amp;gt;\\n&quot;); out.write(&quot; &amp;lt;td&amp;gt;&quot; + member.getUsername() + &quot;&amp;lt;/td&amp;gt;\\n&quot;); out.write(&quot; &amp;lt;td&amp;gt;&quot; + member.getHeight() + &quot;&amp;lt;/td&amp;gt;\\n&quot;); out.write(&quot; &amp;lt;td&amp;gt;&quot; + member.getWeight() + &quot;&amp;lt;/td&amp;gt;\\n&quot;); out.write(&quot; &amp;lt;td&amp;gt;&quot; + member.getBmi() + &quot;&amp;lt;/td&amp;gt;\\n&quot;); out.write(&quot; &amp;lt;/tr&amp;gt;\\n&quot;); } %&amp;gt; &amp;lt;/tbody&amp;gt; &amp;lt;/table&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;데이터를 넣고 결과를 확인해보자.성공이다.2. 결론 / 서블릿과 JSP의 한계서블릿으로 개발할 때 뷰화면을 위한 HTML을 만드는 작업이 자바 코드에 섞여서 복잡했다.이에 대한 해결방안으로 JSP가 나왔다. 뷰를 생성하는 HTML 작업을 깔끔하게 가져갔지만 한 페이지에 JAVA 코드, 저장소에 대한 정보, HTML코드 다 짬뽕되어서 JSP가 너무 많은 역할을 한다. 유지보수에서도 골치가 아플 것이다.이를 해결하기 위해서 MVC패턴이 등장했다.2.1 MVC 패턴Model, View, Controller의 약자로 비즈니스 로직은 서블릿처럼 다른곳에서 처리하고, HTML은 View를 그리는 역할로 분리하여 코드를 작성하자는 뜻이다." }, { "title": "백엔드 웹 개발 노트3.2 - Servlet Web 예제", "url": "/posts/basicSpring3_2/", "categories": "Java, 6_Spring_김영한_스프링MVC 1편", "tags": "Spring", "date": "2022-04-28 01:50:50 +0900", "snippet": "1. 서블릿으로 웹 어플리케이션 제작개요 부분에서 작성한 코드를 가지고 서블릿을 통한 동적 웹을 작성해보자.먼저 회원을 저장하기 위해 등록 폼을 만들어야 할 것이다.대충 패키지를 만들자나의 프로젝트 경로는 다음과 같다.web.servlet에 코드를 다 넣을 것이다.1.1 MemberFormServlet - 회원 등록 폼package hello.servlet.basic.web.servlet;import hello.servlet.basic.domain.MemberRepository;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;@WebServlet(name = &quot;memberFormServlet&quot;,urlPatterns = &quot;/servlet/member/new-form&quot;)public class MemberFormServlet extends HttpServlet { MemberRepository memberRepository = MemberRepository.getInstance(); @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //셋팅 response.setCharacterEncoding(&quot;utf-8&quot;); response.setContentType(&quot;text/html&quot;); PrintWriter w = response.getWriter(); w.write(&quot;&amp;lt;!DOCTYPE html&amp;gt;\\n&quot; + &quot;&amp;lt;html&amp;gt;\\n&quot; + &quot;&amp;lt;head&amp;gt;\\n&quot; + &quot; &amp;lt;meta charset=\\&quot;UTF-8\\&quot;&amp;gt;\\n&quot; + &quot; &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;\\n&quot; + &quot;&amp;lt;/head&amp;gt;\\n&quot; + &quot;&amp;lt;body&amp;gt;\\n&quot; + &quot;&amp;lt;form action=\\&quot;/servlet/members/save\\&quot; method=\\&quot;post\\&quot;&amp;gt;\\n&quot; + &quot; username: &amp;lt;input type=\\&quot;text\\&quot; name=\\&quot;username\\&quot; /&amp;gt;\\n&quot; + &quot; height: &amp;lt;input type=\\&quot;text\\&quot; name=\\&quot;height\\&quot; /&amp;gt;\\n&quot; + &quot; weight: &amp;lt;input type=\\&quot;text\\&quot; name=\\&quot;weight\\&quot; /&amp;gt;\\n&quot; + &quot; &amp;lt;button type=\\&quot;submit\\&quot;&amp;gt;전송&amp;lt;/button&amp;gt;\\n&quot; + &quot;&amp;lt;/form&amp;gt;\\n&quot; + &quot;&amp;lt;/body&amp;gt;\\n&quot; + &quot;&amp;lt;/html&amp;gt;\\n&quot;); }}이렇게 만들고 해당 url로 접근해서 다음과 같이 폼이 뜨면 성공이다.아직 해당 전달받는 서블릿을 만들지 않아서 ‘전달’버튼을 눌러서 오류가 뜨는건 정상이다.전달받는 부분을 만들어보자.1.2 MemberSaveServlet - 회원 저장package hello.servlet.basic.web.servlet;import hello.servlet.basic.domain.Member;import hello.servlet.basic.domain.MemberRepository;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;@WebServlet(name = &quot;memberSaveServlet&quot;,urlPatterns = &quot;/servlet/members/save&quot;)public class MemberSaveServlet extends HttpServlet { MemberRepository memberRepository = MemberRepository.getInstance(); @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //동작 확인용 System.out.println(&quot;memberSaveServlet&quot;); //회원정보를 받아오자. 정보들은 전부 String이므로 int로 반환해줄건 해주자. String username = request.getParameter(&quot;username&quot;); int height = Integer.parseInt(request.getParameter(&quot;height&quot;)); int weight = Integer.parseInt(request.getParameter(&quot;weight&quot;)); //멤버 객체 만들고 저장소에 저장. Member member = new Member(username,height,weight); System.out.println(&quot;member : &quot; + member); memberRepository.save(member); //셋팅 response.setContentType(&quot;text/html&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); PrintWriter w = response.getWriter(); w.write(&quot;&amp;lt;html&amp;gt;\\n&quot; + &quot;&amp;lt;head&amp;gt;\\n&quot; + &quot; &amp;lt;meta charset=\\&quot;UTF-8\\&quot;&amp;gt;\\n&quot; + &quot;&amp;lt;/head&amp;gt;\\n&quot; + &quot;&amp;lt;body&amp;gt;\\n&quot; + &quot;성공\\n&quot; + &quot;&amp;lt;ul&amp;gt;\\n&quot; + &quot; &amp;lt;li&amp;gt;id=&quot;+member.getId()+&quot;&amp;lt;/li&amp;gt;\\n&quot; + &quot; &amp;lt;li&amp;gt;username=&quot;+member.getUsername()+&quot;&amp;lt;/li&amp;gt;\\n&quot; + &quot; &amp;lt;li&amp;gt;height=&quot;+member.getHeight()+&quot;&amp;lt;/li&amp;gt;\\n&quot; + &quot; &amp;lt;li&amp;gt;weight=&quot;+member.getWeight()+&quot;&amp;lt;/li&amp;gt;\\n&quot; + &quot; &amp;lt;li&amp;gt;bmi=&quot;+member.getBmi()+&quot;&amp;lt;/li\\n&quot;+ &quot;&amp;lt;/ul&amp;gt;\\n&quot; + &quot;&amp;lt;a href=\\&quot;/index.html\\&quot;&amp;gt;메인&amp;lt;/a&amp;gt;\\n&quot; + &quot;&amp;lt;/body&amp;gt;\\n&quot; + &quot;&amp;lt;/html&amp;gt;&quot;); }}자 이렇게 만들고 아까 등록 폼에서 ‘전달’ 버튼을 눌러보자.참고로 뒤로가기를 누르고 다른 회원을 등록하면 id값이 하나 증가한걸 볼 수 있다.그리고 코드에서&quot;&amp;lt;a href=\\&quot;/index.html\\&quot;&amp;gt;메인&amp;lt;/a&amp;gt;\\n&quot; + &quot;&amp;lt;/body&amp;gt;\\n&quot; 이부분은 기본 예제에 있던 코드이므로 자신이 index페이지가 없다면 무시해도 된다.이제 회원 전체 목록을 조회하는 폼을 만들어볼 것이다.1.3 MemberListServlet - 회원 목록package hello.servlet.basic.web.servlet;import hello.servlet.basic.domain.Member;import hello.servlet.basic.domain.MemberRepository;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;import java.util.List;@WebServlet(name = &quot;memberListServlet&quot;,urlPatterns = &quot;/servlet/member&quot;)public class MemberListServlet extends HttpServlet { MemberRepository memberRepository = MemberRepository.getInstance(); @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //셋팅 response.setCharacterEncoding(&quot;utf-8&quot;); response.setContentType(&quot;text/html&quot;); List&amp;lt;Member&amp;gt; members = memberRepository.findByAll(); PrintWriter w = response.getWriter(); w.write(&quot;&amp;lt;html&amp;gt;&quot;); w.write(&quot;&amp;lt;head&amp;gt;&quot;); w.write(&quot; &amp;lt;meta charset=\\&quot;UTF-8\\&quot;&amp;gt;&quot;); w.write(&quot; &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;&quot;); w.write(&quot;&amp;lt;/head&amp;gt;&quot;); w.write(&quot;&amp;lt;body&amp;gt;&quot;); w.write(&quot;&amp;lt;a href=\\&quot;/index.html\\&quot;&amp;gt;메인&amp;lt;/a&amp;gt;&quot;); w.write(&quot;&amp;lt;table&amp;gt;&quot;); w.write(&quot; &amp;lt;thead&amp;gt;&quot;); w.write(&quot; &amp;lt;th&amp;gt;id&amp;lt;/th&amp;gt;&quot;); w.write(&quot; &amp;lt;th&amp;gt;username&amp;lt;/th&amp;gt;&quot;); w.write(&quot; &amp;lt;th&amp;gt;Height&amp;lt;/th&amp;gt;&quot;); w.write(&quot; &amp;lt;th&amp;gt;Weight&amp;lt;/th&amp;gt;&quot;); w.write(&quot; &amp;lt;th&amp;gt;BMI&amp;lt;/th&amp;gt;&quot;); w.write(&quot; &amp;lt;/thead&amp;gt;&quot;); w.write(&quot; &amp;lt;tbody&amp;gt;&quot;); for(Member member : members){ w.write(&quot; &amp;lt;tr&amp;gt;&quot;); w.write(&quot; &amp;lt;td&amp;gt;&quot; + member.getId() + &quot;&amp;lt;/td&amp;gt;&quot;) ; w.write(&quot; &amp;lt;td&amp;gt;&quot; + member.getUsername() + &quot;&amp;lt;/td&amp;gt;&quot;) ; w.write(&quot; &amp;lt;td&amp;gt;&quot; + member.getHeight() + &quot;&amp;lt;/td&amp;gt;&quot;) ; w.write(&quot; &amp;lt;td&amp;gt;&quot; + member.getWeight() + &quot;&amp;lt;/td&amp;gt;&quot;) ; w.write(&quot; &amp;lt;td&amp;gt;&quot; + member.getBmi() + &quot;&amp;lt;/td&amp;gt;&quot;) ; } w.write(&quot; &amp;lt;/tbody&amp;gt;&quot;); w.write(&quot;&amp;lt;/table&amp;gt;&quot;); w.write(&quot;&amp;lt;/body&amp;gt;&quot;); w.write(&quot;&amp;lt;/html&amp;gt;&quot;); }}따로 설명할 부분이 없다.등록 폼에서 객체들을 추가하고 해당 url로 들어가면 다음과 같은 화면을 볼 수 있다.2. 결론동적으로 HTML을 만들 수 있지만, 태그를 직접 출력해야하고 오타가 날 위험이 있다.매우 복잡하면서도 비효율적인 이 코드는 결국 자바를 이용해서 문서를 출력하는 것 보다는 HTML에 자바 코드를 넣는게 더 편리할 것이라는 생각으로 템플릿 엔진이 탄생하였다.템플릿 엔진은 HTML문서에 필요한 곳에만 코드를 넣어서 동적으로 페이지를 생성할 수 있게 한다.JSP, Thymeleaf, Freemarker, Velocity 등이 있다.다음은 JSP로 페이지를 만들어볼 것이다." }, { "title": "백엔드 웹 개발 노트2.3 - HTTP Servlet Response", "url": "/posts/basicSpring5/", "categories": "Java, 6_Spring_김영한_스프링MVC 1편", "tags": "Spring", "date": "2022-04-27 04:50:50 +0900", "snippet": "1. HttpServletResponse 정리응답코드를 지정할 수 있는데, 개발자가 편하게 지정할 수 있도록 해당 객체가 많은 기능을 제공한다.1.1 기본 사용법java파일을 만들자.package hello.servlet.basic.response;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(name = &quot;httpResponse&quot;,urlPatterns = &quot;/kms-response-test&quot;)public class HttpResponse extends HttpServlet { @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //status line 지정 200 response.setStatus(HttpServletResponse.SC_OK); //response header 셋팅 response.setHeader(&quot;Content-Type&quot;,&quot;text/plain;charset=utf8&quot;); response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache, no-store, must-revalidate&quot;); response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;); response.setHeader(&quot;my-header&quot;,&quot;hello&quot;); //header 편의 메서드 content(response); cookie(response); redirect(response); //message body response.getWriter().write(&quot;ok&quot;); } private void redirect(HttpServletResponse response) throws IOException { response.sendRedirect(&quot;/basic/kms-message-body.html&quot;); //편의 기능없이 setHeader로 만든 것. 302 //response.setStatus(HttpServletResponse.SC_FOUND); //response.setHeader(&quot;Location&quot;,&quot;/basic/kms-message-body.html&quot;); } private void cookie(HttpServletResponse response) { //쿠키 생성 Cookie cookie = new Cookie(&quot;mycookie&quot;,&quot;kms&quot;); //쿠키 만료일자 지정. 단위는 초 cookie.setMaxAge(600); response.addCookie(cookie); //밑 부분은 편의기능 없이 직접 헤더를 조작하여 쿠키를 설정 //response.setHeader(&quot;Set-Cookie&quot;, &quot;mycookie=kms; Max-Age=600&quot;); } private void content(HttpServletResponse response) { //setHeader()없이 해당 메소드로 편하게 지정해줄 수 있다. response.setContentType(&quot;text/plain&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); }}주석을 참고하자.결과는 다음과 같다.쿠키가 설정된 것을 보고, 새로만든 헤더가 추가된 것을 보면 된다.직접 헤더를 조정하는것은 오타가날 위험도 있으므로 객체가 지원하는 편의 메소드들을 사용하자.!!1.2 단순 텍스트, HTML 응답.단순 텍스트 응답은 앞에서 코드로 작성한writer.println(&quot;ok&quot;);가 단순 텍스트 응답이다.HTML응답을 보내기 위해 자바파일을 생성하자.package hello.servlet.basic.response;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;@WebServlet(name = &quot;httpResponseHTML&quot;, urlPatterns = &quot;/kms-response-htmltest&quot;)public class HttpResponseHTML extends HttpServlet { @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //Content-Type을 HTML로 지정 response.setContentType(&quot;text/html&quot;); //인코딩 타입 지정 response.setCharacterEncoding(&quot;utf-8&quot;); PrintWriter writer = response.getWriter(); writer.println(&quot;&amp;lt;html&amp;gt;&quot;); writer.println(&quot;&amp;lt;body&amp;gt;&quot;); writer.println(&quot;&amp;lt;div&amp;gt; 이렇게 코딩은 하지 말자. &amp;lt;/div&amp;gt;&quot;); writer.println(&quot;&amp;lt;/body&amp;gt;&quot;); writer.println(&quot;&amp;lt;/html&amp;gt;&quot;); }}이제 지정한 url로 들어가서 확인해보자.html로 잘 응답한걸 볼 수 있다.1.3 API JSON으로 응답하기.java 파일을 생성하자.package hello.servlet.basic.response;import com.fasterxml.jackson.databind.ObjectMapper;import hello.servlet.basic.JSONData;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;@WebServlet(name = &quot;httpResponseJson&quot;,urlPatterns = &quot;/kms-response-jsontest&quot;)public class HttpResponseJson extends HttpServlet { ObjectMapper objectMapper = new ObjectMapper(); @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //ContentType은 application/json으로 설정해야한다. response.setContentType(&quot;application/json&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); //JSon으로 만들 객체 생성 JSONData jsonData = new JSONData(); jsonData.setUsername(&quot;kms&quot;); jsonData.setAge(95); //Json 형식으로 바꿔주자. String convertdata = objectMapper.writeValueAsString(jsonData); response.getWriter().write(convertdata); }}주석을 참고하고 해당 url로 들어가면 다음과 같이 뜬다.!" }, { "title": "백엔드 웹 개발 노트2.2 - HTTP Request", "url": "/posts/basicSpring4/", "categories": "Java, 6_Spring_김영한_스프링MVC 1편", "tags": "Spring", "date": "2022-04-27 03:50:50 +0900", "snippet": "Http Request에 대한 내용HTTP 요청 메시지를 통해서 클라이언트에서 서버로 전달하는 방식은 크게 3가지가 있다.1. GET 쿼리 파라미터 url에 직접 요청 데이터를 때려 박는다. 구문은 ‘url?username=kms&amp;amp;city=goyang’ 이런식으로 때려박으면된다. URL에 데이터를 담아 보내고, 검색이나 필터 등에서 많이 사용하는 방식이다. 만들어보자.package hello.servlet.basic.request;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.Enumeration;//url : localhost:8080//kms-request-querystring?username=kms&amp;amp;age=27@WebServlet(name = &quot;requestquerystring&quot;, urlPatterns = &quot;/kms-request-querystring&quot;)public class ReqeustQueryString extends HttpServlet { @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(&quot;전체 파라미터 조회하는 법&quot;); request.getParameterNames().asIterator() .forEachRemaining(param -&amp;gt; System.out.println(request.getParameter(param))); System.out.println(&quot;단일 파라미터 조회하는 법&quot;); String username = request.getParameter(&quot;username&quot;); String age = request.getParameter(&quot;age&quot;); System.out.println(&quot;username : &quot; +username); System.out.println(&quot;age : &quot; + age); System.out.println(&quot;복수 파라미터 조회하는 법&quot;); //url : localhost:8080/kms-request-querystring?username=kms&amp;amp;age=27&amp;amp;username=Vayne String[] names = request.getParameterValues(&quot;username&quot;); for(String name : names){ System.out.println(&quot;usernames : &quot; + name); } response.getWriter().write(&quot;ok&quot;); }}주석으로 처리된 url을 직접 때려박으면 된다. 동일 파라미터의 경우 호출하는 메소드가 다르다는 것을 인지하고 있자. 그리고 중복인 경우 getParameter()를 사용하면 getParameterValues()의 첫 번째 값을 반환한다.2. POST HTML Form 헤더값들을 뒤져보면 ‘content-type: application/x-www-form-unlencoded’라는 것이 있다. 이런것들은 Form형식으로 데이터를 보낸 것이다. 메시지 바디에 쿼리 파라미터 형식으로 전달한다. 위와 같이 ‘username=kms&amp;amp;city=goyang’ 처럼 말이다. 회원 가입, 상품 주문 등에서 사용된다.쿼리 파라미터 형식과 보내는 데이터의 구문은 같은데 뭐가 다른걸까?내 생각이다.일단 메시지바디에 ‘username=kms&amp;amp;city=goyang’을 담으므로 url에 데이터가 나타나지 않는다.Form형식으로 보내기 위해서 새로운 HTML파일을 만들어본다.kms-message-body.html&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;form action=&quot;/kms-request-querystring&quot; method=&quot;post&quot;&amp;gt; username: &amp;lt;input type=&quot;text&quot; name=&quot;username&quot; /&amp;gt; age: &amp;lt;input type=&quot;text&quot; name=&quot;age&quot; /&amp;gt; &amp;lt;button type=&quot;submit&quot;&amp;gt;전송&amp;lt;/button&amp;gt;&amp;lt;/form&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;‘/kms-request-quertstring’에 Post 형식으로 username과 age를 보낼 것이다.접근한 url에 데이터를 입력하고 전송 버튼을 누르면 제대로 전달되는 것을 알 수 있다.결과이걸 테스트 하려고 매 번 폼을 작성하는 것은 번거롭다.Postman을 사용해서 작성해보자.Post 형식으로 HTMl Form은 Content-Type이 x-www-urlencoded이므로 ‘x-www-urlencoded’에 체크해주자.그리고 key과 value값을 위처럼 설정해주면 똑같은 결과를 얻을 수 있다.3. HTTP message Body에 데이터를 직접 담아서 요청. HTTP API에서 주로 사용된다. JSON, XML, TEXT 등.String 단순 메시지 보내기.java 파일을 생성하자.package hello.servlet.basic.request;import org.springframework.util.StreamUtils;import org.springframework.util.StringUtils;import javax.servlet.ServletException;import javax.servlet.ServletInputStream;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.InputStream;import java.nio.charset.StandardCharsets;@WebServlet(name = &quot;httpmessagebody&quot;,urlPatterns = &quot;/kms-request-body-string&quot;)public class HttpMessageBody extends HttpServlet { @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //messagebody를 가져옴. ServletInputStream inputStream = request.getInputStream(); //알아볼 수 있는 String으로 가져와야함. UTF-8형식으로 String text = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8); //콘솔에 출력 System.out.println(&quot;message body String : &quot; + text); response.getWriter().write(&quot;ok&quot;); }}Postman으로 보내보자.body에 체크해주고 raw로 보내고 싶은 메시지를 보내보자.잘 간다.JSON 형식으로 보내보기JSON 방식으로 보내기 위해 객체를 만들 것이다.객체 정보를 담는 클래스 파일을 만들어본다.package hello.servlet.basic;import lombok.Getter;import lombok.Setter;@Getter @Setterpublic class JSONData { private String username; private int age;}그리고 새로운 서블릿을 만들어주자.package hello.servlet.basic.request;import com.fasterxml.jackson.databind.ObjectMapper;import hello.servlet.basic.JSONData;import org.springframework.util.StreamUtils;import org.springframework.util.StringUtils;import javax.servlet.ServletException;import javax.servlet.ServletInputStream;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.nio.charset.StandardCharsets;@WebServlet(name = &quot;httpMessageBodyJson&quot;,urlPatterns = &quot;/kms-reqeust-json&quot;)public class HttpMessageBodyJson extends HttpServlet { //Json 객체로 받기위해 private ObjectMapper objectMapper = new ObjectMapper(); @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { ServletInputStream inputStream = request.getInputStream(); String text = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8); System.out.println(&quot;message body : &quot; + text); //객체 형태로 받는 방법. //위에 Mapper를 선언해야함. //객체 형태로 메시지를 받아온다. JSONData jsonData = objectMapper.readValue(text, JSONData.class); System.out.println(&quot;jsonData.username : &quot; + jsonData.getUsername()); System.out.println(&quot;jsonData.age : &quot; + jsonData.getAge()); response.getWriter().write(&quot;ok&quot;); }}Postman에서 JSON형식으로 해놓고 raw형태로 다음과 같이 보내보자.{&quot;username&quot; : &quot;kms&quot;, &quot;age&quot; : 95}잘 간다. 추가로 JSON 결과를 파싱해서 사용할 수 있는 자바 객체로 변환하려면 Jackson, Gson 같은 JSON 변환 라이브러리를 추가해서 사용해야 한다. Spring Boot로 Spring MVC를 선택하면 Jackson라이브러리를 기본적으로 제공한다." }, { "title": "백엔드 웹 개발 노트2.1 - HTTP Request ServletMethod", "url": "/posts/basicSpring3/", "categories": "Java, 6_Spring_김영한_스프링MVC 1편", "tags": "Spring", "date": "2022-04-27 02:50:50 +0900", "snippet": "1. HTTPServletRequest에 대해HTTPServletRequest는 HTTP 요청 메시지를 개발자가 편리하게 사용할 수 있도록 개발자 대신에 HTTP 요청 메시지를 파싱해옴. 이런 것이 없다면 개발자가 직접 파싱해야할 것이다.!이렇게 파싱한 결과를 HTTPServletRequest객체에 담아서 제공한다.중요한 것은 HTTPservletRequest객체는 파싱한 정보를 개발자가 편히 사용할 수 있게끔 도와주는 것이므로 HTTP 파싱정보에 대한 해석은 개발자 몫이다. 따라서 HTTP에 대한 이해가 기본적으로 깔려있어야 한다는 것이다.HTTPServletReqeust는 파싱한 정보를 제공할 뿐만 아니라 추가적인 기능이 있다.//Key와 Value로 데이터를 임시 저장request.setAttribute(name,value)//Key로 데이터를 꺼냄.request.getAttribute(name)//세션관리 기능.//세션 확인request.getSession(create: true)위 처럼 임시 저장소 기능도 제공하며 세션관리 기능도 제공한다.2. HTTPServletRequest 메소드들새 자바파일을 만들어서 Servlet을 등록해보자.package hello.servlet.basic.request;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(name = &quot;httprequesttest&quot;, urlPatterns = &quot;/kms-request-header&quot;)public class HttpRequestTest extends HttpServlet { @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { printStartLine(request); printHeaderData(request); printHeaderUtils(request); printEtc(request); }}2.1 printStartLine() - &amp;gt; StartLine에 대한 정보.private void printStartLine(HttpServletRequest request) { System.out.println(&quot;-----Start Line 정보 -----&quot;); //Post, Get, Put 등 요청 방식 System.out.println(&quot;HTTP Method: &quot; + request.getMethod()); //Protocol 정보 HTTP 버전 등 System.out.println(&quot;HTTP protocol : &quot; + request.getProtocol()); //scheme 정보 http System.out.println(&quot;HTTP scheme : &quot; + request.getScheme()); //URL 정보 (전체 경로) System.out.println(&quot;HTTP URI : &quot; + request.getRequestURL()); //URI 정보 (루트에서의 경로) System.out.println(&quot;HTTP URL : &quot; + request.getRequestURI()); //Secure 정보 https 여부 System.out.println(&quot;HTTP Secure : &quot; + request.isSecure()); //Query String 정보 확인하려면 url의 끝에 아무값이나 넣어보자. System.out.println(&quot;HTTP QueryString : &quot; + request.getQueryString()); System.out.println(&quot;-----Start Line 정보 끝-----&quot;); System.out.println(); }이렇게 작성하고 &amp;lt;localhost:8080/kms-request-header?test=name&amp;gt;에 접근하면 다음과 같이 콘솔에 찍힌다.2.2 printHeaderData() -&amp;gt; 헤더 정보 private void printHeaderData(HttpServletRequest request){ System.out.println(&quot;-----Header 정보 -----&quot;); //옛날방식으로 헤더정보 꺼내오기. /* Enumeration&amp;lt;String&amp;gt; headerNames = request.getHeaderNames(); while(headerNames.hasMoreElements()){ String headerdata = headerNames.nextElement(); System.out.println(headerdata + request.getHeader(headerdata)); } */ //최근 방법으로 꺼내기. request.getHeaderNames().asIterator(). forEachRemaining(headername -&amp;gt; System.out.println(headername + request.getHeader(headername))); System.out.println(&quot;-----Header 정보 끝-----&quot;); System.out.println(); }2.3 printHeaderUtils() - &amp;gt; 헤더 편의 기능 private void printHeaderUtils(HttpServletRequest request) { System.out.println(&quot;--- Header 편의 조회 start ---&quot;); System.out.println(&quot;[Host 편의 조회]&quot;); //Host 정보 System.out.println(&quot;request.getServerName() = &quot; + request.getServerName()); //Port 정보 System.out.println(&quot;request.getServerPort() = &quot; + request.getServerPort()); System.out.println(); System.out.println(&quot;[Accept-Language 편의 조회]&quot;); //lcoal 정보 (언어 우선순위) request.getLocales().asIterator() .forEachRemaining(locale -&amp;gt; System.out.println(&quot;locale = &quot; + locale)); System.out.println(&quot;request.getLocale() = &quot; + request.getLocale()); System.out.println(); //쿠키 System.out.println(&quot;[cookie 편의 조회]&quot;); //쿠키 정보들 if (request.getCookies() != null) { for (Cookie cookie : request.getCookies()) { System.out.println(cookie.getName() + &quot;: &quot; + cookie.getValue()); } } System.out.println(); System.out.println(&quot;[Content 편의 조회]&quot;); //Post방식으로 데이터를 전송하면 알 수 있다. //받은 데이터의 전송 형식 text 등 System.out.println(&quot;request.getContentType() = &quot; + request.getContentType()); //받은 데이터의 길이 (byte) System.out.println(&quot;request.getContentLength() = &quot; +request.getContentLength()); //받은 데이터의 인코딩 형식 System.out.println(&quot;request.getCharacterEncoding() = &quot; + request.getCharacterEncoding()); System.out.println(&quot;--- Header 편의 조회 끝 ---&quot;); System.out.println(); }2.4 printEtc() -&amp;gt; 네트워크 관련private void printEtc(HttpServletRequest request) { System.out.println(&quot;--- 그 외의 기능 (네트워크 관련) ---&quot;); System.out.println(&quot;request getRemoteUser() : &quot; + request.getRemoteUser()); System.out.println(&quot;request getRemoteAddr() : &quot; + request.getRemoteAddr()); System.out.println(&quot;request getRemoteHost() : &quot; + request.getRemoteHost()); System.out.println(&quot;request getRemotePort() : &quot; + request.getRemotePort()); // System.out.println(&quot;request getLocalAddr() : &quot; + request.getLocalAddr()); System.out.println(&quot;request getLocalName() : &quot; + request.getLocalName()); System.out.println(&quot;request getLocalPort() : &quot; + request.getLocalPort()); System.out.println(&quot;--- 그 외의 기능 (네트워크 관련) 끝 ---&quot;); System.out.println(); }" }, { "title": "백엔드 웹 개발 노트3.1 - Web 예제", "url": "/posts/basicSpring3_1/", "categories": "Java, 6_Spring_김영한_스프링MVC 1편", "tags": "Spring", "date": "2022-04-27 01:50:50 +0900", "snippet": "1. 도메인 모델 작성domain 패키지를 만들고 그 안에 Member라는 클래스를 작성하였다.package hello.servlet.basic.domain;import lombok.Getter;import lombok.Setter;import static java.lang.Math.pow;//lombok@Getter @Setterpublic class Member { //index private Long id; private String username; private int height; private int weight; private double bmi; public Member(){} public Member( String username, int height, int weight) { this.username = username; this.height = height; this.weight = weight; this.bmi = calbmi(height,weight); } /* BMI계산 산출식 : (남자 기준) 체중/신장^2 */ public double calbmi(int height, int weight){ double calheight = (double)height/100; return weight / pow(calheight,2); }}bim계산을 Member 클래스에 넣은 이유는 이제 만들 저장소에 계산 메소드가 들어가는게 아니라고 생각하고 서비스함수이므로 Member 클래스에 넣어 새로운 객체를 만들때마다 자동으로 초기화해주는게 낫다고 생각하였다.다음은 저장소를 만들어 보겠다.프로젝트가 크지 않으므로 domain 패키지안에 MemberRepository를 만들겠다.package hello.servlet.basic.domain;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import static java.lang.Math.pow;public class MemberRepository { //저장소 private static final Map&amp;lt;Long,Member&amp;gt; store = new HashMap&amp;lt;&amp;gt;(); //index가 증가할수록 1씩 늘어남. private static long sequence = 0L; //싱글톤 기법으로 객체 생성 private static final MemberRepository instance = new MemberRepository(); private MemberRepository(){} public static MemberRepository getInstance(){ return instance; } //Method /* 멤버 저장 */ public Member save(Member member){ member.setId(++sequence); store.put(member.getId(), member); return member; } /* 단일 멤버 조회 */ public Member findById(Long id){ return store.get(id); } /* 전체 멤버 조회 */ public List&amp;lt;Member&amp;gt; findByAll(){ return new ArrayList&amp;lt;&amp;gt;(store.values()); } /* 저장소 삭제 */ public void clearStore(){ store.clear(); }}Spring을 사용하면 스프링빈으로 등록하여 싱글톤 패턴을 사용하지 않아도 되지만, 스프링을 아직 사용할 생각이 없다고 강의에서 그런다.싱글톤 패턴이 뭘까?1.1 싱글톤 패턴하나의 인스턴스를 생성하여 모든 클라이언트에게 동일한 객체를 반환하는 패턴이다.원래 기본 코드는if(instance == null){ //최초 한번만 new 연산자를 통하여 메모리에 할당한다. instance = new SingleTon();} 최초 할당시 위처럼 객체를 새로 생성하지만 위의 코드는 그렇지 않다. 자동으로 감지하여 생성해주나보다.2. 테스트 코드테스트 코드를 작성해보자.2.1 멤버 저장 테스트 코드package hello.servlet.domain;import hello.servlet.basic.domain.Member;import hello.servlet.basic.domain.MemberRepository;import org.assertj.core.api.Assertions;import org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.Test;class MemberRepositoryTest { MemberRepository memberRepository = MemberRepository.getInstance(); //테스트를 끝나고 저장소를 초기화 @AfterEach void afterEach(){ memberRepository.clearStore(); } @Test void save(){ //given Member member= new Member(&quot;kms&quot;,178,74); //when Member savemember = memberRepository.save(member); //then Member findmember = memberRepository.findById(savemember.getId()); Assertions.assertThat(savemember).isEqualTo(findmember); }}2.2 findByall Test @Test void findbyAll(){ //given Member user1 = new Member(&quot;kms&quot;, 178, 74); Member user2 = new Member(&quot;jyb&quot;, 160, 46); memberRepository.save(user1); memberRepository.save(user2); //when List&amp;lt;Member&amp;gt; members = memberRepository.findByAll(); System.out.println(user2.getBmi()); //then Assertions.assertThat(members.size()).isEqualTo(2); Assertions.assertThat(members).contains(user1,user2); }2.3 결과findById()나 bmi계산관련 테스트는 없다. 간단해서2편에서 서블릿을 사용한 동적 html을 만들어보도록 하겠다." }, { "title": "백엔드 웹 개발 노트2 - Servlet 동작방식", "url": "/posts/basicSpring2/", "categories": "Java, 6_Spring_김영한_스프링MVC 1편", "tags": "Spring", "date": "2022-04-27 01:50:50 +0900", "snippet": "1. Servlet 노트1.2 프로젝트 생성서블릿을 사용하기 위해서 프로젝트를 생성한다.https://start.spring.io/에서 다음과 같이 설정한다.Group명과 Artifact는 적절하게 바꾸면 된다.중요한 것은 Servlet을 원할하게 사용하기 위해서는 Packaging을 Jar가 아닌 War로 설정해야 한다.전부 설정했다면 Intellij에서 불러오면 된다.1.3 서블릿 기초 코드부트로 설정 하지 않아도 서블릿을 동작시킬 수 있다.하지만 부트에서는 내장톰캣을 제공해서 서버를 작동시키기 편하다. 부트의 기능을 이용하지 않으면 직접 톰캣 설정을 해줘야하기 때문이다.먼저 서블릿 메인 함수에 다음과같이 애노테이션을 달아준다.@ServletComponentScan //서블릿을 자동으로 등록해준다.@SpringBootApllication대충 메인 클래스1.3.1 ServletComponentScan ?이게 무슨 애노테이션일까? 찾아보니 다음과 같다.SpringBoot 환경에서 basePackages 하위서블릿컴포넌트(필터, 서블릿, 리스너)를 스캔해서 빈으로 등록한다.다만 서블릿컴포넌트를 그냥 등록하는게 아니고 해당 서블릿컴포넌트 클래스에는아래와 같이 별도의 어노테이션이 추가되어 있어야 한다. 필터: @WebFilter 서블릿: @WebServlet 리스너: @WebListener이는 SpringBoot의 내장톰캣을 사용하는 경우에만 동작한다. 라고 되어있지만 나는 톰캣 설정을 따로 해줘도 동작한다고 생각. 되던데?이게 무슨 소리인지 나는 알겠지만 처음 배우는 사람들은 모를 것이다.첨언을 하자면, 필터는 서블릿이 동작하기 전에 사전작업을 해주는데, boot에서 서블릿을 실행하기 전에 저 애노테이션이 달린 것들을 스캔해서 실행한다는 의미같다. 서블릿은 마찬가지로 저 애노테이션이 달린 것들을 스캔하여 서블릿을 동작시킨다.WebListner는 나도 몰라서 찾아봤다.https://dololak.tistory.com/616여기 글을 인용하였다.간단하게 WebListner는 어플리케이션이 실행될 때, 종료될 때 이벤트를 설정할 수 있는 핸들러이다.새로운 자바클래스를 만들어서 서블릿을 작성해본다.//name은 서블릿 이름, urlPatterns은 접근 url//즉 localhost:8080/lol로 접근이 가능하다.@WebServlet(name = &quot;servletbasic&quot;, urlPatterns = &quot;/lol&quot;)public class Servletbasic extends HttpServlet { @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //콘솔에 찍힘 System.out.println(&quot;Serlvet start!!&quot;); System.out.println(&quot;Request 정보 : &quot; + request); System.out.println(&quot;Response 정보 : &quot; + response); //get변수들에 url에 적은 값들을 가져옴. //getParameter안에 값들은 url에 적을 값들임. 즉, useranme=입력할값. 이렇게 String getuser = request.getParameter(&quot;username&quot;); String getname = request.getParameter(&quot;chamname&quot;); //콘솔에 가져온 값들을 찍음. System.out.println(&quot;가져온 유저 : &quot; + getuser); System.out.println(&quot;가져온 chamname : &quot; +getname); //전송형태 지정 response.setContentType(&quot;text/plain&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); //받아온 값을 html에 그려서 클라이언트에 돌려줌. response.getWriter().write(getuser); response.getWriter().write(getname); }}원래 예제를 적을 수 없으므로 변형을 했다. 기본 예제는 파라미터 값을 1개만 받지만 나는 2개를 받았다.서버를 구동하고 다음과 같이 url을 적어주자.‘localhost:8080/lol?username=Kms&amp;amp;chamname=Vayne’이렇게 적으면 화면은 다음과 같이 그려진다.콘솔창은 다음처럼 찍힐 것이다.로그로 요청메시지를 확인하는 방법이 있다.application.properties 파일에 다음과 같이 쳐주자.logging.level.org.apache.coyote.http11=debug그리고 서버를 재실행하면 콘솔창에 다음과 같이 로그가 찍힌다.단 운영서버에서는 부하가 걸릴 수 있으므로 개발단계에서만 쓰도록 하자.쿠키에 exp= 어쩌구 저쩌구가 있는데, 쿠키를 이용한 프로젝트를 수행하다보니 쿠키가 저렇게 남은거므로 무시하면 된다.1.4 동작 방식서버를 구동시키면 톰캣을 띄우면서 우리가 작성한 ‘servletbasic’이라는 서블릿을 생성하여 서블릿 컨테이너에 집어 넣고 대기하고 있음.요청이 오면 request와 response를 생성하여 전처리를 한 다음 서블릿컨테이너에 전달.서블릿 컨테이너는 service함수를 동작시켜 response 객체를 조작하고 이를 받은 곳에 다시 반환.반환 받은 곳에서는 HTTP응답을 생성하여 클라이언트에 전달." }, { "title": "Programmers_2022 KAKAO BLIND RECRUITMENT 신고 결과 받기(python)", "url": "/posts/Programmers_get_result/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2022-04-16 02:34:40 +0900", "snippet": "프로그래머스 카카오 블라인드 2022 - 신고 결과 받기 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/860512. 분류 및 난이도Programmers 문제입니다.프로그래머스 카카오 블라인드 2022 문제입니다.Level 1난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 중첩 dictionary를 사용하였습니다.4. 접근 방법을 적용한 코드def solution(id_list, report, k): dict ={} result =[0] * len(id_list) for id in id_list : tmpdic ={} tmpdic[&#39;data&#39;] = list() tmpdic[&#39;count&#39;] = 0 dict[id] = tmpdic for repdata in report : fromp,to = repdata.split(&#39; &#39;) if to not in dict[fromp][&#39;data&#39;] : dict[fromp][&#39;data&#39;].append(to) dict[to][&#39;count&#39;] +=1 idx = 0 for data in dict : for id in dict[data][&#39;data&#39;] : if dict[id][&#39;count&#39;] &amp;gt;= k : result[idx] +=1 idx+=1 return result5. 결과필요시. c++ 짜드리겠습니다. 설명이 필요시 댓글달아주세요." }, { "title": "Programmers_위클리챌린지 시즌3 없는 숫자 더하기(python)", "url": "/posts/Programmers_add_none_digit/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2022-04-16 01:34:40 +0900", "snippet": "프로그래머스 위클리 챌린지 시즌3 - 없는 숫자 더하기 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/860512. 분류 및 난이도Programmers 문제입니다.위클리 챌린지 시즌3 문제입니다.Level 1난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 어렵지 않고, 좀 더 효율적으로 계산(FOR문 하나로만 처리)하기 위해 10까지 더한값에서 배열의 합을 뺐습니다.4. 접근 방법을 적용한 코드def solution(numbers): result = 1+2+3+4+5+6+7+8+9 ans = sum(numbers) return result - ans5. 결과필요시. c++ 짜드리겠습니다. 설명이 필요시 댓글달아주세요." }, { "title": "디지털기획입문강의(1)", "url": "/posts/DTUniversity01/", "categories": "디지털기획, 강의", "tags": "기획", "date": "2022-04-06 01:34:40 +0900", "snippet": "DTUniversity_디지털기획입문안효은 강사님.회사에 신청한 디지털기획입문 정리노트Chapter01 디지털 마케팅1. 마케팅 기본 개념 광고 : 판매자 중심, 영업 : 판매자 중심, 마케팅 : 시장/고객 중심, 대공항, 2차대전때는 경제가 좋지 않아서 사람들의 소비가 줄음. → 광고, 영업업이 활성시장이 살아나면서 소비력이 늘음에 따라 → 마케팅이 활성 ‘팔다’ → ‘팔리다’ 로 상품이 아닌 브랜드가 팔리게끔 기업의 이야기를 해주는 것. 이것이 마케팅 2. 마케팅믹스의 변화 흐름4P(기업중심) → 4C(고객중심) → 4R(관계중심) 4P 기업중심 Product : 제품 Price : 가격 Place : 파는 장소 Promotion : 광고 4C 고객중심 Customer Benefit : 고객들의 느낌을 생각해야함 Cost : 비용 Convenience : 고객들의 편리성(온라인 구매 등) Communication : 고객들과의 소통 4R 관계중심 Responsive : 반응할 수 있어야한다. (댓글 등) Relevant : 일상생활 속에서 마주할 수 있는 브랜드 가치 (일상속에서 고객들의 일상과 관련된것들을 판매할 수 있는것) Relationship : 소비자들과의 관계, 입장을 생각해보자는 것. Return : 고객들이 가치를 느낄 수 있게 해야함. 3. 마케팅 4.0시대 마케팅 믹스고객경로 5A Model Aware(인지) - 브랜드 노출 Appeal(호감) - 브랜드에서 전발받은 메시지를 처리하고 몇몇 브랜드에만 끌림. Ask(질문) - 호기심이 생긴 고객은 미디어, 공식채널 등을 통해 정보를 위한 적극적조사에 착수 Act(행동) - 추가 정보를 접하고 호감을 확인한 고객은 특정 브랜드를 구매하기로 결정 Advocate(옹호) - 충성심은 유지, 재구매, 브랜드를 옹호하는 행동으로 이어짐. 소비자 개개인이 다른 사람들에게 이야기하면서 브랜드를 홍보해줌.4. ATL과 BTL 경계가 무너진다 (이론)ATL : Above the line - TV, 신문, 라디오, 잡지 등 일방향 소통으로 널리 퍼트리는 방법 이라는 뜻.(피드백을 받기 힘듦)BTL : Below the line - 비 전통적 매체(디지털/오프라인 등) 소비자와 접촉하는 활동으로 효율적 광고 시, 적합한 방법. 양방향적경계가 무너지고 있다. 이 둘 라인을 넘나드는 Through the line 이라는 비교적 최근 개념인 TTL이생겨남.5. ATL과 BTL 경계가 무너진다 (사례)None 사례에 대한 이야기.6. 디지털마케팅이란? 인터넷을 중심으로 모바일기기, 배너광고 등 다양한 채널을 통해 디지털 기술을 사용하여 제품이나 서비스를 마케팅 하는 것. Interaction이 어떻게 펼쳐질 수 있을까라는 생각자체가 디지털마케팅. 다양한 미디어를 넘나든다. 인터넷/온라인 마케팅 : 검증 불가능한 컨텐츠 생산과 공유, 과도한 무료 정보 증가 👉 디지털 마케팅 : 스마트/디지털 기술을 활용한 컨텐츠 증대, 과도한 정보 속 필요정보 선택. 데이터, 그래프 등을 분석해서 유의미한 인사이트를 선별하고 그것을 비즈니스에 활용하는것 7. 디지털 마케팅 발전 배경: 디지털 기술의 발전 모바일의 광고비가 PC 광고비를 넘음. 모바일은 접근성이 좋고, 스마트폰 보급 와이파이의 발전의 영향 TV를 잘 안 봄. 모바일 기반의 플랫폼/콘텐츠 등장8. 디지털 마케팅 발전 배경: 소비자 이용행태의 변화 소비자의 이용행태에 관한 강의 인스타그램 → 유튜브 → 네이버 리뷰 등을 봄. 소비자 중심의 데이터 필터링이 가능해짐. 필터링이 되어도 걸러지지 않도록 브랜드가치를 높여야함. 마케팅 전략의 필요.9. 디지털 마케팅의 이해 - 디지털 마케팅 발전 배경: 디지털 시대별 변화의 흐름 Web1.0 → Web2.0 → Web3.0 디지털 이주시대 → 정보의 생성 시대 → 정보의 가공시대 얼마나 사람들에게 많이 노출할 것인가 → 얼마나 적당한 순간에 노출할 것인가. 어떻게 자주 관계를 맺게 할 것인가?10. 디지털 마케팅의 이해 - 디지털 마케팅 발전 배경: 디지털 관점 별 흐름 Community(Email, Brand Site…) → Contents(UCC, Blog, Viral) → Context(주변 상황, 시간, 환경 등이 고려된 좀 더 깊은 곳에 숨겨져 있는 의미를 파악) 고객의 니즈와 시장의 트렌드를 발견하고 최적화하여 메시지를 전달하는 것부터 집중.11. 디지털 채널 별 특징 네이버 : 상위노출의 목적. 최적화 전략, 지속 활용력, 정보 전달력이 필요. 페이스북 : 컨텐츠확산/공유의 목적. 최적화는 부족, 정보 전달력이 있음. 인스타그램 : 트렌드 생성. 해시태그 활용, 뉴트렌드 생성, 정보전달의 제한. 검색엔진의 도달률(따봉의 증가속도)는 낮지만 구매 전환률은 높은편. SNS는 도달률이 높지만 흥미위주라 구매 전환률은 낮은편.이 채널들을 합친 통합운영의 필요성이 있다.12. 디지털 미디어 플래닝 브랜드 공식 SNS 채널, 브랜드 웹 사이트 등 (Owned 미디어) 브랜드 신뢰감 구축, 고객과의 관계형성 꾸준한 컨텐츠 제작, 채널유입 광고 집행 소셜네트워크 서비스, PR, 텍스트/동영상 콘텐츠 (Earned 미디어) - 소비자들이 자발적으로 컨텐츠를 올리는 개념. 브랜드 호감도가 높은 사람들의 자발적인 컨텐츠들의 생성, 확산 텍스트 형식의 블로그부터 유튜브, 인스타 등의 멀티 콘텐츠까지 확산. 디스플레이 광고, 검색마케팅, 프로모션 및 PPL (Paid 미디어) - 돈을 써서 컨텐츠를 홍보. 돈이 들지만 단기적 컨텐츠 메시지에 맞는 채널/인플루언서와의 제휴. 채널에 대한 운영업무 없이 컨텐츠에 대한 인게이지먼트 창출 극대화 이것들을 고루고루 잘 퍼트려야함. 어느 하나에 치중하지 않아야 한다.크로스 미디어 : 메시지 + 미디어 + 컨텐츠가 각각 형식에 맞게 변형하여 전달됨.→트랜스미디어 : 각각 형식에 맞게 변형하여 전달되지만 그것들이 또 융합하여 전달됨.13. 디지털 콘텐츠 형태 규모 → 양/질 (소비자가 콘텐츠를 필터링할 수 있으므로) 브랜디드 컨텐츠 : 브랜드에센스를 기본으로 장점들이 잘 나열되어 있다. 고객들이 시간을 내어 즐기고, 공유할만한 내용으로 구성 (ex 딩고 x 참이슬의 이슬라이브 등) 네이티브 애드 : 흥미를 유발할 수 있는 컨텐츠에 브랜드를 녹여 광고에 대한 거부감을 줄이고 효과는 상승 시킴. (ex 여행에 미치다? 나는 안 봐서 모르겠는데.. 사진속에 화장품들이 있고 분위기를 연출..같은것)14. 디지털 마케팅 믹스 고객들이 어디에서 들어오는가? 노출 : 어떤 타켓들에게 노출시켜야하는가? 분석. 유입 : 어디에서 들어왔는가. 하지만 정말 고객이 원하는 정보를 얻고 나갔는지는 알기 힘듦. 전환 : 우리가 목표로 삼은 어떤 행동을 하였는가? 하지만 이것들은 원할히 진행되지 않는다. 고객들을 어떻게 설득 시킬 것인가? 노출 : 디지털미디어광고, PR, 컨텐츠광고, 캠페인 진행 등.. 유입 : 검색최적화, 채널최적화, 전환 : 목적에 맞게 유도할 수 있게끔 생각해보자. 결국 최적화가 중요하다. 애자일, 빠르게 수행하자.15. 디지털 마케팅 전개모델 Step1 : Be there - 팬들과 소통할 수 있는 채널에서 활동. Step2 : Be Useful - 유용한 컨텐츠로 소비자들을 설득 Step3 : Be Quick : 앞으로의 트렌드를 미리 캐치하고 반영. Step4 : Connect the Dots : 꾸준한 트래킹 및 데이터분석을 통한 브랜드 상황파악 LTE모델 : Love + Triggers + Experience - 브랜드를 사랑하게 만들고 경험을 유도해야함. STD모델 : See + Think + Do - 소비자가 보고 생각하고 재방문 등 목적에 맞는 행동을 유도하게끔 해야하는 모델. " }, { "title": "git - 잔디가 안 심어질때, git rebase를 이용한 해결법.", "url": "/posts/0404giterror/", "categories": "Error, git", "tags": "error", "date": "2022-04-04 03:34:40 +0900", "snippet": "잔디가 사라졌다.맥북을 바꾸면서 git 설정을 해줬는데, 제대로 되지 않은 것 같다.참고글은 다음과 같다.https://babbab2.tistory.com/12?category=846263그런데 git push -f 하는곳에서 잘 되지 않아서https://parksb.github.io/article/28.html을 통해 따로 또 커밋설정을 해주었다.git commit --amend -m &quot;내용&quot;git rebase --continuegit push -f origin master해결" }, { "title": "npm - self signed certificate in certificin Error 해결법", "url": "/posts/npmconfig/", "categories": "Error, NPM", "tags": "error", "date": "2022-04-04 02:34:40 +0900", "snippet": "npm install 시에 발생하는‘Error:SSL Error: SELFT_SIGNED_CERT_IN_CHAIN’ error 또는‘self signed certificate in certificin Error’ 해결.인증서문제 같은데npm config set strict-ssl false로 해결.인증서 검사를 안하겠다는 것.쓸만한 글 : http://blog.securekim.com/2019/03/bash-gradle-python-wget-nodejsnpm-apt.html" }, { "title": "Programmers_월간 코드 챌린지 시즌 3- 나머지가 1이 되는 수 찾기(python)", "url": "/posts/Progrmmaer_find_mod_one/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2022-03-13 02:34:40 +0900", "snippet": "프로그래머스 월간 코드 챌린지 시즌3 나머지가 1이 되는 수 찾기 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/87389?language=python32. 분류 및 난이도Programmers 문제입니다.월간 코드 챌린지 시즌3문제 입니다.Level 1난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 어렵지 않습니다. 효율성 고려 안했습니다.4. 접근 방법을 적용한 코드def solution(n): for i in range(2,n+1): if n%i == 1: return i return i5. 결과필요시. c++ 짜드리겠습니다. 설명이 필요시 댓글달아주세요." }, { "title": "Baekjoon(백준)-5525 IOIOI(Sliver 2)", "url": "/posts/baekjoon5525/", "categories": "Algorithm, Baekjoon", "tags": "baekjoon", "date": "2022-02-11 01:34:50 +0900", "snippet": "baekjoon 5525 - IOIOI문제입니다.1. 문제https://www.acmicpc.net/problem/55252. Input , Outputbaekjoon문제는 스크린샷을 포함하지 않습니다.3. 분류 및 난이도Sliver24. 문제 해석링크 참조.5. codepythonN = int(input())M = int(input())data = input()fidx = data.find(&quot;I&quot;),count = 0result = 0if fidx == -1: print(-1)else : i = fidx while fidx != -1 : if i+1 &amp;gt;=M or i+2 &amp;gt;=M : if count &amp;gt;= N: result += count - N + 1 break if data[i+1] == &#39;O&#39; and data[i+2] == &#39;I&#39; : count+=1 i+=2 else : if count &amp;gt;= N : result += count - N + 1 count =0 fidx= data.find(&quot;I&quot;,i+1) if fidx ==-1 : break i = fidxprint(result) 6. 결과 및 후기, 개선점 중복되는 코드가 너무 많음.필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "Baekjoon(백준)-7569 토마토(Gold 5)", "url": "/posts/baekjoon7569/", "categories": "Algorithm, Baekjoon", "tags": "baekjoon", "date": "2022-02-09 01:34:50 +0900", "snippet": "baekjoon 7569 - 토마토문제입니다.1. 문제https://www.acmicpc.net/problem/75692. Input , Outputbaekjoon문제는 스크린샷을 포함하지 않습니다.3. 분류 및 난이도Gold54. 문제 해석링크 참조.5. codepythonimport sysfrom collections import dequetomato = []M,N,H = map(int,input().split())dq = deque()for depth in range(H) : tomato.append([]) for col in range(N) : tomato[depth].append(list(map(int,sys.stdin.readline().split()))) # depth, col, row 순임.check = [[[0 for row in range(M)]for col in range(N)] for depth in range(H)]day = 0tempdq = deque()dx =[-1,0,1,0,0,0]dy =[0,1,0,-1,0,0]dz = [0,0,0,0,1,-1]#초기 체크tocount = 0 for depth in range(H) : for row in range(M) : for col in range(N) : #print(depth,row,col,M,N) if tomato[depth][col][row] == 1: check[depth][col][row] = 1 dq.append((depth,row,col,0)) if tomato[depth][col][row] == 0 : tocount += 1#print(dq)while dq : d,r,c,counting = dq.popleft() #print(d,r,c,counting) for k in range(len(dz)) : newr,newc,newd = dx[k] + r,dy[k] + c,dz[k] + d if 0&amp;lt;= newd and newd &amp;lt; H and 0&amp;lt;=newr and newr&amp;lt;M and 0&amp;lt;=newc and newc &amp;lt; N : if check[newd][newc][newr] == 0 and tomato[newd][newc][newr] != -1 : if tomato[newd][newc][newr] == 0 : tocount-=1 tempdq.append((newd,newr,newc)) dq.append((newd,newr,newc,counting+1)) check[newd][newc][newr] = 1 while tempdq : td,tr,tc = tempdq.popleft() tomato[td][tc][tr] = 1 day=countingif tocount == 0 : print(day)else : print(-1) 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "The deployment failed because no instances were found for your deployment group. AWS 해결방법", "url": "/posts/awsdeploy/", "categories": "Error, AWS", "tags": "AWS", "date": "2022-02-03 01:50:50 +0900", "snippet": "The deployment failed because no instances were found for your deployment group. Check your deployment group settings to make sure the tags for your Amazon EC2 instances or Auto Scaling groups correctly identify the instances you want to deploy to, and then try again.해결방법이다.수 많은 고통의 흔적이 보이는가?진짜 삽질을 줫나 많이했다.구글링을 하다보면 크게 3가지 방법을 알려준다. 위의 오류는 태그 이름의 매칭 실패에 관한 에러입니다.해결 방법은 ec2&amp;gt;인스턴스에서 인스턴스의 이름과 배포 그룹의 태그 Name의 value값이 일치해야합니다. /var/log/aws/code-agent 로그를 봐라 그냥 인스턴스 갈아 엎어라. 사용자의 role이 잘 설정되었나 봐라.등 ..1번의 경우는 모든 연관관계가 잘 설정되었나 보라는거다.봤다.실패2번 로그를 봐도 별 내용이 없었던 것 같았다.3번은 시도조차 하기 싫었다.4번은 잘설정되어 있었다.도대체 뭐가 문제였을까?그래도 결국 로그를 보라고..\\&quot;error_code\\&quot;:5,\\&quot;script_name\\&quot;:\\&quot;\\&quot;,\\&quot;message\\&quot;:\\&quot;The CodeDeploy agent did not find an AppSpec file within the unpacked revision directory at revision-relative path ~어쩌구 저ㄱ쩌구ㅇ?갑자기 막 배포를 시도하다보니 로그에 찍혔다.해석을 해보니 AppSpec파일을 모르겠단다.분명 나는 작성해쓴데 왜 모르겠단거지?하면서 github action에 등록한 .yml 파일을 봤다.~ # Jar 파일 Copy - name: Copy Jar run: cp ./build/libs/*.jar ./deploy/ # 압축파일 형태로 전달 - name: Make zip file run: zip -r -qq -j ./coinserver.zip ./deploy # S3 Bucket으로 copy - name: Deliver to AWS S3 ~ 가독성을 위한 코드 # appspec.yml 파일 복사 - name: Copy appspec.yml run: cp appspec.yml ./deploy # 배포 - name: CodeDeploy ~ 가독성을 위한 코드이렇게 되어 있었다.내가 대충 알기론 이 코드들의 흐름이 없다고 알고 있는데 설마?..S3 Bucket으로 보내고 appspec.yml을 복사해서 S3에 appspec.yml이 도달하지 않았나?라는 생각을 하게 되었다.그래서 코드의 순서를 바꾸었다.~ # Jar 파일 Copy - name: Copy Jar run: cp ./build/libs/*.jar ./deploy/ # appspec.yml 파일 복사 - name: Copy appspec.yml run: cp appspec.yml ./deploy # 압축파일 형태로 전달 - name: Make zip file run: zip -r -qq -j ./coinserver.zip ./deploy # S3 Bucket으로 copy - name: Deliver to AWS S3 ~ 가독성을 위한 코드 # 배포 - name: CodeDeploy ~ 가독성을 위한 코드요로콤그랬더니 성공진짜 어이가 없지만 해결해서 다행이다내 EC2에 잘 올라왔다..ㅠㅠㅠㅠㅠ" }, { "title": "leetcode(리트코드)-605 Can Place Flowers", "url": "/posts/leetcode605/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2022-01-18 01:34:50 +0900", "snippet": "leetcode 605 - Can Place Flowers문제입니다.1. 문제https://leetcode.com/problems/can-place-flowers/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 n개의 꽃을 심을겁니다. 인접하지 않게 심을건데 1은 이미 심어져 있는 꽃, 0은 심어지지 않은 곳 입니다. 인접하지 않게 꽃을 전부 심을 수 있으면 True, 아니면 False를 리턴하세요.5. codepythonclass Solution: def canPlaceFlowers(self, flowerbed: List[int], n: int) -&amp;gt; bool: if n == 0 : return True if len(flowerbed) == 1 : if flowerbed[0]== 1 and n==1 : return False else : return True for i in range(len(flowerbed)): if i == 0 and flowerbed[i] == 0: if flowerbed[i+1] == 0 : n-=1 flowerbed[i]=1 elif i == (len(flowerbed)-1) : if(flowerbed[i-1] == 0) and flowerbed[i] == 0: n-=1 flowerbed[i]=1 else: if flowerbed[i-1] == 0 and flowerbed[i+1] == 0 and flowerbed[i]==0 : n-=1 flowerbed[i]=1 if n&amp;lt;1 : return True return False 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "Mac OS X1(M1 Chip) Python 기본 버전 바꾸기", "url": "/posts/macchangePython/", "categories": "Error", "tags": "", "date": "2022-01-17 01:50:50 +0900", "snippet": "Mac에 기본으로 등록되어 있는 Python 버전 바꾸기 삽질.파이썬으로 바이낸스API를 이용하기 위해 알아보니, 맥에는 기본적으로 파이썬이 깔려있다는 것.심지어 2.7버전이고 권장하지 않는다고 터미널에서 알려준다.python 버전을 바꾸기 위해서 여러 블로그에는 이렇게 나와있다. 설치된 위치 확인. ls -l /usr/local/bin/python* 여기서 부터 에러가 난다. 왜냐하면 /usr/local이 없기 때문이다. 실제로 ls -l /usr/bin/python* 으로 하면 보인다. 즉, local이 빠져있다. 파이썬 버전 변경을 위해 다음 명령어를 친다. ln -s -f /usr/local/bin/python3.9 /usr/local/bin/python 여기서 나는 local 경로가 없기에 다음과 같이 쳐주었다.sudo ln -s -f /usr/bin/python3.9 /usr/bin/python그런데..ln: /usr/bin/python: Operation not permitted라는 에러가 떴다.머릿속 : ‘sudo로 썼는데 왜 접근에러가 뜬거지?’구글링을 하다보니 mac의 ‘보안 및 개인정보 보호’를 수정해줘야한다해서 바꿔봤다.그래도 해결이 되지 않았다..뭔가 여기에 힌트가 나와있는것 같아서 고치려고 했지만 잘 되지 않았다.https://stackoverflow.com/questions/36730549/cannot-create-a-symlink-inside-of-usr-bin-even-as-sudo/36734569하는 수 없이 homebrew로 설치하기로 했다../bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;설치하고 다음 블로그의 대로 파이썬을 설치https://imksh.com/90성공!" }, { "title": "leetcode(리트코드)-1128 Number of Equivalent Domino Pairs(PYTHON)", "url": "/posts/leetcode1128/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2022-01-15 01:34:50 +0900", "snippet": "leetcode 1128 - Number of Equivalent Domino Pairs문제입니다.1. 문제https://leetcode.com/problems/number-of-equivalent-domino-pairs/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 2개의 데이터를 갖는 도미노들이 들어옵니다. 2개의 데이터의 위치를 바꿔도 되니까 같은 도미노쌍의 총 개수를 리턴하세요.5. codepythonclass Solution: def numEquivDominoPairs(self, dominoes: List[List[int]]) -&amp;gt; int: check = [[0] * 10 for i in range(10)] result = 0 for i in range(len(dominoes)) : x,y = dominoes[i][0], dominoes[i][1] if x &amp;gt; y : check[y][x] += 1 else : check[x][y] += 1 for i in range(10) : for j in range(10) : if check[i][j] &amp;gt;1 : result += (check[i][j] *(check[i][j]-1)) //2 return result 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "백엔드 웹 개발 노트1 - 웹 애플리케이션 이해", "url": "/posts/basicSpring1/", "categories": "Java, 6_Spring_김영한_스프링MVC 1편", "tags": "Spring", "date": "2021-12-19 01:50:50 +0900", "snippet": "1. 웹서버와 웹어플리케이션 서버정적인 페이지를 관리하는 웹 서버와 어플리케이션 로직을 관리하는 웹 어플리케이션 서버가 있다.1.1 웹 서버 웹 서버는 주로 html, css, js, 이미지, 영상 등을 관리한다. Apache, NGINX가 있다.1.2 웹 어플리케이션 서버(WAS) 프로그램 코드를 실행해서 어플리케이션 로직을 수행한다. 동적 HTML, HTTP API(JSON) 등 서블릿, jsp, Spring MVC 톰캣, jetty, Undertow 등이 있다.1.3 서버 구성1기존에는 WAS + DB로 서버를 구성하였다.WAS는 정적리소스와 동적리소스 둘 다 다룰 수 있기 때문이다.시간이 지나면서 WAS에 과부하가 걸리면서 많은 에러를 쏟아냈고, 비싼값을 가진 어플리케이션 로직을 수행하느라 간단한 정적요청을 수행 못하는 일도 있었다.무엇보다도 WAS서버는 장애가 일어나면 사용자에게 에러페이지를 띄우기도 힘들었다.2Web server + WAS + DB 구성정적 리소스를 담당하는 Web을 앞에 두어 처리하고 동적인 요청처리가 필요하면 WAS로 넘겨서 처리한다.효율적인 리소스 관리가 가능하고 정적인 요청이 많은 경우 Web Server를 늘리고, 동적인 요청이 많은 경우 WAS서버를 늘리는 유동적인 증설도 가능했다.또한 WAS에서 요청이 불통이어도 Web서버를 거치기에 사용자에게 에러페이지를 보여주기에도 용이했다.2. 서블릿(Servlet)클라이언트가 데이터를 전송할 때 처리해야할 로직이 많다. 서버 TCP/IP 대기, 소켓 연결 HTTP 요청 메시지를 파싱해서 읽기. POST방식, GET방식 등 인지 Content-Type 확인 HTTP 메시지 바디 내용 파싱 저장 프로세스 실행 비즈니스 로직 실행 HTTP 응답 메시지 생성 시작 TCP/IP에 응답 전달, 소켓 종료이렇게 많은 처리를 예전에는 직접했다.서블릿을 지원하는 WAS를 사용하면서 ‘비즈니스 로직’을 제외한 모든 일은 서블릿이 자동으로 처리해주기 시작했다.2.1 하는 일서블릿을 사용할 경우 우리는 다음과 같은 로직만 작성하면 된다. WAS는 Request, Response 객체를 새로 만들어서 서블릿 객체 호출 개발자는 Request 객체에서 HTTP 요청 정보를 편리하게 꺼내서 사용. 개발자는 Response 객체에서 HTTP 응답 정보를 편리하게 작성. WAS는 Response 객체에 담겨있는 내용으로 HTTP 응답 정보를 생성. 서블릿 객체는 싱글톤으로 관리하기 때문에 공유 변수 사용에 주의해야한다. 동시 요청을 위한 멀티 쓰레드 처리 지원도 중요한 일이다.2.2 멀티 쓰레드만약 요청이 여러개 들어오면 어떻게 해야할까?2.3 쓰레드 쓰레드는 코드를 실행해주는 것들을 의미한다. 즉, 자바 메인 메서드를 실행하면 main이라는 이름의 쓰레드가 실행된다. 쓰레드는 한 번에 하나의 코드 라인만 수행한다. 동시 처리가 필요하면 쓰레드를 추가로 생성해야 한다.요청이 하나인 경우 쓰레드 하나를 할당시켜서 처리하면 된다.쓰레드 하나를 할당시켜서 처리하고 있는 와중에 하나의 요청이 더 들어온다면?처리하고 있는 요청도 처리하지 못하고 새로들어온 요청도 처리하지 못한다.이를 해결하려면 어떻게 해야할까?간단하다 하나의 쓰레드를 더 생성하면 된다.즉, 요청마다 쓰레드를 생성하는 것이다.이를 통해서 동시 요청을 처리할 수 있지만, 쓰레드 생성에 드는 비용이 비싸다보니 요청때마다 쓰레드를 생성하면 응답이 느려진다.또한, 쓰레드 생성에 제한이 없다보니까 고객 요청이 너무 많이 오면, CPU, 메모리 임계점을 넘어서 서버가 죽어버릴 수 있다는 단점이 있다.2.3.1 쓰레드 풀위의 문제를 해결하기 위해서 쓰레드 풀이라는 쓰레드저장소를 애초에 만들어 놓아서 사용한다.쓰레드 풀에 200개의 쓰레드가 있으면 요청이 들어올 때마다 가져다가 쓰면 될 것이다. 요청때마다 사용하는 것이 아니기에 비용이 절약되고, 응답시간도 빠를 것이다.만약 쓰레드풀에 쓰레드가 없으면 요청을 거절하거나 대기시켜 서버 장애를 막을 수 있다.그렇기에 서버를 튜닝할 때 쓰레드 관리가 중요하다.최대 쓰레드(max Thread)를 너무 높게 설정하면 임계치 초과로 서버가 다운될 확률이 있고, 너무 낮게 설정하면 요청이 많은 경우 클라이언트 응답이 느려지는 경우가 있다.자신이 만약 클라우드를 사용하고 있으면 일단 쓰레드를 관리하고, 인스턴스를 추가하는 등의 작업을 취하도록 하자.2.4 WAS의 멀티 쓰레드 지원개발자는 멀티 쓰레드에 관한 것을 신경쓰지 않게 WAS가 멀티 쓰레드에 대한 부분을 처리한다.3. HTML, HTTP API, CSR, SSR3.1 HTTP APIHTML페이지가 아닌 JSON형식을 사용한 데이터를 넘겨버림.앱, 웹 클라이어트 - 서버 / 서버 - 서버 통신 가능3.2 SSR(Server Side Rendering) 서버쪽에서 HTML 결과를 만들어서 웹 브라우저에 전달함. 주로 정적인 화면 JSP, 타임리프 등 -&amp;gt; 정적이지는 않음.3.3 CSR(Client Side Rendering) js등을 통해 동적으로 HTML을 작성하여 웹 브라우저에 전달. React, Vue.js 등을 통한 Gmail, 구글 캘린더 등4. 자바 웹 기술의 역사 스프링에서 최신 기술인 웹 플럭스라는 기술을 알아두자. 굉장히 어렵다. jsp는 속도가 느리고 기능도 부족하여 Spring boot에서 Thymeleaf를 권장." }, { "title": "WEB서버와 WAS 서버의 차이점.", "url": "/posts/jsp02/", "categories": "Java, Spring_CS", "tags": "servlet", "date": "2021-12-16 02:50:50 +0900", "snippet": "web 서버와 WAS 서버의 차이점.웹 서버HTTP 요청을 받아들이고, HTML문서와 같은 자료 콘텐츠에 따라 HTTP에 반응하는 컴퓨터 프로그램.WAS 서버웹 서버 + 웹 컨테이너웹 컨테이너JSP와 Servlet을 실행시킬 수 있는 SW를 웹 컨테이너그니까 JSP와 서블릿을 웹 서버에서 요청하면 톰캣에서는 JSP파일을 서블릿으로 변환하여 컴파일을 수행하고, 서블릿 수행결과를 웹서버에게 전달하게 됨.웹 서버는 HTML같은 정적 컨텐츠를 주로 처리. WAS서버는 asp, php, jsp 등 개발 언어를 읽고 처리하여 동적 컨텐츠, 웹 응용 프로그램 서비스를 처리.Serlvet의 기초 동작방식서블릿은 web.xml의 설정과 동작함.servlet클래스를 만들고, web.xml에서 servlet mapping을 작성해준다.&amp;lt;servlet-mapping&amp;gt; &amp;lt;servlet-name&amp;gt;test&amp;lt;/servlet-name&amp;gt; -&amp;gt; 가상의 이름 &amp;lt;url-pattern&amp;gt;/hello&amp;lt;/url-pattern&amp;gt; -&amp;gt; 접근 url&amp;lt;/servlet-mapping&amp;gt;작성해준 뒤 위에 servlet 태그를 작성해준다.&amp;lt;servlet&amp;gt; &amp;lt;servlet-name&amp;gt;test&amp;lt;/servlet-name&amp;gt; -&amp;gt; 아까 만든 가상의 이름 &amp;lt;servlet-class&amp;gt;example.HelloWorld&amp;lt;/servlet-class&amp;gt; -&amp;gt; 접근 클래스명.(root에서 경로까지)&amp;lt;/servlet&amp;gt;외에도 여러 태그가 존재하지만 ..위의 방식은 servlet 2.X 버전. servlet 3.0 버전으로 넘어오면서 어노테이션을 활룡한 매핑이 가능해졌다.Serlvet의 출력 방식브라우저마다 서블릿에 작성된 코드를 자의적으로 해석함.엣지에서는 자동 줄바꿈이 없지만 크롬이나 사파리는&amp;lt;br&amp;gt;태그가 없어도 줄바꿈을 해준다는 말이다.html로 해석하거나 text로 해석한다는 차이점이 있다.서블릿 코드에 다음과 같이 추가해주면 된다.//res 는 HttpServletResponse 객체//UTF-8로 보내라res.setCharacterEncoding(&quot;UTF-8&quot;);//브라우저한테 해석방법을 알려줌.res.setContentType(&quot;text/html; charset=UTF-8&quot;);Filter수동web.xml에서 태그를 달아준다.&amp;lt;filter-mapping&amp;gt; &amp;lt;filter-name&amp;gt;characterEncodingfilter&amp;lt;/filter-name&amp;gt; -&amp;gt; 가상 이름 &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt; -&amp;gt; 적용할 url&amp;lt;/filter-mapping&amp;gt;...&amp;lt;filter&amp;gt; &amp;lt;filter-name&amp;gt;characterEncodingfilter&amp;lt;/filter-name&amp;gt; -&amp;gt; 위에서 작성한 가상 이름 &amp;lt;filter-class&amp;gt;example.filter.CharacterEncodingFilter&amp;lt;/filter-class&amp;gt; -&amp;gt; 작성한 필터클래스 경로&amp;lt;/filter&amp;gt;자동(어노테이션)@WebFilter(&quot;url&quot;)" }, { "title": "서블릿을 통한 상태유지 3가지 방법", "url": "/posts/jsp01/", "categories": "Java, servlet", "tags": "servlet", "date": "2021-12-16 01:50:50 +0900", "snippet": "서블릿을 통한 상태유지 3가지 방법.1. applicationContext상태 저장공간에 담는다.WAS 서버의 메모리에 있다.//선언은 이렇게 한다. req는 HttpServletRequest 객체ServletContext context = req.getServletContext();//getAttribute는 컨텍스트에 저장된 값을 꺼낸다.int getv = (Integer)context.getAttribute(&quot;v&quot;);String getop = (String) context.getAttribute(&quot;operator&quot;);//setAttribute는 컨텍스트에 값을 저장한다. 키 , 밸류context.setAttribute(&quot;operator&quot;,op);context.setAttribute(&quot;v&quot;,v);2. Session에 담기세션에 값을 저장한다.브라우저마자 세션값이 다르고, 코드를 통해서 직접 세션 만료시간을 설정해줄 수 있다.Was에 세션값들을 저장.처음에 접근했을 때에는 세션값을 부여받지 않은 상태로 접근하고 두 번째 부터는 부여받은 세션값으로 접근한다.세션값으로 접근하면 서버는 요청을 받아줄 수 밖에 없다. 때문에 세션하이재킹(Session hijacking)이 떠올랐다.사용방식은 Context와 굉장히 유사하다.//선언HttpSession session = req.getSession();//값 꺼내기.int getv = (Integer)session.getAttribute(&quot;v&quot;);String getop = (String) session.getAttribute(&quot;operator&quot;);//값 넣기session.setAttribute(&quot;operator&quot;,op);session.setAttribute(&quot;v&quot;,v);3. Cookie에 저장하기쿠키에 값을 담는 방법이 있다.클라이언트가 쿠키를 가지고 있어서 서버에서 그 클라이언트에 저장된 쿠키값들을 받아 연산을 처리한다는 것이다.일반 변수는 각각 찾아주고, 각각 뿌려주는 불편한 점이 있다.추후 Json을 보내는 방식을 알게되면 불편함이 덜 할 것이다.package example;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.*;import java.io.IOException;import java.io.PrintWriter;@WebServlet(&quot;/cookietest&quot;)public class CookieTest extends HttpServlet { @Override protected void service(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException{ res.setCharacterEncoding(&quot;UTF-8&quot;); res.setContentType(&quot;text/html; charset=UTF-8&quot;); Integer result = 0; //Cookie를 가져온다. Cookie[] cookies = req.getCookies(); PrintWriter out = res.getWriter(); String value = req.getParameter(&quot;v&quot;); String op = req.getParameter(&quot;operator&quot;); int v = 0; if(!value.equals(&quot;&quot;)){ v = Integer.parseInt(value); } if(op.equals(&quot;=&quot;)){ int getv = 0; String getop = &quot;&quot;; //Cookie에서 값을 꺼낸다. if(cookies.length&amp;gt;0){ for(Cookie cookie : cookies){ System.out.println(cookie.getName()); if(cookie.getName().equals(&quot;v&quot;)){ //문자열이므로 정수로 치환 getv = Integer.parseInt(cookie.getValue()); } //opertor도 꺼내줌. if(cookie.getName().equals(&quot;operator&quot;)){ getop = cookie.getValue(); } } } if(getop.equals(&quot;+&quot;)){ result = v + getv; } else{ result =v - getv; } out.println(&quot;계산결과는 : &quot; + result); } //쿠키를 추가한다. 문자열의 형태만 가능하다.!! Cookie valuecookie = new Cookie(&quot;v&quot;,String.valueOf(v)); Cookie opcookie = new Cookie(&quot;operator&quot;,op); res.addCookie(valuecookie); res.addCookie(opcookie); }}추가로 setcookie() 메소드를 통해 url을 지정해줄 수 있다.직접 사용해보니 엄청 불편하다. 변수가 늘어날 때마다 하나하나 넣어줘야하고, 하나하나 찾아주는 과정이 복잡할 것이다. 추후 JSON방식으로 보내는 법을 알게되면 나을듯.보통 쿠키의 생조주기는 정해주지 않으면 브라우저의 생존주기와 같다.웹 브라우저의 메모리 또는 파일에 저장된다." }, { "title": "아기곰의 재테크 불변의 법칙 개정판(아기곰 저) 독후감", "url": "/posts/book7/", "categories": "Book", "tags": "book", "date": "2021-11-29 01:00:00 +0900", "snippet": "이 책은 읽은지 꽤 되었지만, 정리하고 싶어서 2번 읽었다.처음에는 퇴근길에 읽고, 두 번째는 정리할 수 있는 공간에서 필기를 하면서 정리했다.유명한 저자이고, 내용도 정말 쉽고 알차다고 생각한다.재테크에서 명심해야할 사항과 부동산에 대한 이야기이다.p20.목표를 웅대하게 가지라는 것과 실현 가능성 있는 목표를 세우라는 것은 전혀 다른 이야기이다.p28.꿈이 명확할수록 그 꿈이 실현될 가능성도 크다.p36.호의호식을 선호하는 것은 인간의 보편적인 본성이다 -&amp;gt; 불편함을 감수하고 이겨내자.재테크는 수단이지, 그 자체가 목적이 되어서는 아니 된다. -&amp;gt; 어떤 경우에도 가족은 중요하다(주변을 챙기라는 뜻)p40.세상은 변했다. 하지만 끊임없이 남과 비교하려는 인간의 본성은 변하지 않았기 때문에,본인이 행복해지려면 그에 상응하는 노력을 해야한다.​p50.폼내는 것은 한순간이지만 휴유증은 생각보다 길게 나머지 삶에 영향을 미친다.p56.부지런한 사람에게는 언제나 좋은 기회가 많이 다가오는 법이다.p71.직장을 다니는 사람이라면 직장에서 인정받는 사람이 되도록 노력하는 것이 자신에 대한 투자가 될 것이다.p87.정보의 올바른 해석, 기사의 의도대로 휘둘리지 않고 행간의 의미를 읽어내는 능력, 감정이나 선입관에치우치지 않고 객관성을 갖추는 것이 돈을 버는 사람의 특징이라 하겠다.p112.열심히 사는것도 목표와 전략이 분명해야 한다.p136.당신의 돈은 누구도 대신 지켜주지 않는다.p158.개미의 특성은 자신의 판단이 아닌 시장 분위기에 따라서 나중에 허겁지겁 쫓아가는 경향이 있다.p206.주택 시장은 레버리지 투자가 가능하다.p230.집 값이란 단순히 인구의 증감 하나만 가지고 전망할 수 있는 것이 아니다.p253.입지의 3대요소 - 교통, 교육, 환경p275.부동산을 고르는 기준이 첫째도 입지, 둘째도 입지, 셋째도 입지p318.무릎에 사서 어깨에 팔라p358.비관론자에게는 남겨둔 자리가 없다.p368.아무런 위기가 없으면 기회도 없다." }, { "title": "잠든 사이 월급 버는 미국 배당주 투자(베가스풍류객 등 저) 독후감", "url": "/posts/book6/", "categories": "Book", "tags": "book", "date": "2021-11-28 01:00:00 +0900", "snippet": "누나의 추천이다.아마 해외장을 시작한다니까 추천해준 것 같다.사실 후기랄 것도 없다.배당주란 무엇인가배당주의 장점배당주 기업배당주 선정시 고려할 점들인데배당주 선정시 고려할 점 특정 부분을 제외하면 전부 당연한 말들이라서 따로 정리하진 않았다.그래도 배당주 개념이 뭔지 알기에는 좋은 책이었다." }, { "title": "돈의속성(김승호 저) 독후감", "url": "/posts/book5/", "categories": "Book", "tags": "book", "date": "2021-10-31 01:00:00 +0900", "snippet": "돈의 속성은 정말 유명한 책이다.​라고만 알고 처음에는 그냥 읽었다.​처음에도 읽기 좋고, 나중에도 읽기 좋은 서적이라고 깨닫게 되었다.​이번 기회에 다시 읽어보면서 내용을 정리를 하게 되었다.​다른 경제블로그들을 많이 보는데, 5할은 이 ‘돈의 속성’ 책에 관한 내용이다.​그만큼 이 책은 명저로 손 꼽히니, 아직 안 읽은 사람은 꼭 읽어보길 바란다.!!​돈은 인격체다.-&amp;gt; 돈을 소중히 다루되, 구두쇠처럼 마냥 저축을 하지 말자. 내 자산을 더 키울곳에 투자하자.일정하게 들어오는 돈의 힘-&amp;gt; 규칙적으로 수입이 생기는 것은 미래예측이 쉽다. 자신이 재능이 있어 비규칙적 수입(연예인 등)이있다면 자본으로 빠르게 바꾸라.​돈은 중력의 힘을 가졌다.-&amp;gt; 돈은 돈을 끌어 모은다. 때문에 10억 벌기전에 1억, 1000만을 목표로 잡고 노력하다보면자산의 힘에 의해 노력이 점점 덜 들겄이다.​리스크가 클 때가 리스크가 가장 작을 때다.-&amp;gt; 워렌버핏 : “남들이 욕심낼 때 두려워 하라. 남들이 두려워할 때 욕심을 내야 한다.”​남의 돈을 대하는 태도가 내 돈을 대하는 태도다.-&amp;gt; 친구가 돈을 번다고 할 때 더 비싼것을 고르지 마라. 그게 내가 가진 돈에 대한 생가이다.​100억을 상속 받았는데 절대 잃지 말라는 유언이 붙었다면-&amp;gt; 돈을 쓰지 않으면 이자로만 월 230의 고정수입이다. 일정한 소득을 손실없이 만드려면 생각보다 적은 돈이다. 돈을 버는것만큼 지키는 것도 힘들다. 100억원을 가졌어도 230만의 급여 생활자 태도를 벗어나면 재산이 하향할 수 있다. ​빨리 부자가 되려면 빨리 부자가 되려고 하지 않으면 된다.-&amp;gt; 마음이 급급하면 리스크를 생각 안해 일을 그르친다는 이야기.-&amp;gt; 내가 빨리 부자가 되려는 마음은 자기과시이거나 다른 사람들과 나를 비교하는 마음.-&amp;gt; 종잣돈을 마련해 복리와 투자에 대해 배우고, 경제용어를 공부해 금융 문맹에서 벗어나라.​경제 전문가는 경기를 정말 예측할 수 있나?-&amp;gt; 없다. 단기적으로는 가능하다.-&amp;gt; 내가 기업조사 등을 통해 시장이 반대의 흐름으로 간다할 때, 반대로갈 용기가 있는 사람이 시장에서 성공한다.​삼성전자 주식을 삼섬증권에 가서 사는 사람-&amp;gt; 만약 주식투자를 하려고 마음 먹었다면 마치 회사를 경영하듯, 대학 학부과정을 다니듯,4년은 공부하기를 바란다.-&amp;gt; 초보자는 직접 보지 않고는 함부로 믿지 않기를 당부한다.​다른 이를 부르는 호칭에 따라 내게 오는 운이 바뀐다.-&amp;gt; 선배와 친구를 존중하고 후배나 제자에게 다정하고 이들이 보이지 않는곳에서도 한결 같아야 한다.​반복되는 운은 실력이고 반복되는 실패는 습관이다.​뉴스를 통해 사실과 투자 정보를 구분하는 법.-&amp;gt; 시장은 지금 현재 상황보다 이 상황의 불확실성을 더 두려워한다.​돈마다 시간을 다르게 흐른다.-&amp;gt; 누구라도 시간 많은 돈을 거느릴만한 주인이 되지 못하면 결국 그 돈이 당신을 거느리게 될 것이다.​달걀을 한 바구니에 담지 않았는데 왜 모두 깨질까?-&amp;gt; 예금, 적금, 부동산, 주식, 채권 등 한 시장 안에서 이런저런 상품을 사놓고 위 격언을 따랐다고 생각하는건 위험하다.​부자가 되는 세 가지 방법.1) 복권에 당첨되거나, 사업에 성공하거나, 상속 받거나2) 직접 창업, 남의 성공에 올라타기3) 가장 빨리 부자가 되는 방법은 천천히 부자가 되는 것.(자신이 관심 있는 분야에서 제일 잘나가는 회사를 찾는다.)​돈을 모으지 못하는 이유-&amp;gt; 생활 태도의 문제-&amp;gt; 신용 카드를 사용하는 사람, 물건을 부주의하게 매 번 잃어버리는 사람.-&amp;gt; 작은 돈을 우습게 아는 사람-&amp;gt; 저축을 아예 안하는 사람.-&amp;gt; 투자에 대해 이해가 없는 사람은 절대 부자가 되지 못한다.​자신이 금융 문맹인지 알아보는 법-&amp;gt; 한국 은행이 2018년 [경제금융용어 700선]이라는 책자를 발행.-&amp;gt; 경제 용어 공부하자.​주식으로 수익을 내는 사람들의 세 가지 특징손실 보는 사람의 특징 : 그냥 따라 들어옴. 무엇을 살 지 계획이 없음. 돈의 힘이 약함. 자신을 경영자로 생각 보유하고 있는 돈이 품질이 좋다. 싸게 살 때까지 기다린다. ​얼마나 벌어야 정말 부자인가? 융자가 없는 본인 소유의 집. 한국 월 평균 소득을 넘는 비근로 소득. 더 이상 돈을 벌지 않아도 되는 욕망 억제능력 소유자 부자는 더 이상 돈을 벌 필요가 없는 사람.​내가 재산을 지키기 위해 매일 하는 일.보고서, 이메일 확인 -&amp;gt; 전국의 신문 읽기 -&amp;gt; 경제 사이트 보기(투자관련) -&amp;gt; 부동산 사이트보기 -&amp;gt; 개인 취미 사이트​가난은 생각보다 훨씬 더 잔인하다.삶의 가치를 부의 축적보다 중요시 여기는 사람의 특징1) 무엇이 삶의 가치인가에 대한 기준이 모호하다.2) 가난이 얼마나 무서운지 모른다.3) 자신이 부자가 되리라는 자신이 없다.부자가 되는 방법의 시작은 자신이 부자가 될 수 있다고 믿는 것이다.​금융공황 발생에 따른 세 가지 인간상(폭락장) 피해를 고스란히 당하는 사람 : 주식을 사지 않아도 기업 축소로 피해를 입음. 영향을 받지 않는 사람 : 빚도 없고 직업도 안정적이다. 이 폭락장에서 이익을 보는 자산가들. ​내가 청년으로 다시 돌아가 부자가 되려 한다면-&amp;gt; 매달 급여의 일정부분 저축하지 않고 주식을 사겠다.(저축으로 부자가 되는건 옛말이라는 뜻)-&amp;gt; 부자는 천천히 되는 길이 가장 빠른길이다.​지혜는 기초학문으로부터 시작된다.-&amp;gt; 투자는 지식과 지혜가 합쳐져야 성공한다.-&amp;gt; 지혜가 없는 지식은 오만ㄴ해지고 지식이 없는 지혜는 허공만 안게 된다.​부자가 되기 위해 우선 당장 할 수 있는 일 한가지.-&amp;gt; 정리정돈 하라는 이야기.​앞으로 주식이 오를 것 같습니까?-&amp;gt; 모른다. 이러한 질문을 하는 사람은 2가지 특징이 있다.1) 빠르게 이익을 얻고 싶어서 조급함.2) 자신의 상품에 믿음이 없음.​현재 임차료를 내는 사람들의 숨은 가치.-&amp;gt; 임대료를 꼬박꼬박 내는 경우 건물주를 생각해봐야 한다.-&amp;gt; 사업이 성장하고 있고, 신규고객들의 유입으로 해당 건물의 값어치가 점점 올라가지만 결국 건물주가 이득을 보는 구조이여서​부동산에 투자하는 것이 좋을까? 주식이 좋을까?-&amp;gt; 성향차이.-&amp;gt; 공부를 잘한다고 반드시 성공하지는 않지만 질문을 하는 사람은 성공할 확률이 높다. 그러나 투자의세계에서는 예외.-&amp;gt; 투자에서 답하는 사람이 답을 아는 경우가 없다.​나의 독립 기념일은 언제인가?-&amp;gt; 인생을 살며 가장 중요한 기념일은 생일과 결혼기념일.-&amp;gt; 개인이 독립하려면 내 수입이 나의 노동이 아닌 다른곳에서 나오게 만들어야 한다.​돈을 다루는 네 가지 능력1) 돈을 버는 능력 : 낙천적, 포기를 하지 않아야2) 모으는 능력 : 자산의 균형을 맞추고 세밀한 지출관리 능력 필요.3) 유지하는 능력 : 가장 힘든 일 중에 하나4) 쓰는 능력 : 검소하되 인색하면 안됨, 욕도 먹을줄 알아야 한다.​이런곳에 나는 투자 안 한다.-&amp;gt; 불법적인 것​보험은 저축이 아니다.-&amp;gt; 생기지 않을 여러 두려움에 경제권을 넘기지 않길 바란다.​예쁜 쓰레기-&amp;gt; 돈을 주고 쓰레기의 예쁨에 현혹될 이유가 없다(명품을 말하는 듯)-&amp;gt; 차라리 그 돈으로 가장 좋은 배게, 이불 등 살아가는데 필요한 것들을 사라.​경제에 대한 해석은 자신의 정치적 신념에서 벗어나야 한다.-&amp;gt; 정치적 신념 때문에 경제를 해석하는데 편겨을 갖지 마라.-&amp;gt; 경제 기사는 부정적 보도가 관행이다.-&amp;gt; 자신의 정치 성향과 개인 경제 정책은 독자적으로 분리해 판단하자" }, { "title": "2021.10.26(화).경제 정리노트", "url": "/posts/economy1026/", "categories": "Economy, DailyNote", "tags": "Economy", "date": "2021-10-26 01:50:50 +0900", "snippet": "2021.10.26 경제 헤드라인을 정리한 글입니다.부동산 관련, 청약 관련글에 대해서는 따로 정리하지 않습니다.기사내용 출처https://blog.naver.com/sonsarang38 부동산 대책 26회나 발표했지만 서울 아파트 평균값 12억 넘었다. → 1월 10억 5월 11억 10월 12억 찍음 3분기 땅값 상승률, 세종시 1위 “국회의사당 이전 기대” 1.48% ↑ 지역개발 기대에 … 땅값 3년만에 최대상승 → 왜이렇게 부동산 이야기만.. 강서 등촌동 노후 아파트 ‘리모델링 바람’ → 등촌부역 건축계획 통과, 속도 높이려 수평증축나섬. ‘오세훈표’ 정책 힘싣는 서울시 내년 예산 44조원 ‘역대 최대’ → 서울비전2030, 청년정책 확대 심의 놓고 시의회(더불어민주당이 다수석)와 갈등 ‘변수’ 사전청약 실적 건설사에 택지공급 인센티브 ‘논란’ 머스크는 주가도 필체도 ‘우상향’ 부자들은 ‘쓰는 법’부터 남다르죠 → 슈퍼리치들의 사인을 비교해보니 우상향한 사인들이 많았다는 기사. → 야망이 느껴진다는 것. 글씨는 자기수양 결과이자 반영을 한다고 함. → 우상향으로 글을 마무리해야겠다. “하필 점심시간에” … 40분 ‘온라인 먹통’에 일상이 멈췄다. → KT 접속 장애에 따른 피해에 대한 기사 → 점심시간이라 자영업자 결제도 먹통이었고, 배달앱도 먹통, 테슬라 문도 안열리고, 증권사 시스템도 먹통이었다는 기사 “공급대란 늦어도 내년말 해소 … 그때까진 상품값 인상 불가피” → 미국 경제는 공급망 차질 등으로 몸살을 앓고 있음. → 바다에서 하역하지 못하고 대기하고 있는 화물이 많으니 참아달라는 내용 인도,탈레반과 충돌 대비 中 국경서 무기사용 허용 → 탈레반이 아프간을 점령했고, 인도와 국경 갈등을 맺고 있어서 중국이 건국 이래 최초로 국경 지대에서 군대가 아닌 경찰도 동원하고 무기도 사용하게 됨. 잭 도시(트위터 CEO) “인플레 온다” vs 옐런(미 재무장관) “내년 진정” → ‘극과 극’으로 갈린 물가 전망 → 기업, 금융인들은 인플레이션 경고를 했지만 파월 의장 등 美 정부 인사들은 “일시적인 현상” 이라면서 낙관중. → 기업, 금융인들은 미국 주요 소비재별 물가지수 변화가 크게 증가하면서 위험하다는 분석을 내림 “억만장자에 부유세” → 법인세 인상 대신 부유세 추진, 펠로시 “법안 준비중” 공식화 → 1천명 미만의 슈퍼리치가 대상이 될듯. 中, 탈레반, 아프간 종전후 첫 고위급 회담 → 왕이 외교부장이 가는데, 미군 철수 한 달 전인 지난 7월 말 중국 텐진에서 탈레반 임시정부 대표단을 만난 바가 있음. → 중국은 탈레반에 2억위안(약 367억)을 주면서 중국 신장 지역과 국경을 맞댄 곳의 테러 위협을 차단해달라고 부탁. → 탈레반은 아프간 집권에는 성공했으나 국제사회에서 고립돼 재정난과 실업난 등에 시달리고 있음. 中 헝다, 건설현장 일부 재개했지만 … / 30년 독재자 몰아낸 수단서 또 쿠데타 유엔가입 50주년 자축한 시진핑 …. 바이든은 “대만도 참여해야” → 美,中 대만 놓고 정면충돌 → 바이든 “中이 대만 공격하면 미국이 나서서 방어할 것” 업계 “탄소 이어 메탄까지 줄이라니… 이중부담” → 2050탄소중립 선언 1년만에 메탄감축서약(30% 감소) 가입의사까지 밝혀 → 文대통령은 “자원 아끼지 않겠다”지만 축산, 폐기물업계 부담이 가중되는 중이다. 빅테크 실적시즌 … 월가 “애플, MS 주목” → 애플, 인플레 압박서도 강해, MS는 클라우드 실적 상승세 → 맞춤형 광고수익 감소 여파에 구글, 페이스북 등 실적 우려 씨티은행, 소매금융 접는다 … 대출, 카드 신규 가입 중단 → 소매금융이란 은행이 가계고객 대상으로 소규모의 금융을 제공하는 것을 말함.(구체적인 예가 뭘까) → 아무튼 소매금융에 철수하면서 노조와도 충돌이 있다. 국내에 진출한 외국계 은행 중에선 SC제일은행만 소매금융을 하게됨. 애플TV플러스, 디즈니플러스 잇단 상륙 … OTT 대격돌 → 애플TV 구독료는 월 6500원, 최대 6명 이용가능. 4K 영상 지원, 시리 지원, 통합 서비스 ‘애플 원’은 아이클라우드 용량을 늘리고 뮤직, 게임 등 다양한 서비스를 지원하는 통합 서비스. 궁금한 사람은 검색 고고. → 디즈니 플러스에 대한 내용은 미미한 기사.. 광고인가? “수소경제 베팅하려면 ‘00 기업’에 관심을” → 상아프론테크 : 수소전자소재 양산 글로벌 경쟁사 2개뿐 → 코오롱인더 : 연료전지 수분제어 기술 → 효성첨단소재 : 국내서 유일하게 수소용기에 쓰이는 탄소섬유 생산 SK “배터리, 반도체, 바이오 인재 2만7000명 뽑는다” → 청년희망ON 프로젝트 동참 → 연간 6000명 수준의 채용계획을 확대해 연간 9000명을 뽑을 것이라고 함. → 이어서 KT는 1만2000개, 삼성은 3만개, LG는 3만9000개의 청년 일자리를 약속했음. 정의선 “내년부터 인도네시아서 전기차 생산 … 동남아 꽉 잡겠다” → 현재 베트남을 제외한 대부분 동남아 국가에서는 도요타 혼다 등 일본 브랜드가 자동차 시장의 90% 이상을 차지하고 있음. → 인도네시아 현대차 공장을 돌리면서 동남아 전기차 시장 진출에 힘을 쏟겠다는 것. 이재용 “겸허한 마음으로 … 뉴삼성 만들자” → 이건희 회장 1주기 조촐한 추모식 용인 인력개발원에 흉상 → 제막식에는 이 부회장 외에 사장단 5명만 참석했다. 제막식과 흉상은 외부에 공개하지 않음. 삼성전자 저가매수 자금 ‘삼성그룹 ETF’에 몰린다. → 삼성ETF 확인합시다. ‘균등배정’ 카카오페이 … 첫날 70만명 몰렸다. → 이번에 균등배정했는데 참여자 대부분이 한주씩 받을듯함. → 균등배정을 한 이유는 금융장벽을 낮추기 위함이라고 한다. → 내년 초까지 MTS를 열어 주식 서비스를 할 것이고 보험서비스 까지 할 것. 증시 덮친 인플레… ‘콘텐츠, 레저株로 피하라” → 코로나19로 인한 공급망 병목현상, 친환경 전환 과정에서 에너지 공급 축소, 임금 상승 등으로 인플레가 진행됨. → 인플레 무관종목인 CJ ENM, 제이콘텐트리 등은 타격이 적고 ‘위드 코로나’수혜를 받는 경우도 있음. 12월 야외 노마스크 …내년 1월엔 결혼식, 돌잔치 인원 제한없어 → 접종률 80% 넘으면 2단계로간다. 유흥시설도 시간제한 풀고 접종 완료자 대규모 집회 가능해짐. → 2단계 시행 후 문제없으면 내년 1월 말에는 3단계 돌입한다. 백신접종 여부와 상관없이 사적모임 인원제한도 해제 " }, { "title": "2021.10.25(월).경제 정리노트", "url": "/posts/economy1025/", "categories": "Economy, DailyNote", "tags": "Economy", "date": "2021-10-25 01:50:50 +0900", "snippet": "2021.10.25 경제 헤드라인을 정리한 글입니다.부동산 관련, 청약 관련글에 대해서는 따로 정리하지 않습니다.기사내용 출처https://blog.naver.com/sonsarang38 주문 폭주에 주가는 훨훨 … ‘테슬라 천하’ → 테슬라 시총 1,000조원을 넘어서버렸다. → 차량 가격을 5000달러씩 인상했지만, 주가는 상승. 한술 더 뜨는 은행들, 대출 우대금리까지 없앴다. → NH농협은행 경우 0.3%P의 신용 우대금리를 폐지해버림. → 우리은행도 27일부터 0.2% ~ 0.3% 축소할 예정. 저소득층, 은퇴자 대출 감소폭 더 커진다. → DSR 조기시행함. → 주담대 한도 2억에서 1.5억으로 줄어들었음. 신도림 우성 1,2차 리모델링 ‘탄력’ → 구로구, 1차 안전지단 용역 발주. 中 부도산 보유세 시범 도입 → 중국은 한국과 달리 재산세나 종합부동산세에 해당하는 보유세가 사실상 없어 집값 상승의 주요 원인 중 하나로 거론되어 왔음. → 이번에 ‘공동부유’를 국정 기초로 주택소유자에게 물리는 ‘부동산 보유세’를 시범 도입할 예정 中 ‘홍색 규제’ 여파… 게임업계 감원 사태로 확산 → 바이트댄스라는 빅테크 게임 자회사의 직원이 30%가 갈림. → 79명에게 퇴사를 요구하거나 다른 자리로 옮기라고 요구. → 게임 업계의 직원 줄이기는 사교육 업체의 감완에 이은 것이라는 판단. 수도권 공공택지 사전청약 시작 … 고령자, 장애인 현장접수 → 사전청약 기사 PASS 도심복합사업에 ‘1년뒤 땅값’ 적용해 논란 → 정부가 도심공공복합사업 후보지의 사업성을 분석하면서 미래 땅값을 예측해 적용한 것으로 나타나 논란. → 중산4구역 등 도심복합사업 후보지 2차 사업설명회에서 공개한 사업비와 감정평가액은 분양예상시점인 2022년 말을 기준으로 산정했음. → 업계에서는 정부가 도심복합사업의 사업성이 민간 재개발보다 우위에 있다는 점을 강조하기 위해 위 같은 계산법을 적용했다고 보고 있음. → 논란에도 불구하고 도심복합사업의 경우 민간 사업과 달리 추정분당금 산정에 대한 외부 검증을 받을 근거가 없음. → 정부와 LH관계자는 ‘통상적인 부담금 산정 방식’ 이라며 문제없다는 입장이지만 민간 정비 사업이었다면 불가능한 방식 속도, 신뢰 중 하나만 뒤처져도 끝… 충성고객 잡기 ‘올인’ → 아마존이 구독플랫폼을 통해 처음으로 월마트의 지출기록(2020년 7월 ~ 2021년 6월)을 제침. → 뒤늦게 월마트가 구독 서비스인 ‘월마트플러스’를 선보였지만, 이미 독점당한 상태여서 따라잡을 수 없게 됨. → 이처럼 구독시장에서 중요한건 ‘선점’이다. 다른예로 디즈니를 이끌었던 제프키는 숏 스트리밍 업체 ‘퓌비’를 선보였으나, 6개월만에 폐업 결정을 알림. → 이유는 3개월간의 무료체험 이후 유료로 전환하자 가입자의 92%가 이탈했기 때문이다. → 넷플릭스에 대응해 디즈니 플러스, 애플 등이 다양한 구독상품을 내놓고 추격하고 있지만 아직은 역부족. 넷플릭스가 소유한 데이터의 벽이 너무 높기 때문이라는 것. 서울 집값 상승세 둔화 … 강남 3구는 여전히 강세 → 고점 인식 확산, 대출규제 강화에 동대문.도봉.강북구 등 숨고르기 재산 아파트 한채인 가정도 … ‘부자들의 세금’ 상속세 대상 → 이제 집 한채여도 아파트 재산가액이 11억원을 넘으면 상속세를 내야함. → 집값이 계속 상승함에 따라 점점 대상이 늘것이고, 정부도 이를 인식하여 세제 개편 방안을 추진하고 있음. → 상속 총액에 일괄적으로 세금을 매기는 종전 유산세 방식에서 상속자 개인의 유산 취득분에 세금을 메기는 유산취득세 방식으로 바꾸는 방안을 검토중. 서울 빌라 매매가 월상승률 1%대로 치솟아 → 1~9월 누적 6.21% …작년의 1.8배 → 1월부터 6월까지는 0%의 상승률을 보이다가 9월 처음으로 1.42%라는 1%대 상승률을 기록. “내년 33조 투입 K뉴딜, 수요파악 없이 예산만 늘렸다” → 검증과 분석없이 사업에 대한 예산만 늘려 이를 비판하는 기사. → 내년 4월부터 월세로 거주하는 청년을 대상으로 최대 12개월 20만원씩 월세지원 사업으로 830억원 책정. → 집행 실적 50% 미만 사업 83개 가운데 사업 추진이 지연된 사업만 30개에 달하고, 집행 사유가 발생하지 않은 사업은 20개, 관계 기간 간 협의 지연 14개 등 답이없는 상황인데 정부가 이사업들의 내년 예산을 오히려 늘려버림. 쿠폰 풀고 유류세 인하, 일상회복 붐업한다. → ‘위드코로나’로 소비쿠폰을 지급하여 소비촉진 정책을 펼칠 것. → 또한 유류세를 15%정도 인하해서 내수부양과 물가안정이란 ‘두 마리 토끼’를 한 번에 잡겠다는 구상 전력난, 천문학적 비용 부담에… 美, 中, EU도 탄소중립 속도조절 → COP26이라는 유엔기후변화협약 당사국총회가 있음. 중국이 이에 불참할 확률이 높다는 것. → 왜냐하면, 최근 중국은 전력난을 겪어 적극적인 탈탄소가 불가능하고, 이에 부담을 느낄 것이라는 판단. → 중국이 땅덩어리가 탄소 영향력이 큰데, 대화로 해결해나가야함. → 독일도 탈탄소를 외쳤지만 화력발전 비중이 여전히 전체 발전량의 23%로 높은편에 속함. → 계속 대화하고 협력할 방법을 찾는 것이 관건 인플레 우려 수위 높인 파월 내년 조기 금리 인상도 시사 → “상황 진정 안되면 모든 수단 동원” 테이퍼링은 이르면 내달 중순 개시 “ESG로 더 큰 수확 거두고 나누자” … ‘빅립’ 화두 던진 최태원 → SK, 2021 CEO 세미나에서 SK가 2030년에는 탄소 2억톤(세계 탄소 감축 목표량[210억]의 1%)를 줄이겠다고 선언. 카카오페이 오늘부터 청약 … 1억 넣어도, 90만원 넣어도 똑같이 받는다. 일주일새 1천억 … 메타버스 ETF에 꽂힌 개미 → 상장후 개인 1066억원 순매수 타이거메타버스 551억 뭉칫돈, 코덱스액티브ETF 17% 상승 등.. 수소, 전기차 시대 살아남기, 요즘 주유소 별 걸 다한다. → 수소와 전기차 등 친환경차 보급이 늘어나자 주유소가 살아남기 위해 다양한 전략을 펼치고 있다. → 1. 도심속 물류거점지점으로 활용. → 2. 주거지와 접근성이 좋은 점을 활용하여 ‘픽업센터’로도 활용. 이케아의 사례 → 3. 관리자가 있고, 폐쇄회로에도 CCTV가 있다는 점에서 중고거래 장소지로도 활용 → 4. 전기자전거 주차와 대여, 반납 서비스도 제공 기업은 구인난, 구직자는 취업 연기 … 30대만 고용 감소 → 올 상반기 부족인력 6만 늘어 28만, 취업 미룬 인구는 6분기 연속 늘어 실적 뛰고 배당도 두둑 … 삼성카드,포스코인터,S-OIL등 주목 “멈췄던 소비 폭발한다” … ‘70% 할인’ 라방에 車경품까지 총력전 → 백화점 대규모 오프라인 행사.. 페이백 상품권도 실시 → E커머스 업계도 여행,공연,스키장 시즌권 판매 강화 → 신세계백화점은 라이브 방송을 통해 150여 개 브랜드에 대해 최대 76% 할인 판매할 예정. 등등.. 산업재편 끝낸 선진국들이 사실상 강제 제조업 중심 한국 등엔 메카톤급 악재 → 사실상 제조업 중심인 우리나라가 강제로 탈탄소에 끌려다닌다는 기사 LG엔솔.SK온 중저가 배터리 공략 나선다 → 테슬라가 저가형 주력사양인 ‘스탠더드’트림에 리튬인산철(LFP) 전지를 쓰겠다고 밝히면서 고사양 전지를 주력으로 삼는 LG엔솔, SK온이 LFP전지 개발 검토를 언급하는 등 경쟁이 치열해질 것으로 예고 올해 아파트 매입 29%가 외지인 → 2016 ~ 2020년에는 20%를 웃돌다가 올해 21년에 28.6%로 크게 치솟음. 게처럼 좌우로 달린다고? 90도 회전 차 바퀴 만들었다. → 현대 모비스 ‘e-코너 모듈’개발 90도 좌우 이동, 제자리 회전도 “좁은 도로에서 민첩성 늘어나” " }, { "title": "부의 본능(브라운스톤 저) 독후감", "url": "/posts/book4/", "categories": "Book", "tags": "book", "date": "2021-10-25 01:00:00 +0900", "snippet": "이 책을 잡게 된 계기는 친누나가 도서관에서 빌렸다고 읽으라고 줬다.​주면서 하는 말“어떻게 보면 정석적인 말이라 잘 읽힐 것”그 말을 듣고 읽어서인지 몰라도, 잘 읽혔고 내용도 쉬운편이었다.내용을 정리하면 인간의 본능을 9가지로 보고, 그 부자가 되기 위해서는 본능에 어떤 행동양식을보여야할지 알려준다.01. 무리짓는 본능의 오류원시인때부터 무리를 짓기 시작했기에 무리에 익숙하지만 부자가 되기 위해서는 무리에 ‘휩쓸려서는’ 안된다는 것.부자는 외로운 늑대, 빈자는 무리 짓는 양떼02. 영토 본능의 오류집을 사는 것과 집에 사는 것은 다르다.-&amp;gt; 자기만의 집을 가져야한다는 말.03. 쾌락 본능의 오류쾌락에 빠지지 말라는 말. 고통스런 현실이 장밋빛 미래를 약속한다. 부자들의 첫 번째 취미는 독서 04. 근시안적 본능의 오류-&amp;gt; 짧은 시간에 일확천금 하고자 하는 인간의 근시안적 본능가까운 이익에 눈이 돌아간다는 것임.단기투자자들이 대부분 실패하는 이유이고, 특히 빚내서 하는 투자는 망하는 지름길이다. 일확천금의 모든 신화는 거짓이다.05. 손실공포 본능의 오류잃을까봐 안절부절, 아무것도 안하는 사람의 습성을 말함 사람들이 부자가 되지 못하는 이유 중 하나는 투자를 하지 않기 때문이다. 가장 큰 위험은 아무 투자도 하지 않는 것이다. 어느정도 빚을 내더라도 내 집 마련하는 것이 유리하다. 06. 과시 본능의 오류쾌락의 오류와 비슷함. ‘원하는’것과 ‘필요한’것을 구분하라 아내의 절약이 집안을 부자로 만든다.(남자도 마찬가지) 돈과 자동차로 과시하는 빈수레들 미혼 시절 재테크에 눈떠야 부자 된다. 도사 환상의 오류아무나 막 믿고 잃는 사람들에 대한 오류 인간은 아는 것보다 믿는 것을 더 좋아한다 전문가는 알고보면 세일즈맨이다. 마녀 환상의 오류 부자를 미워하는건 인간의 본능이다. 부자를 질투하는 대신에 칭찬하라. 부자가 되고 싶다면 남 탓 하는 성격부터 고쳐라 09. 인식 체계의 오류 인간은 보고 싶은 것만 보도록 진화했다. 하수는 행운만 보지만 고수는 최악의 상황도 대비한다. 하수는 예측하려 하지만 고수는 대응하려 한다. 외에도 과거의 경험으로 새날을 더럽히지 마라. 소비의 쾌락을 고통으로 치환하라. 부자에게도 이 악물고 종자돈 모으던 시기가 있었다. 처음에는 작은 금액을 목표로하라. 가난을 자신의 책임으로 떠안아라. 은행은 당신의 돈을 이용할 뿐이다. 라는 어록이 생각나서 메모했었다.진자 뻔한 말이지만, 그렇기에 까먹으면 안 되는 말들이다.이렇게 뻔한 말이 나올법도 한게, 책이 쓰여진지 꽤 되었고 현재는 코로나로 인해 부자가 된 사람들이 많아서 다 같은 소리를 하는 것 같다.아무튼 내일 책 반납일이라 부랴부랴 읽었는데, 초보자가 읽기에는 잘 읽히는 책이다.​" }, { "title": "부자아빠 가난한 아빠 20주년(로버트 기요사키 저) 독후감", "url": "/posts/book3/", "categories": "Book", "tags": "book", "date": "2021-10-10 01:00:00 +0900", "snippet": "이 책을 읽게 된 계기는 친누나의 추천.20년이 지난 책인데도, 굉장히 유명한 책이다.대부분의 사람들의 행동양식을 비판(?), 팩폭을 하여 머리글에서 호불호가 갈리는 책이라고 저자도 인지하고 있는 듯했다.1년 전의 나였으면 똑같이 비판했겠지만.. 취준을 하면서 자아성찰하면서 나는 우물안의 개구리였구나.. 를 많이 느꼈다.그저 사회는 취업 -&amp;gt; 돈 모으고 결혼 -&amp;gt; 자식낳고 하하호호하다가 end 인줄 알았는데 이 ‘돈 모으고’고 현실적으로 어려운 단계라는 것을 깨달았다.취업해서 돈 버는걸로는 뒤에 ‘하하호호’가 가능할 확률이 낮다고 생각했다.물론 행복하게 살 수 있지만 0.1%의 확률도 돈 때문에 사건이 터지지 않았으면 한다.그래서 뉴스와 책들을 읽으면서 결국 사업을 해야하는 구나.. 라를 깨달았다.취준하면서 깨달은게 참 아이러니한 상황이지만.. (면접에서 혹시나 결국 나중엔 나가서 사업할 거 들킬까봐)이 책은 주인공의 친아버지와 친구의 아버지에게 배운 내용을 쓴 글이다.친아버지는 교사시며, 안정적인 수입과 안정적인 삶을 택하는 사람이다.친구의 아버지는 중학교 졸업자이지만, 자신의 매장이 5개정도 있고 대성한 사업가이다.그 두분의 마인드 차이를 보면서 주인공이 느낀점을 쓴 글이다.나는 사람들이 대학교 가지고 뭐라하는게 예 부터 이해가 되지 않았다.어차피 사람 다 거기서 거기이다. 서울대 나와도 누군가의 ‘노동자’가 된다면 결국 부자가 되기 힘들 것이다.내가 옛날부터 생각한 사람의 본보기는 ‘인성’ 과 ‘배울점이 있는 사람’이라고 생각한다.좋은 대학을 나온 사람들이 인성이 좋지 않고 그저 공부만 하는 사람들이라면 결국 현실의 벽에 부딪힐거라 생각한다.하지만 좋은 대학을 가야 인성이 좋게 형성될 확률은 높다고 생각한다.아무래도 미래를 안 보고 현실만 살아가며 유흥에 빠진 이들은 좋은 대학에 갈 확률이 낮으니까나는 대학으로 무시 하는 사람들에게 무시 받기 싫어서 편입으로 그래도 상위 5%대학에 갔다.아무튼, 좋은 대학이 부자로 가지 못하는 것은 친누나의 사례가 있다.친누나의 직장동료들은 sky대학을 나왔다. 그 중에는 과학고등학교 다니던 사람도 있다. 어학연수도 있고 외국에서 학교나온 사람도 있다.친누나의 직장은 업계 1등 기업이다. 그렇기에 환경이 사람을 안주하게 만들 수 있겠지만.. 그들은 현재6시에 퇴근하면 습관처럼 ‘롤(게임)’을 킨다. 그러고 다같이 롤을 하다가 잠을 잔다.거기서는 롤학원을 다니면서 소비하는 사람도 있고, 재산을 전부 탕진해서 누나한테 주식하는 법좀 알려달라는 사람도 있다고 한다.그런 사람들에게 우리 누나가 답답해하는 점은 그것이다.‘말이 안 통한다.’누나는 기업리포트도 읽고, 책도 많이 읽으며 계속해서 경제에 대해 학습한다.그래서 누나는 월1천을 주식으로 벌고 30살에 집도 샀다.그런데 직장동료들에게 당연히 자랑같으니까 위의 상황은 말은 못하고, 가끔씩 경제얘기 나올때 사람들이 자기만의 ‘고집’이 있어서 말이 안 통한다고 하다.‘돈이 없어서..’, ‘돈 잃을까봐…‘라는 것은 변명이라고 책에 써있다.기회를 잃는다.누나 사례와 책을 보고, 실패를 걱정하지말고 공부하면서 끊임없이 노력해야한다고 생각한다.부자가 되려면 리스크를 감수해야한다. 이 책에도 그렇게 써있다.리스크를 줄이려면? 공부하면 된다. 실패확률을 줄일 확률이라고 다른 서적에 써있었다. 아마 돈의속성이었던 것 같다. 부의 추월차선이나안정적인 삶만 추구하면 달라지지 않는다.그리고 소비를 절제하라고 책에 써있었다.물론 나는 돈이 없다.이제 취업을 하면서 사회에 한발 내딛었는데, 주변 직장친구들에게 주식에 얼마 넣고 있고 누나한테 앞으로 어떻게 살아가야할 지 조언을 구했다.첫월급도 부모님한테 절반정도 드리고 최소한의 생활비만 냄겨놓고 전부 주식에 넣을 것으로 생각했다.그리고 절대로 사치와 게임에게 과한 돈을 쓰지 않기로 했다.나는 사치를 절대 못한다. 예전에 19만원 티셔츠를 샀었다.메종키츠네 반팔인데, 여우로고 하나 박혀있다고 19만원을 받았다.이쁘긴 한데, 처음에는 입고다니다가 다른사람이 보기에 너무 ‘자랑’같아 보여서 다음부터는 안 입었다.아깝긴 하지만 ‘나는 사치를 좋아하지 않는구나’라는 깨달음을 얻게 되었다.겉보다는 속이 중요하다.게임은.. 취미생활이니 한달에 5만원 그 밑으로 돈을 넣을 것이다. ㅎㅎ 게임이용료 느낌으로..책을 읽으면서 느낀 것은 그렇고 내가 생각한 중요한 어록들을 적겠다.P39포기할 때 가난한 것이다.P56다른 사람들보다 나 자신을 바꾸는 것이 훨씬 쉽다.(취준생들이 겉으로 사회를 탓하여 위로하는것은 좋지만속으로도 진짜 그렇게 생각하지 않았으면 좋겠다.어차피 기업은 바꾸지 않는다. 내가 바뀌어야 한다.)P70인간의 삶은 두 가지 감정에 의해 지배된다.그것은 바로 두려움과 욕심이다.(내가 돈을 잃게될 것이라는 두려움.한방에 돈을 탈거라는 욕심)P138부채와 자산의 차이를 이해라라P143부자는 자산을 산다.가난한 이들은 오직 지출만을 한다.중산층은 부채를 사면서 그것을 자산이라고 여긴다.(중산층의 경우 자본금에서 나가는 지출들이 더 많거나 비슷한 경우들을 말한다.)P184내 부자 아버지는 로빈 후드를 영웅이라고 생각하지 않았다.그분은 로빈 후드가 나쁜 놈이라고 말했다.(자세한 건 책으로)P188가진 자와 가지지 못한 자 사이의 전쟁은 수백 년동안이나 이어져왔다.새로운 법률이 만들어지는데, 문제는 그 전투에서 패배하는 쪽은 늘 지식이 부족한 이들이라는 것.(배우지 않으면 결국 새로운제도에 등골 빨린다는 이야기)P213정보가 재산이다.낡은 사고방식이야말로 가장 큰 부채이다.(정보화 시대에 관한 이야기)P220가장 중요한건 정신돈이 중요한 것이 아니다. 돈은 서로간 합의한 약속P229금융 지능은 다음의 네 가지로 구성된다. 회계 투자 시장에 대한 이해 법률 (다 알고 있으면 좋다는 이야기.)P240인간은 원래 실수를 통해 배우도록 설계된 존재이다.(실수를 두려워하지말고, 남이 실수한다고 해서 비난하지 마라)P241다른 사람들이 놓친 기회를 찾으라.자금을 조달하라.똑똑한 사람들을 조직화하라.P 6챕터에서돈을 위해 일하지 말고 배움을 위해 일해라.(돈을 쫓아가면서 일하지마라)P274성공에 필요한 3가지 관리 현금흐름관리 시스템관리 사람관리 P287금융지식을 갖추고 있으면서 자산 개발을 못하는 요인 5가지 두려움 냉소주의 게으름 나쁜습관 오만함 P290잃는 걸 너무 두려워하지마라이기는 것은 지는 것을 두려워하지 않는 것이다.P294실패느 승자에게 힘을, 패배자에게는 좌절을 준다.부자가 되기 위한 10단계 현실보다 더 좋은 이유를 찾으라 : 정신의 힘 매일같이 선택하라 : 선택의 힘 친구는 신중하게 고르라 : 협조의 힘 하나의 방식에 통달하라. 그런다음 새로운것을 익히라 : 빠른 배움의 힘 자신에게 먼저 지불하라 : 자기 통제의 힘 중개인에게 넉넉하게 지불하라 : 좋은 조언의 힘 인디언들처럼 주고 받으라 : 공짜로 얻는 힘 자산을 이용해 사치품을 사라 : 집중의 힘 당신의 영웅을 선택하라 : 신화의 힘 가르치라 그러면 받으리라 : 주는 것의 힘. 이 책은 ‘부의 추월차선’처럼 엄청 잘 읽혔다.아쉬움도 남는 책이다. 왜냐하면, 내가 모든것을 습득했을 것이라 생각하지 않기 때문이다.나중에 한 번더 읽어볼 것이다." }, { "title": "Spring DAO란?, DTO란?, VO란?, DTO vs VO, DTO vs Domain, DAO vs Repository", "url": "/posts/Spring_semina/", "categories": "Java, Spring_CS", "tags": "Spring", "date": "2021-10-06 01:34:50 +0900", "snippet": "귀염둥이 후배들과 스터디를 하면서 세미나를 하기로 했다.나는 DAO, DTO, VO, @Entity의 개념을 조사하기로 했다.DAO(Database Access Object)즉, 데이터베이스에 접근하는 객체이다.단일 데이터의 접근 및 갱신의 개념.프로젝트의 구성중 Repositry와 DAO가 비슷하다고 생각하여 조사하였다.(실제로 같다고 보는 사람들도 있다.)public interface QuestionRepository extends CrudRepository&amp;lt;Question, Long&amp;gt; {} Repository vs DAO 일단 이게 논란이 많은 부분이라고하는 듯. 그래서 찾아보면 다 개인적인 견해라고 밝힘. 제일 심오하게 고민한 글 : https://bperhaps.tistory.com/entry/Repository와-Dao의-차이점 각자 읽는 것을 추천. 저 내용을 정리하기엔 제대로 전달할 자신이 없다. 참고 : &amp;lt;https://bbbicb.tistory.com/44&amp;gt; 1. None DAO는 data persistence의 추상화 Repository는 a collection of objects의 추상화. 먼말인지 모르겠음.. 찾아봐도 잘 안 나온다. data persistence관련은 IBM 홈페이지에 정리되어있음.&amp;lt;https://www.ibm.com/docs/en/cloud-paks/cp-biz-automation/20.0.x?topic=designer-data-persistence&amp;gt; DAO는 데이터베이스와 관련이 많다. Table중심. Repository는 도메인과 관련이 많다. Arggregate Roots만을 다룬다. DDD와 Aggregate Root란?DDD(Domain Driven Design) - 도메인 중심으로 설계하는 디자인 방법론 도메인 주도 설계 Domain ? 회원가입, 회원탈퇴 등에서 작업은 모두 ‘회원’의 중심으로 진행됨. 여기서 회원이 도메인. 어플리케이션 내 로직들이 관여하는 정보와 활동의 영역. 옷 쇼핑몰에서 손님들이 주문하는 도메인이 존재할 수도 있고, 점주입장에서는 옷들을 관리하는 도메인이 존재할 수 있다. 즉, 사건이 발생하는 집합들. 추상화된 것들도 대상이 될 수 있다는 것. ‘주문’이라는 것처럼. 또한 이처럼 문맥에 따라 객체의 역할이 바뀌는 것을 Bounded Context라고 부름. Bounded Context에 따라서 Model의 역할은 완벽히 달라지고, 책임 또한 달라짐. DDD가 필요한 이유 데이터에 종속적으로 개발하거나 모델링과 개발이 불일치한 경우를 방지하기 위해 DDD가 등장. 설계 방식? 크게 3가지 Layer로 나눔. 그 전에 사진에 MicroService가 나왔는데 why? 위에서 Bounded Context에 대해 말했는데, 이러한 관점을 더나아가서 서비스에 적용시킨 것이 MicroService라고 한다. 서로 다른 도메인 영역에 영향을 끼치기 위해서는 API 호출로 해야 된다는 것. 각각의 도메인은 서로 철저히 분리되고, 높은 응집력과 낮은 결합도로 변경과 확장에 용이한 설계를 얻게됨. (응집력, 결합도 모르는 사람?) Application Layer : 주로 도메인과 Repository 바탕으로 실제 서비스(API)를 제공하는 계층 Domain Layer : Entity, VO를 활용하여 도메인 로직이 진행되는 계층 Infrastructure Layer : 쉽게 말해서 외부와의 통신(ORM, DB, NoSQL)을 담당하는 계층 DDD의 핵심은 도메인을 서비스로 별로 분리하라 하지만 모든 도메인마다 많은 객체를 다루고 각 객체마다 Repository를 만들면 DDD가 가지는 장점을 내세울 수 없게됨. 여기서 등장하는 것이 Aggregate(집합) Aggregate(집합) 각각의 도메인 영역을 대표하는 객체를 Aggregate라고 함. 그렇게 하면, 각각의 도메인에 Repository로 묶어야하는 객체(Entity)가 명확해지기 때문. Top - Down 방식으로 계층을 타고타고 내려갈 때 어떤 Entity를 만들기 위해 도메인이 이루어져 있는지 명확하게 들어오기도 함. 예출처 : &amp;lt;https://huisam.tistory.com/entry/DDD&amp;gt; 위의 예시에서 Order라는 Domain에서 Order라는 Entity를 만들기 위해 다양한 객체들이 상호협력하고 있는 관계를 볼 수 있다. 이 Aggreagte 포함되어 있는 특정 Entity를 Aggregate Root라고 한다. 위의 경우에서 루트는(Order)는 하나만 존재하고, Aggregate 내의 특정 엔티티를 가리킨다. 경계 안의 객체는 서로 참조할 수 있지만, 경계 바깥의 객체는 해당 Aggregate의 구성요소 중 루트에만 참조할 수 있다. 위의 방식으로 사용해야 하는 이유는 데이터 무결성 측면이 있다. Order가 아닌, shpping address 등에만 데이터를 저장하면 데이터 무결성이 깨질 위험이 있다. DTO(Data Transfer Object)DataBase에서 Data를 얻어 Service나 Controller 등으로 보낼 때 사용하는 객체.VO(Value Object)각 계층간 데이터 교환을 위한 자바 객체를 의미.레이어 간에 전달하는 목적을 가지고 있으며, 객체의 속성과 getter, setter만을 가지고 있음.계층간 데이터 교환을 위한 자바 빈즈(Java Beans)이다. 자바 빈즈? 자바로 작성된 소프트웨어 컴포넌트들을 지칭하는 단어 MVC모델 기준 Model이 JavaBeans JSP에서도 쓰이는데 JSP문법은 모르니 pass → JSP 파일 내에서 사용이 가능한 객체라고 생각. 즉 DTO는 Database에서 Data를 얻어 Service나 Controller 등으로 보낼 때 사용하는 객체. VO(Value Object) vs DTOVO는 DTO와 동일한 개념이지만 read only 속성을 갖음.VO는 특정한 비즈니스 값을 담는 객체이고, DTO는Layer간의 통신 용도로 오고가는 객체를 말함.Entity - 고유 식별자를 바탕으로 객체의 정체성을 부여실제 DB의 테이블과 매칭될 클래스 즉, 테이블과 링크될 클래스임을 의미. Entity클래스 도는 가장 Core한 클래스라 부름 최대한 외부에서 Entity 클래스의 getter method를 사용하지 않도록 해당 클래스 안에서 필요한 로직 method를 구현한다. Entity와 VO의 차이점 Entity는 고유 식별자(Primary key)를 바탕으로 객체의 정체성을 부여. VO는 상태(Attribute)를 바탕으로 객체의 정체성을 부여. equals Hashcode를 id로만 하면 Entity, 상태에 대한 모든 정보로 하면 VO DTO와 Entity를 분리하는 이유 View Layer와 DB Layer의 역할을 철저하게 분리하기 위해서이다. 테이블과 매핑되는 Entity 클래스가 변경되면 여러 클래스에 영향을 끼치게 되는 반면 View와 통신하는 DTO클래스는 자주 변경되므로 분리해야 한다. Domain Model을 아무리 잘 설계했다고 해도 View 내에서 Domain Model의 getter만을 이용해서 원하는 정보를 표시하기 어려운 경우가 있다고 함. 이런 경우 Presentation을 위한 필드나 로직을 추가하게 되는데, 이러한 방식이 모델링의 순수성을 깨고 Domain Model 객체를 망가뜨리게 됨. 또한 Domain Model을 복잡하게 조합한 형태의 Presentation 요구사항들이 있기 때문에 Domain Modl을 직접 사용하는 것은 어려움. 즉 DTO는 Domain Model을 복사한 형태로, 다양한 Presentation Logic을 추가한 정도로 사용하며 Domain Model 객체는 Persistent만을 위해서 사용한다. 여기서 Persentation은 View계층, persistent는 인프라스트럭쳐 = DB, 외부 라이브러리 등의 인프라Controller(web) 기능 해당 요청 url에 따라 적절한 view와 mapping 처리 @Autowired service 를 통해 Service의 method를 이용 적절한 RsponseEntity(DTO)를 body에 담아 Client에 반환 @Controller vs @RestController Controller API와 view를 동시에 사용하는 경우에 사용 대신 API 서비스로 사용하는 경우는 @ResponseBody를 사용하여 객체를 반환 View(화면) return이 주목적 RestController view가 필요없는 API만 지원하는 서비스에서 사용. @ResquestMapping 메서드가 기본적으로 @ResponseBody 의미를 가정 data(json, xml 등) return이 주목적 : return ResponseEntity 즉, @Controller + @ResponseBody Service 기능 Autowired를 사용하든 뭘하든 어떠한 방식을 통해 repository의 method를 이용 DAO로 DB에 접근하고 DTO로 데이터를 받은 다음, 비즈니스 로직을 처리해 적절한 데이터로 반환 @Servicepublic class UserService { @Autowired private UserRepository userRepository; // -&amp;gt; DAO @Resource(name = &quot;bCryptPasswordEncoder&quot;) private PasswordEncoder bCryptPasswordEncoder; // 비즈니스 로직을 처리하기 위한 변수? @Autowired private MessageSourceAccessor msa; //비즈니스로직, userRepo에 접근하고, 예외가 발생할 경우 메시지를 던지는 비즈니스 로직 public User save(UserDto userDto) { if (isExistUser(userDto.getEmail())) { throw new UserDuplicatedException(msa.getMessage(&quot;email.duplicate.message&quot;)); } return userRepository.save(userDto.toEntityWithPasswordEncode(bCryptPasswordEncoder); }} " }, { "title": "2021.10.01(금).경제 정리노트", "url": "/posts/economy1004/", "categories": "Economy, DailyNote", "tags": "Economy", "date": "2021-10-04 01:50:50 +0900", "snippet": "2021.10.01 경제 헤드라인을 정리한 글입니다.부동산 관련, 청약 관련글에 대해서는 따로 정리하지 않습니다.기사내용 출처https://blog.naver.com/sonsarang38 자영업 이어 제조업 흔들리자… 경제수장들 ‘위드코로나’ 촉구 → 현재 우리나라 경제를 떠받치는 제조업의 생산 및 매출이 줄어들고 있다. → 이로 인해서 ‘방역과 경제 동반실패’라는 비판에 직면할 수 있기 때문에 ‘위드 코로나’로 전환하겠다고 정부가 밝힘. → 위드코로나로 바꾸면 단계적으로 일상회복을 하는데, 신용카드 캐시백 10% 사업과 집합금지, 제한 조치를 당했던 업종에 대한 보상이 진행될 예정이다. 5조 내다판 기관, 크래프톤. 현대重은 샀다. → 기관 투자자들이 반도체와 인터넷 종목을 대거 매도한 반면 크래프톤, 현대중공업 등과 같은 새내기 공모주를 대거 사들였음. 총 5조를 매도하고 크래프톤 5000억원, 현대중공업 2300억원 매수. 공매도 쏟아낸 기관 거래비중 한달새 2배 대출제한 여파 … 서울 아파트 매매.전세가격 상승폭 2주 연속 줄어 → 매매가격지수가 9월27일의 전 주기준 서울 0.28%, 수도권 0.36%, 지방 0.34%에서 0.24%, 0.20%, 0.16%로 오름폭이 축소되었음. → 전세가격 상승세도 서울0.18%, 수도권0.23%, 지방0.12%에서 0.16%, 0.21%, 0.11%로 상승폭이 줄음. 금리 상승 공포 … “과도한 미래 이익 반영된 주식 피할 때” 애증의 항공주, 이번엔 날까 보잉. 에어버스 목표주가 상향 → 백신 접종률이 올라 여행 수요가 증간한 것 같다며 보잉의 주가가 10%상향함. “천연가스값 감당 못해”… 英 에너지업체 줄파산 → 영국의 에너지업체 3곳이 파산함. → 영국에선 에너지업체가 수시로 가격이 변하는 도매시장에서 천연가스를 구매한 뒤 정부가 정한 가격 상한 내에서 소비자에게 판매함.. 때문에 가격변동에 대한 위험을 업체가 고스란히 받게된다. → 국제시장에서 천연가스는 2021년 1월 기준 2.33달러에서 5.88달러로 급등했는데, 이 부담을 업체가 고스란히 가져가는 것. → 가격이 오른 이유는 영국의 풍력 발전량이 부족하기 때문이다. 설상가상으로 유럽 천연가스 사용량의 3분의 1이상을 공급하는 러시아가 천연가스 수출을 대폭 줄였다. → 이유는 시베리아의 천연가스 가공 공장에 화재가 발생했다고는 하는데, 유럽 ‘길들이기’일 수도 있다는 관측. 中 제조업 경기 코로나 이후 ‘최악’ → 9월 PMI(제조업 구매관리자지수)가 기준선(50) 밑으로 떨어짐. → 50 밑으로 떨어진 경우는 코로나19 충격이 극심했던 지난해 2월(35.7) 이후 1년 7개월만. → 이렇게 떨어진 이유에는 원자재 가격 상승에 더해 전력난까지 덮치며 일부 공장 가동이 중단된 게 경기 위축의 주요 요인으로 꼽힘. → 중국 정부는 기업의 전력 생산량을 올리고 소비자의 전력소비량을 줄이겠다는 방안을 검토중. → 또한 가정용 전기요금 인상도 검토하고, 석탄 숭비도 적정한 수준으로 늘린다는 계획. 경미한 車사고, 본인 과실만큼 치료비 낸다. → 2023년부터 車보험 ‘치료비 과실책임주의’ 도입 → 이러한 제도를 통해 고(高)과실자의 치료비가 저(低)과실자에게 전가되는 문제를 바로 잡을 수 있다. → 또한, 4주 초과 장기 치료 시 진단서 제출을 의무화하기 때문에 나이롱 환자를 줄이는데 도움이 될 전망. → 2023년에 적용될 예정인 이유는 전 국민의 자동차보험 약관을 모두 바꿔야하기 때문에 시간이 걸린다. 포스코, 폐배터리서 니켈.리튬 뽑아낸다.→ 포스코그룹이 율촌산단에 2차전지 리사이클링 공장 건설에 착수. 1200억원을 들일 예정.→ 블랙 파우더라는 리튬이온배터리 스크랩을 파쇄 및 선별 채취한 것을 갖고 니켈, 리튬, 코발트 등을 추출한다. SK지오센트릭, 폐플라스틱서 석유 뽑아낸다→ 옛 SK종합화학이 폐플라스틱에서 열분해유를 생산하는 데 국내 최초로 성공. 카뱅, 연말까지 신규 마통 중단.→ 정부 대출규제 압박에 조치→ 내년 가계부채 증가율 4%로 억제할 것이라는 목표가 있기 때문이다. 가족소득 있어도 생계급여 받는다.→ 부양의무자 기준 60년만에 폐지. 저소득층 40만명 새롭게 혜택 “시장 색깔 바뀐다 … 가치株로 대피하라” ‘배터리 화재 막는 해결사’ 캠트로스, 이틀 새 26% 급등→ 전기차 화재가 잇따르며 배터리용 첨가제 회사인 캠트로스가 부각.→ 캠트로스는 지나친 온도 상승으로 발생하는 배터리 화재를 막아주는 기술을 적용한 첨가제를 생산. 때문에 이틀 새 주가가 26% 급등. 모건 스탠리, 잇단 ‘빅딜’로 1위 지켜 … KB證, 주식.채권발행 ‘2관왕’ “脫탄소 시대에 투자하세요” 탄소배출권 ETF 4종 첫 출격→ 상장 첫날 1.05 ~ 1.65% 상승함.→ 종목으로는 KODEX유럽탄소배출권선물ICE, HANARO글로벌탄소배출권선물ICE, SOL유럽탄소배출권선물S&amp;amp;P, SOL글로벌탄소배출권선물IHS ‘몸값 10조’ 현대엔지니어링, 상장 예심 청구→ 내달 코스피 상장 계획 승인될 듯하다.→ 9월 30일 현대 엔지니어링은 한국거래소에 유가증권시장 상장을 위한 예비심사를 청구했다. 별다른 문제가 생기지 않으면 오는 11월 중후반 상장계획을 승인받을 가능성이 높음. 투자자 모집와 증권신고서 제출 등 IPO를 마무리하면 예상 상장 시점은 내년 1분기 신길동 신풍역세권에 아파트 1871가구 가을 분양 성수기 … 이달 전국서 6만5000여가구 쏟아진다→ 10월 일반분양 물량은 올 들어 월별 기준으로 가장 많음. 올가을 유망 분양단지 ‘한자리’에 … “내집 마련 기회 잡으세요”→ 10.1 금 10.2 토에 진행된 ‘집코노미2021’에 대한 내용 삼성전자 대신 삼성그룹ETF 샀다면→ 1년 간 37.7% 수익, 개별투자 앞질러 … 1주일 새 854억 유입 올해 서울 주택구입자 46.3%는 “임대 목적” ‘나주역자이 리버파크’ 내달 1554가구 분양 - GS건설, 청약제한 등 규제 없어 연휴에 집값 숨고르기 … 수도권 상승폭 줄어 증산4, 주민의견 전격 수용 가구수 줄여 중대형(85m^2) 늘린다.→ ‘중소형 80%’ LH안 거부. 주민들의 불만으로 LH가 중대형평형 공급을 늘릴 것. 하지만 공급량이 4139에서 3800가구로 줄여짐. LH, 국가유공자 7500명에 임대주택 제공→ 독립유공자 특화주택 시범사업. 노인 일자리 1만8천명 채용 지원.→ 또한, LH는 생계가 어려워 임대료나 관리비를 납부하지 못하는 저소득 가구를 지원하기 위해 지난 9월 경남 진주 LH본사에서 우리은행, 경남은행, 하나은행과 함께 주거위기 가구 생활안정 지원을 위한 기부금 3억3000만원을 주거복지재단에 전달. 검단서 또 공사중단 … 입주 기다리던 분양자들 속타→ 2개 단지 무기한 공사 중지 3400가구 입주계획 ‘흔들’ ‘허허벌판에 섬’같은 3기신도시→ 입주때 철도 11개 중 2개 개통. 선입주 후개통이라는 우려가 실현될 수 있다는 우려. " }, { "title": "Spring Security 오류 FindBy~()가 DB에서 객체를 못 찾을 때", "url": "/posts/Spring_Project1/", "categories": "Java, Spring_CS", "tags": "Spring", "date": "2021-10-02 01:34:50 +0900", "snippet": "Spring 스터디를 하면서 Spring Securtiy를 통해 로그인, 로그아웃 구현을 하였다.처음에는 내 식대로 커스텀마이징 하다가 많인 오류가 생겼고, 그냥 따라치기로 했다.도대체 뭐가 문제였을까?일단 알아야할 것이 있었다. @Override protected void configure(HttpSecurity httpSecurity) throws Exception{ httpSecurity. authorizeRequests() .antMatchers(&quot;/login&quot;,&quot;/signup&quot;,&quot;/user&quot;).permitAll() //누구나 접근 허용 .antMatchers(&quot;/&quot;).hasRole(&quot;USER&quot;) //USER, ADMIN만 접근 가능. .antMatchers(&quot;/admin&quot;).hasRole(&quot;ADMIN&quot;) //Admin만 접근 가능. .anyRequest().authenticated() //나머지 요청들은 권한의 종류에 상관없이 권한이 있어야 접근 가능. .and() .formLogin() .loginPage(&quot;/login&quot;) // 로그인 페이지 설정. .defaultSuccessUrl(&quot;/&quot;) // 로그인 성공시 라다이렉션 페이지 .and() .logout() .logoutSuccessUrl(&quot;/login&quot;) // 로그아웃 성공시 리다이렉션 페이지 .invalidateHttpSession(true) // 세션 날리기 ; }위의 코드에서 원래는 loginProcess()가 있어야하는데, 없어도 된단다. Security에서 loginProcess()가 없을 때 UserDetails를 상속받은 서비스에서 필수 구현 메소드인 loadUserByUserName()를 찾아 해당 로직을 수행한다.Service 코드@Override public UserInfo loadUserByUsername(String email) throws UsernameNotFoundException{ Optional&amp;lt;UserInfo&amp;gt; findEmail = userRepository.findByEmail(email); System.out.println(findEmail + &quot; !@!!#@!#&quot;); return userRepository.findByEmail(email).orElseThrow(() -&amp;gt; new UsernameNotFoundException(email)); }해당 로직을 수행할 때 Repositry에서의 코드는 다음과 같다.public interface UserRepository extends JpaRepository&amp;lt;UserInfo,Long&amp;gt; { Optional&amp;lt;UserInfo&amp;gt; findByEmail(String email);근데 DB에는 잘 저장되어 있는데 계속 Optional값을 뱉어내는 것이다.이유가 뭘까 하다가 임시방편으로 @Query를 이용해서 해결했다.public interface UserRepository extendsJpaRepository&amp;lt;UserInfo,Long&amp;gt;{ @Query(&quot;select u from UserInfo u where u.email like %?1&quot;) Optional&amp;lt;UserInfo&amp;gt; findByEmail(String email);}하지만 Spring에서 직접 쿼리를 내보내는 것은 권장하지 않기에 근본적인 원인을 해결해야 했다.위의 방식으로 로그인을 했더니, 일반 User계정 로그인은 잘 되고 Admin은 객체를 못 찾겠다고 또 오류를 뱉길래 그 로그를 그대로 구글링했다.참고 : https://kimji0139.tistory.com/34위 글에 따르면 view에서 name태그를 username으로 바꿔야한다고 하더라.그래서 네임태그를 바꾸고 @Query문을 지우니 해결..아마 SpringSecuriy 내부에서 로직을 돌릴 때 thymeleaf와 어떤 관계가 있나보다.(정확하지 않음.) themleaf에서 &amp;lt;input type=&quot;hidden&quot; th:name=&quot;${_csrf.parameterName}&quot; th:value=&quot;${_csrf.token}&quot; /&amp;gt;라는 문법을 통해 Form을 누르면(뭐 로그인하는 버튼) hidden 속성으로 CSRF토큰이라는 세션을 날림.-&amp;gt;Spring security Config에서 설정한protected void configure(HttpSecurity httpSecurity) throws Exception이 함수가 작동함.함수 내부에 있는loginProcess(&quot;URL&quot;)를 작성했으면 Controller에 있는 “URL”을 로직을 수행 작성 안 했으면 그냥 Security 내부에서 Login 처리를 함. Login 처리를 위해 필수 구현함수인public UserInfo loadUserByUsername(String email) throws UsernameNotFoundExceptionloadUser~함수를 실행함.위 함수를 통해 Repo에 접근함(repo는 JPArepository를 Extends한 것) 그 속에Optional&amp;lt;UserInfo&amp;gt; findByEmail(String email);JPArepositroy를 Extends하면 저렇게 함수를 작성하기만해도 알아서 JPQL을 만듦(수정하고 싶으면 내가 했던 @Query를 사용하면 됨)근데 그 내부에서 값을 view에서 name으로 지정한 username을 기준으로 찾나봄?csrf관련 : https://reiphiel.tistory.com/entry/spring-security-csrf" }, { "title": "인성의 힘(로버트 캐슬런2세 저) 독후감", "url": "/posts/book2/", "categories": "Book", "tags": "book", "date": "2021-09-29 01:00:00 +0900", "snippet": "이 책을 처음 접하게된 것은성공한 사업가의 이야기를 들려주며 인성에 대한 중요성을 알려주는 책이라고 생각했지만.. 내 생각과는 꽤나 달랐다.군인이 쓴 책으로, 예시들도 군인들에 대한 예가 많았고,‘내가 만약 군인이었다면 이런 생각을 했겠지?’라는 생각을 많이 하게 되었다.책을 읽으면서 나름대로 마음에 와닿는 구문을 적었다.p146“실헝용 쥐는 언제나 옳다” - 행동 심리학자 스키너p177관계는 중요하다 中“중요한건 타인들이다” - 크리스토퍼 피터슨p247(내가 공감하지 못한 부분)“전쟁은 인격의 시험대이다. 좋은 사람은 더 좋은 사람이 되고, 나쁜 사람은 더 나쁜 사람이 된다”내가 든 생각 : ‘어떤 느낌인지는 알겠는데 전쟁으로 인해 좋은 사람은 더 좋은사람으로 된다는건 뭔가 말이 이상하다’p254성장이라는 카테고리 中(이것 또한 의문)“주요 외상을 겪은 사람들은 알 것이다.그 경험 때문에 그들의 인생이 어떻게 바뀌었는지 직접 물어보라이들은 자신의 경험 덕에 더 나은 사람이 되었다고 말할 것이다. 최소한 일부는 그리할 것이다.”내가 든 생각 : ‘어떻게 물어볼 수가 있지.? 외상을 겪은 사람이 그 경험 덕에 자신이 발전했다고 사실 그걸 말로 하는 것 자체가 너무나도 대단한 거 아닌가..? 모르겠다’이쯤 되면 번역을 잘 못한건지 아니면 내가 잘 못이해한건지 내가 아직 부족한건지 모르겠다.p257“도전은 우리가 바라는 목표에 대한 장애물을 인식하는 방법이다.장애물을 위협으로 보는 것은 부정적인 반응이다.”이 말에는 배울점이 있었다.좋은 인성 표현을 막는 3가지 요인 개인내적위협(자아도취, 마키아벨리즘, 사이코패스 기질)마키아벨리즘이란, 자신의 이익을 위해 타인의 희생을 갈구하는 것. 이기주의자 환경요인(수면부족, 수면방해 등) 사회, 조직 요인 " }, { "title": "leetcode(리트코드)-917 Reverse Only Letters(PYTHON)", "url": "/posts/leetcode_Reverse_Only_Letters/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-09-14 03:34:50 +0900", "snippet": "leetcode 917 - Reverse Only Letters문제입니다.1. 문제https://leetcode.com/problems/reverse-only-letters/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 문자열이 들어옵니다. 문자열을 반대로 출력할 것인데, 원본문자열의 인덱스에서 문자가 아닌 것은 자리를 그대로 유지하여 출력해야합니다.5. codepythonclass Solution: def reverseOnlyLetters(self, s: str) -&amp;gt; str: res = &quot;&quot; def findalpha(reverseidx) : while reverseidx &amp;gt; 0 and not s[reverseidx].isalpha() : reverseidx-=1 return reverseidx reverseidx = findalpha(len(s)-1) for char in s : if char.isalpha() : res += s[reverseidx] reverseidx = findalpha(reverseidx-1) else : res += char return res 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "2021.09.14(화).경제 정리노트", "url": "/posts/economy0914/", "categories": "Economy, DailyNote", "tags": "Economy", "date": "2021-09-14 02:50:50 +0900", "snippet": "2021.09.14 경제 헤드라인을 정리한 글입니다.부동산 관련, 청약 관련글에 대해서는 따로 정리하지 않습니다. 인천 집값 올해 20.5% 올라 ‘수도권 1위’ → 서울은 9.8%, 경기 18.7% 앞질렀다. → 수도권 광역급행철도(GTX) 호재 등으로 재평가 받고 있다. → 삼성바이오로직스, 셀트리온 등 바이오 기업이 인천스타트업파크 건립도 예정 돼있다. 주변시세 2억 ‘쑥’ … 둔춘주공 분양가도 오를까 → 둔춘주공아파트 재건축 사업에서 분양가를 놓고 국면에 돌입. → 조합은 평당 3,700만원 이상으로 책정하였지만, 주택도시보증공사(HUG)는 2,900만을 제안함. → 조합이 3,700으로 책정한 이유는 작년기준 집값이 2억원이 뛰었기 때문이다. → 정부 입장에서도 곤란한데, 분양가가 높아질수록 중도금대출이 어려워져 3700만원 기준 25평이 9억원을 초과해버림. 그래서 중도금 대출을 못 하게되기에 실수요자보다 현금을 많이 들고있는 사람들의 잔치가 되어버릴까 우려를 하고 있음. → 이에따라 특별공급 물량이 증발할 가능성이 높아짐. “ICU로 1분 안에 권리분석 … 아파트 거래 사고 막죠” → 부동산 공기업인 한국부동산원의 사내벤처기업 비앤써가 만든 ICU앱 → 2018년 발생한 ‘창원 오피스텔 보증금 사기 사건’을 안타까워하며 만듦. → 앱의 기능은 거래하려는 부동산의 주소와 가격만 입력하면 잠재적인 거래 위험 요인을 1분 안에 알려줌. 각종 권리 설정 여부에 더해 각 상황에 따라 무엇을 해야하는지 구체적 솔루션 제공. 계약서에 넣을 특약시항도 제시. 거래 금액이 시세 대비 적정한지, 해당 건물이 위반건축물 혹은 무허가건물인지확인. 계약 단계 진위여부 확인 등 신영, 고급 주거시설 ‘브라이튼 한남’ 이달 선보여 → 광고기사인듯? 경기 이천에 ‘븰리브 어바인시티’ 지상 49층 중대형 주상복합 분양 부산 좌천동에 57층 주거시설 ‘주식 고수’ 상장사, 3개월 만에 年이익 벌었다 → 서희건설이라는 곳은 50여개 종목에 분산투자해서 돈 벌고, 동양 생명, KCC 등도 돈을 벌었다는 기사 與, 암호화폐 과세 원점서 재검토 → 대선 앞두고 투자자 눈치보는 중. → 내년부터 시행하기로한 가상자산 과세 계획은 가상자산 매매 소득을 ‘기타소득’으로 분류해 연 250만원 초과시 초과금액의 20%를 세금으로 내야함. → 여당에서는 좀 더 논의를 해봐야겠다고하지만, 기획재정부에서는 “처음 듣는 얘기”라면서 법을 준비하고 있다고 함. → 민주연구원장인 노웅래 의언은 과세를 1년간 유예하고 ‘기타소득’이 아닌 ‘금융 투자 소득’으로 분류해서 5000만원까지 공제해주자는 세법 개정안을 발의한 상태. → 국민의힘에서도 윤창현 의원이 과세 시점을 1년 늦추는 내용의 소득세법 개정안을 제출해 놓고 있음. → 정치권에서 대선을 앞두고 가상자산투자자의 눈치를 보는 듯하다. ‘움직이는 컴퓨터’ 전기차 보안 시장 잡아라 → 전기차의 전장 부품이 차지하는 중요성이 커지고 있다. → KOTRA에 따르면, 내연기관차 원자재 비용 중 기계 비중이 19년 84%에서 25년 65%로 하락할 예정이라고함. 반면 전장 부품은 16%에서 35%로 증가할 전망. 즉, 해커들의 ‘공격 포인트’가 늘어난 셈. 파워트레인 분야 배러티 시스템 충전부, 내장장치의 확장형 인포테인먼트 솔루션 등.. → 테슬라가 보안 취약 점검 대회를 개최하였는데, 테슬라 프리미엄 스포으유틸리티 차량 ‘모델X’를 해커가 2분30초 만에 해킹해버림. → 전기차의 보안이 중요해질 수 밖에 없음. 현차는 보안업체 시옷과 하드웨어 보안 모듈 관련 공급 계약을 맺고 장비 테스트에 들어감. → 여담으로 AVAS는 가상 엔진음을 만들어내는 전장기술인데, 전기차의 소음이 너무 적어서 보행자의 안전을 위해 인위적으로 소음을 발생시키는 것. “구리값 연내 1만弗 다시 넘을 것” … 풍산 등 수혜주 ‘들썩’ → 구리주가 상승하고 있다. → 중국이 보통 1분기, 4분기에 구리의 재고를 늘리고 2분기,3분기에 감소를 시키는 경향이 있어 가격을 올리고 있다는 것. ETF, ETN 투자도 관심을 갖고 있는 중. 정부 규제에 털썩 …韓.美.中 빅테크 ‘동병상련’ → 주가 떨어진 것 원인 분석. 어제 자세하게 정리하였으므로 pass → 크케 카카오 (정치에 의하여), 애플(반독점 판별 때문), 텐센트(중국 규제) 국민 10명 중 7명 “원자력발전 찬성” → 말그대로 전국 성인 1000명 대상으로 조사한 결과 72.1%가 ‘원전 이용을 찬성한다’고 답함. 특히 18~20세 젊은 층에서 원전을 유지 또는 확대해야 한다는 응답이 79.5%로 높게나옴. → 안전도를 묻는 항목에 72.3%가 ‘안전하다’고 응답. → 원자력학회 관계자는 “2050년까지 원전 비중을 6~7% 축소한다는 탄소중립위원회 결정은 대다수 국민의 뜻과 정면 배치되는 것”이라며 “소형모듈원전(SMR)을 포함한 원전이 탄소중립 시대 각국의 주요 에너지 전략에 포함되고 있는 것과도 상반된다”고 지적. 정제마진 2년 만에 최고 … 정유 빅4, 힘받는다. → 정제마진 : 석유제품(휘발유 경유 등)에서 원유값을 뺀 것. → 원래의 공식은 원유가격 상승 → 수요 상승 → 석유 제품 가격 상승 → 정제마진 개선이라는 공식인데 코로나19때문에 원유값만 오르고 석유제품 가격은 유지하거나 떨어져버림. → 이러한 것이 현재 개선되어, 2년 만에 정제마진이 최고치를 찍음.(배럴당 5달러) → GS칼텍, SK이노, 등 비정제 부문으로 버티고 있었는데, 실적이 올라갈 전망 日서 ‘쿠키런’ 흥행 …데브시스터즈, 상한가 → 일본에서 쿠키런 대박터져서 주가 급등 카카오페이, 보험상품 판매 전면 중단 → ‘알 모으기’ 서비스는 유지 → 정부의 플랫폼 규제에 결국 카카오페이가 보험상품 판매를 중단하기로 함. → 손보사의 자동차보험료를 비교해 사용자가 최적의 상품을 선택할 수 있게 도와주는 비교분석 서비스도 중단. → 결제 시 리워드를 주고 이를 자동 투자하는 ‘알 모으기’ 서비스는 유지. 위법소지가 없다고 카카오페이가 판단했기 때문이다. → 펀드 투자 서비스를 선택했을 때 판매.중개 주체가 카카오페이증권임을 안내하는 메시지가 먼저 뜨도록 서비스를 개편하여 사용자에게 상기시킴. “빅테크는 놔두고 .. 카드 수수료 우리만 인하?” → 빅테크 VS 카드사 기사 → 빅테크는 카드수수료가 빅테크 기업에서 임의로 정해서 (0.96 ~ 2.5%)까지 받음. → 카드사는 금융당국이 카드사의 자금 조달 비용, 마케팅 비용, 리스크 관리 비용 등을 분석해 수수료를 정함 (0.8 ~ 2.06%) → 카드사의 수수료는 매년 낮아지고 있다. 현재는 정치에 휘말려 소상공인의 표를 얻기위해 이러한 조치를 취하는 것이 아닌가라는 비판이 나오는 중. → 이렇기에 두 업체가 대립구조가 나올 수 밖에 없다. 美 법인세율 21% → 26.5% 민주당, 하원서 추진할 듯 → 바이든 제안 28%보다 낮은 수준. “맨친 등 당내 온건파 반대하자 법안 통과 중점 두고 타협” 분석 우량기업마저 직원 줄였다 … 올해 상장사 47%가 감원나서 → 최저임금 인상 등 고용 비용 증가, 투명한 경기, 실적 둔화 등에 따른 투자감소에 채용을 안 하고 있다. “추석 앞두고 변동성 확대 … 방어적 대응 필요” → 방어적인 투자전략을 취하라는 기사. → 추석 연휴 직전 한 주동안 코스피지수 평균 상승률이 0.47% 부진했기 때문이다. “재난지원금 90%로 확대지급 안돼” → 홍남기, 이의신청 감안해도 88% 이달 가계부채 추가 대책 발표 코인거래소 28곳 인증 확보 30여곳은 영업 중단 불가피 → 지난달 21곳서 7곳이 늘었음. 추가인증 가능성은 낮다고 봄. → 원화거래만 안 하면 ISMS인증 획득만 해도 신고가 가능하다. 원화거래를 한다면 금융위 산하 금융정보분석원(FIU)에 신고를 마쳐야함. → 일부 가상자산사업자는 ISMS 인증 신청후 심사를 받고 있으면서 ISMS인증을 했다고 과대 홍보를 하는 사례가 전해짐. → 기한 안에 신고를 마치지 못한 사업자는 영업을 종료해야 하며 실명계좌를 확보하지 못한다면 원화 거래는 종료해야 함. → 금융위 관계자는 “이용자들이 거래소 폐업 등으로 피해를 입지 않도록 기존 사업자의 신고 상황, 사업 지속 여부 등을 최대한 확인하고 거래에 각별히 유의해야 한다”며 적절한 조치를 취하라고 전함. 내년 장기요양보험료율 12.27% 가입자 평균 1135원 오른다. → 복지부가 결정하였음. 현재 ‘건강보험료의 11.52%’에서 ‘12.27%로 0.75%인상할 것으로 결정 됨. → 근로자와 사업주가 절반씩 부담하는 보험료는 월평균 1만 3311원에서 1135원 늘어난 1만4446원으로 될 것 → 대신에 현재 노인요양시설의 요양보호사의 배치 비율은 1:2.5명인데, 1:2.1명으로 늘려나갈 예정. →장기요양보험료는 2017년 6.55%였지만, 이제 12.27%로 거의 두배로 뜀. 가입자들의 부담액도 3조 2772억원에서 6조3568억원으로 94%가 늘음. → 부담은 두 배가량 늘었지만 재정은 악화일로(상황이 나쁜쪽으로 빠진다는 말) 수입 증가분보다 지출이 더 큰 폭으로 늘어났기 때문이다. 소송전으로 번지는 바이든표 ‘백신 의무화’ → 인구 30% 백신접종 의무화 VS 개인자유 침해 → 바이든 “할 테면 하라” 강행 의지 ‘아파트 한채 값’ 최고급 골프장 회원권 … “없어서 못 삽니다” → 하이엔드 골프장 회원권이 없어서 못 사고 있다. → 가격이 대략 10억을 웃도는데, 골프장의 서비스가 너무 만족스러워서 사람들이 회원권을 팔지도 않는다. → 또한, 회원등록을 하기 위해서는 심사가 필요하다. 그에 맞는 ‘격’을 갖춰야하기 때문. 코인이나 주식 등으로 갑자기 돈을 번 부자는 반기지 않음. 부의 출처가 명확해야 한다. 심사는 3 ~ 6개월 정도 걸리며, 회원이 되면 그 자체만으로도 부의 상징이 되는 것임. → 투자자로서의 매력도 커지고 있다. 코로나 발생 전 회원가격이 6억원대에 거래되었던 경기 광주 남촌CC는 현재 14억원에 팔리고 있음. 경제 되살아난 유럽 .. 공급난에 발목 잡히나 → 백신 접중 늘며 봉쇄 풀리자 2분기 GDP의 증가율이 미국과 중극을 추월함. → 하지만, 원자재 부족에 따른 공급망에 차질이 생길 것으로 예상되어 한계가 있을거라는 분석. 美 긴축 시동에 애플 꺾이고 … 中 규제에 알리바바 12% ‘뚝’ 수도권 아파트 전세금 폭등 3년반 전엔 이값에 집샀다. → 2018년 1월 수도권 아파트 평균 매매가 4억인데, 현재 평균 전세가가 4억임. → 2018년과 2019년 2년동안 평균 전셋값은 3억1000만대를 유지하였으나 작년에는 반년 만에 16%가 급등해버림. 그러다보니 가격이 같아버리는 현상이 생김. “코로나 충격에 잠재성장률 0.4%P 추락” → 한은, 잠재성장률 재추정 → 투자.고용 줄어들고 생산성 약하 일각에서는 코로나19로 인해 정부가 너무 비대해져서 그렇다는 입장도 나옴. 왜냐하면 민간부분보다 효율성이 떨어지는 공공 부문이 늘어나 그만큼 자원 배분이 왜곡되고 경제 전반의 생산성이 하락했기 대문이다. → 인구 감소도 문제 명품에 지갑 활짝 연 ‘이대남’ … 5060 부모는 모바일쇼핑에 빠졌다. → 다양한 데이터들이 있다. → 20대의 골프장 이용률이 98% 늘음. 주 이용 고객인 40 ~ 60대의 점유율이 89%로 여전히 압도적이지만 빠르게 치고올라오는 중. → 이를 포함해 백화점에서 100만원 이상 결제한 건수가 20대 남성과 20대 여성은 각각 300%, 179%의 증가율을 보임. 과감한 소비와 투자를 한다는 것. → 과거에는 부모가 삼성TV를 사용하면 자녀도 삼성사의 제품을 사용하는 ‘브랜드 다운’현상이 강했지만 이제는 자녀가 부모에게 소비문화를 전파하는 ‘브랜드 업’의 현상이 두드러지고 있다고 함. → 50대의 배달앱 사용률도 늘어나고, 자녀가 추천해준 브랜드의 의류를 입는 50대들이 있다고도 함. " }, { "title": "JAVA - Static이란? Final과 비교", "url": "/posts/JAVA01/", "categories": "Java, CS", "tags": "JAVA", "date": "2021-09-14 02:50:50 +0900", "snippet": "Spring 스터디를 하다가 의문점이 생겼다.Static과 Final의 차이는 뭘까? 사실 깊게 생각하면 확연히 다른데, 헷갈리니 메모를 해야겠다고 생각했다.아주 좋은 글이 있어서 이해한 내용을 토대로 적어야겠다.https://djkeh.github.io/articles/Why-should-final-member-variables-be-conventionally-static-in-Java-kor/finalfinal키워드는 곧 상수를 의미합니다.위키피디아에서는 다음과 같이 정의합니다. Final은 Entity가 오로지 한 번 할당될 수 있음을 의미합니다.3가지 경우로 나눌 수 있습니다. Final 변수 해당 변수가 생성자나 대입연산자를 통해 한 번만 초기화 가능합니다. 상수를 만들 때 유용합니다. private final int value; Final 메소드 해당 메소드를 오버라이드하거나 숨길 수 없음을 의미합니다. Final 클래스 해당 클래스는 상속할 수 없음을 의미합니다. 문자 그대로 상속 계층 구조에서 ‘마지막’ 클래스입니다. 예를 들어서 java.lang.System, java.lang.String 등이 있습니다. public final class String{} public class examString extends String {} //불가능합니다. 세부 분석 Final 멤버 변수 반드시 상수는 아닙니다. public class Test{ private final int class_value; public Test(int value){ this.class_value = value; } public int getValue(){ return class_value; } } 만약 Test라는 인스턴스 객체가 100개 있다면, 각 객체에서 class_value라는 변수가 100개 있을 것이고, 그 값들은 다 다를 것입니다. 그렇기 때문에 클래스 레벨의 ‘상수’라고 할 수는 없습니다. 다만, 각 인스턴스 내부에서 값은 변경할 수 없을 것입니다. 그래서 상수란 static final을 함께 쓰는 것입니다. private 메소드와 final 클래스의 모든 메소드는 명시하지 않아도 final처럼 작동합니다. 오버라이드가 불가능하기 때문입니다.final 클래스는 상속을 금지시키기에 오바라이드가 불가능합니다.하지만 private에서 final을 명시할 수 있는데, 불필요해도 컴파일러에서 막지 않는 의미는 의미 구분을 위해서 쓰는 경우가 있기 때문입니다. private : 자식 클래스에서 안 보입니다. (오버라이드 금지) final : 자식 클래스에서 보이지만, 오버라이드가 금지됩니다.비슷한 예로 인터페이스 메소드에 public을 붙이거나, final 클래스 메소드에 final을 붙이는 등의 경우도 문제가 생기지 않습니다.Static 키워드static 전역, 정적의 의미로 통용됩니다. static은 해당 데이터의 메모리 할당을 컴파일 시간에 할당할 것을 의미합니다.즉, 동적데이터와 달리 프로그램 실행 직후부터 끝날 때까지 메모리 수명이 유지됩니다.사용법은 다음과 같이 나뉩니다. static 멤버 변수 클래스 변수라고도 부릅니다. 모든 해당 클래스는 같은 메모리를 공유합니다. 특정한 인스턴스에 종속되지 않습니다. 인스턴스를 만들지 않고 사용 가능합니다. public class MyCalcu{ public static int add(int x,int y){ return x + y } Mycalcu.add(1,2) // 인스턴스 없어도 가능. } static 메소드 클래스 메소드라고도 부릅니다. 오버라이드 불가합니다.(당연하게도 다양한 인스턴스가 접근이 가능하므로) 상속 클래스에서 보이지 않습니다. static 블록 클래스 내부에 만들 수 있는 초기화 블록입니다. 클래스가 초기화될 때 실행되고, main() 보다 먼저 수행됩니다. static 클래스 일반적인 클래스 중첩 클래스(nested 클래스)에만 사용할 수 있습니다. static nested class : static으로 정의된 nested class inner class : static으로 정의되지 않은 nested class 부모클래스의 멤버 필드 중에서 static 필드에만 접근할 수 있습니다. static import 다른 클래스에 존재하는 static 멤버들을 불러올 때 사용합니다. 멤버 메소드를 곧바로 사용할 수 있습니다. static 블록 ?코드 한방이면 이해가 됩니다.public class testmain { public static void main(String[] args) { Init.b = 3;; //static initializer block 호출 System.out.println(&quot;Init.b = &quot; + Init.b); System.out.println(&quot;-------- instance 생성 전 --------&quot;); Init block = new Init(); System.out.println(&quot;-------- --------&quot;); new Init(); System.out.println(&quot;-------- instance 생성 후 --------&quot;); }}class Init extends MySuper{ private int a; public int [] arr = new int[5]; public static int b; //instance initializer block(인스턴스 초기화 블럭) { System.out.println(&quot;++++ initializer block 실행 ++++&quot;); a = 11; // b = 22; 불가능 for(int i = 0 ; i &amp;lt; 5 ; ++i){ arr[i] = i*3; } System.out.println(&quot;인스턴스 변수 a = &quot; + a); System.out.println(&quot;인스턴스변수 arr 길이 = &quot; + arr.length); System.out.println(&quot;클래스 변수 b = &quot; + b); } //static initialzier block(클래스 초기화 블럭) static { // a = 1; error b = 2; System.out.println(&quot;Init.b = &quot; + Init.b); System.out.println(&quot;++++ static initialization block 실행&quot;); } Init(){ super(); System.out.println(&quot;생성자&quot;); }}class MySuper{ MySuper(){ System.out.println(&quot;Mysuper의 생성자&quot;); }}결과는 다음과 같습니다.참고로 super() 부모 클래스의 생성자를 호출합니다.사담으로 super는 this처럼 부모 클래스로부터 상속받은 멤버를 참조할 때 사용하는 참조 변수입니다. 부모 클래스와 자식 클래스의 멤버의 이름이 같은 경우 사용합니다.보통 static final을 합쳐 쓰는데 안 그런 경우가 있을까?대표적으로 Spring의 DI가 있습니다.각 인스턴스마다 서로 다른 final 멤버 변수를 생성자에서 초기화 시키는 사용하는 경우입니다.DI기법을 통해 클래스 내부에 외부 클래스 의존성을 집어 넣는 경우가 있습니다.public class MovieRecommender { private final CustomerPreferenceDao customerPreferenceDao; @Autowired public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) { this.customerPreferenceDao = customerPreferenceDao; } // ...}자세한건 Spring공부하면서 다시 다루겠습니다.반대로 static만 사용하면 ?기술적으로 가능하지만, 동시성 프로그래밍을 어렵게 만들고, 값이 계속 변할 수 있으므로 테스트하기 어려울 수 있다는 단점이 있습니다." }, { "title": "leetcode(리트코드)-1189 Maximum Number of Ballons(PYTHON)", "url": "/posts/leetcode_Maximum_Number_of_Balloons/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-09-14 01:34:50 +0900", "snippet": "leetcode 1189 - Maximum Number of Ballons문제입니다.1. 문제https://leetcode.com/problems/maximum-number-of-balloons/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 문자열이 들어옵니다. 들어온 문자열을 재배열할 때 “ballon”이라는 글자를 몇개 만들 수 있는 지 그 갯수를 리턴하세요5. codepythonclass Solution: def maxNumberOfBalloons(self, text: str) -&amp;gt; int: res = 987654321 res = min(text.count(&#39;b&#39;),res) res = min(text.count(&#39;a&#39;),res) res = min(text.count(&#39;l&#39;)//2,res) res = min(text.count(&#39;n&#39;),res) return min(res,text.count(&#39;o&#39;)//2) 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "2021.09.13(월).경제 정리노트", "url": "/posts/economy0913/", "categories": "Economy, DailyNote", "tags": "Economy", "date": "2021-09-13 01:50:50 +0900", "snippet": "2021.09.13 경제 헤드라인을 정리한 글입니다.부동산 관련, 청약 관련글에 대해서는 따로 정리하지 않습니다. “기술이 시민 행복에 기여” … 서울형 스마트시티 순항 → 스마트시티가 늘어나고 있다는 기사 “전셋값 치솟자 울며 겨자먹기 월세” → 서울 암파트임대 10곳중 4곳이 반전세이다. 전세값이 너무 올라 세입자들이 갈 곳이 없기 때문. 8월 소비자물가. 소매판매 지표에 관심 → 내일(14일) 8월 소비자물가 지표가 나옴. 안동.경주.익산 … 영.호남 연내 5만 4486가구 공급 특공 당첨 길 열린 무자녀 신혼 … 오피스텔 있으면 청약 못해 → 도시근로자 월평균소득 160%를 넘는경우 해당되는 것 “40분이면 강남 간다” 월곡.장위동.동북선 진척에 ‘들썩’ → 상계 ~ 왕십리 2025년에 개통하는 동북선 착공 등 개발 호재로 집값이 들썩이고 있음. 3년물 국채금리 年 1.5% 돌파 → 한은, 기준금리 추가인상 시사에 3년물 금리 22개월간 최고치ㅣ → 장민 금융연구원은 “현 기준금리 적정 수준보다 2%P가량 낮아”라고 함. 청약통장 다시 찾는 ‘청포족’ … 은행들 “청년엔 금리 얹어드려요” → 최근 청약 조건이 완회되면서 청약통장을 만드는 소비자들이 늘어남. → 이에 따라 은행들도 여러 조건들을 붙이며 고객들을 유치하려고함. 청약통장은 하나밖에 유지할 수 있기 때문이다. → 신한은행은 만 29세 이하 고객이 ‘신한 마이홈 적금’ 동시 신규가입하면 최대 연 5.5%의 적금 금리 제공함. 이 외에도 하나, 우리, 농협, 대구 은행 등이 있음. → 청년우대형 적금금리도 있으니 찾아보는 것이 좋다. 美 법원 “ 애플 인앱 결제 위법 … 외부결제 허용해야” → 애플의 주가가 3.3% 떨어졌음. “모바일게임 독점기업 아니다”에 안도하는 중. → 에픽게임즈가 애플 인앱결제에 대해 소송을 걸었다. 법원은 “성공은 불법이 아니다”라며 독점기업이 아니라고 했다. 그리고 애플에게 90일 이내에 개발자들이 앱 스토어에 올리는 앱에 외부 결제 서비스를 연결할 수 있도록 허용하라는 명령도 함께 내림. → 하지만 둘 다 ‘절반의 승리’를 취한 것이라는 분석. 내년 3분기부터 삼성전자 0.1주씩 쪼개 살 수 있다. → 금융위, 소수점 거래 허용. 금액 단위도 투자 가능. 해위 주식은 확대 적용. → 일부 증권사를 통해 해외 주식에만 가능했던 소수점 단위 거래가 국내 주식으로 확대 된다. 금액 단위로 투자가 가능한데, 삼성전자 주식을 1만원(0.123~~주)만 살 수 있다는 것. → 원래는 주식불가분 원칙과 온주(온전한 주식)단위로 설계된 예탁결제 인프라 때문에 불가능 했지만, 방식을 바꿀 것. → 증권사 입장에선 소수 단위 주문을 취합해 1주를 주문하고 이를 전자증권 형태로 변환해 고객에게 나눠줄 것. 부족분은 증권사가 스스로 메우는 방식으로 온주를 만들 것임. → 주식 배당금은 받을 수 있지만, 소수 지분의 의결권은 인정되지 않음. 日 부동산 투자금 44조엔 사상 최대 → 부동산 PEF, 상장 리츠 첫 추월 → 코로나19 확산 이후 본사와 도심 오피스빌딩을 팔려는 기업이 늘면서 글로벌PEF 운용사들도 일본에 적극적으로 진출했다. → 대표적으로 세계 최대 PEF 운용사인 블랙스톤은 3월 호텔 8개를 600억엔에 인수했다. → 전문가들은 주요국 중앙은행들이 기준금리를 인상할 것으로 예상되는 내년부터 일본 부동산 투자금이 줄어들 가능성이 있다고 내다봤다. 부동산보다 더 높은 수익률을 기대할 수 있는 다른 자산으로 몰려갈 가능성이 있기 때문이다. 정규직 전환에 1천억 썼지만 … 기간제 되레 늘어 → 정부가 중소기업 1인당 1000만원, 중견기업은 인당 700만원의 정규직 전환 세금공제를 해줌. → 기업이 이를 노리고, 정규직 채용을 줄이고 기간제 근로자 채용을 늘린 것 같다는 분석. → 4년간 7천여명 전환했지만 기간제 비중은 8.7%에서 9.7%로 늘음. → 정부가 이 같은 도덕적 해이에 대한 아무런 통제 장치를 마련하지 않아 1000억원 넘게 투입하고도 정규직 비중을 늘리지 못했다는 분석. 경제회복에 베팅 … 기업 자본지출 14년만에 최대폭 즈가 → IT. 유통. 장비 투자 집중 올해 지출 13% 증가 전망 → 세계 기업들의 올해 자본 지출이 지난해보다 13.3%늘어날 것이란 전망 → 코로나로 인해 시장 경쟁이 활발해졌다는 이유이다. 반도체 산업에서는 삼전을 비롯해 대만TSMC, 미국 인텔 등이 대규모 투자계획을 발표했다. → 친환경 경영 압박도 경영 지출 확대에 영향을 주고 있다. 탄소배출량 감소 정책을 내놓고 잇는 상황에서 기업들도 관련 투자를 늘리고 있다는 분석. 추석 앞두고 분양 ‘풍성’ 전국서 9256가구 분양 → 14일 평촌 엘프라우드, 태봉공원 푸르지오, 백양산 부암서희스타힐스, 광양 한라비발디 → 15일 월드메르디앙 구례 중국發 석탄값 초강세 … 롯데정밀화학.한화솔루션 웃는다 → 중국 선탄 가격이 급등하면서 석탄을 주원료로 사용하지 않는 국내 기업들이 반사이익을 누릴 것이라는 기사 → 대표적으로 한화솔루션, 롯데정밀화확 → 한화솔루션 : PVC를 생산하는데 ‘키바이드 공법’과 ‘EDC 공법’이 있다. 키바이드 공법은 석탄을 주 원료로 사용하고 중국에서 절반 가량이 이 공법을 사용하는 반면 한화솔루션은 EDC공법으로 생산하고 있다. 그렇기에 석탄 가격이 뛰고 에틸렌 가격은 떨어지면 이득을 볼 수 있는 구조 → 롯데정밀화학 : 주력제품인 ECH인데, ‘글리세린 기반’과 ‘프로필렌 기반’이 있다. 글리세린은 메탄올이 투입되고 중국에서 40%정도를 이 공법을 사용하기에 중국기업에 타격이 있을 듯하다. 그러면서 ECH 업황 호조를 이끌 주요 동력이 될 것이라고 함. ‘기준 금리 사전예고제’ 코스피 300P 끌어올린다. → 잘 이해를 못한 기사. → 주요국 동결 흐름 속 금리 인상 ‘잡음’ 여전 → 정책 불확실성 줄이고 소통 늘려야 경기 호조 → ‘금리 예고제’ 도입해 미래 기준금리 알리면 안정적 경제활동 가능 → 내 생각 : 금리 예고제란 미국 테이퍼링처럼 시장과 미리 소통 하면서 대비할 수 있게끔 도와주는 것. 파월 의장이 “테이퍼링 한다” , “테이퍼링 안 한다” 이러다보면 시장이 이에 대비하게끔 움직여서 시장이 안정화 된다는 뜻 같다. 수주호황에도 본사인력 줄인 조선사 .. “1년 뒤 어쩌나” → ‘조선 빅3’ 3년새 3100명 감소. → 왜 그러냐면 코로나19 영향으로 당장 일감이 없고, 원자재값 상승으로 적자를 계속 내고 있기 때문이라는 분석. → 선비 제작 비용의 20 ~ 30% 차지하는 후판가격이 상승 하였다. → 아마 내년부터 인력 수요가 늘어날 것 이라는 분석. ‘암호화페 대출’ 놓고 SEC-코인베이스 신경전 → 코인베이스 : 미국 최대 암호화폐거래소 → SEC : 미국 증권거래위원회 → 암호화폐 대출 서비스를 내놓으려 햇는데, SEC로부터 소송 가능성 경고 통지서를 받음. → 암호화폐 보유자가 코인베이스를 통해 대출을 신청한 사람에게 코인을 빌려주면 연 4% 이자를 받을 수 있는 서비스 상품이다. SEC는 투자자보호법에 따라 정부에 등록해야 하는 상품이라고 판단한 것으로 보인다고 월스트르트저널이 전함. → 코인베이스 창업자인 브라이언 암스트롱은 “막후에서 협박하는 전략”이라고 SEC를 비난. “우리는 법규 준수를 약속했지만 때로는 법이 불분명하다”고 지적. 그는 지난 5월 워싱턴DC를 방문해 SEC와 면담을 시도했으나 거절당했다. 금감원 “빅테크 전담법 필요 … 지배력 더 커지면 금융 시스템 불안” → 빅테크 규제에 따른 내용. 현재는 동일 행위. 동일 규제 방식인데 기업 규제 방식으로 바꿀수도 있다는 것. → 기업규제 방식으로 바꾸면 기업 내부의 지배구조 관리 및 내부 통제 등 훨씬 많은 통제가 이뤄질 수 있음. → 네이버는 금융업 라이선스가 없어서 집중 타깃이 되지 않을 가능성이 있지만, 비금융 플랫폼을 활용하거나 타사 제휴를 통해 간접적으로 금융업을 영위하려던 네이버의 사업 전략에 타격이 클 것이라는 분석 中 빅테크 바닥 ? 텐센트에 본토자금 몰려 → 이달 77억위안 순매수 .. 주가 반등 항셍테크지수는 저점 대비 15% ↑ → 집중 규제로 휘청이던 중국 빅테크 기업들의 주가가 반등하고 있다는 기사. → 텐센트는 10일에 2.08%올랐고, 알리바바, 메이퇀 등 주가가 오르고 있음. → 저가매수로 보는 시각도 많다. 반면 빅테크들의 실적이나 시장지배력이 여전하고, 적극적으로 사회 환원에 나서면서 리스크를 줄이고 있다는점에서 매수한다는 분석도 나옴. 블록체인 서비스, 공공부문서 꽃 피울것 → 코인플러그 : 국내 최초 대한민국 블록체인 기업. → 코인플러그는 실명계좌 발급이 불발되면서 문을 닫았지만 기술력이 좋다. → ‘메타파이’ : 누구나 쉽게 NFT를 구매해서 소장할 수 있고, 크리에이터가 되어 디지털 창작물을 만들어 올릴 수 있는 플랫폼. ‘버핏과의 점심’처럼 유명인이나 전문가의 시간을 사고 팔 수도 있게 될 것. → 더 폴(THE POL) : 회원가입할 때 휴대폰 인증만 하면 다양한 설문에 응답할 수 있는 어플. 블록체인으로 강화된 보안으로 걱정없이 할 수 있고, 보상으로 받은 가상화폐로 스토어에서 치킨,피자 등으로 바꿀 수 있다는 것. → B패스 : 부산시민카드, 가족사랑카드, 해운대구민카드 등을 어플에 넣고 다니면서 다양한 공공서비스를 이용할 수 있는 서비스. 이 역시도 블록체인 기반 집값 뛰어 찾는 사람 느는데.. 공증인이 없다 → 어려운 기사.. 찾아봐주세요. → 공증이란 공증인이 특정 사실 또는 법률관계를 공적으로 증명하는 것을 가리키는데 이러한 것이 줄어듦. 왜 필요하냐면 예를들어 부모님으로부터 돈을 2억원 빌렸으면 이를 차용증을 받고 공증을 받아야하나봄. 집값 상승으로 수요는 늘었는데, 공급은 없는 상황 설마했는데… 빌라 현금청산 ‘날벼락’ 현실로 → 현금청산 : 정부가 추진하고 있는 도심공공주택 복합사업이 대상이된 곳은 각 사업지에서 6.29이후 등기가 이뤄진 주택을 대상으로 신축 아파트 입주권을 받지 못하고 현금 청산의 대상이 되는 것. (투기를 막으려는 정책인 것 같음) → 즉, 거주지를 6.29이후에 샀는데 정부사업 대상지가 된 경우 집을 팔아야한다는 소리. → 이에 따른 실수요자들의 피해가 속출하는 듯. 인테리어비도 돌려받지 못함. → 보통 실수요자들은 아파트값 상승과 전셋값 상승을 버티다 못한 사람들의 선택지가 되는 경우가 많은데, 쫓겨나면 어디로 가야할 지 모름. 집단감염 가락시장의 눈물 … “추석 대목에 손님 구경도 못해” → 어떤 가락시장에서 상인 110명 중 99명이 코로나에 감염됨. → 또한 도매가게 23곳 중 17곳이 문을 닫음. → 작년보다 훨씬 심각한 상황이다. 정부는 전통시장 활성화에 나서는데 방역당국은 ‘밀집 자재’라며 딜레마에 빠지고 있다. “급여 10년前 후퇴” … 조선.뿌리산업 4만명 떠났다. → 중소기업에 본격 적용된 52시간제 여파로 조선업계와 뿌리산업의 고용불안이 가속화되고 있음. → 근로시간 감축에 따라 실질임금이 줄어들면서 근로자들이 투잡을 뛰기 시작함. 밤에는 배달대행업체 서비스를 이용한다던지 등.. 밤새 알바 뛴 직원들, 졸다 사고 날라… 아침마다 ‘토막잠’ 재우는 사장들 → 올해초 부업에 나서는 직원이 2~3%였는데 현재 20%가 넘음. → 조선업이 제조업 가운데 재해율이 높은 편인데, 가스질식사고, 추락사고 등의 요소가 포함되어 있기 때문이다. → 그렇기에 아침마다 직원들의 건강을 체크하고 사내 휴게실에서 강제로 ‘토막잠’을 자게함. → 이처럼 투잡이 일상화되면서 내년부터 본격 시행될 ‘종대재해처벌법’에 저촉되는 사례가 급증할거라는 우려 야근 못하자 쪼그라든 월급 … 낮엔 조선소서 용접, 밤엔 배달 뛴다. → 같은 기사. 보통 조선협력사 업체들이 이런 문제를 겪고 있음. 원자재값이 급등하면서 남는게 없어졌기 때문. 비사업용 토지 양도세, 내년부터 2배 … 주차장 지으면 절세 → 비사업용 토지는 그냥 땅만 사둔 토지를 말하는 것 같다. 이러한 토지에 대한 양도세가 내년부터 대폭 커질것. 왜냐하면 사업용 전환 등 여러 절세수단이 남아 있기 때문이다. → 그래서 사업용토지로 놓아야하는데, 이를 위해선 3년 중 2년 이상을 해당 용지에 맞게 사용해야함. 농지인 경우 30km 안에 거주하며 직접 경작 활동을 해야함. → 그 외에도 건물을 짓거나, 주차장을 만들면 사업용 토지로 바꿀 수 있음. “美 경기 아직 안 꺾여 … 조정 오면 에너지.금융株 사들일 적기” → 뉴욕생명자산 운용 CIO의 인터뷰 기사 " }, { "title": "2021.09.10(금).경제 정리노트", "url": "/posts/economy0910/", "categories": "Economy, DailyNote", "tags": "Economy", "date": "2021-09-10 01:50:50 +0900", "snippet": "2021.09.10 경제 헤드라인을 정리한 글입니다.부동산 관련, 청약 관련글에 대해서는 따로 정리하지 않습니다. 美 청정에너지 확충 속도전 “15년내 태양관발전 40%로” → 바이든, 탄소제로 청사진 현재 3%대서 대폭 늘려 2035년에는 40%목표 → 이를 위해 세금공제 혜택을 고려하고 있음. → 하지만, 미.중 무역분쟁이 태양광발전 확산에 걸림돌이 될 수 있다. → 미국 자체적으로 충분한 태양광 제품을 공급하기 어려운데, 중국 태양광 패널 원료 수입을 전면 금지했음. 신장위구르족 인권 타압과 강제 징용에 중국이 연루되었기 때문임. “美경기 저속기어 변환” 우려에도 … 흔들림 없는 연준 → 8월 취업자 수 증가가 시장 전망치의 3분의 1에도 못 미치는것으로 발표되자 테이퍼링이 내년으로 연기될 것이라는 전망이 나옴. 하지만 윌리엄스 총재는 당초 계획대로 연내에 실시하는 것이 바람직하다 말하며 기존 입장을 고수하겠다는 의지를 드러냄. → 다만 윌리엄스 총재는 “상당한 추가진전 기준에 부합했다고 선언하기 전에 고용에서 다 많은 개선을 보길 원한다”고 언급. Fed “美 경기회복 둔화” … 테이퍼링 늦춰지나 → 원자재와 인력부조긍로 인한 물가 상승 및 임금 상승에 따라 경기회복 속도가 둔화되고 있음. “연예인 모델 쓰지마” 中, 게임사 군기잡기 → 유료결제 유도 금지 요구, 신규 게임허가 장정 중단 → 연예인이나 유료결제를 유도하는 행위를 막기로함. → 또한, 미성년자에게 게임계정을 대여해주는 행위도 차단할 예정 ‘13년만에 최고’ 생산자물가 … 中 기업 휘청 → 소비자물가와 격차 더 벌어져 → 원자재 가격이 급등하면서 생산자물가 지수가 13년 만에 최고 수준을 기록. → 소비자물가지수(CPI) 상승률은 시장 예상치인 1%에도 못미쳤는데, 생산자물가지수(PPI)상승률은 13년 만에 최고 수준인 10%를 달성. 그래서 둘의 격차가 커짐. 월가도 아리송 … 美증시 연말 전망 오락가락 → UBS증권은 S&amp;amp;P500이 4650까지 상향한다고 예측 왜냐하면, 주가가 떨어지면 저점 매수세가 유입돼 지수가 상승한다고 분석. → 모건스탠리는 4000까지 하락한다고 예측. 물가 상승 압박, 연방정부의 반독점.법인세 인상이 IT기업에 불리하게 적용할 것이라는 예상에 따라. “미용.헬스케어.모바일株, 가을증시 이끈다” → ‘위드 코로나’ 주목 공모가 밑도는 쿠팡, 커지는 의구심 → 미국에 상장한 쿠팡의 주가에 대한 내용. → 주가가 계속 떨어지고 있는데, 보호예수 물량 풀리면서 그런것 아니냐는 분석이 있음. → 또한, 장기적으로 봐야한다는 입장. 아마존은 창업 13년 만인 2002년에 처음으로 흑자를 냈음. 쿠팡은 계속 적자를 내고 있음. 이번 2분기에는 -5억달러. 1분기에는 -2억달러. 이렇기에 장기적으로 봐야하는 것 아니냐는 입장. 이러한 플랫폼을 토대로 새로운 사업에 도전하면서 흑자를 낼 수 있느냐가 중요해질 듯. 핀테크 때리기 이제 시작 .. IPO 앞둔 카카오페이 직격탄 → 금융위원회 긴급 간담호 → 핀테크 기업은 “24일로 예정된 금융소비자보호법 계도 기간을 연장해달라”고 했지만, 금융당국은 “유예 기간 연장은 없다”며 강경한 태도를 보임. → 핀테크 기업들은 안되는 것들 만 있고, 되는 것이 없어 서비스 할 수 있는 방법을 알려달라고 하자 그런건 서비스 업체에게 별도로 문의하라고함. → 가장 큰 타격을 입는것은 카카오페이로, 자회사인 카카오증권, 교보라이프플래닛생명보험과 손잡고 ‘내 보험 관리’서비스를 진행했는데 이 역시 ‘중개’에 해당됨. → 카드추천 같은 서비스는 여신급융법상 불가하다며 막을 예정 “전기차 하드웨어까지 개발” … 애플의 승부수 → 애플이 자동차업체들과 협업이 불발되자 그냥 아예 자기들이 만들겠다고 함. → 자동차업체들은 하도급업체로 자리매김하는게 여간 불편하지 않은 모얌. 애플의 서비스를 자동차업체에 맞춰야지 자동차 업체의 생산방식을 바꿔 애플에 맞출 수 없다는 입장. → 애플카는 자율주행차일 가능성이 크다는 분석도 나오고 잇음. 엑슨모빌 때문에 도넛 못 먹는다고? → 바이오 디젤 생산을 늘리면서 식용유 공급이 부족해지고 있음. → 식용유 공급이 부족해짐에 따라 도넛 등 식료품기업들은 식용유 확보에 비상이 걸림. → 대두유가 거의 3배가까이 뛰었다. 대두유 소비량의 45%가 바이오연료 생산용으로 쓰이고 있어 거의 연구에 쓰이는 중. LNG船 75% 자율주행船 50% … 세계 1등 조선 강국 이룰 것. → 정부가 세계친환경 선박시장에서 국내 업체들의 시장점유율을 75%까지 올리겠다는 구상을 내놓음. → 자율주행선박에 1600억원의 자금을 투입하여 2030년까지 자율주행선박이 50%의 점유율을 갖도록 할 것임. → 무탄소선박 상용화도 추진중 → 이에따른 인력 양성을 항 예정이다. 집값.가계빚 ‘위험수위’ … 금리카드 또 커낸 한은 → 집값이랑 가계부채 증가율이 늘어나자 한은이 금리를 또 올릴 수도 있다는 기사 금리 올랐던 과거에도 … 공급 부족한 美 집값은 올랐다. → 왜 미국은 금리에 대한 인상을 안 하고 테이퍼링으로 경제를 조정하려고 할까? → 미국은 옛날에 집값이 오를 때 금리를 인상한 적이 있다. 집값은 근데 계속 올랐다. → 나의 개인적인 생각 : 왜 올랐을까? 금리랑 상관없이 어떻게든 돈을 빌려 집을삼 → 그만큼 집값 상승폭이 크고 차익이 커지기 때문. 빚은 ? : 어떻게든 갚음. 고된일을 하더라도 갚음. 자본의 가치가 높아지기 때문. 그래서 집이 사회에 공급되지 않고 수요만 느는 것. 규제 풀어 핀테크 키운다던 금융위 … 이젠 ‘특혜받을 시기 지났다” → 간편결제 규제를 풀어 많은 서비스를 키운 금융위 이제 제재를 나섬. → 기사에서 추측하기론 카카오모빌리티의 서비스 값 인상이 소비자의 불만을 키워 나타난 현상이라고 함. → 급해진 빅테크 기업들이 금융위 찾아서 읍소(울면서 빌음)도 함 세수 55조 늘었는데 … 나랏빚은 900兆 넘었다. ‘런지씨’ 분노에 엔씨소프트 휘청 … 시총 5조 사라졌다. → 자사 매입 카드도 안 먹힌 엔씨.. 어떻게 할 것인가? “재건축 부담금 적용시기 늦춰달라” → ‘재건축조합연대’ 설립 총회. 초과이익 환수제에 반대하는 전국 재건축 조합들이 집단 대응에 나섬. → 초과이익 환수제 : 재건축으로 조합원이 얻은 이익이 인근 집값 상승분과 비용 등을 제하고 가구당 평균 3000만원을 넘을 경우 초과 금액의 최고 50%를 부담금으로 환수하는 제도. 2006년 시행됐지만 주택시장 침체 등의 이유로 2013 ~ 2017 유예 2018년 1월 부활. → 이러한 제도는 평가 이익에 대한 징벌적 과세에 해당해 조합원들의 기본적인 권리마자 침해하고 있다며 반대중. 전셋값 등골 휘는 20대 … 전세대출 4년간 20조, 455% 급증 → 서울 아파트 평균 전셋값 23% 올라, 1인가구 늘며 30대 대출 156% 급증. ‘1조 재개발’ 신림1구역 “컨소시엄 시공사 반대” 목소리 커져 → 컨소시엄이란 건설 공사 등의 수주에서 여러 기업체가 공동으로 창며하는 방식 또는 모임 → 이렇게 컨소시엄 시공을 하면 보수작업에서 책임이 불분명해지고, 아파트 고급 브랜드 적용에서도 송파구 ‘헬리오시티’처럼 불리해질 수 있다고 반대의 목소리가 나오고 있음. → GS건설 컨소시엄 관계자는 책임소재를 한 곳에서 명확히 하겠다고 함. → 한편 용남구 한남3구역 재개발 조합도 조합원 반발이 있었지만 현대건설은 이 구역에 고급 아파트 브랜드 ‘디에이치’를 적용하겠다고 밝힌 바가 있음. 신도림 우성 4개단지 리모델링 1.2차, 3.5차 두곳씩 통합 사업 “결혼 좀 합시다” 부케 대신 근조화환 든 신부들 → 잘 이해 못 한 기사임. → 현재 식사 없으면 99인까지 허용가능하고 식사를 허용하면 49인까지 가능함. → 49인 기준일 때는 보증 인원을 원래 300명의 50%로 줄여줬는데 99명 기준이 생기면서 보증인원만 210명으로 늘엇음. 그래서 보증인원이 210명인 경우 하객을 식사 대접 없이 99명 초대하면 남은 답례품 11명분은 예비부부가 직접 가져가야함. 식대는 1인 6만원, 답례품 2만원에 금전적 피해와 마음의 짐을 짊어지게됨. → 백신 인센티브 달라. ㅠ 노래방 있는 건물 살땐 중과규정 따져봐야 꺾이지 않는 서울 집값 … 강서구, 노원 제치고 상승률 1위 → 서울 내 아파트값 상승률이 노원이 1등이었는데 이를 제취고 강서구가 1등함.(9월 첫주 0.3%상승) 엉터리 분양가상한제 공시 … 가산비 산정 98%가 ‘깜깜이’ 금리인상 충격에도 꿈쩍않는 서울 집값 너무 올랐나, 9월 강남.마포..강북.중구 아파트 매매 ‘0’ → 9월 8일까지 강남.마포.강북.중구 중에서 실거래 신고가 한 건도 없음. ECB, 채권 매입 규모 줄인다 → ECB(유럽중앙은행)이 채권 매입 프로그램의 속도를 낮출 것이라고 밝힘. → 유로존 소비자물가 상승률이 2021년 1월 0.9%에서 8월 3.0%로 상승하였기 때문 中 8월 생산자물가 9.5% 급등 13년 만에 최고 … 기업 부담 가중 → 5번 기사와 같은 내용 운좋게 당첨돼도 … 중도금대출 안될수도 → 금융권 대출 조이기 시작하니까 차라리 청약을 포기하는 사람들이 늘어나고 있음. → 광교 힐스테이트에 이어 공공분양도 중도금 대출이 막힘. 사실상 실수요자가 아닌 100% 현금을 갖고 있는 사람들을 위한 땅 ‘교토의정서’에 눈 번쩍 … 친환경만 보고 달렸다 → 에코프로비엠이 SK이노베이션과 10조 규모의 전기차용 하이니켈 양극재 판매 계약을 체결하면서 떡상. → 에코프로비엠은 양극재를 생산하는 회사임. → 에코프로비엠 회장 이동채 회장은 ‘교토의정서’라는 책을 읽고 친화경으로 사업을 시작. 그 결과,23년만에 10조 계약을 따낸 것. " }, { "title": "2021.09.09(목).경제 정리노트", "url": "/posts/economy0909/", "categories": "Economy, DailyNote", "tags": "Economy", "date": "2021-09-09 02:50:50 +0900", "snippet": "2021.09.09 경제 헤드라인을 정리한 글입니다.부동산 관련, 청약 관련글에 대해서는 따로 정리하지 않습니다. 美 델타변이 확산 속 임금.집값은 급등 … 스태그플레이션 우려도 → 8월 시간당 노동자 평균 수입이 증가했지만, 물가는 상승하고,일할 사람은 없고 부품도 부족하고 인구 8명 중 한 명은 코로나에 감염되어 경제 성장률이 예상보다 빠르게 하락하고 있다. → 이러한 인플레이션이 일시적이라고 파월은 주장하지만.. → 영국, 호주 등 물가상승률이 치솟자. 대응을 하기 시작. → 캐나다 중앙은행은 국채 매입 규모를 축소, 호주 중앙은행은 정부 발행 채권 매입 규모를 줄이기로 했다. 日 잡으려 만든 70 ~ 80년대 커리큘럼으로, 21세기 공대생 가르쳐 → 공감하는 기사.. 대학의 낡은 커리큘럼으로 대학생들을 가르치니 기업이 원하는 ‘실질적으로 일하는 인재’와 부합하지 않음. 그래서 채용미스매치가 발생 → 어떤 대학에서는 바이오 과목을 식품영양 교수가 수업을 함. → 현대의 흐름에 맞게 대학에서 강의를 구성해도 대학 교수 입장에서는 인센티브가 없음. → 인턴십을 확대하거나, 인센티브를 주는 것을 방안으로 내야할 것같다는 입장. 수능은 문.이과 통합, 교실은 문.이과 분리 → 문이과를 통합한다고 교육과정을 개편했지만, 여전히 문제가 많다는 기사. → 문과반 학생도 원한다면 과학,수학을 들을 수 있지만 이과생과 내신 경쟁을 해야하고 수능에도 반영되지 않아 할 필요성을 느낄 수 없음. → 이러한 문제는 결국 대학들이 여전히 문.이과로 나눠 입시를 치르기 때문이라는 분석. → 주요 상위권 대학들이 입시 단계부터 인문계와 이공계를 구분해서 학생을 모집함. ‘미적분/기하, 과탐 응시’를 못 박을분 인문계에는 아무 제한을 두지 않고 있음. 神의 직장, 이젠 神도 들어가기 어렵다. → 정규직 전환에, 한전 65% 인국공 45% 채용을 줄임. → 코로나로 인한 영향이 있겠지만, 인국공의 경우 4년만에 8000명에 가까운 비정규직이 정규직으로 전환한 부담이 크게 작용했을 듯. → 전체적으로 청년들의 취업문이 줄어들고 있음. 2018년부터 취업자 수가 감소하거나 정체하는 수준임. 4년 사이에는 9만3000여명이 줄어들었음. → 전문가들은 과도한 노동 규제로 기존 취업자는 지나치게 보호받고 있고, 투자와 신규 고용이 위축돼 청년층의 노동시장 진입을 더욱 어렵하게 한다는 분석. 대출 조이기 효과, 가계대출 증가세 꺾였다. → 가계대출이 증가하는 속도 증가폭이 줄어들었다는 기사인데.. 대출 조이기효과인지는 모르겠다. 카뱅 신용대출. 마통한도 2,000만원 쪼그라 들었다. → 신용대출 7000, 마이너스 5000한도였는데 2천씩 줄어서 5000,3000이 되었음. → 이렇게 카뱅이 대출 한도를 조인 것은 중저신용자 대상대출은 확대 조치를 이어나가기 위해서라는 분석. → 고신용자의 대출 한도는 줄였지만 중.저신용 고객을 위한 상품인 중신용대출, 중신용플러스대출 상품 등의 한도는 유지할 계획. 각각 1억원, 5000만원이다. 이로 인해서 카뱅의 중.저신용자 대출 규모는 빠르게 증가하고 있음. 증권 128만명 vs 은행 97만명 .. ISA 반년만에 대역적극 → 중개형 앱 등이 생기면서 주식투자 가능해지자 MZ세대가 몰렸음 → 그 결과 은행에서 증권사로 넘어가는 고객들이 많아졌고 이를 ‘머니무브’라고 한다. 이러다보니 처음으로 증권사 ISA 가입자 수가 은행 가입자 수를 앞질러버렸다. → 은행은 뾰족한 방법이 없어 투자자들의 해지 요구에 복잡한 절차를 둬서 막는 고육책을 쓰는 정도. 옮기려면 10가지의 이전 절차에 서류를 팩스로 전송하는 절차만 4번 진행해야함. 한달새 49% 올랐다, 수소주 급속충전 → 수소주의 주가가 급등함. 평화산업의 경우 49%, 상아프론테크 24%, 일진하이솔루스 24%, 코오롱인더스트리 15%, 두산퓨얼셀 8%,에스퓨얼셀 5% 등.. 정의선은 수소차, 최태원은 수소 생산 … “글로벌 3000兆 시장 선점” → 현대차가 최근 일산 킨텍스의 ‘수소모빌리티 쇼’에서 무인 수소 트럭을 보여줬음. → 이를 위해 필요한 수소 생산.저장 관련 사업은 SK, 포스코, 롯데, 한화, GS, 효성, 이수 등이 맡음. → SK는 액화수소 공장을 짓고 있고, 포스코는 2050년까지 수소를 500만톤 생산하겠다고 함 ‘수소환원제철’이라는 기술을 상용화해서. 롯데는 수소 생산뿐 아니라 수소저장 용기 사업 진출도 꾀하고 있음. GS는 한국가스공사와 협업해 액화수소 공장을 짓고 있다. 한화는 물을 전기 분해해 수소를 얻는 ‘수전해 기술’을 개발 중. 효성은 수소 충전소 구축 사업, 수소연료탱크에 쓰이는 탐소섬유 외에도 울산에 짓는 액화 수소공장을 통해 수소 생산 사업 확대 중. → 수소는 풀어야 할 과제가 많다. → 친환경으로 만들면 화학 공정에서 나오는 ‘부생 수소’에 비해 단가가 2 ~ 3배 비삼. → 수소에 있어서 개선해야할 기술들도 많다. 현재 기술들은 해외 의존도가 높은 편이다. → 인프라 확층도 만만찮고, 규제도 풀려야함. 한국에서 수소가 안전하지는 않기 때문에 충전할 때 전담 안전요원이 충전하기 때문 매년 9월 총회열어 이슈 공유 …. 해외 파트너 공동발굴도 → 국내 10대 그룹을 주축으로 한 ‘한국판 수소위원회’는 회원사 간 수소사업 협력을 통한 수소 투자 촉진에 힘쓸 계획임. → 현차, SK, 포스코 3개 그룹이 공동의장사를 맡음. 총회는 매년 9월 전 회원사가 참여한 가운데 열릴 것. → 이 자리에서는 주요 이슈와 현황을 공유하고 협력 방안을 모색함. 회원사 간 정기 모임도 진행될 것이다. 수소공급. 수요.인프라 부문에서 회원사 간 협력을 촉진하는 데 집중할 계획. 도요타, 美 켄워스와 수소상용차 공략 … 다임러.볼보는 합작사 설립 → 수소차 시장이 활발해지고 있음. 도요타는 미국의 켄워스와 협력해 전년 대비 8.7배 늘어난 수소 전기차를 판매하여 수소전기차 시장 점유율 1위인 현대차를 위협하고 있음. → 독일 다일러와 스웨덴의 볼보트럭도 손을 잡음. 합작사 ‘셀센트릭’을 발족. → 프랑스 르노구릅도 올해 초 세계 최대 수소연료전지 업체 중 하나인 미국의 플러그파워와 합작 법인 ‘HYVIA’를 세움. 올해 말 경상용차인 ‘마스터밴 에이치2테크’를 발매한다고 발표. → 독일은 수소 시자과 기술 개발을 위한 투자를 하고 있고, 미국은 2035년까지 수소 버스1만7000대를 도입하겠다고함. 중국은 2035년까지 수소전기차 100만대 보급을 목표 “미래 모빌리티 선점” 현대차-폭스바겐 로보택시 상용화 경쟁 → 현대차는 2023년, 폭스바겐은 2025년 상용화될 로보택시의 실물을 공개함. 레벨4 자율주행이라고 함. SK가스-르노삼성자동차 QM6 LPe모델 프로모션 아마존 효과? 11번가 1주만에 해외직구 3.5배 급증 → 11번가는 8일 “지난달’아마존 글로벌 스토어’론칭 후 첫 일주일간 해외직구 카테고리 거래에 전월 동기간 대비 3.5배이상 늘었다”고 밝힘. → SK텔레콤의 아마존 구독상품인 ‘우주패스’가입자가 폭발적으로 늘어서 그런 듯. → 사담으로 이런게 있는지도 몰랐네.. 주가는 왜 그대로지? 네이버, 카카오 ‘검은 수요일’ 시총 13조 날아갔다. → 금융당국의 빅테크 첫 규제와 정치권 공세 맞물려 주가 급락함. → 금융상품 비교 견적 사실상 금지 규제인데, 네이버는 해당 서비스를 제공하고 있지 않지만 불안감 때문에 주가가 떨어짐. 카카오는 대리업체를 통해 진행하겠다고 밝힘. → 정치권에서는 카카오를 ‘탐욕과 구태의 상징’이라며 문어발식 사업을 비판. → 대표적으로 카카오모빌리티의 갑질을 비판하며 방지대책이 도대체 뭐냐며 집중적으로 질의하리고 했음. → 소상공인의 지지를 얻기 위해 플랫폼 규제가 더 심해질 것이라고 분석. 배달앱 수수료 부담 점점 커져, 음식값 안올리면 수익내기 어려워 → 배달앱 수수료는 늘고 있는데, 경쟁은 배달업체끼리 하고 있음. 매출에서 광고비 떼고 포장비 떼고 해도 건당 배달료는 6000원에 임박할 수도 있음. → 숙박 플랫폼 경우 앱 고객 추가 매출이 600 ~ 700만원이지만 280 ~ 290만원은 플랫폼이 가져감. 조이면 무주택자 울고, 놔두면 가계빚 늘고 … 전세대출 규제 딜레마 → 전세대출 딜레마. 전세대출을 놔두자니 가계부채를 제어하기 어렵고, 죄자니 무주택자 등 실수요자의 주거안정성을 해칠 수 있다는 기사. 규제 풍선효과에 김해.구미평택 갭투자 ▲ … 깡통전세 주의보 → 풍선효과로 지방아파트 ‘갭투자’로 의심되는 것이 늘어나고 있음. 김해시 아파트 매매인의 비율의 41%가 외지인임. 거주하지 않는다는 뜻. → 투자가 몰리자 아파트값은 덩달아 오르고 있음. 전세가가 매매가보다 1,000만 ~ 2,000만원 높은 깡통전세도 나타나고 있음. 미친 전셋값 … 서울 빌라 지하층도 평균 1억원 넘어 → 서울 빌라 반지하 전셋값도 1억 원을 넘겨버림. 주거환경이 열악하다고 손꼽히는데 말이다. 미혼 1인가구, 맞벌이.무자녀 신호부부 ‘특공’ 기회 넓힌다. → 60m^2이하 주택만 신청할 수 있다. → 원래는 월 평균 소득 160%를 넘고, 결혼했거나 자녀가 있는 가구로 자격을 한정했는데 이러한 자격을 없애고 특공 물량의 30%를 제공하기로 바꿈. → 소득 기준을 초과하는 경우 자산 기준이 전세보증금을 제외하고 3억3000만원 이하여야 함. 지방 신청 0건 공공재건축 외면 → 8.4 공급대책의 핵심 사업 중 하나인 ‘공급 재건축’이 외면 받는 중. → 최근에 전국 대상으로 사업지를 공모했지만, 단 한 건의 신청도 접수되지 않았다. 주요 재건축 단지들 초과이익 환수제 등 부동산 규제도 부담. → 공고 재건축 : 사업성이 떨어져 재건축이 어려운 노후 아파트에 용접률이나 층수 제한 같은 건축 규제를 풀어주는 대신 늘어나는 가구 수의 절반 이상을 공공주택(임대.분양)으로 환수하는 제도. → 서울 재건축 단지들은 ‘과도한 기부 채납 등 참여할 이유가 없다’며 외면. → 정부가 강력한 인센티브나 규제 완화를 고민하지 않는다면 정부의 사업은 실패할 것이라는 분석. 과천서 30년 청약통장도 탈락 … 로또 공공분양 경쟁률 718대1 → 말그대로의 기사 커트라인 평균이 2586만인데, 한달 한도 10만원 기준으로 236 ~ 367 개얼 납입해야함. 이는 역대 최고 공공분양 커트라인임. → 최고 커트라인이 3670만원인데 이는 30년 8개월간 납입한 금액임. 30년은 탈락함. 올해 아파트 거래 100건 중 28건이 ‘외지인’ → 퇴지금까지 정산 받아 집을 산 사람도 있음. 투기 수요자도 있고, 서울 집값을 감당 못하고 인천,경기로 내려오는 사람들이 많아짐 전능동 일대, 주택 1,122가구 공급 은평구 옛 기자촌엔 예술마을 조성 → 관심이 없어서 pass.. 대도시권 교통망에 1조 쏟는다. → 서울 7호선 청라연장 등 교통망 확층 예산이 26.6% 증가하여 1조원을 넘음. → 철도.도로 분야 광역.도시철도 사업 12개, 광역.혼잡도로 23개 사업 등 9288억원 반영 → 청라연장, 서울 9호선 4단계연장, 동북선경전철, 광주도시철도2호선, 양산도시철도 등이 편성 → 광역버스, 광역BRT, 환승센터 및 알뜰교통카드 등이 서비스 개선 비용으로 책정. “밀리면 끝장”… 삼성, TSMC, 인텔, 시스템반도체에 400조 투자 → 반도체 3사가 돈을 쏟아부으면서 경쟁을 심화시키고 있다는 기사 → 삼전은 133조 원을 투자하겠다했는데 38조를 더해 171조 원으로 투자할 것. → TSMC도 미국 애리조나주에 4년간 110조 원 이상을 쏟아붓기로 함. → 인텔은 10년간 100조 원을 들여 두 개의 반도체 공장을 유럽에 짓겠다고 함. 애플카 프로젝트 총책임자 포드로 되돌아간 까닭은? → 포드. 테슬라 거쳐 애플로 옮긴 더그 필드 부사장 다시 포드로 → 이러한 결정은 전기차에 대한 애플의 야망에 충격을 줬겠다는 사람들의 평가 디즈니+ 11월 12일 상륙 … 넷플 떨고 있니 → 디지니+가 11월 12일 한국에 상륙한다. → 어벤져스, 스타웢, 겨울왕국 등 막강한 오리지널 콘텐츠로 무장한 디즈니+의 한국 출시일이 정해지면서 국내 시장 1위 넷플릭스는 물론 국내 OTT서비스 업체들의 경쟁이 치열해질 듯. → 디즈니+의 매달 구독료는 9900원 또는 연 9만9000원으로 정해졌다. → 국내 IPTV 파트너기업도 곧 결정될 것임. " }, { "title": "Java버전 바꾸기, 업그레이드", "url": "/posts/JavaToy01/", "categories": "Java", "tags": "JAVA", "date": "2021-09-09 01:34:50 +0900", "snippet": "Spring 스터디를 하기 전에 JAVA 버전을 맞춰야할 일이 있어서JAVA 11버전을 16버전으로 바꿔야했습니다.찾아보니 JAVA에 OpenJDK랑 OracleJDK랑 라이센스 차이가 있고, 그냥 맘편하게 OpenJDK를 쓰기로 했습니다.구글에 “OpenJDK download”를 검색하면 되는데,https://openjdk.java.net/에서 다운받으면 됩니다.압축 파일로 받고, 기존에 자바 11버전이 있던 곳에 들어가서 일단 모르니까 같이 두었습니다.옛날에도 나는 OpenJDK를 받았었나보다. 아마 Oracle받은 사람은 다른 곳에 저장되어 있을 것 같네요.이제 간단합니다.일단 jdk-16.0.2를 복사해놓고 환경변수만 바꿔주면 됩니다.JAVA_HOME 부분만 저렇게 복사해둔것으로 바꿔주면 끝저는 인텔리제이를 쓰므로, 인텔리제이 cmd창에서java --version을 통해 버전을 확인하겠습니다.성공!" }, { "title": "2021.09.04(토).경제 정리노트", "url": "/posts/economy0904/", "categories": "Economy, DailyNote", "tags": "Economy", "date": "2021-09-04 01:50:50 +0900", "snippet": "2021.09.04 경제 헤드라인을 정리한 글입니다.부동산 관련, 청약 관련글에 대해서는 따로 정리하지 않습니다. 기업 임금 인상 속 고용지표 저조 … 델타변이가 변수될 듯 → 미국의 주요 식품. 소매 기업 등을 중신으로 임금 인상 움직임이 거셈. → 월마트는 시급 11달러에서 12달러로 인상, 패스트푸드 업체들도 15 → 16달러로 인상함. → 금융 및 항공까지 전업종으로 확산되고 있음. 구인난 때문임. → 기사에 왜 이런 현상이 발생했는 지 찾지 못했음. 내 예상으로는 아마 델타변이 확산 우려때문에 대면및 시장성이 떨어지는 기업에 구인을 하지 않는듯.? ‘가계부채 해소’ 공조 다진 이주열. 고승범… 추가 금리인상 더 앞당겨지나 → 고승범” 자산가격 과열 선제 관리”, 이주열 “ 취약부문 지원 노력 강화” → 둘이 첫 만남에서 1,800조 원이 넘는 가계부채 등 금융 불균형 문제에 공동 대응하기로 의기투합함. → 경기회복에도 취역 부문에 어려움은 계속 되고 있어 이를 타깃으로 하는 지원 정책도 지속될 필요가 있다고 함. 260조 빚 짊어진 2030, 부채 연소득 두 배 넘어 ‘시한폭탄’ → 빚을 내면서 주식을 투자하고 아파트 사고 등 관련된 내용. → 신규 가계대출 58% 30대이하이고, 부동산 매입 비중도 37%로 최다이다. → 개인적인 생각으로 빚내면서 주식 투자하는건 아니라고 보지만, 부동산 매매는 현명한 선택이 아닐까 싶기도.. MZ세대 1인당 신용융자 6287만원, 반대매매 공포에 떨어 → 신용융자 : 증권사가 주식 매매 비용을 대출해주는 것 → 1년 반만에 차주 수가 2배(5만명)으로 늘고, 증권사에서 빌린 돈 역시 4506만원에서 6287만원으로 늘음. → 반대매매 : 빌린 돈을 약정한 만기까지 갚지 못할 경우, 고객의 의사와 상관없이 그 보유 주식을 증권사가 강제로 매도 처분해 대출을 회수하는 것을 말함. → 이 반대매매가 늘어나고 있다는 기사. → 또한, 신용공여 등을 증권사에 속속 중단하고 있음. 신용공여 한도가 소진되어 따른 조치라는 것. 한국투자증권, NH투자증권, 미래에셋,대신, DB금융투자 등이 중단한 바가 있음. 대출 금리 인상 본격화 … ‘빚투’족 상환 부담 가중 → 금리 연내 0.25%P 추가 인상 무게 ‘마통’ 신용대출 앱서 5분이며 OK, 핀테크 경쟁이 대출 키워 → 이제 마이너스통장을 앱에서 5분이면 개설가능하다는 것을 말함. → 그에 따른 우려도 많다. 일단, 2017년에 비해 2030 마통 개설률이 36%가 증가했고 마통이 계속 늘어나고 있음. → 뿐만 아니라 신용융자 서비스도 늘어나고 있다. 4번 기사랑 비슷한 내용 빚 내역 파악, 연체되거나 상환기간 짧은 것부터 갚아야 → 빚을 갚아야할 때 우선순위를 알려주는 기사 코스피 PER 높고 반도체. 원화 약세 … 한국 증시 매력 저하 → 외국인들이 왜 계속 우리나라 주식을 파는 지에 분석하는 기사→ 외국인이 봤을 때 매력이 없다는 점. 미국의 아마존, 애플 등 플랫폼 기업이 국내에 있는 카카오, 네이버보다는 훨 강력하기 때문이다. 또한, 반도체 주가가 하락하면서 경기둔화 우려 때문에 위축된 것.→ 환율도 영향을 미쳤을텐데, 원화 가치가 하락할때 달러로 바꾸려고 매도하는 외국인 투자자가 많다는 것. 실제로 수출이 지난해 같은 기간에 비해 30% 이상 늘었지만, 무역수지 흑자가 줄었음. 외국인이 주식을 내다 팔면서 그만큼 달러가 빠져나간 것. ‘MZ 개미’ 늘며 접속량 30% 쑥 … 해외주식, 공매도 정보 ‘광클’ → ‘세이브로’ 라는 증권정보 홈페이지가 있는데, 그 홈페이지 뷰(사용자가 홈페이지를 들어간 횟수)가 8월이지만 작년 횟수의 75%를 달성함. 그만큼 사람들이 많이 본다는 얘기 → 지난해부터 대거 유입된 MZ세대 투자자들의 중심으로 정보 활용도가 높아진 것이 주 원인으로 보임. 기존에는 금융, 언론, 회계, 정부, 정책 기관 등이 주 사용자였는데 직접 투자하기로한 개인투자자들의 비중이 늘어났기에 발생한 일이라는 분석. ‘애플카’ 이번엔 진짜? … LG전자 10% 쑥 → 애플이 협력사 후보군 접촉에 나서자 LG그룹이 제일 유망해지면서 계열사와 함께 주식이 상승함. LG전자는 10%, 이노텍 6%, 화학 1% 등.. → LG가 주목받는 이유는 캐나다 전장 부품 업체 마그나인터내셔녈과 합작 법인인 LG마그나 이파워트레인이 전기차 생산에 필요한 모터, 인버터 등 파워트레인 부품과 구동시스템을 개발하는 핵심 역량을 갖췄기 때문. SK케미칼, 中 재활용 업체에 투자 … LG는 GM과 ‘리사이클’ 협력 → 폐(廢) 경제에 기업들이 눈을 돌리고 있음. → 재활용 기술이 진화하고 있다. 플라스틱을 완전히 분해해 원료 상태로 되돌리는 화학적 재활용을 시도하고 있음. → 폐배터리의 자원 순환 역시 친환경 사업으로 조명 받고 있음. 전기차 수소차 등 친환경 자동차 보급이 확대 되면서 수명을 다한 폐배터리들이 쏟아져 나올 것으로 관측. 때문에 LG에솔은 GM과 함게 합작법인 ‘얼티엄셀즈’를 통해 폐배터리의 코발트,니켈, 리튬 등 다양한 배터리 원재료를 재활용할 예정. SK, 태영부터 대형 PEF까지 달아오르는 ‘KG ETS 인수전’ → KGETS라는 기업이 매각을 진행하기로 하였는데 여러 기업들이 폐기물사업에 눈을 돌리면서 인수에 총력전을 다하는 중. → KGETS는 폐기물 처리 사업부분에서 인정받는 기업임. → 태영그룹은 환경 사업에서 업계 1위로 평가받는데, KGETS의 폐기물 사업을 사들여 소각 분야로도 사업 지평을 넓히기 위해 인수전을 준비 중임. 수처리 시장에서 2위, 매립 시장 분야에서는 1위여서 소각 분야까지 확보하면 폐기물 사업 전 분야에서 위상을 굳힐 수 있기 때문. → SK에코플랜트는 EMC홀딩스라는 환경 폐기물 업체를 1조에 인수한 뒤 폐기물 업체들을 무서운 기세로 사들이면서 업계 1위를 넘보고 있음. → PEF 중에서는 IMM인베스트먼트, E&amp;amp;F PE가 관심을 가지는 중. → KGETS는 경기도 시흥에 사업장이 있고, 수요가 가장 많은 수도권을 대상으로 함. 처리 기술도 인정받으면서 처리 단가가 업계 평균보다 2배 이상 높음. 온실가스 줄이기 나선 LG엔솔 협력사 ‘RE100’ 전환 돕는다 → LG에솔이 협력사와 함께 ‘재생에너지 100% 사용(RE 100)’ 전환에 적극적으로 나설 듯. → ‘RE100 온라인 설명회’를 개최하여 동향, 공급망 재생에너지 전환 목표, 조달 방안 등을 공유하고 협력 회사들의 적극적인 협조를 당부했음. → 배터리 제조 과정에서 나오는 상당 부분의 온실가스는 배터리 소재인 양극재, 음극재, 분리막 등을 생산하는 과정에서 발생하기 대문인데 이를 우선적으로 전환하고 나머지 소재에 대해서는 2030년까지 순차적으로 전환할 수 있도록 지원해나갈 계획이라고 밝힘. 고효율 SiC 기반… 연비 10% 향상 기대 → 현차가 ‘전력 반도체’를 내재화했음. 이는 인피니언에 전량 의존해왔던 기술을 내재화했다는 점에서 의미가 큼. 기술 장벽이 높고 국가적으로 전략 기술로 생각되기 때문에 소수의 선진국 기업들만 독점하고 있는 구도. → 이를 통해서 전략물자로 부상한 차량용 반도체 품귀 현상이 조금이나마 해소되지 않을까 기대하고 있다. 현대重그룹, 암모니아 추진선 상용화 앞당긴다 → 현대중공업 그룹이 암모니아 연료 공급 시스템 개발에 성공. → 항해 중에 자연 발생하는 암모니아 증발 가스를 활용해 배기가스 내 질소산화물을 제거하고 잔여 증발가스는 엔진 연료로 사용함. 이를 통해 암모니아 추진선은 환경규제를 충족할 수 있는 선박으로 평가받고 있음. → 암모니아는 분자 구조상 질소를 포함하고 있어 유해물질인 질소산화물이 배출된다는 것이 문제였는데, 현대중공업이 질소산화물을 크게 저감해 IMO 규제를 충족할 수 있게 되었음. → IMO규제 : 2050년까지 이산화탄소 배출량을 70%까지 저감해야 하는 국제해사기구의 환경 규제 SK지오센트릭, 초소형 전기차용 경량화 소재 개발 → 쎄브모빌리티와 공동 추진함. 경향화 소재 개발을 위한 업무협약을 체결했다고 밝힘. → 국내 초소형 전기차 업계 1위인 쎄보 모빌리티. 이번 협약을 통해 기존 승용차, 상용차 경량화 솔루션에 더해 초소형 전기차 등 경량화 소재 적용 대상을 확대해나갈 계획. 더 멀어진 ‘인서울 내집마련’ … 한 푼 안쓰고 18.5년 모아야 금리 인상, 대출 규제에도… 아파트 ‘사자’ 심리 더 커져 → 일제히 하락했던 전국, 수도권, 서울의 아파트 매수 심리가 한 주만에 다시 반등했음. 수도권 상위 20% 집값 15억 돌파 文정부 출범 이후 2배나 뛰었다. 국민銀, 주담대. 전세대출 금리 동시 인상 → 국민은행이 3일 주담대와 전세자금대출 변동금리를 0.15% 포인트 인상했음. → 농협은행이 일부 신규 가계담보대출 취급을 11월30일까지 중단하자 ‘풍선효과’로 수요가 쏠릴 것을 대비해 내놓은 조치. 보광아파트 재건축심의 통과 구로동 ‘신축 단지’ 물꼬트나 → 340가구서 675가구로 탈바꿈 2004년 이후 신축대단지 없어 대출규제 비켜간 아산, 미분양 속속 완판 → 다주택자도 대출이 된다는 소식에 아산의 미분양 아파트를 분양받아 매물이 사라지는 중. → 또한, 아산은 비규제지역으로 2년 후에 매도할 때 양도소득세 증과가 없다는 것도 장점. 그 결과 이곳은 3 ~ 4개월 만에 미분양 물량이 빠르게 소진되었음. 외지인들이 싹 쓸어가니까 요즘 다시 현지이들이 찾기 시작함. 임대료 못받아도 시세차익 기대에 경매 몰려 → 코로나로 인해 여러 빈 상가들이 경매 시장에 나왔음. → 시세보다 낮게 사려는 수요가 몰린 결과로 감정가가 3200만원 이었던 상가 한 건이 결국 5200만원에 낙찰됨. → 현재 서울 상가 경매 낙차가율은 7월 78%에서 124%로 뜀. 그리고 상가 공시률(빈 집) 올라가고 있음. 美북동부 강타한 허리케인 … “하늘서 나이아가라 폭포 쏟아졌다” → 지구 온난화 탓에 습기 더 품어, 허리케인 강우량 훨씬 많아져, 기후위기 선진국도 예외 아냐, ‘아이다’ 지역에 133년 만의 기록적 폭우 뉴욕 등 4개주서 40여명 사망. 트럼프 ‘IS 궤멸 선언’ 2년만에 IS-K 활개 … ‘외로운 늑대’ 잠깨 → 외로운 늑대란, IS일원은 아니지만 극단적인 믿음으로 인해 테러를 일으키는 사람들을 말함. → IS와 탈레반, 알카에다의 역사와 비교를 해가나는 기사. 소비자 : “중개보수 더 내려야”, 중개업체 : “거래 없는데 숨통 조여” 식지 않는 불만 → 자주 다뤘던 기사 내용. 반값 복비라더니… 지역따라 몇백만원 더 낼수있다. → 정부가 부동산 개정안에 ‘수수료 0.1% 가감 가능’을 지자체에 판단할 수 있게 떠넘겨버림. → 이로인해서 지역에 따라 같은 아파트가격인데 수수료를 더 비싸게 내는 사람이 발생할 수 있다는 것. → 이러한 조항을 추가한 이유는 공인중개사업계가 수수료 인하인에 강력히 반발하자 내놓은 추가조항이라고 판단. → 한편 일부 부동산업체는 정부 개편과 별개로 중개수수료 인하 경쟁에 나서고 있어 ‘반값 수수료’ 서비스를 제공하는 ‘다윈중개’ 플랫폼은 정부 상한 0.7%의 절반인 0.35%의 고정 수수료를 받는다고 함. 부동산중개 앱, 수수료 반값에 VR로 매물 구석구석 확인… 중개사협회는 반발 → 프롭테크가 활발해지면서 나오는 갈등. → 공인중개사는 “골목상권 침범”이라면서 반발하고 있음. " }, { "title": "2021.09.02(목).경제 정리노트", "url": "/posts/economy0902/", "categories": "Economy, DailyNote", "tags": "Economy", "date": "2021-09-02 02:50:50 +0900", "snippet": "2021.09.02 경제 헤드라인을 정리한 글입니다.부동산 관련, 청약 관련글에 대해서는 따로 정리하지 않습니다. “일단 받고 보자” 8월 은행 주담대 4兆 늘어 → 대출을 받을 수 있을 때 받자며, 사람들이 몰리고 있음. → 마이너스 통장도 신규개설이 65% 늘음. 월별 증가폭으로는 8월이 최대치를 찍음. 유로존 물가 3% 상승 … 10년 만에 ‘최고’ → 에너지가격이 1년 전보다 15% 치솟은게 원인으로 분석되고 있다. → 전문가들은 인플레이션이 일시적인 현상이라고 분석하고 있음. 코로나가 끝나면 되돌아갈 것으로 예상하고 있음. 강남구 평균 전셋값 3.3$m^2$당 4000만원 넘었다. → 4년만에 60% 가까이 급등함. 은마아파트는 1년새 5.2억에서 10.5억으로 전세값이 뜀. 가평 첫 힐스테이트 아파트 이달 분양 건보료 이어 고용보험료까지 … 국민 부담 가중 → 세금과 사회보험료가 계속 오르고 있음. → 정부는 조세 부담과 준조세 부담의 GDP 대비 비중을 나타내는 국민 부담률을 28.6%로 제시. 올해 예상치인 27.9% 보다 높음. → 이러한 상승세는 세계 최고 수준임. → 한국의 국민 부담률은 5년 만에 3.7% 상승했는데, OECD 평균인 0.5%의 7배 → 법인세 상승과 사회보험료 인상이 국민 부담률을 높이는 원인으로 지목되고 있음. → 사회보험료 상승은 코로나19 최저임금 인상 등과 맞물려 소상공인 자영업자 고용 감소로 이어짐. 강남구 아파트 전셋값, 임대차법후 2억원 올라 → 3번기사와 같은 내용. 아파트 매수, 30대가 ‘큰손’ 수도권. 대전. 부산 40대 추월 → 수도권과 부산 등 일부 광역시에서 30대가 아파트 매수의 큰손으로 자리잡히는 중. → 위 세 지역은 30대가 40대의 주택 매매량을 추월함. → 대전은 9.8%, 부산 및 울산 8.6% 5.4% 상승함. 가상화폐 거래소 코인빗 원화입출금 서비스 중단. → 실명계좌가 없는 코인빗은 신한은행 법인계좌를 사용했는데, 은행이 이를 금지했음. 때문에 중단되었음. 규제 풍선효과 … 생확숙박시설도 웃돈 1억 → 마곡 롯데 르웨스트에 대한 이야기 → 그곳은 ‘주거금지’이지만 ‘생활숙박시설’이다. → 생활숙박시설 : &amp;lt;https://m.blog.naver.com/veatles/221295833906&amp;gt; → 청약통장 없이 당첨이 가능한 주거상품으로 알려지면서 + 계약 즉시 전매가 가능한 점으로 대혼란이 옴 사려는 사람, 팔려는 사람, 이 둘을 연결해주려는 사람으로 난리통이다. 이번주 들어온다던 모더나 600만회분… 나흘 남았는데 아직도 ‘미정’ → 모더나가 들어오지 않고 있다. 구체적인 일정이 여전히 확정되지 않은 상태. → 모더나 백신 공급에 또 다시 차질이 생기면 ‘추석 연휴 전 전국민의 70% 1차 접종 완료’ 목표도 불가능해짐. 인천 계양 85$m^2$, 20년 부어야 당첨 → 3기신도시 첫 사전청약 결과이다. → 사전청약을 실시한 인천 등의 수도권 공공택지에서 일반공급 당천선이 평균 1945만원 수준인걸로 나타남. → 그 중 인천계양은 30평 기준 당첨선이 2400만원임. → 최대 납임 인정액이 월 10만인걸 감안하면 거의 20년동안 청약통장에 예금을 넣어야한다는 소리. 6년 만에 재개발 신규 지정 … 서울시, 이달말 공모 → 25곳 2만6000가구 후보지 선정함. → 서울에 노후화, 슬럼화로 주거환경 개선이 시급한 지역을 기준으로 후보지를 선정할 계획. → 투기방지 대책도 마련해 놓았다. 재개발구역 후보지를 공모할 때 공모 공고일이 ‘권리산정 기준일’이 된다. (이게 왜 대책인지는 모름) 카뱅. 크래프톤, 내주 코스피 200 편입 앞두고 강세 → 카뱅, 크래프톤이 코스피200에 편입될 듯. 하지만 이는 이미 사람들의 기대가 주가에 영향을 미친 결과일 수 있으니 투자에 신중하란 말. 남양유업 매각 파기 … ‘洪회장 “독단”이 혼란 키웠다. → 남양유업 홍회장이 남양유업 매각 계약을 파기함. → 홍회장은 회사를 독단적으로 운영하는 것으로 유명함. 두 아들조차 남양유업이 매각된다는 사실을 뉴스에서 접했음. → 홍회장 : “매수자가 경영 간섭, 비밀 유지 의무도 위배” 라고 주장 → 한앤코(매수회사) : “터무니 없는 얘기, 홍회장이 가격 재협상 등 수용하기 곤란한 사항들을 ‘부탁’이라며 말함” → 7월 임시주주총회 때 홍회장이 나타나지 않고, 예고없이 날짜를 연기하자 계약이 파기되었다는 소리가 나오기 시작. → M&amp;amp;A 계약은 계약 이행의 상세 조건과 계약 파기 시 손해배상 등에 관한 내용을 아주 상세하게 적는다. → 홍회장이 너무 싸게 팔았다라는 말만 듣고 무리수를 두는 것 같다는 전문가들의 의견 “S&amp;amp;P500지수, 내년 말 5000 돌파” → 2020년 3월 2237, 2021년 8월30일 4528 → 잭슨홀미팅에서 테이퍼링을 시사하면서도 금리 인상은 즉각적으로 이뤄지진 않을것이라며 이것이 S&amp;amp;P가 상승할 수 있는 원인이 될 수 있다는 것. “내년초 3800 간다” … KB증권 ‘눈길’ → ‘삼성전자.하이브.휴젤 등 유망’ → KB증권이 분석한 내용. 궁금하면 찾아보셔요. “탈중앙화된 금융 생태계가 블록체인의 미래” → 두나무라는 업비트를 운영하는 회사가 ‘업비트 개발자 콘퍼런스 2021’을 진행했음. → NFT와 디파이에 대한 얘기를 하며 향후 시장을 움직일 것이다라고 함. → NFT : 디지털 그림이나 음악을 블록체인 기술로 유동화한 것. → 디파이 : 블록체인 네트워크 안에서 가상화폐를 담보로 한 예금,대출 등 금융서비스 사전청약 당첨 최저점 평균 1945만원 → 11번 기사와 비슷한 내용. 美 집값 1년새 19% ‘역대급 폭등’ → 미국 주택 가격이 오르고 있다. 왜냐하면 재택근무가 많아지면서 교외로 이사하려는 사람들이 많아졌음. 이로 인해서 건축자재 부족, 노동력 부족, 목재 가격 상승 등이 겹치면서 주택가격을 올려버림. → 월스트리트저널은 백악관이 집값 및 임대료 상승 등을 억제하기 위해 주택 공급 대책을 마련하고 있다고 보도. → 주택 공급을 늘리기 위해 지경개발금융기관(CDFI)에 대한 기존 보조금 프로그램을 확대하는 방안과 국책 모기지 보증기관의 임대 아파트 투자를 늘리는 방안 등이 논의되고 있음. 용산역 일대 재개발 ‘속도’ … 1구역 조합인가 → 정리하기 어려워서.. 찾아보시는걸 권장합니다 2분기 부동산업 대출 12조 증가 … 사상 최대 → 임대업 등 상업용 투자 증강 전분기 증가액 대비 5兆 늘어 공정위 “IT 대기업 지배구조 집중 감시” → 지분출자. 경영승계 등 견제 → 작년까지 업종별 현황을 굳이 분류해 발표하지 않았던 공정위는 올해 처음으로 IT 업종의 현황만을 따로 분류해 공개함 → 총수 2세가 지분을 보유한 IT 업종 기업집단이 작년에 넥슨 한 곳뿐이었는데, 올해는 카카오가 추가되었다는 내용. → 성경제 공정위 기업집단정책과장은 “IT기업집단의 외형이 커지면서 앞으로 승계 작업이 진행될 가능성이 있다”며 앞으로 IT기업집단에 대해 공정위가 보다 관심을 갖고 지분구조를 들여다보겠다는 의미를 전달하려는 의도”라고 말함. 혈세로 갚아야 할 나랏빚만 700조 → 국가 채무가 너무 가빠르고, 채무의 질(質)도 악화되고 있다는 내용. 2017년 말 600조에서 현재는 1068조 한 정권서 고용보험료 두차례 인상은 처음 … 사실상 증세 ‘부메랑’ → 고용보험료가 올라감. 정부는 코로나 탓이라고 하지만, 시민과 전문가의 입장은 다름 → 시민과 전문가는 선심성 실업급여 사업에 남발했다고 지적하고, 그런 대책없는 관리때문에 사업주와 근무자에게 부담을 주는거 아니냐며 비판. → 인상 안하면 2023년에는 기금이 고갈될 것임. 2017년 시작할 때는 규모가 45억원 사업이 1조 4500억까지 사업이 커지면서 기금을 계속 쓰고 있는 듯. 올 1억 코스피 투자 수익 900만원 韓,美 유럽 분산했다면 1550만원 → 나스닥이 꾸준히 상승함에 따라 주가가 올라가는 것을 말하는 것. → 중국은 불안하다는 전문가의 입장. 미국과의 패권전쟁을 통해 투자자들의 투자심리 위축이 요인. → 분산투자에 대한 장점을 쓴 기사 줌, 펠로톤, 핀터레스트 급락 코로나 수혜株조정 시작됐다. → 줌 : 다수의 사람들과 화상통화 가능한 서비스 → 펠로톤 : 홈트레이닝 업체 → 핀터레스트 : 요리법과 공예 관련 시각 자료 공유하는 서비스 업체 → 줌은 최대 400%까지 주가가 상승하였지만, 백신접종 및 대면만남이 많아지면서 매출이 떨어짐. 이로 인해서 주가도 하락하고 있다. → 줌은 개인 이용자, 10인 이하 소규모 기업 고객 부문의 실적이 많이 줄음. → 펠로톤, 핀터레스트와 같은 ‘집콕주’가 약세를 보이고 있다. ‘밑빠진 사회보험’에 세금 19兆 … 나라 곳간 축내는 퍼주기 복지 → 이해 못했습니다. ㅠ 증시 ‘찬바람’ 솔솔 … 일찍 온 배당주의 계절 → 배당주 주식 추천하는 기사 " }, { "title": "leetcode(리트코드)-565 Array Nesting(PYTHON)", "url": "/posts/leetcode_Array_Nesting/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-09-02 01:34:50 +0900", "snippet": "leetcode 565 - Array Nesting 문제입니다.1. 문제https://leetcode.com/problems/array-nesting/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.4. 문제 해석 nums가 주어집니다. 해당 인덱스의 요소로 점프할 수 있다고 할 때 그렇게해서 만들어진 배열의 길이가 가장 긴 배열을 리턴하세요.5. codepython class Solution: def arrayNesting(self, nums: List[int]) -&amp;gt; int: res = 0 def solution(idx,nums,count) -&amp;gt; int: if nums[idx] == -1 : return count - 1 nxtidx = nums[idx] nums[idx] = - 1 return solution(nxtidx,nums,count+1) for idx,num in enumerate(nums) : count = 0 if nums[idx] == -1 : continue tmpcount = solution(idx,nums,count+1) res = max(tmpcount,res) return res 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "2021.09.01(수).경제 정리노트", "url": "/posts/economy0901/", "categories": "Economy, DailyNote", "tags": "Economy", "date": "2021-09-01 01:50:50 +0900", "snippet": "2021.09.01 경제 헤드라인을 정리한 글입니다.부동산 관련, 청약 관련글에 대해서는 따로 정리하지 않습니다. “비트코인, 내달 중순까지 상승여력 … 美 테이퍼링, 규제가 변수” → 비트코인 점유율 하락하면 상승장 ‘끝물’로 해석하지만 40%까지 밀리면 재반 등 전망이 있음. → 언제나 그렇듯 낙관론과 비관론이 있음. 연말까지 10만달러까지 오른다 vs 2만달러까지 떨어질 수도 있다. 쌓이는 ‘카드 포인트’로 주식. 금. 미술품에 투자하세요. → 카드 포인트가 남을경우 주식이나 금 미술품에 투자할 수 있는 서비스가 생김. → 신한카드의 경우 ‘해외주시 스타백서비스’를 활용해 해외주식을 ‘소수점 단위’로 매수하는 데 쓸 수 있음. → 하나카드를 쓰면 적립되는 ‘하나머니’로는 금 투자가 가능해짐. 최소 0.0001g단위로 살 수 있음. 또한, 한정판 운동화나 미술품도 살 수 있음. → 비씨카드는 ‘페이북’에 출석한 횟수에 따라 미국 주식 매입 쿠폰을 최대 2만원까지 제공하는 이벤트를 한 달간 진행함. ‘발등에 불’ 코인거래소 … 트래블 룰 합작법인 출범 → 국내 2, 3, 4위 암호화폐거래소인 빗썸. 코인원. 코빗이 거래소 신고기한을 3주 앞두고 ‘트래블 룰’에 대응하기 위해 합작법인 CODE를 만듬. 자본금은 총 9억원으로 3사가 각각 3분의1씩 내고 의결권도 3분의1씩 가짐. → 대표는 2년씩 돌아가면서 할텐데 현재는 코인원대표가 맡을 것. → 익명으로 암호화폐를 주고받으며 범죄자금을 숨기는 사례가 늘자 이를 잡아내기 위한 취지로 만들어진 ‘트래블 룰’ → CODE는 업비트까지 참여하여 출범할 예정이었지만, 업비트가 돌연 하차를 해버려서 설립 논의가 길어진 것 같다는 입장이 나오는중. → 트래블 룰 감독 유예기간이여도 자금세탁 관련 범죄가 발생하면 은행이 법적 책임을 져야하기 때문에 트래블 룰이 실명계좌 발급보다 선행되어야하는 문제임. 파주 운정신도시에 내달 ‘힐스테이트’ 주거복합단지 → 현대건설이 49층 랜드마크를 조성함. 아파트 744실, 오피스텔 2669실 정부 규제에 대출도 ‘사재기’ … “내년 쓸돈까지 미리 빌린다” → 대출규제로 인해서 돈을 쓸데는 없지만 대출을 미리 받는 사람들이 생겨나고 있음. 반도건설, 양천구 재건축 사업 수주 카톡으로 ‘보험 선물하기’ 내놓은 보험사들 → DB손보, 카카오 전용 암보험을 출시함. 다른 보험사들도 ‘보험 선물하기’ 등 카카오 플랫폼을 활용한 서비스를 줄줄이 내놓고 있다. → 보험 가입 전 과정을 카카오페이 내에서 진행할 수 있도록 한 것이 특징. → 삼성화재와 현대해상은 모바일 보험 상품권을 카카오톡 선물하기 코너에 선보임. → 기존에는 보험상품을 온라인 쇼핑 플랫폼에서 판매하는 것이 금지되어 있었지만, 지난해 하반기 금융위가 ‘혁신금융서비스’로 지정하면서 가능해짐. → 보험사의 생존때문이지만, 빅테크 기업이 데이터를 축적해서 자체적으로 출범할 수 있다는 것에 경계를 두어야한다는 비판도 나오고 있음. “없애라, 줄여라”해도 … 여전한 20兆 ‘좀비세금’ → 감사원이 부담금 부과에 대해 실태조사를 해봤음. → 조사해본 결과 과밀, 학교부담금 등 18건이 위법사항임. → 또한, 폐지 권고 및 징수액을 줄이라고 권고했는데도 뻐팅기는 겨우가 있음. → 재정 운용에 타격을 받을 것이라는 우려 때문이라고 입장을 밝히는 곳도 있음. 음식.숙박업 4차 대유행 ‘직격탄’ 7월에만 종사자 6.4만명 줄었다. → 업종 전체론 27만여명 늘었지만 대부분이 일용직 등이다. → 코로나19가 확산하기 시작한 지난해 2월부터 18개월째 감소세를 면치 못하고 있다. → 임시 일용근로자는 19만명(11%)가 늘어 전체 종사자 증가세를 이끌음. LG화학 넘은 삼성SDI … ‘배터리 대장株’ 교체 → 삼성SDI가 3.9% 올라 시총 54.5조를 찍고 배터리 1등 LG를 제침. 전체 시총은 6위(삼전 우선주 제외) → 2007년 이후로 처음으로 역전하였고, 이유는 미국에 공장을 증설한다는 이야기와 LG화학의 배터리 폭발사건이 큰 듯. 삼성SDI 주가는 꾸준히 오르고 LG화학의 주가는 내려가고 있음. → 또한, 증권업계 관계자는 “LG화학과 SK이노에 투자한 주주 대부분이 배터리 성장성을 보고 들어온 것라서 물적분할은 주가에 악재가 될 수밖에 없다”고 실망. → 두 회사와 달리 삼성SDI는 순수 배터리 회사여서 이런 우려가 없음. 미래에셋 ETF 순자산 20조원 돌파 → 점유율 31.6%… 삼성운용 맹추격 2차전지. 반도체 등 테마형 흥행 → ETF 시장 점유율 1위는 삼성자산 운용의 KODEX ETF로 45.2%임. 28조6520억원. 최근에 감소세를 보이고 있다. 원래는 50%를 넘겼었음. → 그렇기에 미래에셋 자산운용이 바짝 뒤쫓고 있음. → 미래에셋이 2차전지, 전기차 등 테마형 ETF를 잇따라 흥행시킨 것이 상승으로 이어진 듯. 종부세 기준 11억으로 상향 … 수술실 CCTV 의무화 → 올해부터 공시가격 11억원 이하 주택을 보유한 1주택자는 종합부동산세를 내지 않게 됨. → 또한, 병원 수술실 내부에는 폐쇄회로TV(CCTV)설치가 의무화되었다. ‘소규모주택정비’ 2차 전국 확대 → 국토부가 전국 자자체 대상으로 소규모주택정비 관리지역 2차 후보지를 공모한다고 밝힘. → 소규모주택정비 관리지역 : 신축,노후 건축물이 섞여 있어 대규모 정비가 어려운 저층 주거지역을 체계적으로 정비하기 위한 사업. → 관리지역으로 지정되면 정비사업 요건 완화, 용적률 상향 등 건축 특례를 받을 수 있음. 또한, 150억원 규모의 기반시설 지원도 해줌. 3 ~ 6개월짜리 단기 예.적금 추천 … 금리 年5 ~ 10% 특판상품 공략도 → 예적금 금리가 올라가는중. 하지만 아직 ‘쥐꼬리’만함 → 5~10% 이자를 주는 적금도 생기고 있는데, 다양한 조건을 만족하면 최대 10%이다. KB저축은행, 우리종합금융, 수협은행, 케이뱅크 등에서 진행중이니 찾아보실 분은 찾아봅시다. 반년 만에 1兆 이상 산 외국인 코스피, 3200 턱밑까지 회복 → 반도체 우려 완화… 삼성전자 급등 원.달러 환율 급락도 영향 → 외국인이 유가시장에서 1조1700억원어치를 매수했음. → 대만 TSMC의 가격 인상 소식에 반도체 업황 우려가 누그러지면서 삼전을 쓸어담았음. 韓 2035년 부담할 탄소국경세 4700억원 → 탄소국경세 : EU 역내에서 생산된 제품보다 탄소배출량이 더 많은 수입품에 부과하는 관세 → 유럽의 환경정책 싱크탱크 샌드백과 E3G는 한국을 비롯한 EU의 6대 주요 교역국가가 낼 탄소국경세 전망치를 담은 보고서를 발표. → 하지만 싱크탱크는 실질 부담액은 이보다 훨씬 적을 것이라고 함. 탄소국경세가 EU 소비자 가격에 전가될 가능성이 높다는 이유라서. → 반면에 미국은 미미하고, 중국도 터키, 우크라이나보다 적을 정도로 적다. 델타에도 끄떡없는 유럽 … 고용.소비 ‘활황’ → 스페인 호텔 예약률이 50%를 넘었다. 코로나19이후 처음이다. → 또한, 4개국 8월 극장 수입이 70%가 급증하면서 서비스업이 부활한거 아니냐는 것. 보험금 매년 늘지만 중도해지 땐 손실 커 → 체증형 종신보험의 불완전판매가 급증하고 있으니 조심하란 기사. → 체증형 종신보험 : 일정 기간이 경과하면 보험금이 증가하는 상품. 물가 상승으로 보장자산의 가치가 하락하는걸 방지하지만, 보험금 증가분때문에 평준형보다 비싸고, 주로 무/저 해지형으로 판매되고 있어 중도해지 땐 금전적 손실이 확대될 수 있음. 신도시급 기대 … 의왕.군포.안산 집값 ‘들석’ → 갭투자 문의 늘고 매물 끊겨 → 또한 의왕GTX 호재까지 겹쳐 아파트가격이 최대 2억원넘게 껑충했음. → 문제는 공공택지 조성이 7~10년이 걸릴 수 있고, 인프라가 잘 구축되지 않으면 이마저도 늘어날 수 있는데 지금부터 가격이 뛰기 시작한다는 것. ‘대출 갈아타기 공공 플랫폼’ 기다렸는데… 연내 도입 가물가물 → 은행권과 빅테크의 밥그릇 싸움을 하고 있음. ‘대환대출 플랫폼’ 앞날에 대한 기사 → 정부와 빅테크가 협업해서 금리가 싼 상품을 추천해주는 플랫폼을 만드려고 했다. → 하지만, 은행측에서 상품 판매 주도권을 플랫폼 회사에 빼앗길 수밖에 없다면 반대를 했고, 정보공유 반대와 신용대출만 포함시키자고 건의함. → 논의가 빅테크 위주의 플랫폼에서 은행과 빅테크 독자 플랫폼 2개로 쪼개졌다. → 은행측에서는 자체 플랫폼에서도 여러 조항을 붙여 서비스 범위를 축소하려는 움직임을 보이고 있고, 마이데이터 허가를 받은 업체에 신용정보를 공유하겠다고 했지만 속내는 전혀 그럴 생각이 없다는 것. 바닥 다지는 LG이토넥 … ‘PER 역사적 저점’ → 올 영업익 1兆 60% 증가 전망 日 경쟁사 생산차질 반사이익도 있다. → PER가 저점까지 떨어졌다는 분석이 나오고 잇음. 서울 재개발 관심지역 주택 5가구 중 2가구, 외지인이 샀다. → 도봉.구로구 등 상반기 40%가 외국인이 사들임. 내년 상속증여세 44%, 종부세 30% 늘어날 듯. → 기획재정부의 자료를 보니 2022년에 그렇게 할거라는 예상 중소 거래소 이용하고 있다면 코인.예치금 옮겨놓으세요. → 자주나오는 기사. ISMS인증, 은행 실명계좌한 업체에 옮기라는 것. 델타 충격에 … 7월 생산.소비 동반 뒷걸음질 → 7월 생산 0.5% 소비 0.6%가 줄었음. → 고강도 거리두기로 소비가 위축되었다는 전망. 환률 오를대 달러 팔자 … 달러예금 뚝 → 지난달 원.달러 환율이 치솟자 개인 및 기업 고객이 ‘팔자’에 나서면서 시중은행의 달러예금 잔액이 감소하는 모습을 보임. 몸값 낮춘 카카오페이, 10월 상장 ‘급물살’ → 공모가를 내리고 상장절차를 재개할 것임. → 따라서 공모자 기준 시총이 8000억원 가량 줄어듬(11조7300억원대) 재난지원금, 배달앱서 쓸 수 있다? → 정부는 안된다고 했지만, 실제로는 사용할 수 있다. → “지역사랑상품권 가맹점의 자체 단말기를 사용해 현장에서 결제하는 경우에는 지원금이 사용 가능하다”라고 했는데, 사실상 배달앱 주문 대부분에 적용될 수 있다는 것. → 배민원, 요기요익스프레스처럼 운영회사로 결제되는 것을 제외하고 일반 서비스를 이용하면 쓸 수 있다는 것. 다만 쿠팡은 주문 전체가 쿠팡앱에서 결제되기 때문에 쿠팡이츠는 해당되지 않는다. 국민연금, 중소형주 더 담나 → 국민연금이 5년 만에 중소형주형 국내주식 위탁운용사를 추가 선정했음. → 미래에셋자산운용 신한자산운용 한국밸류 자산운용이, 액티브 퀀트형에는 KB자산운영 트러스톤자산운용 한국투자신탁운용이 선정되었음. " }, { "title": "2021.08.31(화).경제 정리노트", "url": "/posts/economy0831/", "categories": "Economy, DailyNote", "tags": "Economy", "date": "2021-08-31 03:50:50 +0900", "snippet": "2021.08.31 경제 헤드라인을 정리한 글입니다.부동산 관련, 청약 관련글에 대해서는 따로 정리하지 않습니다. “9월도 박스피 … 경기민감株 다시 주목할 때” → 테이퍼링 가시화에 따른 증권업체들의 종목 추천 기사 GTX라인 남쪽 끝자라게 ‘여의도 두 배’ 택지 … 7만가구 들어선다 → 의왕,군포, 안산 화성진안에 가구공급을 할 예정 25만원 지원금 스타벅스, 배민선 못 써 … 연말 지나면 자동 소멸 → 재난지원금 지급이 9.7부터 시작된다. → 지급대상은 지난 6월 부과된 건보료가 기준액 17만원 이하면 받을 수 있음. 직장기입자 본인부담금 기준 2인 : 20만, 3인 : 25만, 4인 : 31만으로 완화 → 작년 재산세 과세표준이 9억원 이상이거나 금융소득이 2000만원을 넘으면 받지 못함. → 네이버, 카카오, 토스에서 확인이 가능하며 출생년도 끝자리에 따른 5부제 실시 → 기본적으로 동네마트, 전통시장 등에서 사용가능. 배민배달앱은 사용불가능하지만 가맹지점이 단말기로 직접결제하거나 지역사랑상품권 가맹점이면 사용가능. 스타벅스, 루이비통 같은 대형 외국업체는 사용 불가능. 부동산 산업 발전. 선진화 협력 개발협회, 분양협회, 양해각서 → 한국부동산개발협회가 부동산분양서비스협회와 ‘부동산 산업 발전 및 선진화를 위한 상호 협력 양해각서(MOU)를 맺음. → 개발협회에는 800여 개 디벨로퍼가 소속돼 있고, 분양협회에는 130여 개 분양마케팅회사가 가입돼 있음. → 두 기관은 이번 협약을 통해 부동산산업의 건전한 발전 및 업계 권익 향상에 협력하기로 함. 세미나 및 정책연구, 정책.제도 개선 공동 추진, 전문 분야의 상호 발전을 위한 온.오프라인 성장 및 협력모델 발굴, 공동사업 활성화를 위한 실무협력체 구성 등 ‘공공기획 재건축 1호’ 오금현대, 시작부터 삐걱 → 오금현대는 1984 준공되어 1316가구로 이루어짐. 2016년 정밀안전진단에서 D등급을 받아 재건축이 확정. → 하지만, 오금현대 비상대책위원장은 “대부분의 주민이 사전에 서울시와 송파구로부터 공공기획 관련 협의나 소식을 듣지 못했다”고 말하였고, 전체 가구의 20%가 임대주택으로 공급되는 것에 주민들이 공공기획에 반대하고 있음. 상반기 창업 73만곳 … 작년보다 9.8% ↓ → 부동산업을 제외한 기술창업기업은 증가(10%)했고, 부동산 창업은 줄음.(45%) → 신규 주택임대소득자 사업자등록이 작년보다 대폭 줄면서 부동산업의 메리트가 줄어들음. → 도.소매업은 통신판매업 등 전자상거래 분야를 중심으로(18.3%)증가 → 숙박.음심점업 창업은 1.8%, 기술창업은 5.3% 증가.전문.과학.기술업도 22.1% 늘음. 가평.여주… 수도권 비규제 지역 분양 ‘봇물’ → 홍보기사 같은데.. 전매제한 6개월이고, 대출가능, 서울접근성 개선 메리트가 있다네요. 지원금 지급 시군 내에서만 쓸수있어 대형 배달앱. 스타벅스선 사용 불가능 → 3번 기사와 같은 내용. “메타버스 ETF 테마 선점하자” 자산운용사 앞다퉈 출시 경쟁 → 기사 제목 그대로의 내용. 메타버스 시장의 성장 가능성을 본 것 같음. 의왕.군포.안산, 화성 진안에 ‘신도시’ → 2번기사와 같은 내용. 카뱅, 중저신용자 대출 한 달 새 2배 늘렸다 → 기사 그대로 “케이뱅크 몸값 최소 8조 … 과제는 여신 확대” → 케이뱅크가 저평가되고 있다는 기사. → 업비트로 인해서 가입자가 늘어났는데, 잘 유지하는 것이 관건이라는 기사 빗썸. 코인원. 코빗, 합작법인 만든다 → 신원파악 시스템을 함께 구축하여 당국 ‘트래블 룰’에 공동대응하겠다는 것으로 보임. → 트래블 룰을 준수한 합작법인을 출범할 계획. → 최근 NH농협은행이 제휴 관계인 빗썸과 코인원에 거래소 간 코인 이동을 중지할 것을 요청한 것에 대한 대응이라는 분석. → 하지만 합작법인이 트래블 룰 시스템을 시간적 제약으로 거래소 신고 기한인 다음달 24일까지 구축하지 못할 수도 있다는 것. 현대.삼성 7090억에 맡는다 → 서울 성동구 금호벽산아파트의 리모델링 사업을 수주. 별동 증축할 듯. → 입주민들은 부대시설 부족, 설비 노후화 등을 이유로 리모델링 사업설명회 시작 한 달 만에 50%가 넘는 주민 동의서를 모음. → 임시총회에서는 현걸, 삼물 컨소시엄과의 수의계약에 대해 조합원 찬반 투표를 한 결과 1132표 중 1117표 98.6% 찬성으로 두 회사를 시공사로 선정함. 신규택지 등 8곳 토지거래허가구역 지정 → 내달 5일부터 고강도 규제를 시작함. → 신규 택지 10곳 중 7곳과 과천 갈현지구 등 총 8곳의 택지와 인근지역을 토지거래허가구역으로 지정함. → 토지거래허가구역 : 토지를 거래할 때 지방자치단체의 허가를 받아야 한다. 때문에 실거주.실경영 목적으로만 토지 및 주택을 거래할 수 있음. → ‘부동산 투기근절 및 재발방지대책’ 에 따른 고강도 투기 방지대책도 시행할 것. “대선 키워드는 부동산”… 건설株, 동반 급등 → 기사제목대로 건설주식 상승했다는 얘기 연봉 5800만원 1인가구도 대상 … 신청 다음날부터 사용 → 국민지원금 얘기 3번기사와 같은 내용. 화성 ‘시리물류단지’ 사업자에 유앤미개발 → 화성도시공사가 경기 화성시 남양읍 시리 일원에 조성하는 시리물류단지 개발사업에 참여할 민간사업자 우선 협상 대상자로 유앤미개발 컨소시엄을 선정했다고 밝힘. → 나머지는 지역의 특성에 대한 이야기. “3기 신도시보다 입지 떨어져 … 서울 수요 흡수할지 의문” → 서울에서 너무 멀고, 입주까지 걸리는 기간이 너무 길어서 3기 신도시의 입지가 떨어진다는 기사. 또한, 교통 및 일자리 인프라도 공급이 더 필요하다는 입장. “신규택지 토지보상 첩첩산중 … 교통확층은 차기정부에 떠넘겨” “코인 경고는 작심발언 2030 분노는 이해한다” → 은성수 금융위원장이 퇴임하는데, 가상화폐에 대한 발언은 작심발언이라며 소신을 굽히지 않음. → “(젊은이들이) 잘못된 길로 가면 어른들이 얘기해줘야 한다”고 발언해 논란을 일으켰고 자진사퇴를 촉구하는 국민청원이 제기 돼 20만명이 넘는 찬성을 받음. 가상화폐, 결제수단으로 신뢰 떨어져… 달러화 패권 지속될 것. → 가상화폐는 불안정성이 커 적절한 규제가 있어야 널리 통용될 수 있을거라는 말. → 디지털위안화는 익명성 보장 못하고, 세계 각국에서 사용되기 어렵다고 함. → 노벨경제학상 수상자인 폴 밀그럼 교수 개통 감감한 GTX만 믿고 … 서울서 점점 멀어지는 신규택지 → 19번 기사와 같은 내용 넷플릭스 신작 ‘D.P.’ 흥행 제이콘텐트리. 키다리 ‘강세’ → 넷플릭스 오리지널 드라마 ‘D.P.’가 흥행하니까 주식이 오름. → D.P.는 탈영병을 잡는 헌병 이야기를 그린 6부작 드라마. 정해인과 구교환이 출연. → 제이콘텐트리는 지난해 5월 넷플릭스와 오리지널 드라마를 연평균 2~3편가량 공급하는 계약을 맺었는데, 첫 드라마가 흥행을 해버렸음. 그래서 관심이 커짐. 이번엔 공무원 투기 정황 없다지만 국토부,LH 직원만 조사 ‘반쪽 논란’ → 국토교통부와 LH,GH,IH의 현직 지원들만 검증대상이 되고, 다른 부처 공직자들과 국회, 지방자치단체 등에 대한 검증이 이뤄지고 있지 않음. 그리고 실거래 조사 역시 3년간 3만여 건 중 1000건만 들여다보는 데 그쳤다는 점을 감안하여 ‘반쪽짜리’ 검증이라는 비판이 제기 되고 있음. 글로벌 리츠 올해 수익률, 해외주식보다 앞섰다. → ‘아이셰어 글로벌 리츠’ 23% 상승. 글로벌 증시 ETF는 18% 기록 “임대사업자만 때려선 집값 해결 못해… 세금 혜택 부활시켜야” → 최재형 전 감사원장의 인터뷰 거꾸로 친환경 … 석탄발전 늘고 신재생 줄어 → 여름이라 석탄 발전량이 폭증해버림. 전력 예비율을 높이기 위해서다. → 3개월 전에 비해 30% 넘게 폭증해 버렸고, 신재생 에너지는 12%가 감소해버림. → 태양광 등 공급 불규칙성에 원전 정비기간이 길어진 탓도 있고, 최근 최대 석탄 소비국인 중국이 호주와의 무역 갈등으로 석탄 수입을 배제해버리면서 석탄 시장의 수급 불균형으로 이어졌다는 분석이 나오고 있음. 기술 더디고 ‘눈덩이 적자’… 비틀대는 자율주행차 → 생각보다 저조한 성과를 가진 자율주행차에 대한 기사 → 2018년 테슬라의 자율주행차는 경찰차를 박은 적 있음. 이게 자율주행차 문제인지는 밝혀지지 않음. → 미국 차량호출업체 우버와 리프트는 경영난 때문에 자율주행 부문을 매각해버림. 각각 오로라와 도요타에 넘김. → 알파벳(구글 모회사)의 자율주행차부문 계열사인 웨이모도 흔들리는 중. 2018년 1750억달러로 평가받언 회사가 지금은 300억달러 수준으로 쪼그라듬. → 상용화까지 꽤 시간이 걸릴 것 같다는 것 같다고 함. 일론 머스크는 2020년에는 무인택시가 100만대가 다닐거라 예측했었음. 현재 테슬라는 0~5단계 (4단계 이상부터 조건 아래 운전자 개입이 없음) 중 2단계 웨이모는 4단계이지만 600대 정도만 시범 운행중. 또한, ‘홀본 문제’가 가로막고 있음. 홀본 문제란 출퇴근시간에 도로에 보행자가 쏟아져 자율주행차가 움직일 수 없는 상항을 말하는 듯. → 이로 인해서 스타트업은 줄어들고 자금력 있는 대기업을 중심으로 재편될거라는 전망이 나오고 있음. 아마존, 제너럴모터스 등의 회사가 스타트업을 인수하고 있음. 앞으로 업체 간 M&amp;amp;A가 더욱 늘어날 것. " }, { "title": "Baekjoon17936-백도어", "url": "/posts/beakjoon17396/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, Dijkstra", "date": "2021-08-31 02:02:00 +0900", "snippet": "백준 사이트 17396 - 백도어 문제입니다.1. 문제https://www.acmicpc.net/problem/173962. Input , Output3. 분류 및 난이도다익스트라 문제입니다.4. 생각한 것들 다익스트라 연습하기 위해 푼 문제5. codeimport heapqimport sys input = sys.stdin.readlineinf = sys.maxsizeN,M = map(int,input().split(&#39; &#39;))sight = list(map(int,input().split(&#39; &#39;)))sight[-1] = 0 graph = [[] for i in range(N)]for i in range(M) : a,b,t = map(int,input().split()) graph[a].append((b,t)) graph[b].append((a,t))q= []heapq.heappush(q,(0,0))res = [inf] * N res[0] = 0 while q : time,curr = heapq.heappop(q) if res[curr] &amp;lt; time : continue for i in graph[curr] : newtime = time + i[1] if newtime &amp;lt; res[i[0]] and sight[i[0]] == 0: res[i[0]] = newtime heapq.heappush(q,(newtime,i[0]))ans =res[-1]print(ans if ans &amp;lt;inf else -1)6. 후기" }, { "title": "leetcode(리트코드)-598 Range Addition II(PYTHON)", "url": "/posts/leetcode_Range_Addition_II/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-08-31 01:34:50 +0900", "snippet": "leetcode 598 - Range Addition II 문제입니다.1. 문제https://leetcode.com/problems/range-addition-ii/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 input으로 m * n 배열이 들어옵니다. ops배열에서 각 요소의 첫번째요소와 두번째 요소의 의미는 해당 인덱스까지 1씩더한다는 의미입니다. [2,2]는 [1,1], [1,2],[2,1],[2,2]까지 1씩 더하라는 의미입니다.5. codepythonclass Solution: def maxCount(self, m: int, n: int, ops: List[List[int]]) -&amp;gt; int: if len(ops) == 0 : return m * n minrow = 10**5 mincol = 10**5 for i in range(len(ops)): minrow = min(ops[i][0],minrow) mincol = min(ops[i][1],mincol) return minrow * mincol 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "Baekjoon1916-최소비용 구하기", "url": "/posts/baekjoon1916/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, Dijkstra", "date": "2021-08-31 01:02:00 +0900", "snippet": "백준 사이트 1916 - 최소비용 구하기 문제입니다.1. 문제https://www.acmicpc.net/problem/19162. Input , Output3. 분류 및 난이도다익스트라 문제입니다.4. 생각한 것들 다익스트라 연습하기 위해 푼 문제5. codeimport heapqimport sysinput = sys.stdin.readlineN = int(input())M = int(input())graph = [[] for i in range(N+1)res = [int(1e9)] * (N + 1)for i in range(M) : tmp = input().split(&#39; &#39;) graph[int(tmp[0])].append((int(tmp[1]),int(tmp[2])))start,end = map(int,input().split(&#39; &#39;))def dijkstra(first) : q = [] #first-=1 heapq.heappush(q,(0,first)) res[first] = 0 while q : dis,current = heapq.heappop(q) if res[current] &amp;lt; dis : continue for i in graph[current] : nextdis = dis + i[1] if nextdis &amp;lt; res[i[0]] : res[i[0]] = nextdis heapq.heappush(q,(nextdis,i[0]))dijkstra(start)print(res[end])6. 후기" }, { "title": "2021.08.30(월).경제 정리노트", "url": "/posts/economy0830/", "categories": "Economy, DailyNote", "tags": "Economy", "date": "2021-08-30 01:50:50 +0900", "snippet": "2021.08.30 경제 헤드라인을 정리한 글입니다.부동산 관련, 청약 관련글에 대해서는 따로 정리하지 않습니다. 저출산 예산 200兆 43%는 청년에 썼다. → 정부가 저출산 극복에 16년간 200조원을 부었지만 이 중 절반 가량은 저출산과 직접 관련이 없는 청년 예산인 것으로 나타남. 현재 출산율이 0.82명인데 0명대인 국가는 세계에서 한국이 유일함. ‘마이데이터 대면영업’놓고 … 은행 - 빅테크 또 기싸움 → 마이데이터 서비스를 기존 비대면 플랫폼뿐만 아니라 은행 창구 현장의 대면 영업까지 허용해야 한다는 주장. → 은행측의 주장 디지털 취약 계층의 금융 소외 가속화 은행 영업점 고객의 자기 의사결정권 침해 빅테크.인터넷은행에 유리한 ‘기울어진 운동장’ 해소 → 빅테크 입장 고객 신용정보를 활용한 불완전판매 가능성이 높아진다. 은행 영업점 직원이 고객 개인정보를 침해할 우려가 있다.(마케팅 등) 대면 영업 허용은 시대적 흐름에 역행하는 것이다. ‘테이퍼링 불확실성’ 지운 美 증시 …. 이젠 ‘금리인상 시점’에 촉각 → FED의 파월 의장이 테이퍼링 착수 기능성을 언급했지만 “기준금리 인상은 아주 먼 얘기”라며 시장을 안심시킴. 이로인해서 S&amp;amp;P500 나스닥이 연일 최고치를 찍음. ‘중국판 마켓컬리’란 말만 듣고 베팅 … 손실 40% → 유튜브에서 한 애널리스트의 말을 듣고 추천한 종목의 주가가 내리 꽂으면서 40%의 손실을 봄. → 이는 해외 주식의 특징으로, 대형주를 제외하면 회사 정보를 알기 힘들어 즉각적으로 대응하기 힘들다는 것. → 다다넥서스, 중국 보험사, 국내 투자자 보유금액 1위인 항서제약도 내리막길을 가버림. ‘집값 고점론’에도 … “최고 재테크 수단은 부동산” 48% → 집 안사면 바보라는 기사 템플스테이.e 스포츠 저출산 사업 둔갑 … 이러니 출산율 ‘꼴찌’ → 저출산예산이 이상한 곳이 쓰이고 있었음. 창업성장기술개발사업(1.2조), 민관협력 창업자 육성(428억), 게임개발자 육성(428억) 등… 업비트 ‘독주 체제’ … 예치금 2위 빗썸의 5배 → 이유는 업비트가 암호화폐거래소 중 유일하게 ISMS 인증과 은행 실명계좌를 확보했기에 안정적. 그리고 카카오와 협력을 하면서 안정적인 지배구조를 가지고 있음. 예치금은 빗썸의 5배로 약 5조에 달함. 거래량이 세계 2위로 올라섬. 1위는 바이낸스 보험사 주담대 받아볼까 … 은행보다 한도 넉넉, 금리는 엇비슷 → DSR규제 측면에서 은행보다 유리한 보험사에 대출에 대해 쓴 기사 → 보험사 대출에는 3가지가 있다. 주택담보대출 : 은행에서 제공하는 서비스와 같음. 금융당국에서 DSR규제를 강화할 것으로 예고했으므로 지켜봐야함. 신용대출 : 기존 서비스와 같음. 다만, 금융당국이 신용대출 한도 규제를 가했지만, 이미 보험사에서는 그만큼의 서비스를 제공하였기에 타격이 적을 것. 보험계약대출 : 보험사에 납부한 보험금을 담보로 대출을 해주는 것이다. 때문에 금리가 보험 계약별로 천차만별임. 코로나 시대 재테크 … 글로벌 ETF가 답이다. → 글로벌ETF가 왜 성장했냐에 대한 이야기 크게 2가지가 있음. 기업 활동과 투자 범위가 이제는 평평한 운동장이 됐기 때문. 지금은 국내와 해외를 구별하는 것이 오히려 어색할 정도 가국이 추진하는 산업정책의 대전환 때문. 금융위기 전때에는 선진국에 속한 우량기업이 밖으로 나갔었는데, 그때는 신흥국 투자가 유리했지만, 지금처럼 본국으로 환류될 때에는 선진국에 투자해야 높은 수익을 낼 수 있음. 셀트리온. 카카오 … 외국인,기관 따라 ‘핀셋 투자’해볼까 → 제목에 핀셋이 들어있는데 내용은 없어서 약간 혼란이 온 기사 → 큰손들이 투자한 기업을 알려줌. (셀트리온, 카카오, H&amp;amp;M, OCI, SK이노 등..) ‘마통’한도, 5000만원 이하로 “대출 미리 받자” 은행에 줄섰다. → 가계대출 규제가 본격화 되면서 마이너스통장은 5000만원 이내로 한도를 대폭 축소 하기로 함. 리모델링 ‘시동’건 당산 현대홈타운. 효성 → 영등포구 당산동 노후 아파트 단지들이 리모델링에 시동을 거는 중. 주민들의 동의를 받고 있음. 원룸 울고 투룸 웃고 … 오피스텔 시장도 ‘덩치’따라 양극화 극심 → 다주택자 규제에 오피스텔도 포함되어, 소형 오피스텔 매물이 쌓이고 있음. → 다른 한편으론 아파트를 살 수 없는 사람들이 중,대형 오피스텔을 알아보면서 중,대형 오피스텔 매물은 없어지고 있음. → 오피스텔은 70%까지 대출을 받을 수 있고, 청약시에는 무주택자로 간주되기에 인기가 많아지고 있음. → 이러한 현상때문에 중,대형 오피스텔 가격이 오르고 있음. 엘사바도르의 비트코인 실험 … 달러화와 ‘동급’ 된다 → 세계 최초로 비트코인을 법정통화로 채택한 엘사바도르가 막바지 준비 작업을 이어가고 있음. → 비트코인 ATM을 설치하고, 50곳의 지점도 개설한다고 밝힘. 달러로 비트코인을 수수료없이 인출할 수 있고, 반대로 달러를 비트코인으로 입금할 수도 있음. → 정부는 비트코인 이용을 활성화하기 위해 지갑 앱에 처음 등록하는 국민에게 1인당 30달러어치 비트코인을 무상지급할 예정이라고 함. → 부켈레 대통령 : “비트코인 사용을 강제하지 않는다. 하지만 비트코인을 쓰지 않는다면 첫 보너스도 못 받고, 송금 수수료도 내야 하고, 사업 기회도 잃게 된다”고 말함. 아파트 임대사업자, 등록 기간 끝나면 ‘보유세 폭탄’ 떠안는다. → 아파트 임대 제도 폐지로 기존 사업 기간 종료되면 종부세 합산배제가 사라져 세금부담이 폭발적으로 증가함. 자세한건 기사 찾아보기 로또 분양 당첨돼도 시세차익 ‘먼 훗날’ … 전매제한 최대 10년 → 분양 되어도 10년뒤에 팔 수 있다는 기사 손님 없는데 ‘이자 폭탄’까지 … 자영업자들 “더는 못 버틴다” → 코로나로 적자 쌓이는데 금리 오르고, 대출은 옥죄니까 자영업자들이 힘들어서 거리나와서 단체행동을 시작함. ‘31번째 한강다리’ 월드컵대교 개통 … 오세훈 첫삽 11년만에 → 9월1일부터 차량 통행이 가능함. 서부간선지하도로도 동시에 가능함. 테이퍼링 시점, 8월 고용지표에 달렸다 졸속 3기신도시, 하수처리도 못할판 → 정부가 집값 안정을 위해 졸속으로 입지 선정에만 매달린 결과 정작 도시계획에 필요한 ‘내실’은 전혀 챙기지 못한 결과. → 하수처리장을 만들 곳이 없음. 만들어야하는데 과천시와 서초구가 싸우는 중. 근데 결정이 되어도 환경영향평가 등 절차를 거치려면 최소 6~7년이 걸림. 집값 잡겠다고 쫓기듯 발표하더니 …3기 신도시 곳곳 인프라 ‘펑크’ → 위 기사와 같은내용. 본청약까지 ‘희망고문’? 남양주왕숙 반년 밀렸다 → 3기 신도시 내용임. 청약을 현재 반년 미뤄버림. 만약 3기 신도시가 극단적으로 갈 경우에는 10년 이상 걸릴 수도 있어 청약이 ‘희망고문’이 될 수 있다는 우려 → LH 사태로 토지 보상 현장에서 일정이 지연된 결과. 3기 신도시도 …先입주 後교통 → 3기 신도시의 교통 인프라스트럭처 구축이 입주가 시작되는 시기보다 늦어질 가능성이 높아지고 있음. → 정부는 ‘선교통 후입주’ 원칙을 내세웠지만 주민 반발과 지자체 갈등에 부딪혀 지연되고 있기 때문이다. → GTX의 경우는 최근 공사현장에서 조선시대 유적이 발견되는 등 공사가 더 지연될 듯. → 양주 덕정 ~ 수원은 강남 재건축 단지 주민들의 반발이 거셈. 노선의 우회 변경을 요구하고 있음. “2030 신용대출 일부 갚고 … 4050 주담대 고정금리 전환 검토” 과거 금리 인상기, 집값 뛰고 부채 더 늘었다. → 금리 인상으로 인한 부채 감축 효과는 제한적이며 취약계층 타격만 커질 수 있다는 분석이 나옴. 은행 예적금 금리 이번주 일제히 인상 → 적금 금리가 오름 그래봤자 kb의 경우 1년 만기 금리 1.4% 4 ~ 6월보다 10월 카드 더 쓰면 10% 돌려준다. → 정부가 10월 시행을 목표로 상생소비지원금 지급을 추진하고 있음. → 이 같은 캐시백 한도는 1인당 월별 10만원이 제한. 정부 계획대로 2개월간 시행하면 최대 20만원 캐시백 가능. → 백화점, 대형마트, 온라인쇼핑몰 등 일부 소비는 실적으로 인정되지 않음. 소상공인과 골목상권 소비 활성화를 유도하겠다는 취지. 한강조망에 한남뉴타운 생활권 ‘겹호재’ → 한남뉴타운 개발에 따른 호재들 정리한 기사. 거의 홍보기사 소유주 70% 반대해도 … 국토부 ‘동자동 개발’ 강행 → 공공주택법 적용해서 쪽방촌을 개발하는데, 주민 동의도 철회 요건도 없음. → 소유자의 70%가 반대 의견을 표출해도 정부는 강행하겠다는 의지를 보이고 있음. → 서울역 쪽방촌 정비사업은 공공주택특별법에 따라 진행되는데, 다른 정비사업과는 달리 토지 등 소유자의 동의 요건이 없음. " }, { "title": "시간여행TV의 만화로 배우는 주식 투자(시간여행TV 저) 독후감", "url": "/posts/book1/", "categories": "Book", "tags": "book", "date": "2021-08-30 01:00:00 +0900", "snippet": "이 책을 알게 된 건 누나의 추천이다.​누나가 초보자도 읽기 쉬운 만화책이라며, 중간중간 개그가 재미없어서 못 보겠다고 했다.​나는 고등학교 감성나서 좋았고, 하루만에 다 읽어버렸다. 아무래도 만화책이라 그런가보다.​읽으면서 정리를 했는데, 공유!​저자 : 26살 300억 주식계좌를 보유한 고려대생​그래서인지 만화에서 나오는 인물이 고려대생.​Chapter1. 주식이란 무엇이고 왜 공부해야할까→ 주식은 자본주의 시장의 꽃. 부동산과 달리 소액으로 시작할 수 있다.→ 옛날에는 좋은 학교 나오고 좋은 곳에 취직하면 먹고살기 힘들지 않았으나, 들끓는 집값 상승으로 한계가 있으니 투자를 해야함.→ 주식은 위험하지만 결국 “아무것도 투자하지 않는 것이 더 위험하다”라는 것.Chapter2. 수요와 공급의 원리→ 수요와 공급이 맞는 지점에서 가격이 정해짐.→ 보통 주식시장에 정부가 개입하지 않지만 ‘불공정 거래’ 또는 코로나19와 같은 재난위험때에는 정부가 개입함.→ 재난위험의 경우 정부마스크 공급 또는 마스크 사재기를 막으면서 개입.→ 불공정 거래는 크게 3개의 요소가 있다.미공개 정보 이용 : 회사 내부 등을 통해 회사 정보를 알고 투자하는 것.시세조작 : 말그대로 주식을 엄청 사서 거래량이 활발하게 보이게 하고 뺀다던지 등의 조작부정행위 : 시세 조작을 위해 거짓말 및 거짓정보를 발설하는 것Chapter3. 거래량의 의미→ 거래량은 어느시점에서 거래된 총량이다.→ 거래량이 많다는 것은 해당지점에서 투자자들이 ‘이 정도 가격이면 살만하지’며 사는 것.→ 거래량은 보조지표이니까 너무 참조로 쓰는 것은 자기 자유이다.→ 거래량은 4가지 상황이 옴.주가 변동 x 거래량 많음 → 투자자들이 적정가라고 생각하고 안정적으로 투자하고 있음.적은 거래량 주가 상승 → 2가지 상황. 뉴스 등으로 인해 호재가 있을 경우, 일시적으로 적정가를 안주고 비싼가격에 주식을 산 투자자가 있을 경우. 이경우는 주가가 보통 다시 돌아옴.많은 거래량 주가 상승 → 회사가 성장중적은 거래량 주가 하락 → 회사 내부에서 아무런 위험이 없는 경우 보통 다시 돌아옴.Chapter4. 시장 가격의 결정→ 단기간에 급등한 회사에 투자하는 것은 좋은 전략이 아니라는 내용→ 시장의 가격은 결국 투자한 곳의 가치에 돌아오게 되어있음.→ 예를들어 3,4 위전인 한.일전 티켓이 1만원이라고하고 결승전이 10만원이라고 해도 한국인들은 ‘한.일’전 타이틀이 걸린 3,4위전 티켓을 많이 사려고하다보니 공급이 수요를 따라가지 못하고 결국 결승전 티켓보다 더 비싸질 수 있지만 결국 그 가치는 1만원짜리 티켓이라는 것임.→ 이를 이용해서 주식시장에서 큰손들이 조작을 할 수 있으니 좋은 투자전략이 아니라는 것.Chapter5. 주식시장의 기초→ 주식시장은 전쟁터이다. 아무도 믿지 말고, 자신이 판단해서 투자하고 손절하자→ 때문에 공부를 많이해야하고, 다른사람을 믿고 나락을 갈 수 있고 책임져주지 않으므로 조심하자는 내용Chpater6. 좋은 주식의 조건→ 좋은 주식은 성장하고 있는 기업을 말하는 것이 아님.→ 미래가 좋기에 성장하면서 주주들에게 수익의 일부를 나눠주는 기업이 좋은 주식이다.→ 회사에서 급전이 필요해서 수익을 다른방식으로 나눠줄 수 있음.자사주 매입 : 회사 자금으로 주식을 사서 유동주식을 줄여 투자자들의 주식가치를 높임.무상증자 : 증자를 하여 발행된 주식을 주주들에게 무상으로 줌.액면분할 : 액면가액을 일정한 비율로 나눠 주식의 발행수를 증가시킴.Chapter7. 주식투자에 영향을 미치는 심리적 요인→ 누나와 얘기했던 것들 시가총액이란 총주식수 * 주식가격임.→ 시총이 2020년 기준 삼성이 357조였는데 그 1%인 3조가지고는 주가조작이 어렵지만 시총이 700억인 기업의 1% 7억가지고 주가조작은 쉬움.→ 때문에 소형기업들의 주식이 급락하고 급상하는 일은 어떻게 보면 보기 쉬운 일이다.→ 이와 비슷하게, 만약 ‘카카오’라는 기업과 ‘카카오유사기업입니다.’ 라는 기업이 있으면 카카오기업이 주식이 상승하면 카카오유사기업입니다도 주식이 상승하는것이 심리적 요인임. 사람들이 착각을 한 것이기 때문.→ 만약 자신의 보유주식이 갑자기 아무이유없이 급상을 한다면 매도하는 것이 바람직할 수 있다는 얘기.Chapter8. 보통주와 우선주의 차이→ 일단 주식은 환불이 되지 않음.→ 주식시장에서 말하는 주식은 보통주가 보통임.→ 우선주란 기업의 이름 끝에 ‘우’가 붙거나 ‘2우C’처럼 우 + 알파벳이 붙음. 최저배당을 보장해준다는 의미→ 우선주는 보통주에 비해 상장 주식수가 적어서 변동성이 크다. 때문에 보통주보다 주가가 급락 및 급등하기가 쉬움.→ 우선주는 보통주에 비해 배당금을 더 가져갈 수 있지만 주주총회에서 ‘의결권’이 없어 기업입장에서 경영권침해의 문제가 없음.→ 우선주에서 배당금을 안주는 곳도 있는 데 이는 투자할 가치가 없으므로 거르면 됨.→ 우선주는 변동성이 크다보니 금융당국에서 이를 막기 위해 규제를 취했으나 ‘풍선효과’로 인해 다양한 문제가 생김.풍선효과 : 한 문제를 해결하려고 하다보면 다른 문제들이 생겨나는 것.→ 현재 우선주는 장기투자의 목적이고 초보자들에겐 어려운 내용.Chapter9. 품절주의 의미→ 품절주의 기준은 없지만 보통 전체 주식의 70%이상을 한 주주가 가지고 있는 것을 말함.→ 이렇게 될 경우 적은 거래량으로 인해 급등과 급락이 쉬워 변동성이 커짐.→ 하지만, 실제로 회사의 미래가 좋고 품절주라면 급등하기 쉽기에 수익을 내기도 쉬움.→ 만약 최대주주가 주식을 매도하는 순간 심리적요인으로 주식이 급락할테니 주의가 필요하다→ 최근에는 실적 좋고 미래가 밝은 품절주가 우상향 곡선을 그리는 추세이니 잘 보고 판단.Chapter10. 재직자의 평가는 주가와 무관하다.→ 회사의 평판이 좋지 않다고 해서 주가가 떨어지지 않는다.→ 효율성 임금 제도 때문인데, 보통 기업에서 자발적으로 높은 임금을 주는 이유는 다음과 같다.이직률 감소근로자의 동기부여 상승제일 중요한 인재영입(돈 많이주면 인재가 옴)→ 회사에 따라 인재의 중요도가 다름. 바이오회사의 경우 몇명의 인재로만 돌아가는 경우 다른 사원들은 나가도 상관이 없음. 때문에 나간 사원들이 평판을 좋지 않다고 해도 실제로 회사는 몇명의 인재로 잘 돌아가고 있으므로 주가에 영향을 못 미친다는 얘기Chapter11. 주식투자를 할 때 조심해야할 점→ 주식시장에 정답은 없다.→ 가장 좋은건 성공한 투자자들을 보는 것인데, 자신의 계좌를 까지 못하는 투자자는 거르자.→ 기사를 너무 믿지마라. 홍보성 기사도 있고, 어떠한 목적에서든 잘못 쓴 기사인 경우 타격이 크다.→ 정보를 조합해서 고급정보를 만들어내는 안목을 기르자.Chapter12. 주식투자를 할 때 조심해야할 점 2→ 자기자본으로 하자. 레버리지 땡기는건 너무 위험하다. 대출이랑 미수 등.→ 여유있게 기다리자. 만약 넣을 곳이 없으면 현금을 보유하는 것도 좋은 방법이다.Chapter13. 테마란 무엇이며 어떻게 만들어지는가→ 테마주란 내가 이해했을때는 그 시기에서 주식이 오를 수밖에 없는 회사들 종목을 말함.→ 예를들어 코로나19 때문에 마스크, 손세정제 이름도 모를 회사의 주식이 급등한것처럼 어떠한 시나리오에서 뜨는 기업들.→ 이러한 테마주는 큰 이익을 낼 수 있지만 큰 손실을 낼 수도 있음.→ 가장 좋은 테마주는 영업이익은 높고, 시총이 낮고, 부채율은 낮고, 유보율이 높은 기업들. 상장폐지될 가능성이 적기 때문이다.Chapter14. 정치테마주 - 인맥테마주→ 정치테마주는 투기가 아니다. 명확한 근거와 소신이 있으면 투자가 된다. 일반 주식매매도 마찬가지→ 인맥테마주 : 특정 정치인과 연관이 있다고 판단되는 회사종목들→ 크게 3개 혈연, 동문, 친구로 나뉨.혈연 : 박근혜 대통령 대선 당시 친동생이 EG회사에 다닌다는 이유로 10배 급등.동문 : 특정 정치인과 기업의 임원이 동문이면 정치테마주로 편입되는 경우가 있음.친구 : 특정 정치인과 친구인 기업의 임원Chapter15. 정치테마주 - 정책 테마주→ 정책 테마주 : 만약 정치인이 공약을 걸면 그 공약에 관련있느 기업들의 주가가 상승할 것 같은 종목들ex)→ 저출산 공약 : 신생아가 많이 출산될 것이므로, 유아용 장남감 등의 회사의 매출이 오를 것이므로 주가가 상승하는 것.→ 가장 좋은 것은 사람들이 관심이 없을 때 샀다가 관심이 생겼을 때 매도하는게 가장 좋은 수익을 낼 수 있다는 것을 명심하자.Chapter16. 경영권 분쟁이란?→ 주식을 사면 ‘의결권’을 가짐.→ 가장 많은 의결권을 가진 사람이 주주총회에서 임원을 선발할 수 있음.→ 때문에 절대권력을 가지기 위해선 전체 주식의 50% + 1주만 있으면 절대권력을 가진다. 과반수를 넘기기 때문→ 만약 그렇지 않다면 경영권 분쟁을 해야하는데, 이를 이기기 위해선 2가지 방법이 있음.주식을 더 매입해버림 → 수요와 공급의 원리에 의해 주가가 상승함.상대방의 의결권을 없애버림이럴려면 상대가 부정거래 의심이 되거나, 친가족이여서 의결권을 양도받았다는 등 여러 상황이 있음.그렇기에 이 경우에는 보통 경영권 분쟁이 심해지고, 주가가 급등함. 사람들의 기대심리에 의해서다. 왜냐하면 주주들이 경영권에서 이기기 위해서 소형주주들의 지지를 받아야함. 소형주주들의 지지를 받기 위해 배당금을 올려준다는 등 공약을 내세움. 지킬지는 미지수Chapter17. 경영권 분쟁의 끝→ 모든 주가에는 추세라는 것이 있다.→ 만약 어떤 우주산업 기업에서 위성을 쏘아올린다고 하면 주가가 급등할 것이다.근데 주가가 어느 한계치를 넘어버리면 너무 올랐다고 판단해서 투자자들이 매도를 해버림. 그러면 주가 상승세는 꺾임. 실제로 그 기업이 위성을 쏘아올린건 문제가 아니라는 것. 이러한 현상을 ‘재료소멸’ 이라고 하고 이런 추세가 주가에 존재한다는 것이다.→ ‘재료소멸’ 이 되면 테마주는 테마주에서 퇴출이 되어버린다. 그렇기에 가장 좋은 투자방법은 이미 오른 주식을 사는 것이 아닌 오를 것 같은 주식을 사는 것이다.Chapter18. 차트란 무엇이고 어떻게 활용할까→ 차트에 선을 그리면서 분석하는 방법을 말함.→ 저자는 추천하지 않는 방법. 주식은 불확실성이 있고, 과학적인 방법으로 접근하기가 힘들기 때문→ 워렌버핏도 손실을 보는 매매를 하는 경우가 있으니까 주식은 ‘불확실성’이 있다는 것을 인정하고 자신만의 기준을 세워 매매하자.Chapter19. 저평가된 종목을 발굴하자.→ 오해하면 안되는 부분→ 일반적으로 90일간 거래대금량이 20억 미만일 경우 소외종목이라고 판단. 하지만 소외종목이 저평가 기업은 아님.→ 또한, 유상증자를 했거나 전환사채를 했으면 그 기업은 사지말자.→ 적자가 오래 지속된(책에서는 3년) 기업도 피하자.→ 회사가 신뢰를 받지 못하고 있는 것인지, 또한 실적은 내지만 주가가가 안올라가는 기업들을 잘 살피자.Chapter20. 고평가된 종목은 피하자→ 보통 고평가된 기업은 책 기준으로 다음과 같은 특징을 갖는다고 한다.→ 1. 해당 시점과 52주 전을 비교했을 때 2배이상 올람. 이런 경우는 정말 드물다고함.→ 2. 공매도 비율이 높은 기업.→ 3. 동종업계 경쟁사 대비 PER 수치가 높은 기업." }, { "title": "(Project)로스트아크 레벨 알려주는 디스코드 챗봇만들기", "url": "/posts/LostarkChatbot/", "categories": "Toy", "tags": "chatbot", "date": "2021-08-29 01:34:50 +0900", "snippet": "로스트아크 챗봇만든이유 : 같이 로스트아크하는 대학교 선배,친구들이 서로의 템렙을 수시로 물어봐서- 만든 과정기존에 있던 코드를 바꿈. 필요한건 냅두고 필요없는 것은 버림.내부 동작방식을 유추할 수 있게끔 살짝 공부했다.import asyncioimport discordfrom urllib.request import urlopenfrom bs4 import BeautifulSoupfrom urllib import parsefrom collections import dequeclient = discord.Client()# 디스코드에서 생성된 토큰을 여기에 추가token = &quot;디스코드 토큰값&quot;# 아래는 봇이 구동되었을 때 동작하는 부분@client.eventasync def on_ready(): print(&quot;Logged in as &quot;) #봇의 아이디, 닉네임이 출력 print(client.user.name) print(client.user.id)# 봇이 새로운 메시지를 수신했을때 동작하는 부분@client.eventasync def on_message(message): # 아래는 로스트 아크 홈페이지에서 아이디로 페이지를 읽어 레벨을 가져오는 부분 #message.content는 레벨 channel = message.channel if message.content == &quot;!도움말&quot; : await channel.send(&quot;!레벨 -&amp;gt; 모든 사람들 캐릭터 레벨 정보\\n!사람이름 -&amp;gt; 해당 사람의 캐릭터 레벨들\\n&quot;) #나 dic = {} dic[&quot;강민석&quot;] = deque() dic[&quot;강민석&quot;].append(&quot;두둥챠&quot;) dic[&quot;강민석&quot;].append(&quot;BTS김지완그리고나&quot;) dic[&quot;강민석&quot;].append(&quot;불닭보꺼&quot;) dic[&quot;강민석&quot;].append(&quot;초이록산&quot;) dic[&quot;강민석&quot;].append(&quot;두두챠&quot;) ##세원이형 dic[&quot;고세원&quot;] = deque() dic[&quot;고세원&quot;].append(&quot;Fani01&quot;) dic[&quot;고세원&quot;].append(&quot;Fani02&quot;) dic[&quot;고세원&quot;].append(&quot;Fani03&quot;) dic[&quot;고세원&quot;].append(&quot;Fani04&quot;) dic[&quot;고세원&quot;].append(&quot;Fani05&quot;) dic[&quot;고세원&quot;].append(&quot;Fani06&quot;) dic[&quot;고세원&quot;].append(&quot;Fani07&quot;) if message.content == &quot;!레벨&quot; : for name in dic : #url = &quot;https://lostark.game.onstove.com/Profile/Character/&quot;+parse.quote(message.content[1:]) #channel이라는 변수에는 메시지를 받은 채널의 ID를 담습니다. await channel.send(name + &quot;\\n-----------------\\n&quot;) while dic[name] : data = dic[name].popleft() url = &quot;https://lostark.game.onstove.com/Profile/Character/&quot;+parse.quote(data) html = urlopen(url) bsObject = BeautifulSoup(html, &quot;html.parser&quot;) tmpContent = bsObject.find_all(&quot;div&quot;, {&quot;class&quot;:&quot;level-info2__item&quot;})[0].find_all(&quot;span&quot;)[1].text tmp = bsObject.find_all(&quot;div&quot;, {&quot;class&quot;:&quot;level-info2__item&quot;})[0].find_all(&quot;span&quot;)[1].text jobs = bsObject.find_all(&quot;div&quot;,{&quot;class&quot;:&quot;profile-character-info&quot;})[0].find(&quot;img&quot;)[&quot;alt&quot;] await channel.send(data+&quot; / &quot; + jobs + &quot;\\n&quot;+str(tmpContent)) await channel.send( &quot;-----------------\\n&quot;) elif str(message.content[1:]).isdigit() : print(&quot;숫자입니다.&quot;) elif message.content[1:] in dic: name = message.content[1:] while dic[name] : data = dic[name].popleft() url = &quot;https://lostark.game.onstove.com/Profile/Character/&quot;+parse.quote(data) html = urlopen(url) bsObject = BeautifulSoup(html, &quot;html.parser&quot;) tmpContent = bsObject.find_all(&quot;div&quot;, {&quot;class&quot;:&quot;level-info2__item&quot;})[0].find_all(&quot;span&quot;)[1].text jobs = bsObject.find_all(&quot;div&quot;,{&quot;class&quot;:&quot;profile-character-info&quot;})[0].find(&quot;img&quot;)[&quot;alt&quot;] await channel.send(data+&quot; / &quot; + jobs + &quot;\\n&quot;+str(tmpContent)) client.run(token)- 만든 후기크롤링을 하는 방식이고, 직접 아이디를 하드코딩하는게 불편함.더 좋은 방식이 있을까 고민했지만.. 음 그사람의 개인정보로 캐릭터 레벨을 아는 것도 보안상의 문제가 있으니 넘어가기로 했따." }, { "title": "leetcode(리트코드)-1247 Minimum Swaps to Make Strings Equal(PYTHON)", "url": "/posts/leetcode_Minimum_Swaps_to_Make_Strings_Equal/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-08-28 03:34:50 +0900", "snippet": "leetcode 1247 - Minimum Swaps to Make Strings Equal 문제입니다.1. 문제https://leetcode.com/problems/minimum-swaps-to-make-strings-equal/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.4. 문제 해석 ‘x’와 ‘y’로 이루어진 두개의 문자열이 들어옵니다. 두 문자를 스왑할 수 있을 때 가장 적게 스왑하여 두 문자를 같게 만들어야합니다. 그 수를 리턴하세요.5. code코드설명 s1이 ‘xxxxxyyy’라고 하고, s2가 ‘yyyyyxxx’라고 하면 s1기준으로 x가 다른부분은 5개 y가 다른 부분은 3개입니다. 이 총합이 짝수가 아니면 -1을 리턴해야합니다. 만약 홀수라면 둘 중 하나의 갯수가 홀수라는 것인데, 그러면 두 글자를 절대 맞춰줄 수 없기 때문입니다. x기준으로 swap을 해줍니다. 위의 예제에서 ‘xxxxx’인데 일단 홀수개 이므로 s1의 ‘xxxx’와 s2의 ‘yyyy’만 바꿔줍니다.(xcount // 2 코드) 그 결과 ‘xyxyxyyy’가 되고, s2는 ‘xyxyyxxx’가 됩니다. 마찬가지로 y를 기준으로 바꿔줍니다. s1에서 ‘yyy’입니다. (ycount // 2 코드) 그 결과 ‘xyxyxyxy’가 되고, s2는 ‘xyxyyxxy’가 됩니다. 다른부분은 s1의 ‘xy’와 s2의 ‘yx’가 되는데, 이는 특별한 경우로 swap을 2번 진행해줘야합니다. 이 경우는 x의 기준으로든 y의 기준으로든 홀수인 경우에만 나타납니다.(xcount%2 == 1 : 코드 x기준으로)pythonclass Solution: def minimumSwap(self, s1: str, s2: str) -&amp;gt; int: xcount = 0 ycount = 0 res = 0 for i in range(len(s1)) : if s1[i] != s2[i] : if s1[i] == &#39;x&#39; : xcount += 1 else : ycount += 1 # 두문자의 다른부분이 홀수인 경우 -1 if (xcount + ycount) % 2 == 1: return -1 else : #맞춘 상태에서 시작 res = (xcount // 2) + (ycount // 2) if xcount %2 == 1 : res += 2 return res 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "leetcode(리트코드)-503 Next Greater Element II(PYTHON)", "url": "/posts/leetcode_Next_Greater_Element-II/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-08-28 02:34:50 +0900", "snippet": "leetcode 503 - Next Greater Element II 문제입니다.1. 문제https://leetcode.com/problems/next-greater-element-ii/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.4. 문제 해석 배열을 볼 때 인덱스를 기준으로 오른쪽으로 탐색할 때 해당 인덱스보다 큰 값을 결과 리스트에 담아 리턴합니다. 만약 제일 큰 값이면 -1를 넣고, 기존 리스트의 맨 끝까지 탐색했는데 없다면 다시 맨앞부터 탐색하여 찾습니다.5. code문제해석 stack을 사용해야합니다. 만약 배열이 [1,5,2,3,6,4]라고 할 경우 5,2,3,6에서 5와 3은 6을 넣어야하는데, 그 중간에 있는 2를 6을 넣어줘야하는 지 여부를 stack으로 따져야하기 때문입니다.pythonclass Solution: def nextGreaterElements(self, nums: List[int]) -&amp;gt; List[int]: stack = deque() sz = len(nums) res = [-1] * sz # 2바퀴를 돌기 위해서 for i in range(sz * 2): while stack and nums[stack[-1]] &amp;lt; nums[i%sz] : res[stack.pop()] = nums[i % sz] stack.append(i%sz) return res 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "leetcode(리트코드)-434 Number of Segments in a StringNumber of Segments in a String(PYTHON)", "url": "/posts/leetcode_Number_of_Segments_in_a_StringNumber_of_Segments_in_a_String/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-08-28 01:34:50 +0900", "snippet": "leetcode 434 - Number of Segments in a StringNumber of Segments in a String 문제입니다.1. 문제https://leetcode.com/problems/number-of-segments-in-a-string/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 문자열이 들어옵니다. 어절의 개수를 리턴하세요.5. codepythonclass Solution: def countSegments(self, s: str) -&amp;gt; int: if len(s) == 0 or s.count(&#39; &#39;) == len(s) : return 0 res = 0 idx = 0 while idx &amp;lt; len(s) : if s[idx] != &#39; &#39;: res += 1 while idx &amp;lt; len(s) and s[idx] != &#39; &#39;: idx+=1 else: idx += 1 return res 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "2021.08.27(금).경제 정리노트", "url": "/posts/economy0827/", "categories": "Economy, DailyNote", "tags": "Economy", "date": "2021-08-27 03:50:50 +0900", "snippet": "2021.08.27 경제 헤드라인을 정리한 글입니다.부동산 관련, 청약 관련글에 대해서는 따로 정리하지 않습니다. 현대오일뱅크, 50조 수소연료전지 시장 뛰어든다. → 분리막 생산설비를 천안에 구축한다고함. 시장이 아직 활성화되지 않았고, 전해질막 기체 확산층 등 주요 부품의 수입 의존도가 높은편임. 그렇기에 자체 생산을 위해 연구를 진행중. 낸드시장 선두 삼성전자 잡아라 … 글로벌 2,3위 합병설 → 낸드플래시 시장 점유율 2위(일본 키옥시아)와 3위(미국 웨스턴디지털)이 합병된다는 소리가 있음. → 두 기업이 합병을 하면 현재 점유율 1위인 삼성전자와 점유율이 비슷해짐. → 하지만, 성사될 지는 미지수. 정부에서 반대할 가능성이 있기 때문이다. 실제로 엔비디아는 ARM 인수계획이 있었지만 국가안보, 시장독점 등을 고려해서 정부가 영국이 반대의 입장을 표해 합병이 되지 않음. 또한 합병설이 돌았던 기업중 하나는 결국 IPO를 하면서 합병설이 무산이 된 이력도 있음. 잘나가다가 ‘뚝’ 재생에너지 열풍 재생 가능할까 → 재생에너지 관련주들이 하락세를 달리고 있는데 여러가지 복잡한 요인이 있음. ‘탄소중립’ 열풍은 맞으나 원자재값이 급등. 기후변화로 인한 에너지 생산 불안정성 극대화 원자력 등 기존 발전 기술의 경쟁력 강화 재생에너지의 발전 설비 대형화로 인해 단가가 싸져 경제성이 약화되고 있음. 해임 운임마저 급등하여 결정타 심지어 재생에너지가 ‘깨끗하지 않다’라는 문제까지 제기되고 있음. 포스코케미칼-OCI, 음극재 코팅 국산화 → 피앤오케미칼에 745억을 투자함. → 음극재 코팅 소재 ‘피치(Pitch)’를 국산화할 예정. 피치는 그간 전량 수입에 의존하였음. → 음극재 코팅은 2차전지의 충전.방전 효율을 높이고 수명을 늘리기 위해 사용됨. 서울 새 아파트 10채중 4채, ‘분양가 9억’ 넘어 중도금 대출 안돼 → 2017년에 9억원을 초과하는 아파트가 11% 현재 43.3% → 2017년에 서울 평균 분양가 5억원 → 2021년 평균 분양가 9억원 → 9억원 아파트는 평균보다 낮지만 중도금 때문에 60%수준인 5.4억은 현금으로 쥐고 있어야 살 수 있음. → 실수요자 피해, 기준의 현실화가 필요하다는 비판 마포 다시 재개발 붐 … 공덕18, 염리도 시동 → 서울 강북 사업 부진을 이유로 중단됐던 재개발 사업들이 하나둘 속도를 내고 있음. → 공덕18 토지 등 소유자 대상으로 찬반 투표를 한 결과 71%이으로 정비 본격화 → 염리4.5 구역은 재개발이 무산되다가 ‘마포프레스티지자이’, ‘마포자이’가 들어서며 가격이 뛰자 정비사업이 다시 추진되고 있음. 찬반 투표는 76%를 받음. GM “LG서 볼트 배터리 결함 통보받고 리콜 확대 결정” → GM(제너럴모터스)에서 14만여대의 이르는 볼트EV(전기차)의 리콜은 배터리 결함을 확인한 LG의 통보가 결정적이었던걸로 나타남. 이로 인해서 GM이 잡은 리콜비용 2조원보다 더 많은 비용이 생길듯. → 배터리셀에서 보기 드문 결함이 발생하였음. 음극 탭 단선과 분리막 밀림결함 펀드매니저 마음대로 운용하는 ‘액티브 ETF’ 급성장 … 1년 반만에 3.7배, 121조원 늘어 → 지수 추종 ETF와 달리 자산 공개 안해도 돼, ‘아크’(아크 이노베이션 ETF)가 대박을 터트리며 관심이 많아짐. → 국내에도 상품이 있으나 자산을 공개해야해서 구성종목을 꼼꼼히 따져야함. 도심공공개발 반대 주민들 “사전청약 강행땐 헌법소원” → 정부의 2.4 대책 핵심 사업인 도심공공주택복합사업에 반대하는 주민들이 서전청약 확대에 대해 헌법소원을 추진하는 등 집단행동에 나선다는 계획. “주택 거래 줄며 상승폭 둔화” “감당할 수준, 집값 잡기 역부족” → 금리에 따른 집값이 어떻게 될 것 같냐는 두 가지 입장에 대한 기사. 남양주 왕숙.하남 교산 공급 3,00가구 늘렸다. 영끌 매수 크게 줄듯 … “당장 집값 하락 없겠지만 속도가 변수” 한은 금리 인상은 ‘미풍’ … 파월 입이 ‘태풍’ 되나 → 금리를 올려도 금융시장이 크게 바뀌지 않음. 일반적으로 금리를 올리면 외국인 자금이 한국 시장에 유입돼 원화가치는 오르고(환율 하락), 채권을 사려는 사람이 줄어들면서 채권값은 떨어진다(채권 금리 상승). 하지만 반대로 움직였음. → Fed잭슨홀 미팅연설에서 테이퍼링에 대한 언급이 주목받을 듯. → 하지만 미국 경제가 최근 불확실해지면서 테이퍼링에 대한 언급은 한동안 없을거라는 입장도 나오고 있다. 가계빚-집값-물가 3高에 금리 처방 … “내년 1.25%까지 올릴수도” → 치솟는 집값,물가 등을 잡기위해 금리를 올릴 수도 있다는 입장. 이러면 취약계층과 일부 중소기업의 피해가 불가피함. → 다양한 전문가들의 의견이 나오는 중. ‘금리 올려도 공급확대 없인 집값 잡기 역부족이다.’ 등… → 과거에는 금리를 올려도 집값이 오른 전적이 있기에 신중해야한다. ‘백신 돈방석’ 앉은 화이자.AZ.모더나, M&amp;amp;A로 영토확장 → 화이자 : 캐나다 암치료제 개발 업체 인수. → AZ : 미국 면역 질환 치료제 개발회사 알렉시온 인수. → 모더나 : 시총 1600억 달러 달성. 상반기 매출의 90%가 백신. 유전자 치료와 유전자 편집 분야에 새로 진출할 것을 밝힘. 美 큰손들은 테이퍼링 대비 … 애플,테슬라 팔고 월마트,JP모건 샀다. → 레이 달리오 : 소비재에 투자를 많이함. 월마트 지분을 522만주로 45% 늘림. 맥도널드, 펩시코 등 다양한 소비재 기업을 대거 사들임. 반면 S&amp;amp;P 500 ETF아 금 투자비용은 줄임. → AQR캐피털대니지먼트 : 애플,마이크로 등 기술주를 축소하고 JP모건, 골드만삭스 등 금융주 지분을 크게 늘림. 테이퍼링으로 인한 경기에 민감한 주들은 줄인것. → 캐시우드 : 화폐거래소, 인터넷 쇼핑, 기업용 커뮤니케이션 등 생소한 종목을 주로 사들임. → 외에도 여러 큰손들이 트위터, 월마트 등을 삼. 트위터의 경우 주식이 급락해버리기도 함. → 중국 정부 규제로 블랙록은 보유중 알리바바 주식 중 88%인 7403만주를 처분, 아크인베스트도 12만여주를 처분 등 중국 주식을 처분하는 움직임. → “테슬라를 싸게 살 기회”라며 165만주를 산 캐시우드CEO도 테슬라 주식 35만주를 팔음. 가계 이자부담 3조1000억 증가… 빚투-영끌 대출자 발등에 불 → 금리 인상으로 인한 대출시장 후폭풍에 대한 내용. → 급전 필요한 실수요자들이 피해를 입는중. 비슷한 기사의 내용이 많습니다. 사정청약, 1주택자도 가능 … 래미안.자이 중대형도 공급 → 청약가점제에서 추첨제 물량도 사정청약에 포함하면서 1주택자도 청약가능하게 됨. 美 ‘잭슨홀 미팅’ 테이퍼링 힌트 미룰듯 → 13번 기사와 비슷한 내용. “파월 모호성 유지 할 것” 전망함. → 파월 의장이 별다른 말이 없을 경우 9월 FOMCC가 다음번 분기점이 될 수 있다는 전망. 감염병 확산에도 금리 올린 이유 → 경기회복, 물가상승, 집값, 미국 테이퍼링에 대응하기 위해서 “은행들, 신용대출 얼마나 줄일지 보고하라” → 내년 7월부터 저축은행과 상호금융회사는 마이너스통장 한도 전체에 대해 대손충당금을 쌓아야함. 지금은 은행.보험사에만 이 규제가 적용되고 있음. → 금강원은 모든 시중은행에대해 개인 신용대출 상품별 최대 한도와 향후 대출 한도 조정 계획을 27일까지 제출하라고 요구. SK 바사 115%, 셀트리온 -21% … 백신으로 갈렸다. → 백신관련 기업들 SK바사(위탁 생산, 자체 백신 개발중), 삼성바이오로직스는 주가 오르고 그 외 바이오기업들은 주가가 내려감. 도요타 뛰어들었다 … 韓, 獨, 日 ‘수소트럭 삼국지’ → 친환경을 위해 수소트럭도 나오는 중. 수소차 양산기술을 확보한 곳은 현대차, 도요타, 다일러 정도임. → 현대차 : 유일하게 수소 트럭을 양산해봄. 작년부터 스위스에 수출하기 시작. → 다일러 : 첫 수소 트럭 ‘젠H2’를 공개. → 도요타 : 미국 시장 공략중. 시제품으로 개발한 수소트럭. → 수소 트럭인 이유 : 미래 화물 트럭으로 전기차보다 수소차가 낫다고 생각. 배터리를 탑재해야하는데 상대적으로 수소탱크가 전기차의 배터리 탑재량보다 적기 때문이다. 또한 최근 배터리 공급량이 부족해지면서, 전기 트럭을 생산할 여력이 없음. 하지만 수소 트럭은 연료전지 등 각종 부품이 고가여서 비싸다. 폭발위험성도 가지고 있음. 현재 수소의 90%는 화석연료에서 추출하기 때문에 탄소배출량이 많음. 때문에 수소를 재생에너지로 생산해야 하는데, 비용. 기술적 한계가 있어서 나중에야 가능할 듯. 일단 사고 돈은 나중에… ‘BNPL’ 시장, 애플도 가세 → BNPL(Buy Now Pay Later) : 선 구매 후 지불 시스템. 소비자 대신 결제업체가 먼저 물건값을 가맹정에 전액 지불하고, 소비자는 일정 기간에 걸쳐 분할 납부하게되는 시스템. → 미국 전체 소매 업체의 85%가 애플페이를 쓰는데, 애플도 골드만삭스와 손을 잡고 ‘애플 페이 레이터’ BNPL 서비스를 출시했음. → 비판이 많음. ‘편리함’이 가계 부채로 이어질 수 있고, 신용등급에 상관없이 이용할 수 있기에 과소비 유발 및 납부를 하기 위해 대출을 하는 연결고리가 될 수 있다는 비판. → 경기가 나빠지면 BNPL이 BNPL(Buy Now Not Pay Later)가 될 수 있다고도 함. →한국은 쿠팡과 네이버가 ‘나중결제’ 서비스를 도입. 다만 신용카드 발급이 해외처럼 까다롭지 않고, 무이자 할부 서비스가 잘되어 있어서 해외만큼 활용하기 어렵다는 입장도 있고, 금융 규제에 따라 시장이 달라질 수 있다는 입장도 있다. 1분기 일자리, 2030 10만개 줄고 50대이상 40만개 늘었다. → 정부의 공공 일자리사업 등이 전개도면서 사회.복지.공공근로 부분을 중심으로 중장년층의 일자리가 늘음. 20대는 몰라용 원자재 비싸지자 경제성 타격, 환경오염까지… 되레 원자력 매력 부각시켜 → 친환경 에너지의 불안정한 공급성이 부각됨. 세계 최대 해상 풍력 발전 회사가 지역 평균풍속을 예상하여 발전시켰는데, 실제값은 평균보다 9.3%낮았음. 발전 결과 2500억원의 손실을 봄. 위와 같이 공급의 안정성 문제가 제기됨. → 재생에너지의 경우 대구모의 경우에만 원전보다 단가가 저렴하고, 원전의 경우 탄소배출량이 ‘0’에 가까움. 또한, 발전 단가가 낮아 조명받고 있음. 또한 SMR이라는 차세대 기술이 주목받고 있음. → 위로 인해서 낙관론과 비관론이 나뉘는 중. 낙관론 : 주가는 일시적인 것이고, 전례없는 투자가 진행되고있다. 비관론 : 기후의 불안정성, 생산비용 비싼 문제. 삼성 SDI 美진출 임박 배터리 경쟁구도 재편 → 현재 중국의 CATL과 한국의 LG에솔이 1위자리를 놓고 경쟁을 벌이고 있음. 삼성SDI는 5위 → LG에솔, SK이노는 미국에 셀 공장이 있지만, 삼성SDI는 미국에 공장이 없고, 유럽에 투자중인데 그마저도 괄목할 만한 수준은 아님. → 하지만 이번에 삼성SDI가 완성차 브랜드 스텔란티스와 합작법인(JV)을 설립하거나 독자적인 공장 신설을 통해 미국 진출을 현실화한다면 달라질 수도 있다는 관측. 빚투 시대 끝났다, 현급 비중 늘려라 → 기준금리 인상에 대한 기사. " }, { "title": "leetcode(리트코드)-409 Longest Palindrome(PYTHON)", "url": "/posts/leetcode_Longest_Palindrome/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-08-27 02:34:50 +0900", "snippet": "leetcode 409 - Longest Palindrome 문제입니다.1. 문제https://leetcode.com/problems/longest-palindrome/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 문자열s가 들어옵니다. 문자를 재조합할 때 가장 긴 Palindrome을 찾아 그 길이를 리턴합니다.5. codepythonclass Solution: def longestPalindrome(self, s: str) -&amp;gt; int: dic = {} for i in range(len(s)): if s[i] not in dic : dic[s[i]] = 1 else : dic[s[i]] += 1 check = False li = [] for counting in dic : if dic[counting] %2 == 1 : check = True li.append(dic[counting]) res = 0 for i in range(len(li)) : res += li[i] - (li[i] % 2) return res if check == False else res+1 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "Programmers_2017 카카오코드 예선 카카오프렌즈 컬러링북(c++)", "url": "/posts/Programmers_2017KAKAO01/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-08-27 01:34:40 +0900", "snippet": "프로그래머스 2017 카카오코드 예선 카카오프렌즈 컬러링북 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/18292. 분류 및 난이도Programmers 문제입니다.2017카카오코드 예선 문제입니다.Level 2난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) BFS나 DFS를 묻는 문제입니다. 구현방식만 알면 어렵지 않습니다.4. 접근 방법을 적용한 코드#include &amp;lt;vector&amp;gt;//BFS를 사용하기 위함.#include &amp;lt;queue&amp;gt;//max()함수를 사용하기위함.#include &amp;lt;algorithm&amp;gt;//입출력#include &amp;lt;iostream&amp;gt;using namespace std;//좌표이동int dx[4] = {0,0,1,-1};int dy[4] = {1,-1,0,0};// 전역 변수를 정의할 경우 함수 내에 초기화 코드를 꼭 작성해주세요.vector&amp;lt;int&amp;gt; solution(int m, int n, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; picture) { int number_of_area = 0; int max_size_of_one_area = 0; vector&amp;lt;int&amp;gt; answer(2); answer[0] = number_of_area; answer[1] = max_size_of_one_area; int row = picture.size(); int col = picture[0].size(); for(int i = 0; i &amp;lt; row; ++i){ for(int j = 0; j &amp;lt; col; ++j){ if(picture[i][j] != 0){ int res = 0; answer[0] += 1; int pr = picture[i][j]; //BFS queue&amp;lt;pair&amp;lt;int,int&amp;gt;&amp;gt; q; q.push(make_pair(i,j)); //방문처리는 0으로 바꿔주는걸로 합니다. 효율성 고려 while(!q.empty()){ int x = q.front().first; int y = q.front().second; q.pop(); for(int k = 0 ; k &amp;lt; 4; ++k){ int newx = x + dx[k]; int newy = y + dy[k]; if(0 &amp;lt;= newx and newx &amp;lt; row and 0 &amp;lt;= newy and newy &amp;lt; col and pr == picture[newx][newy]){ res += 1; q.push(make_pair(newx,newy)); picture[newx][newy] = 0; } } } answer[1] = max(answer[1],res); } } } return answer;}5. 결과필요시. python 짜드리겠습니다.설명이 필요시 댓글달아주세요." }, { "title": "2021.08.26(목).경제 정리노트", "url": "/posts/economy0826/", "categories": "Economy, DailyNote", "tags": "Economy", "date": "2021-08-26 03:50:50 +0900", "snippet": "2021.08.26 경제 헤드라인을 정리한 글입니다.부동산 관련, 청약 관련글에 대해서는 따로 정리하지 않습니다. 청약.대출규제 피한 지방, 초기분양률 100% 육박 → 2분기 작년 63 → 96%로 늘음. 청주, 아산, 포항 등 분양에 관심이 있음. “위드 코로나 수혜” … 에어비앤비 급등 → 3분기 사상 최대 매출 기대중임. → 위드 코로나 : 높은 백신 접종률을 선제 조건으로 코로나19와 공존이 불가피하다는 인식 아래 확진자 억제보다는 위중증환자 관리에 집중하는 방역 체계를 뜻함. “전산 개발 아직…” 전세대출 증액 안 된다는 카카오뱅크 → 이사철 앞두고 세입자들의 불만이 폭발하고 있음. → 상대적으로 금리가 낮아 카카오뱅크로 전세 대출을 받은 사람들이 집주인의 추가 보증금 요구 등으로 대출을 연장하려는데, 카카오뱅크측에서는 전입신고 새로 해야 대출이 가능하다고 함. → 결국 더 높은 금리를 가진 신용대출을 받아 차액을 메꿈. 암호화폐 거래소 63곳 중 24곳 ISMS 신청 안해 ‘줄폐업 예고’ → 필수 요건인데 절차를 안 밟음. 정부측에서는 “이용자 예치금 인출해야”라고 말함. → 미신청 24곳은 기사에 나와있습니다. 고승범(금융.위원장 후보자) “코인거래소 신고 기한 연장 안돼” → 국회 인사청문회 서면 답변 → “시장신뢰 확보 위해 일정 유지해야 암호화폐 금융자산 인정 어려워” - 현재 4곳(업비트, 빗썸, 코인원, 코빗)만 신고하여 독과점 체제가 조성될 것이 우려. → 최근 빅테크 기업(카카오, 네이버 등을 말하는 듯)이 금융권에 진출하여 빅데이터, 플랫폼 기반으로 과도하게 시장을 지배할 수 있으므로 합리적이고 공정하게 이 문제를 해결할 예정. → “머지 사태는 디지털 범죄행위 감독 규제 사각지대서 발생” 마이스 복합단지 효과 … 마곡 아파트값 ‘들썩’ → 마곡 아파트값 올랐다는 얘기 국민연금, 자산 900兆 돌파 33년간 500兆 넘게 벌었다. → 기금 자산 908조에서 상반기 운용 수익률 7.49%로 62조를 집계됨. → 국민연금 자산 중에서 국내채권 비중이 가장 높았음. 전체 자산의 37.6%인 341조원어치를 갖고 있음. 이어 해외주식(25.8%), 국내 주식(20.3%), 대체투자자(10.4%), 해외채권자(5.8%)순 年2% 대 신용대출 사라졌다 … 농협銀 한도 2억 → 1억 축소 → 은행 최저금리가 3%로 늘음. 시장금리가 급등하고 정부의 압박으로 이렇게 변한 것. → 농협은행도 신용대출을 연봉내로 축소할 것이고 타 은행들도 한도를 줄일 전망 → 고승범 “금리 소폭상승은 긍정적”이라고 말씀해 대출금리 더 오를 것 같다는 입장도나옴. “뛰는 우윳값 잡자” … 정부, 原乳가격체계 ‘손질’ → 8년만에 원유가격 연동제를 개편함. → 기존은 수요를 고려하지 않고 생산비 증가만을 반영하였는데, 수요를 고려하여 가격을 책정하는 등의 개편사항이 논의 되었음. → 미국과 유럽의 원유가 491원, 470원 정도인데 한국은 1083원정도로 비싼편이고, 국산 유제 점유율도 2001년 77.3%에 비해 48.1%로 많이 줄음. → 또한, 낙농가가 생산한 우유를 유업체가 모두 사들여야 하는 쿼터제도 수정을 검토하기로 함. 2002년 생산량 감축을 위해 쿼터제를 도입하였지만 생산량보다 쿼터량이 더 많은 상황이라 취지가 사라졌기 때문이다. 이 방향에 대해 낙농가는 이익이 사라져 ‘반대’, 소비자와 유업체는 ‘환영’ 하는중. 청약후 입주까지 최소 4~5년 … “수도권 집값 상승세 막기엔 역부족” → 25일 정부가 민간 아파트를 포함해 10만1000가구 규모의 추가 사전청약계획을 밝힘. → 하지만 청약후 입주까지 4~5년이 걸리기에 2030패닉바잉, 전세난 등이 해결될 지는 미지수라는 입장이 나오는 중. ‘거침없는’ 나스닥 박스권 갇힌 코스피 → 코로나 봉쇄로 외국인이 이탈하면서 한.미 증시 수익률 격차가 확대됨. “해외투자 이젠 선택 아닌 필수”라는 말도 나올정도 18~49세 1차 접종에 모더나 몰아주겠다는 정부 … 2차는 ‘나몰라라’ → 추석전 1차 접종률 70%를 맞추기 위해 1차에 모더나백신을 무리하게 배정시킴. 2차때는 “시나리오 없다. 그때 가서 고민”이라는게 정부의 입장. → 9월말까지 모더나 확보 안 되면 수백만명 ‘반쪽접종’ 초유의 사태가 벌어질 듯. → 백신1차접종 후 6주 이내로 2차 접종을 맞아야하는데, 물량을 확보하지 못한다면 델타변이에 취약해짐. 해외투자 ETF 순자산 12兆, 전년대비 2배 급증 → ETF에 순자산총액이 작년기준 2배로 늘음. 해외주식을 쉽게 투자할 수 있는게 장점인 ETF. 대표적인 해외형 ETF TIGER 차이나전기차 50% 오르며 증가율 3위, S&amp;amp;P도 증가율 5위를 기록. 널뛰는 팔라듐.백금값 … 반도체 자동차 감산 쇼크에 급락 → 팔라듐, 백금은 내연기관차의 정화장치 촉매제로 쓰임. 4 ~ 5월에는 세계 각국에서 온실가스 배출 기준을 강화하면서 이 원자재 값들이 급등을 했음. 수요가 많으니까. 하지만 슬슬 기업들이 내연기관차를 생산하지 않겠다(감산)을 발표하자 원자재 값들이 떨어지고 있음. 전기차는 이 원자재를 거의 쓰지 않는 것도 이유. 경북 안동서 2억원대 아파트 나온다 - ‘영무예다음’ 944가구 분양 태릉 6800가구. 과천 4300가구 공급 확정 … “주민 요구 적극 수렴” → 태릉지구가 규모 줄여 저밀도 개발을함. 정부과천청사 대신 대체지를 확보했음. 맥 못추는 韓증시 … 외국인 이달 6兆 팔아치워 → 美증시와 디커플링(비동조화)이 심화되고 있음. → 반도체 업황 피크아웃 우려와 테이퍼링을 앞두고 신흥국 매력이 떨어지고 반대로 미국은 테이퍼링, 아프간 사태 등으로 초강세를 나타내고 있음. 있는대로 끌어모아 16만가구 사전청약 →10번 기사와 비슷한 내용임. 2024년까지 10.1만 가구를 추가하겠다는 정부의 발표. 내년까지 진행되는 수도권 공공분양 아파트까지 더하면 16.3만 가구가 사전청약 ‘삼성 240兆 투자’ … 원익IPS, 한솔케미칼 웃는다 → 삼성이 240조를 투자하겠다고 함. 증권업계에서는 200조 정도가 반도체 산업에 투자될 것으로 예상함. → 비메모리 관련주를 주목해야 한다. 원익 IPS : 반도체 장비업체이고, 삼성전바가 지분 3.8%를 보유한 협력사. 기술적으로 난도가 높은 증착 분야에서 독보적인 경쟁력을 보유하고 있다는 것이 특징. 한솔케미칼 : 소재 분야에서 대장주로 꼽힘. 반도체용 소재인 과산화수소와 프리커서를 생사 → 삼성전자에 매출 비중이 높은 기업도 주목해야 한다. 하나머터리얼즈, 유니셈, 테스나, 네페스 등. 공통적으로 매출 비중의 40~50%가 삼성전자. “양주 고읍지구에 단독주택 지으세요” → LH, 71개 필지 추첨 공급 예정가격은 2.4억 ~ 3.8억 → 장점으로는 지구 북쪽에는 지하철 7호선 양주옥정역(예정) 2025년 개통 예정, 구리 ~ 포천 고속도로 및 3번국도 우회 도로, 수도권 제2외곽순환도로 등을 이용하면 잠심까지 40분, 강남까지 1시간내 도달 가능하다는 점. 필수품 뜨고 사치품 지고 … 美 소비 트렌드 변화가 주가 가른다. → 미국 소비자들이 이젠 재량소비제(자금에 여유가 있을 때 사는 소비재 자동차, 의류, 엔터테인먼트, 자동차, 레저용품 등)의 소비가 이제 주춤해짐 정부 보조금와 낮은 금리의 효력이 끝나가고 있기 때문. 이로 인해서 PC, 자동차, 스마트폰 등에 들어가는 반도체의 수요가 줄었다는 것도 볼 수 있다는 입장. 하지만, 국내는 D램의 주가가 떨어졌지만 애플, MS 등 완성품 업체의 주가가 견고하기에 의문이 있다는 입장도 있음. → 실제로 루이비통모엣헤네시, 케링, 에르메스, 리치몬트 등 럭셔리 업체의 시총이 줄어들고 있음. 소폭 반등했다가 다시 하락하고를 반복중 당국 “카드론도 매주 관리하라” 다중채무자 ‘급전 통로’ 막히나 → 카드론, 현금서비스, 리볼빙 합산 증가율이 금융당국에서 요구한 목표치(5~6%)를 넘어섰기 때문이다. → 7개사 카드론 잔액이 14.5% 급증하면서 제2금융권 가계부채가 ‘위험 수위’에 도달할 것으로 볼 수 있다는 분석이 있음. → 당국은 주 단위로 현황을 점검하고 있는데, 일부 카드사는 한도를 축소하거나 마케팅을 중단하기로 함. → 카드론과 캐피털사의 가계대출은 금융권 전체 대출의 4.4%에 불과하지만, 사용자의 65%가 다중채무자라는 점에서 가계부채의 약한 고리로 꼽히고 있음. ‘삼성 투자 수혜’ 아산 탕정면 오피스텔 844실 분양 → 삼성에서 대규모 투자를 진행하는 충남 아산시 삼디플 아산캠퍼스 인근에서 오피스텔이 나옴. 인천경제자유구역, 기업 유치 ‘활기’ → 신약 개발회사인 제넥신의 자회사 에스엘포젠이 인천경제자유구역청과 토지매매 계약을 지난 24일 체결. → 인천경제자유구역의 삼형제인 송도.청라. 영종 국제도시가 각각 차별화된 기업 유치에 성공을 거두고 있다. 송도 : 삼성바이오로직스, 셀트리온, SK바사 연구소들 청라 : 현대모비스(수소연료 전지관련 시설 착공) 영종 : 항공화물 관련 기업들 이스라엘 항공우주산업의 화물기 개조공장 다시 웃는 서학개미 … 美증시, 기업 87%(2분기 S&amp;amp;P기업) ‘깜짝 실적’에 연일 신고점 집값의 6 ~ 16% 내고 10년 거주 ‘누구나집’ 사업 9월부터 본격화 → 누구나집은 사전에 확정된 가격으로 무주택임차인에게 우선 분양을 약정하는 공공지원 민간임대주택. 집값의 6% : 거주권만 집값의 10% : 분양권만 보유 집값의 16% : 거주권과 분양권을 모두 받음. 10년간 임대료는 주변 시세의 80 ~ 85% 수준. 안정적인 소득원은 있지만 당장 집을 마련할 목돈이 없는 무주택자, 청년, 신호부부 등이 혜택을 볼 수 있을 전망. 다만 수익성이 낮아 민간 사업자의 참여가 낮을 수 있다는 지적. 또한, 향후 집값 하락으로 임차인이 분양전환을 포기하면 대규모 미분양 사태가 발생할 우려도 존재. ‘공공기획’ 도입한 신림 1구역 최대 29층 4250가구로 재개발 고철값 뛰는데 철광석은 급락 … ‘脫탄소’가 원자재 가격 뒤흔든다. → 친환경정책으로 인한 것. → 탄소배출량 감축을 위해 철광석 대신 고철을 사용하면서 나타남. → 리튬, 알루미늄 등 친환경 배터리를 생산하기 위한 원자재의 값은 급등하고 있음. 지독한 美 가뭄 … 주춤하던 농산물값 또 뛴다. → 제목 그대로 밀 농사 63%정도가 흉작이 예상되면서 선물가격이 12% 상승하고 옥수수. 콩 재고 8년만에 최저를 찍음. → 유럽도 폭염.산불로 황폐화가 진행중이고 스페인은 국토 20%가 사막화진행중임. " }, { "title": "Programmers_위클리챌린지 2주차 상호 평가(python)", "url": "/posts/Programmers_Week02/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-08-26 02:34:40 +0900", "snippet": "프로그래머스 위클리 챌린지 2주차 - 상호 평가 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/832012. 분류 및 난이도Programmers 문제입니다.위클리 챌린지 2주차 문제입니다.Level 1난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 어렵지 않습니다. 효율성을 고려하여 풀려했지만.. 전혀 만족스럽지 않은 코드가 탄생하였습니다. 4. 접근 방법을 적용한 코드def solution(scores): row = len(scores) col = len(scores[0]) answer = &quot;&quot; for i in range(col): countnum = [0] * 101 maxnum = 0 minnum = 101 sumnum = 0 mine = 0 res = 0 for j in range(row) : if i == j : mine = scores[j][i] maxnum = max(maxnum,scores[j][i]) minnum = min(minnum,scores[j][i]) sumnum += scores[j][i] countnum[scores[j][i]] += 1 if (mine == minnum or mine == maxnum) and countnum[mine] == 1 : res = (sumnum - mine) / (row-1) else : res = sumnum / row plus = 10 if res != 100 : plus = int(10 - res // 10) if plus &amp;gt; 4 and plus &amp;lt; 6: plus = 4 if plus &amp;gt; 5 : plus = 6 answer += chr(plus-1 + ord(&quot;A&quot;)) else : answer += &quot;A&quot; return answer5. 결과필요시. c++ 짜드리겠습니다. 설명이 필요시 댓글달아주세요." }, { "title": "leetcode(리트코드)-331 Verify Preorder Serialization of a Binary Tree(PYTHON)", "url": "/posts/leetcode_Verify_Preorder_Serialization_of_a_Binary_Tree/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-08-26 01:34:50 +0900", "snippet": "leetcode 331 - Verify Preorder Serialization of a Binary Tree 문제입니다.1. 문제https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.4. 문제 해석 str로 prorder를 시킨 Tree의 요소값들이 들어옵니다. 위의 정보를 가지고 이진트리를 구성할 수 있으면 True 아니면 False를 리턴하세요. discuss를 참조하였습니다. preorder를 기준으로 트리를 만들 때 빈 자식의 개수는 유효한 자식의 갯수 + 1이라는 사실을 이용한 코드입니다.5. codepythonclass Solution: def isValidSerialization(self, preorder: str) -&amp;gt; bool: tmp = preorder.split(&#39;,&#39;) slot = 1 for i in tmp : if slot == 0 : return False if i == &#39;#&#39; : slot -= 1 else : slot += 1 return True if slot ==0 else False 6. 결과 및 후기, 개선점 어떠한 규칙이 있을거라 생각했는데, 이런 규칙이 있는줄 몰랐네요.필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "2021.08.24(화).경제 정리노트", "url": "/posts/economy0824/", "categories": "Economy, DailyNote", "tags": "Economy", "date": "2021-08-24 04:50:50 +0900", "snippet": "2021.08.24 경제 헤드라인을 정리한 글입니다. 제도권 대출 틀어막자 사금융 기승 “은행 대신 ‘쩐주’ 모셔오겠다” → 대출을 막아버리니 당장 돈이 급한 사람들은 대부업을 통해 돈을 빌리는 사람이 늘어남. 하락장 탈피 vs 기술적 반등 … 코스피 어디로 한은에 맡긴 보증금 8조 풀려 은행들, 추가 자금여력 생겨 → 은행간 자금이체 담보 30조 이중 8.3조 유동성자금 인정. 시중銀 투자.대출 활용할듯. 실수요자 반발에 한발 물러선 금융당국 → 은행창구 상담 받느라 ‘북새통’ “입주 코앞인데 대출 어떻게” → 은행도 혼란 “명확한 지침 없어” → 금융위 “ 농협은행 제외한 시중은행은 지속적 대출할 것” → 때문에 우리은행은 4분기가 시작되는 10월부터 재개할 것 천안 오룡경기장 땅에 복합단지 민관협력형 도시재생 1호 사업 ‘상가 부담금’ 폭탄이 재건축 최대 걸림돌 → 재건축부담금 : 종료시점 집값 - (개시시점 집값 + 정상 집값 상승분 총액 + 개발비용) * 부과율 → 여기서 개시시점 집값이 오로지 ‘주택’ 가격만 따짐. 상가가치는 계산하는 과정에서 빠져서 이로인해서 문제가 발생함. → 초과이익환수제 부담금이 확 늘어나게 되면서 상가조합원이 주택조합원보다 더 많은 부담금을 내야함. 상가조합원은 평균 5700만원이었는데, 상가조합원은 3억원에 육박하는 것으로 나타남. → 정부도 개선 필요성을 알고 있지만 관련법안 국회서 수년째 ‘낮잠’문정도136 재건축사업 헛바퀴돌음. ‘합병 발표’ SK - SK머티리얼즈 … “주가 같이 뛴다” → SK㈜, 발표후 장중 9% 치솟고, 머티리얼즈도 2% 동반 상승 “합병전까지 비슷하게 움직일 듯” → SK그룹 지주사인 SK와 반도체2차전지 소재자회사인 SK머티리얼즈의 분할.합병 소식에 따라 두 회사 주가가 동반 상승함. → SK주주들은 호재라하고 SK머티리얼즈 주주들은 불안해함. 배당금은 늘어나도 순수 정보기술(IT)소재업체로서의 성장성이 희석되었기 때문. → 하지만 SK머티리얼즈과 SK 합병비율이 1대1.58이여서 주식 1주를 SK 주식1.58주로 바꿔줌. 때문에 합변전까진 주가가 비슷하게 움직일 수 있다고 함. 그래도 불안은 사라지지 않는 중. 흑석2.신설1.금호23 비대위 “ 공공재개발 후보지 빼달라” → 상가 소유자 등 시청앞 집회 마성건영, 공공재건축 ‘포기’ → 상가 소유자들이 개발이 진행되는 동안 임대료를 받지 못해 생계를 이어갈 수 없다며 반대. 당국 ‘연체관리 취약지대’ 카드론도 조인다 → 사람들이 이제 카드론을 통해 대출을 하기 시작하니 정부가 규제를 하겠다고 함. → 카드론이 2020년 상반기 잔액이 22조에서 2021년 상반기 잔액이 24조로 11%가 늘었기 때문임. → 카드론은 금리가 시중은행에 4배(12~13%)에 달하고 최대 대출한도가 적지만 아직 규제가 가해지지 않았기에 다중채무자가 많음. → 당국이 조치를 취할 듯. 팬데믹에 악화일로 … 파월 ‘소득 불평등’ 경고한다 → 미국 연방준비제도의 잭스홀 회의에 시장의 주목하고 있음. 테이퍼링에 관한 것 때문. → 반면 테이퍼링과 관련해서 이번 잭슨홀 회의가 예상보다 큰 변수로 작용하지 않을 것이라는 해석도 있음. 뱅크오브아메리카(BoA)는 “수많은 의견이 나오는 와중에 파월 의장이 9월 FOMC(연방공개시장위원회) 회의를 미리 열고싶어 하지 않을 것”이라고 함. 또한 테이퍼링보다 경제 불편 등에 대한 발언이 시장에 더 큰 영향을 미칠 수 있다는 전망을 내놓고 있음. 올 최고가 거래 아파트는 청담 ‘PH129’ → 전용 273m^2 115억 안전진단 미루는 서울 재건축 … “내년 대선 뒤에 보자” → 재건축을 하기 위해서는 안전진단을 해야하는데, 기존에 빠르게 진행하던 양상과 달리 안전진단을 미루고 있음. → 이번 정부에서는 재건축을 막기때문에 어차피 해도 안 될것이라는 생각때문임. → 해서 안되면 다시 도전하는데 드는 비용과 시간이 있기에 다음 대선때 하자는 것. → 37년 노후된 노원구 ‘태릉우성’아파트도 안전진단검사에 탈락하자 많은 노후아파트들이 적지 않은 충격을 받았다. 코오롱글로벌, 주택.풍력 ‘두 토끼’잡는다. → 대전.강릉서 내달 ‘하늘채’ 2100가구 분양 … 풍력발전 ‘10년투자’결실 → 올해 사상최대 1만가구 착공한다는 내용과 풍력발전 시장 점유율 1위라는 내용 재테크 제3의 물결 ‘글로벌 투자’ → 주식투자자 1000만명 시대, 이제 국내뿐만 아니라 해외주식에도 눈을 들이고 있음. → 상대적으로 외부 충격에 약한 국내시장에 비해 견고한 해외주식을 사는 사람들이 많아짐. 최근 주식조정에 영향을 받은 것도 있음. 많이 떨어진 삼성물산.기아 … 보텀피싱(저점매수) 언제쯤? → 증권사가 추천하는 종목을 알려주는 내용. 그러려니 하고 넘어갔음. “광주 상무지구, 판교처럼 탈바꿈” → 제2테크노벨리 모델로 삼아 산업.주거.문화 인프라 조성할 듯. 금융위 톱3, 알고보니 ‘가계부채 저승사자’ → 금융위에서 고승범 금융위원장 후보자를 비롯해 부위원장, 사무처장 등 금융위 넘버 1 ~ 3이 모두 가계부채 ‘저승사자’로 이름을 날림. → 고 후보자는 2005년 최초로 총부채상환비율(DTI) 개념을 도입한 장본인이다. DTI : 주담대에서 연간 상환해야 하는 금액을 연 소득의 일정 비율로 제한한 것. 상대적으로 관리가 느슨했던 제2금융권에 대해 엄격한 관리의 토대를 마련했다는 평가. → 도규상 부위원장은 2016년 국장 재임 시절 집단대출에 총부채원리금상환비율(DSR)을 처음으로 지표로 활용하도록 했음. → 이세훈 사무처장은 국장으로 일할 때 15억원 초과 아파트 구입 목적의 주담대를 금지한 주역. → 금융권 관계자는 현재 최대 난제인 가계부채 문제를 해결하겠다는 것으로 풀이된다. → 과거 전례를 감안하면 앞으로 가계부채 대책은 강도가 높으면서도 촘촘한 그물망식이 될 듯하다고 말함. 소득없는 고령자 종부세 납부유예 결국 ‘없던 일’로 → 종부세 과세이연을 없애버림. → 종부세 과세이연은 소득이 없는 고령자를 위해 만들어져서 종부세를 주택처분시점까지 연기해주는 제도임. → 외에도 공정가액 비율 하향 논의도 중단되었고 26개의 대안이 폐기되어 납세자들이 혼란스러워함. 정부, 결국 고용보험료 인상 방침 → “근복적인 건전화 방안 필요” 이르면 내달 중 노사정 논의 ‘영끌’ 2030 대출규제 직격탄 … “금융 사다리 걷어차나” 부글부글 → 많이 나온 기사내용. 2030이 내집마련 막차를 타기 위해서 대출을 엄청 하는 중. 1년새 0.5%p ‘쑥’ … 보험사 주담대 금리도 뛴다. → 금융당국을 의식해서인지 보험사들의 주담대 금리가 야금야금 오르고 있음. → 보험사 대출은 보험에 가입하지 않아도 신청할 수 있지만, 보험을 많이 들면 우대금리를 받을 수 있음. 과천 ‘린 파밀리에’ 오늘 1순위 청약 → 분양가는 8억중반정도 1순위는 과천시 2년 이상 거주자(30%), 2순위는 경기도 2년 이상(20%) 거주자 나머지 (50%)를 가져감. 외국인 팔 만큼 팔았나 코스피 장중 3100선 회복 고령자 종부세 납부연기 없던 일로 … 또 정책 뒤집기 →18번 기사와 같은 내용 오늘 G7 아프간 회의 美 철수시한 연장 논의 → 피란민 수용 확대 해법 주목 → 영국은 이번 회의에서 탈레반에 들이댈 ‘채찍’을 마련하는 데 주력할 전망. 영국은 올해 G7 정상회의 의장국. 미국은 탈레반에 대한 제재.압박 기조에는 공감하지만 시기 등에 대해서 다소 유보적임. → 바이든 대통령은 지지부진한 아프간 철수 작전의 속도를 높일 방안을 만들어내는 것이 회의의 최우선 목표. 구체적으로는 미국이 이달 말로 제시했던 미군 철수 사한을 연장하는 문제가 회의 테이블에 오를 개연성이 큼. → 함께한 아프간 협력자 상당수 중 한국 이주를 희망하는 분이 있어 우리나라로 이동하는 방법에 대해 韓정부도 여러가지 고민을 하고 있음. → 8월31일까지 아프간 대피 기한 연장을 검토중이라고 밝힌 것과 관련해, 탈레반은 기존 마감 시한을 지켜야한다고 강조. 탈레반은 미군과 영국군이 예정 날짜까지 철수를 끝내야 한다고 말함. 표본 2배 늘렸다지만 … 통계정보 공개엔 한계 여전 → 집값 자료 비공개를 고집함. 비정상 거래의 집중 타깃이 될 수 있기 때문임. → 서울 아파트 시세가 순식간에 약 20% 급등했는데, 부동산원이 최근 내놓은 7월 집값 통계에 실거래가를 반영하지 못한다는 지적임. → 또한, 아파트 조사대상이 3.7만채에서 7.8채로 2배가량 늘렸는데 조사원은 기존 300명에서 25명만 추가되어 업무과중도 논라이 되고 있음. ‘빚투’ 25兆 … 증권담보대출 일시중단 → 한투,NH 신규 대출 금지 요건 충족땐 만기 연장은 가능함. → 신용공여 한도 소진으로 증권담보대출을 일시 중단하고 있음. → 신용융자는 아직 가능함. 증권사 돈으로 주식을 매입하는 것을 신용융자라고 함. “데이터로 대출 길 터준다” …. 소상공인 신용평가 사업 키우는 IT기업 → 카뱅 : 한국신용데이터와 손잡고 개인사업자 CB 예비허가 신청함. → 네이버 : 스마트스토어 대출 운영하여 출시 6개월 만에 500억원 돌파함. → 네이버파이낸셜 : 미래에셋캐피탈과 협업해 신용평가모델을 활용하고 있음. 네이버파이낸셜이 금융사가 아니기에 직접 대출이 불가하여 미래에셋케피탈이 받은 고객을 네이버파이낸셜 자체 신용 평가 모델을 통해 심사하고, 결과를 전달받은 미래에셋케피탈이 한도와 금리를 정해 대출해주는 방식. → KT : 연내 점포 신용평가 서비스를 출시할 예정. 또한, 소상공인 대출 사업 및 소상공인 상권분석 서비스 ‘잘나가게’를 기반으로 운영할 예정. " }, { "title": "leetcode(리트코드)-537 Complex Number Multiplication(PYTHON)", "url": "/posts/leetocde_Complex_Number_Multiplication/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-08-24 03:34:50 +0900", "snippet": "leetcode 537 - Complex Number Multiplication 문제입니다.1. 문제https://leetcode.com/problems/complex-number-multiplication/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.4. 문제 해석 str로 복소수가 2개 들어옵니다. 두 str로 이루어진 복소수를 곱한 결과를 str자료형으로 리턴하세요.5. code코드설명pythonclass Solution: def complexNumberMultiply(self, num1: str, num2: str) -&amp;gt; str: idx1 = num1.index(&#39;+&#39;) idx2 = num2.index(&#39;+&#39;) real1 = num1[:idx1] real2 = num2[:idx2] imag1 = num1[idx1+1:num1.find(&#39;i&#39;)] imag2 = num2[idx2+1:num2.find(&#39;i&#39;)] num1 = complex(int(real1),int(imag1)) num2 = complex(int(real2),int(imag2)) res = num1 * num2 temp = &quot;&quot; if res.real == 0 : temp += &quot;0+&quot; else : temp += str(res.real)[:-2] + &quot;+&quot; temp += str(res.imag)[:-2] + &quot;i&quot; return temp6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "leetcode(리트코드)-1572 Matrix Diagonal Sum(PYTHON)", "url": "/posts/leetcode_Matrix_Diagonal_Sum/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-08-24 02:34:50 +0900", "snippet": "leetcode 1572 - Matrix Diagonal Sum 문제입니다.1. 문제https://leetcode.com/problems/matrix-diagonal-sum/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 matrix가 주어집니다. 대각선으로 합한 결과를 구하세요. 단, 중복은 제외합니다.5. code코드설명pythonclass Solution: def diagonalSum(self, mat: List[List[int]]) -&amp;gt; int: sz = len(mat) res = 0 for i in range(sz) : res += mat[i][i] + mat[i][sz-i-1] return res if sz % 2 == 0 else res - mat[sz//2][sz//2]6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "Programmers_위클리챌린지 1주차 부족한 금액 계산하기(python)", "url": "/posts/Programmers_Weekly01/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-08-24 01:34:40 +0900", "snippet": "프로그래머스 위클리 챌린지 1주차 - 부족한 금액 계산하기 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/826122. 분류 및 난이도Programmers 문제입니다.위클리 챌린지 1주차 문제입니다.Level 1난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 어렵지 않습니다. 효율성을 고려해서 등차수열 합계산을 이용하여 풀었습니다. 4. 접근 방법을 적용한 코드def solution(price, money, count): result = money - price * (count * (count + 1) // 2) return 0 if result &amp;gt;0 else abs(result)5. 결과필요시. c++ 짜드리겠습니다. 설명이 필요시 댓글달아주세요." }, { "title": "2021.08.23(월).경제 정리노트", "url": "/posts/economy0823/", "categories": "Economy, DailyNote", "tags": "Economy", "date": "2021-08-23 04:50:50 +0900", "snippet": "2021.08.23 경제 헤드라인을 정리한 글입니다. 나스닥 투자하고 TDF(타깃데이트펀드)로 자산배분 … 퇴직연금 수익률 날았다. → 상위 10% 연금투자 고수들 평균수익률 30% 육박 성과, AB미국그로스, 피델리티펀드 美기술주로 최고 年40% 수익, 나스닥100ETF 23% 겅가 전기차, 2차전지 테마도 각광받는 중. ‘닥터 키퍼’의 귀환 … LS니꼬동, 풍산 극심한 온도차 왜 ? → 구리값이 오르면서 두 기업의 영업이익이 편차가 커짐. → LS니꼬동 : 제련업체. 국내 유일한 제련업체인데, 중국과 가격경쟁에 따른 제련수익이 하락했다. 스마트팩토리로 원가 절감에 총력을 다해 위기를 벗어나겠다는 포부를 밝힘.(작년 2285 올해 2000 ~ 2500예상) → 풍산 : 금속판, 봉, 동전 가공하는데 전기동의 값이 급등함에 따라 쌓아둔 재고가 그대로 재고자산 차익에 반영됨. 이로 인해서 영업이익이 많이 올랐다.(작년 1212 → 올해 2500이상예상) 신냉전이 쏘아올린 中日 ‘군비증강戰’ → 미국에 열세를 느낀 중국이 핵전력 보강에 나섬. (현재 미국의 5%정도임.) → 또한 중국과의 격차가 점점 벌어져 위기의식을 느낀 일본이 방위비를 사상최대로 늘려 군비보강에 나섬. “자격미달 암호화폐 거래소 쏟아져 … 투자자 속 탄다” → 9월25일 특금법 시행되면 대다수의 암호화폐거래소가 문을 닫을 예정. → 문을 안듣으려면 두가지 요건을 충족해야함. ISMS(개인정보보호관리체계) 인증을 받아야함. 실명확인 입출금계정 서비스. 범죄예방을 위해 진행하는 것인데, 대부분의 암호화폐거래소가 이 부분이 진행되지 않고 있다. → 위 두가지를 총족해도 안심할 수 없음. 지적 사안을 보완하지 못하면 가상자산사업자 신고를 거부당할 수 있음. → 중소거래소에 있는 돈은 빠르게 다른 거래소 이관하거나 빼야함. 중소거래소가 폐쇄를 선언하면 예치금 등을 무작정 반환하지 않아도 투자자가 직접 소송을 제기하는 것 외에는 보상받을 방법이 없음. 거래절벽 와중에도 … 초저가 아파트 거래폭발 → 전국 아파트 매매가 9%감소했지만, 1.5억미만 거래는 20%가 올랐음. ‘부부 공동노력’인정 … 배우자, 최대 30억까지 상속세 안 낸다. → 이해하기 어려워서 정리 못하겠다. 찾아봐주세요. 美 방어주 ETF 뜬다 … 연말까지 돈 묻어둘 상품은? → ETF에 많은사람들이 유입되고 있음. 방어주 ETF는 주식시장의 변동성이 커지거나 경기 침체기에도 상대적으로 안정적으로 수입을 내는 상품임. → 델타변이 확산과 중국, 아프간 변수에 투자자들이 방어적인 모습을 보여 많은 투자자드리 유입된다고 추정. 아직 바닥 아냐, 현금비중 확대 vs 테이퍼링 공식화땐 반등 가능 → 주식시장에서 지금이 저점이냐 vs 아니냐에 대한 내용 → 저점이 아니다 : 미국의 시장이 생각보다 좋지않다. 코로나가 재확산 되면서 1.1% 정도 소매판매가 줄음. → 저점이다. : 미국이 테이퍼링을 공식화하면 불확실성이 해소되면서 주가가 반등할 수 있다. 수직증축 리모델링 수익성 좋지만 … 문제는 ‘규제 허들’ → 리모델링을 하는 방식은 크게 3가지가 있다. 수직증축 : 아파트 층을 3개정도 늘림. 수익성이 좋지만, 늘어나는 하중에 따라 안정성이 떨어져 안정성 검토 과정을 통과하기 어려움. 검토과정이 오래걸리기 때문이다. 국내에는 서울 송파구 성지아파트만 검토과정을 통과했음. 수평증축 : 아파트를 앞 뒤 혹은 옆으로 늘림. 별동증축 : 단지 내 부지에 별개의 동을 새로 지음. 보통 수평증축과 함께 진행, 수익성은 수직증축에 비해 떨어짐. → 수직증축의 규제를 완화해서 수익성을 개선해야 리모델링이 활성화가 가능하다고 목소리가 나오고 있다. 머리띠 대신 SNS로 뭉치는 2030노조 .. “돈도 좋지만 워라밸” → SK이노 : 4조 3교대를 4조 2교대로 바꾸자는 것을 논의. 근무시간이 늘어나지만, 휴무일이 기존에 비해 80일정도 늘음. → 현대차 : 임단협 교섭에서입사 후 1년 뒤 첫 차를 구입하면 찻값의 20%를 할인해주기로함. 기존에는 근속 25년 이상이어야 30% 그 밑은 10%을 할인해주었음. 또한 울산공장의 노후사택에 1000억을 투자해 1인1실 기숙사로 개조하기로 했음. 생산직 40,50대 위즈의 노조가 MZ세대 목소리를 반영하기 시작한 결과. → MZ세대의 노조들은 보통 온라인중심의 활동. 돈보다는 워라밸을 추구하고 물리적 농성보단 실용적 소통을 중시한다는 것이 특징이다. 주민 원해도 해임 못해 … ‘언터쳐블’ 입대회(입주자대표회의) → 입대회의 관리비가 늘어나면서 권한도 늘어났는데, 비리도 늘어났음. → 비리를 의식해 해임을 하기 위해서는 입주민의 10분의 1이상이 투표에 참여해 과반수가 찬성하면 입대회 회장을 해임할 수 있다. 하지만! 입주민의 동의를 얻더라도 선관위 판단에 따라 해임되지 않는 곳이 많음. 선관위가 아파트 관리규약상 해임 사유가 아니라고 판단하면 입주자는 해임 투표조차 시작할 수 없음. 규제 강화에 치솟는 대출 금리 … ‘모바일 주담대’로 갈아타볼까 → 은행들이 비대면 주담대를 강화하고 있음. → 코로나의 영향이 있겠지만, 디지털 기술이 발전하면서 이러한 현상이 나타남. 우리은행, kb국민은행 등 서비스를 확장하고 있으며 카뱅, 토스뱅크 등 핀테크 기업들도 확장 중임. 동남아 봉쇄령에 공급망 ‘흔들’ … 소비마저 꺾여 기업실적 ‘경고등’ → 동남아의 주정부가 델타 바이러스 확산으로 인해 기업에 규제를 가하고 있음. → 규제 중 하나는 직원들의 이동을 금지하고 회사가 숙식을 제공하라인데, 비용이 너무 많이 발생하여 공장 가동률 등을 줄여야함. 어떤 중소기업은 그냥 문을 닫아버림. → 또한, 펜트업효과(눌러있던 소비욕구를 폭발)가 약발이 떨어지면서 영업이익이 감소할 것으로 예상. 델타변이에 ‘테이퍼링 속도조절론’ 급부상 → 코로나19 델타 변이 바이러스 확산에 따라 하반기에 미국 경기가 둔화될 가능성이 제기되자 Fed(연준)내에서 유동성 공급 축소 일정에 신중을 가해야 한다는 목소리가 나오고 있음. → 고용시장이 현재와 같다면 무리 없이 테이퍼링이 진행되겠지만, 고용시장 회복세가 꺾인 것으로 확인되면 연준의 판단이 달라질 것으로 예상. → 골드만삭스는 18일에 미국 성장률 전망치를 6.4%에서 6.0%로 하향 조정했음. 한도 20% 줄이고, 이자 30% 더 내야 대출연장 … 영끝, 빚투족 ‘패닉’ → 주담대에 이어 신용대출 죄기 본격화에 나섬. → 대출 한도를 줄이고 금리를 올려버림. → 기존에는 은행 대출이 막히면 이자를 더 내고 2금융을 이용할 수 있었지만, 이 고리가 끊어질 수 있음. 대부분이 자영업자여서 큰 혼란을 받을 것이라고 예상. 주된 이용계층인 중.저 신용자들의 ‘대출 절벽’도 현실화할 수 있다는 의미. → 또한 대출이자가 늘어나면서 자산가격 변동성이 생길 것이라고 예고(필자는 이해를 잘 못함.) 금융시스템에 큰 부담을 줄 수 있다고 함. 증시 급락에 개인 주식투자 불안 … 다시 ‘펀드의 시간’ → 제목 그대로 증시가 급락하자 펀드를 하는 투자자들이 많이 유입되고 있다는 내용이다. 자녀 교육비, 투자 목적으로 쓰이면 증여세 부과 → 애매한 부분들이 있음. 크게 두 가지 경우에는 증여세가 과세될 수 잇음. 자녀가 자력으로 생활을 유지할 수 있는데도 교육비를 주는 경우. 조부모가 경제적 능력이 있는 자녀의 피부양자인 손자녀에게 교육비를 지원해주는 경우. → 자녀 교육비라고 해서 무조건 증여세과 비과세되는 게 아니라는 점에 유의하자. 지구온도 낮추려니 물가가 펄펄 끓는다 … ‘탄소제로’의 역설 → 탈탄소를 하려면 금속 원자재 생산과정에서 화석연료 사용과 탄소배출이 불가피함. → 금속 원자재는 친환경 에너지를 구축하기 위해 필요함. 때문에 온실가스 배출을 축소하는 과정에서 모순이 발생해버림. → 또한, 전기차 등을 만드는 데 필수 원자재인 구리, 알루미늄 등 금속 가격이 오르는 ‘그린플레이션’ 현상이 나타남. 녹색경제를 달성하는 과정에서 발생하는 원자재 가격 급등을 의미. 조선, 제철 ‘그린인플레’ 치명타 … 발빼는 큰손들 → 온실가스 배출많은 산업군 고강도 규제에 주가도 출렁이는 중. → 조선 업종 등이 친환경 정책에 따른 불확실성이 높은 산업으로 잡혀 주가가 떨어지는 중. 탈레반 이어 IS테러 위협까지 … 美 “카불공항도 안전지대 아니다” → 카불공항이 잠재적 위협이 도사리고 있음. 탈레반이 장악하여 검문을 하고 있다. → 탈레반이 미국인을 구타했다는 보고까지 들어가면서 미국이 민간 항공기, 헬기 등을 이용해서 미국인과 아프간 난민들을 태우는 중. → 알카에다가 탈레반에 축하메시지를 보내거나, 아프간 전 대통령의 친동생이 탈레반에 충성을 맹세하는 등 양상을 보이는 중. 최저임금 올린 뒤 세금으로 달래는 정부 → 최저임금을 가파르게 올린 보완 조치로 내년에도 ‘일자리안정자금’을 유지하기로 했음. → 올해까지만 집행하고 폐지할 방침이었지만, 내년에도 최저임금을 올리기로 한 뒤 민심이 싸늘해지고 코로나19로 인한 소상공인의 불만이 커진것에 대한 조치. → 하지만 예산이 너무 적어 임금인상기업에 실질적인 도움이 되지 못해 ‘병 주고 약 주는 임시처방’이라는 비판이 나옴. → 이 방식 직원 30명이 안 되는 기업과 소상공인 등에게 직원 월급 일부를 세금으로 직접지원하는 것인데 예산이 4000억원 정도로 직원 1인당 한달에 1~2만원만 지원받게 되는 수준으로 왜 이 사업을 고집하는 지 의문이라는 목소리가 커지고 있음. → 한국 노동시장의 40% 가까이를 자영업자가 차지하고 있기에 이정도 예산안은 표를 얻기위한 의도로밖에 해석되지 않는다는 말도 나오고 있음. “전세 가뭄에 단비” … 서울 새 아파트 1만518가구 연내 집들이 → 서울의 전세난이 해소되지 않고 있음. 전세 매물 줄고 가격은 오르는 중 → 와중에 대단지 입주에 관심을 가져야하는데, 신규 입주이기에 이전 세입자가 없어서 바로 이사가 가능하다는 점. 통상 주변 시세 대비 저렴한 가격에 계약할 수 있다는 점. → 입주 초 잔금 마련에 어려움을 겪는 경우가 많은데, 부족한 분양 잔금을 처리하기 위해 주변 단지 시세보다 저렴하게 전세계약을 체결하고 2년 또는 4년뒤에 전세가를 올림. → 대단지의 경우 수요자 대비 공급의 물량이 많아 시장의 원리에 따라 전셋값이 일시적으로 낮아지는 경우가 많음. 원주 꼬마아파트 3주새 41채 동나…“외지인이 싹쓸이” → 기사 제목 그대로 50대이하 1차접종에 모더나 늘려 … ‘추석전 70%’(1차접종 완료) 속도 → 모더나 백신이 2주간 700만회분이 들어올 예정. → 또한 루미니아에서 사용 기한이 얼마 남지 않은 모더나 백신을 들여오는 방안도 추진중. → 4000만회분 도입계약을 맺은 노바백스 백신도 세계보건기구의 긴급사용승인 절차를 밟고있는 중. → 모더나는 현재 계약 물량의 6%수준인 245만회분만 들어온 상태. 이달 안에 915만회분이 들어와야 하지만 생산 차질을 밎었던 모더나 측은 이달에 450만회분을 줄 수 있다는 입장. 수요처 늘린 삼성전기 … 삼성전자 의존 절반 ‘뚝’ → 2019년 상반기 기준 삼성전기라는 계열사의 매출의 절반(50%)이 삼성전자가 차지했는데, 그 절반인 25%로 떨어짐. → 샤오미에 스마트폰용 카메라 모듈과 MLCC를 공급하는데 샤오미의 매출이 늘면서 삼성전기의 매출도 오른 것. → MLCC : 전기를 저장했다가 필요시 반도체 등에 일정하게 공급하는 역할을 하는 부품으로 스마트폰, 태블릿, 자동차 등 다양한 제품에 들어감. 애플에도 대거 납품하는 것으로 알려져 삼성전기의 매출이 모회사에 의존적이지 않게 되고 있음. → MLCC 시장은 더욱 성장할 것이므로 삼성전기의 모회사 의존성이 점점 떨어지면서 성장세를 보이는 중. → 삼성전기는 “특정 고객사에 과도하게 매출을 의존할 경우 변동성에 따른 리스크가 커지는 만큼 지속적으로 거래처 다변화를 위해 노력하겠다”고 말함. 아파트 꽁꽁 묶자 ‘꼬마 빌딩’ 활활 … 50억 밑 매물 씨 말랐다. → 많은 기사에서 다룬 내용. 제목 그대로 국민.신한銀 대출한도 여유 있지만 … 가수요 급증땐 안심 못해 → 위 은행들이 대출을 막아버림. 안해주니까 사람들이 다른 은행에 쏠리고 대출문이 닫히기 전에 대출을 하자는 생각으로 대출자들이 늘어 혼란이 늘고 있음. → 때문에 실수요자들이 피해를 입을 수 있다며 다른 규제가 필요하다는 것. → 어떤 사람은 집 들어갈 때 계산하여 전세 만기때 대출을 하여 집을 구매할 예정이었으나 대출규제 때문에 다른집으로 가야하는 상황 등 여러 상황등이 있어버림. 현대제철 ‘제2 인국공’우려 … “본사 직고용? 경쟁뚫은 우린 뭐냐” → 현대제철이 자회사를 3개 설립하는데, 직원들을 협력사직원들을 고용할 예정. → 현대제철 정규직의 80%의 혜택을 받는데, 본사직원들은 불공정 하다고 주장하고 있음 → 원만한 회사 출범에 지장을 초래할 것을 우려, 자회사를 통한 채용은 판결을 회피하기 위한 꼼수, 향후 자회사 임김 줄이기를 통한 구조조정에 나설 수 있다고 주장하는 것으로 전해짐. → 현대제철 관계자는 “자회사 채용은 고용노동부에서도 적법한 구조라고 인정하고 있는 방식”,”구조조정 가능성이 높아지는 것이 아니라 오히려 구용 안정성을 높이는 조치”라고 설명. 반대매매(증권사가 주식 강제처분 하는 것) 13년만에 최대, ‘개미지옥’ 되나 → 국내 주가 하락세가 거세지자 난리가 난 상황. 2030 “취업 대신 창업 직진” 프랜차이즈업계 ‘큰손’ 됐다. → 소규모.비대면 1인 창업이 대세가 되었음. 탁자와 의자 등을 빼면서 초기 창업비용이 20%가 줄었기 때문이다. → 위의 이유와 더불어 바늘구멍보다 좁은 취업문을 통과하는 대신 창업을 하는 2030세대들이 늘고 있음. → 본도시락 30대 개업이 11%가 늘고 BBQ 배달매장의 절반이 ‘청년’이다. → BBQ가 bsk(BBQ의 배달.포장 전문매장) 창업 지원 프로젝트(청년 스마을 프로젝트)를 열었는데, 7000명이 넘는 지원자가 몰림. ‘청년 스마일 프로젝트’ : 초기 운영 자금과 매장 인테리어 비용 등 약 8000만원을 지원해주는 사업 " }, { "title": "leetcode(리트코드)-1464 Maximum Product of Two Elements in an Array(PYTHON)", "url": "/posts/leetcode_Maximum_Product_of_Two_Elements_in_an_Array/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-08-23 03:34:50 +0900", "snippet": "leetcode 1464 - Maximum Product of Two Elements in an Array 문제입니다.1. 문제https://leetcode.com/problems/maximum-product-of-two-elements-in-an-array/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 array가 들어옵니다. 가장 큰값과 두 번째로 큰 값을 찾아 각 값 - 1을 곱한 결과를 리턴하세요.5. code코드설명 정렬해서 요소 두개 곱하기pythonclass Solution: def maxProduct(self, nums: List[int]) -&amp;gt; int: nums.sort() return (nums[-1]-1) * (nums[-2] - 1)6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "leetcode(리트코드)-653 Two Sum IV - Input is a BST(PYTHON)", "url": "/posts/leetcode_Two_Sum_IV_-_Input_is_a_BST/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-08-23 02:34:50 +0900", "snippet": "leetcode 653 - Two Sum IV - Input is a BST 문제입니다.1. 문제https://leetcode.com/problems/two-sum-iv-input-is-a-bst/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 Tree가 주어집니다. 트리에서 2개의 요소를 고를 때 그 합이 k와 같은 요소가 존재한다면 True를, 없으면 False를 리턴하세요.5. code코드설명 탐색하면서 해당 값이 존재하는 지 찾는 알고리즘을 작성하면 더 빠르게 결과가 나오겠지만, 비슷한 문제는 많으므로 이 코드에서 고치진 않겠습니다. Eazy는 Eazy하게 빠르게 푸는 것.!!python# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def findTarget(self, root: Optional[TreeNode], k: int) -&amp;gt; bool: dic = {} def dfs(root): if root : dic[root.val] = 1 dfs(root.left) dfs(root.right) dfs(root) if len(dic) == 1 : return False for i in dic : if k - i != i and (k - i in dic) : return True return False 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "Programmers_위클리챌린지 4주차 직업군 추천하기(python)", "url": "/posts/Programmers_WeekChallenge04/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-08-23 01:34:40 +0900", "snippet": "프로그래머스 위클리 챌린지 4주차 - 직업군 추천하기 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/843252. 분류 및 난이도Programmers 문제입니다.위클리 챌린지 4주차 문제입니다.Level 1난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 어렵지는 않지만 자료구조에 대해 여러가지 생각을 할 수 있게끔 도와주는 좋은 문제인 것 같습니다. 자료의 크기가 크지 않아서 푸는데 지장은 없지만 테이블의 크기가 1만개가 넘는다면 어떻게 최적화할 지 생각하여 코드를 작성하게 되었습니다. 4. 접근 방법을 적용한 코드def solution(table, languages, preference): answer = &#39;&#39; maxres = [] maxnum = 0 for i in range(len(table)): sumnum = 0 # 공백을 기준으로 분리합니다. 점수를 확인하기 쉽게 인덱스로 나누었습니다. templist = table[i].split(&#39; &#39;) for j in range(len(languages)): score = 0 try : # 테이블이 5개만 들어오기에 6 - 찾은 인덱스를 해줍니다. 6인 이유는 처음에 SI, GAME 등 종목이 들어오기 때문입니다. score = 6 - (templist.index(languages[j])) except : scroe = 0 sumnum += score * preference[j] # 종목과 점수합계를 리스트에 넣습니다. maxres.append([templist[0],sumnum]) for i in range(len(maxres)): #사전순으로 업데이트 해줍니다. if maxnum == maxres[i][1] : answer = answer if answer &amp;lt; maxres[i][0] else maxres[i][0] elif maxnum &amp;lt; maxres[i][1] : answer = maxres[i][0] maxnum = maxres[i][1] return answer5. 결과필요시. c++ 짜드리겠습니다. 설명이 필요시 댓글달아주세요." }, { "title": "leetcode(리트코드)-1448 Count Good Nodes in Binary Tree(PYTHON)", "url": "/posts/leetcode_Count_Good_Nodes_in_Binary_Tree/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-08-18 01:34:50 +0900", "snippet": "leetcode 1448 - Count Good Nodes in Binary Tree 문제입니다.1. 문제https://leetcode.com/problems/count-good-nodes-in-binary-tree/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.4. 문제 해석 Tree가 주어집니다. 상위 부모노드의 val값보다 큰 자식의 val값의 갯수를 찾아 리턴합니다.5. code코드설명python# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def goodNodes(self, root: TreeNode) -&amp;gt; int: result = [0] def dfs(root : TreeNode, sd,result) -&amp;gt; int : if root : if sd &amp;lt;= root.val : sd = root.val result[0] += 1 print(result,root.val,sd) dfs(root.left,sd,result) dfs(root.right,sd,result) dfs(root,root.val,result) return result[0] 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "2021.08.17(화).경제 정리노트", "url": "/posts/economy0817/", "categories": "Economy, DailyNote", "tags": "Economy", "date": "2021-08-18 00:50:50 +0900", "snippet": "2021.08.17 경제 헤드라인을 정리한 글입니다. 10억 아파트 매매 수수료 45% 낮아져 … 6억 전세 480만 → 180만원 → 집 값이 오르면서 중개 수수료받는것도 부담이 됨. → 정부가 절충안을 3가지 내놓음. → 1안 : 2억 ~ 12억원 미만 0.4%, 12억원 이상 0.7%의 요욜 상한을 적용. → 3안 : 2억 ~ 6억원 0.4%, 6억 ~ 12억 0.5%, 12억원 이상 0.7%를 적용 → 2안 : 1안과 3안을 적절히 합친 것으로 6 ~ 9억원의 경우 중개보수가 상대적으로 덜 떨어져 일부 소비자의 반발을 살 듯. → 개편안은 이달 말 확정 될 것. 폐배터리 大戰 현대차, 재사용 기술개발 박차 LG엔솔, GM과 재활용 사업 → 배터리 제조업체들이 잇달아 廢배터리 시장에 뛰어드는 중. → 원자재 가격 변동에 영향을 받지 않고 리튬, 코발트, 니켈 등을 자체 조달할 수 있고 시장 규모도 가파르게 성장하고 있기 때문이다. → LG엔솔은 미국 제너럴모터스(GM)와 설립한 합작법인 얼티어셀즈를 통해 배터리 재활용업체 리-사이클과 배러티 재활용 사업을 하고 있음. → 현차는 글로벌 안전인증 기업 UL과 재사용 배터리를 기반으로 한 에너지저장장치(ESS)를 개발하고 있음. → 기아는 SK이노베이션과 배터리 재활용 기술을 확보, 순환경제 구축에 나서는 중. 복비 확 낮춘다… 9억 집 810만 → 450만원 → 1번 기사와 같은 내용. 한달 남았는데 .. 요건 갖춘 코인거래소 ‘0’ → 암호화폐거래소가 특정금융정보법에 따라 금융위원회 심사를 거쳐 등록해야 하는 시한이 다음달 24일로 다가왔지만 제대로 요건을 갖춘 거래소가 단 한 곳도 없는 것으로 나타남. → 무더기로 폐쇄하지 않도록 일부 요건을 완화해줄 방침. 공인중개사 시험 합격인원, 보조원 채용 제한 → 정부가 ‘중개서비스 개선방안’을 조숙히 마련 / 중개서비스는 동일한데 비해 집값 상승으로 중개비가 상승했기 때문에 → 공인중개사 선발 시험에 최소 합격 인원을 설정하는 방안이 유력하게 검토. → 중개보조원 채용 제한를 도입하는 방안도 강구 중. 현재 공인중개사무소의 90% 이상이 1명 이하의 중개보조원을 고용해 운영하고 있는데, 중개보조원에 의한 사고가 전체 사고중 67%를 넘었기 때문이다. → 중개사 수에 비례해 인원을 지정하거나, 공인중개사 수를 초과하지 않도록 조정하는 방안 등을 검토 → 부동산 중개 공제상품을 다양화하고 공제 범위를 확대하는 방안도 검토 대상. 임대사업자 ‘보증보험’ 가입 문턱 낮춰 공시가격 적용비율 상향 … 시세도 반영 → 설명하기 어려움.. 찾아보시길 “고연봉 IB 컨설팅社도 싫다” ‘인재 피라미드’ 맨 위 스타트업 → IB기업에서 주니어 인력들이 스타트업으로 빠져나가고 있음. → 고액의 연봉을 주지만, 업무에 지친 것으로 보임. “출근은 눈치껏, 퇴근은 새벽2시”라는 말이 나올 정도. → 유망한 스타트업의 연봉도 많이주고, 수평적인 기업구조에 자유로운 기업문화에 매력을 느낀듯. → 어떤 중견 IB사는 2~3년 일해 성과를 내면 원하는 PEF나 VC, 스타트업으로 옮길 수 있도록 직접 알선해주겠다는 약속도 함. “스톡옵션 줄테니 와라” … 애널리스트 쓸어가는 바이오 기업 → 바이오의 위상이 높아지면서 원래 몸값이 높은 바이오 애널리스트가 대형 증권사에서 벤처로 빠져나가는 중. → 위의 기사와 마찬가지로 높은 업무강도가 문제인듯. 해외주식, 유튜브, 리테일 서비스를 해야하는데, 그에 비해 보상이 부족함. → 벤처기업은 직함과 억대 연봉, 스톡옵션까지 제공하기에 애널리스트가 옮겨가는중. 거래소 줄폐쇄 우려에 당황한 정부 … “원화거래 안하면 영업 허 용”→ 4번 기사와 같은 내용. 해외 거래소들, 줄줄이 한국어 서비스 종료 → 사업자 등록 대신 서비스를 중단해버림. → 세계 최대 규모인 바이낸스에 이어, 라인 美거래소 비트 프론트도 발 뺌. → 마케팅, 한국어 고객센터, 거래소를 중단하기로 함. 알트코인 다시 ‘불장’ 이더리움 한달새 70% ↑ → 도지코인, 업비트서 하루 2兆 거래 “폐배터리서 ‘도시채굴’ 안 하며 오일 쇼크급 충격 올 수도” → 팀 존스턴 리사이클회장이 말한 것. → 도시채굴이란 폐배터리에서 원자재를 재활용하는 것을 말함. → 도시채굴을 하지 않으면 수요에 공급이 따라가지 못 할 것이라는 말. → 도시채굴은 효율성 면에서도 앞서는데, 광산에는 고농도의 원자재를 채굴하기 어려우므로, 제조와 검증 과정을 거친 배터리를 재활용하는 것이 효율적이라는 것. 中 ‘규제 칼날’에 IT 돈줄 마르고 반도체엔 뭉칫돈 → VC의 반도체 투자금 2분기 89억달러 ‘사상최대’ → 핀테크 36% 게임 96% 급감 → 규제에 따라 핀테크와 게임사업이 망했음. → 반대로 반도체와 AI기업들이 수혜를 보고 있다. → 그 외로 감독기관에서 일하던 공무원들을 채용하고있다. 규제 칼날이 어디로 향할지 가늠할 수 있어서이다. 때문에 관료들의 몸값이 엄청 올라버림. “원전 없이 탄소중립” 외친獨 석탄발전 의존 더 심해졌다. → 독일이 원전을 없애, 전력 부족난을 석탄으로 해결 중이다. → 독일이 탈원전을 강조하는 것은 일본 후쿠시마 원전 사고에 가장 민감하게 반응한 나라이기 때문이다. → 주변국들과 비교하면 독일의 탈원전 기조는 대세에 동떨어진 ‘나홀로 정책’ 유럽 국가 중 유일하게 탈원전 정책을 펴는 영국마저 새로운 원전을 건설하고 있다. 혜지펀드 수익률 12년 만에 ‘최고’ 올 상반기 184억달러 자금 유입. 부동산에 AI 속속 결합 … 재개발 설계 바꿔 500억 추가 수익.→ 부동산 + AI : 프롭테크(proptech)→ AI가 설계를 해버림. 5일 걸리던 것이 30분만에 뚝딱. 거의 500억의 이득을 봄.→ 가구별 일조량 체크도 가능하고, 투자. 실거주에 맞춰 아파트 추천도 해줌. 일자리, 개발 호재, 대중교통 등 28개의 요소를 분석해버림. 한은, 이달 금리 올릴까 … ‘4대 변수’에 고심. → 이달 26일 기준금리 결정을 앞두고 고심중. → 소비자 심리는 위축되는데, 물가와 대출률은 올라가고 있어서 머리가 아픈 상황. → 자영업자를 비롯한 취약계층의 살림살이가 나날이 나빠지는 것도 이유. 소상공인 재난지원금 오늘부터 접수. → 최대 2000만원 … 순차 지급 국민지원금 추석 前 나눠줄 듯. 메타버스 탄 은행들 … 신한銀 ‘가상 점포’ 낸다. → 은행들이 메타버스 금융을 준비 중임. → 신항은행의 경우 자체 메타버스 플랫폼을 구축할 것이고, 야구장 대학 캠퍼스 등을 만들고 상품 가입, 상담 서비스도 제공할 예정이다. → 국민은행은 ‘업무공간’을 메타버스에 꾸리는 실험을 함. 채용 상담부스, 대강당 재택센터 등으로 구성된 ‘KB금융타운’을 마련. → 우리은행도 은행권에서는 유일하게 삼전, 현차, 등 200여 곳이 참여 중인 ‘메타버스 얼라이언스’에 가입. → 금융당국도 ‘메타버스 금융’의 미래에 맞춰 금용소비자보호법 등을 적절하게 개정할 필요성을 느낌. 신용대출 한도, 연봉 이하로 낮춘다. → 금감원, 가계빚 늘자 은행에 요청했음. 현재 연소득 2배 수준에서 반토막이 나버림. → 하지만, 제2금융권의 가계대출도 증가해버렸으므로 ‘풍선 효과’가 더욱 커질 수 있다는 우려가 있다. ‘공격 행보’ SK바이오사이언스, 석달새 직원 40%늘렸다. → SK바사는 삼성바사보다 임원이 더 많아졌음. → S바사는 27명이 임원이고, 삼성바사는 24명이다. 매출은 삼성이 5배를 앞서고, 영업이익은 8배가 더 많다. → 하지만, 팬데믹 이후 SK바사가 코로나19백신을 즉각 대량 위탁생산할 수 있는 세계 몇 안되는 공장으로 주목받음. → 아스트라제네카의 백신 원액생산과 이를 주사병에 담는 완제 공정을 수주했고, 노바백스와도 백신 위탁개발생산 계약을 맺음. 그렇기에 SK바사가 ‘유명CMO’로 각인됨. → 이 때문에 작년기준 영업이익률은 46%에 달해버림. → 문제는 이러한 ‘일회성 이벤트’에 기회를 잡은 SK바사가 이후 경쟁력을 어떻게 확보할 것인지가 관건. ‘호재 다발’ 신세계그룹株 “매수 타이밍” → 코로나로인한 보복소비, 중국 소비시장 회복 등으로 신셰께인터내셔널이 호실적을 거둠. → 이마트의 계열사 쓱닷컴은 e커머스 사업을 총괄하는데, 적자 폭이 늘었지만 미래를 위한 ‘옳은투자’라는 평가. 자가면역질환 치료제 임상 재개 가능성 “한올바이오파마 오를때가 됐다.” → 한올바이오파마에서 주도하는 임상시험이 재개되어 주가가 오르고 있음. → 자가면역질환 치료제 ‘HL161’의 원개발사임. 해외시장 주름잡은 미용의료株 … “더 오른다” → 미,중,일 등 수출액 144% 껑충 뜀. → 제이시스메디칼이라는 주가가 석달새 123% 오름. → 글로벌 의료기기 시장이 커질것으로 보여지며, 다만 중국의 헬스케어 규제(불법 의료미용시술소의 규제 강도가 높아짐)가 ‘변수’로 작용할 듯. 한강 가까운 이촌동, 리모델링 타고 가격 ‘껑충’ 현대건설, 부산 범천4 재개발구역 수주 / 18개동 아파트 2604가구 건립 도시정비 수주 2조원 돌파 눈앞. ‘천안레이크마크’ 411가구 분양 / 개발업체 KD시행, 포스코 시공 직산.삼은저수지 가까워 쾌적 청량리 용두 1-3구역 384가구 공급 / 동대문구 사업시행계획 인가 소형 213가구 일반분양 예정 부동산, 주식 역대급 ‘불장’에 코로나 이후 더 걷힌 세금 33조 → 증가분 중 양도세만 18조임. 1년 전보다 65% 늘어났고, 증권거래세는 67% 증가함.(2.2조 → 3.3조) → 사속, 증여세는 8조로 지난해 4조보다 104%늘음. 이 수치에는 삼성 회장 관련 상속세 2조3000억원도 포함. 평택 포승지구 805억 외자 유치 → 경기경제자유구역청이 평택 포승지구에 외국인직접투자(FDI)로 약 805억원에 유치에 성공. 역대 최대 규모의 외국인 직접투자액임. → ESR켄달스퀘어(다국적 물류 기업)가 투자한 것이고, 2023년까지 2300여만 달러를 추가로 납입하는 등 총 1억달러를 투자하기로 함. → 물류기업들에 물류공간 임대사업을 시작할 예정이고, “탄소중리과 기후변화에 대비해 친환경 설비를 물류센터에 설치할 것”이라고 말함. → 위를 통해 입주기업의 애로사항 청취, 다양한 지원사업 발굴, 규제 개선이 일자리창출로 이어질 수 있음. " }, { "title": "2021.08.16(월).경제 정리노트", "url": "/posts/economy0816/", "categories": "Economy, DailyNote", "tags": "Economy", "date": "2021-08-17 00:50:50 +0900", "snippet": "2021.08.16 경제 헤드라인을 정리한 글입니다. 올 추석 ‘김영란법 민간 적용’ 안한다 → 민간인판 김영란법이 논의가 되었음. → 민간인판 김영란법이란 김영란법 규정을 민간 이해관계자에게 적용하도록 하는 것임. → 초안으로는 음식물 3만원, 경조사비 5만원, 선물 5만원 등 관련 규정을 적용하려고 했는데 농업계의 반대 목소리가 커짐. → 농,축,수산물 선물이 크게 위축될 수도 있다며 반대를 함. 그래서 당장은 추진하지 않도록 함. 향후 추진할 수도 있다 삼성 베팅한 개미들 2.8兆손실 … 66%가 ‘8만.9만전자’때 샀다. → 삼전주식이 8.7만에서 7.5만으로 떨어진 것에 대한 기사. → 긍정론과 부정론이 교차 → 긍정론은메모리 수요가 견조하게 유지될 것을 근거로 오를 것이다. → 부정론은 코로나의 수혜로 반도체 수요가 급증한 것이다. 스톡옵션만 수백억원 김창한, 윤호영,윤석준 ‘슈퍼리치’ 반열에 올라 → 크래프톤 대표 김창한 2783억 → 블루홀 스튜디오 개발 총괄 김형준 프로듀서 435억 → 카카오뱅크 윤호영대표 1000억 이상 → 카카오게임즈의 조계현대표 93억 → 하이브 윤석준 하이브아메리카대표 368억 → 모두 스톡옵션으로 인해서 골프장까지 짓는 카카오 … 예약.결제. 모빌리티 ‘통합’ → 카카오가 경기 기흥에 1500억을 들여 골프장을 만들 듯. → 카카오VX라는 계열사가 개발을 할 것인데, 빅테이터.AI로 잔디, 고객관리를 하고 골프에 IT를 접목할 수 있는 모든 것에 접목시킬 예정이라고함. → 카카오VX의 대표는 한게임 창업원년멤버인 문태식대표. 한게임에서 ‘당신은 골프왕’이라는 게임을 개발한 경험이 있음. 카카오 의장과 문태식대표 둘 다 골프마니아라 나온 아이디어 → 골프장에 카카오프렌즈 캐릭터를 세우는 등 테마파크 건설하는 방안도 검토중 ‘접종률 70%’로는 델타변이 못 막는데… 정부, 철지난 공식에 집착 → 접종률 70%는 낡은 목표라는 지적. 이스라엘은 접종 완료율이 60%에 육박한데, 매일 5000~6000명의 감염자가 나오는 상황. → 그리고 70%에 도달하려면 대략 4천만 회의 접종이 필요(1차 2차 합쳐서 현재 1차 접종률 43%, 2차 19%) 그런데 공급에 차질이 있음. SK바사 17억, 하이브 7.8억 단숨에 ‘주식부자’된 2030 샐러리맨 → 3번 기사와 비슷한 내용이다. 상장을 앞둔 기업에서 상장하고 스톡옵션으로 인해 대박을 터트리면서 부자가 되어버림 → 하지만 우리사주조합에 가입돼 있으면 상장후 곧바로 주식을 팔 수 없다는 점 때문에 회사 주가가 하늘을 찌를 때 직원들이 사표를 내버림. 직원 둔 자영업자 30년 만에 ‘최저’ 지난달 127만명. 최저임금 인상, 코로나 여파 / ‘나홀로 영업’ 갈수록 늘어 2년 새 13만 5000명 증가. → 위 기사와 이어지는 내용. 전용 104m^2… 최저입찰가 34억 시세보다 비싸고 대출도 제한 → 서울 서초구 서초동 ‘서초푸르지오써밋’보류지 한 가구가 34억원으로 현 시세보다 4억원 비싸게 입찰이 부쳐진다. 인천 동암. 서울 용두 “도심공공주택 철회를” → 후보지 56곳 중 8곳 철회요구함. 정부 일방적 사업추진에 불만을 가짐. “동의 안 받고 사유재산권 침해” → 서울 신길4구역, 가산디지털단지 등 6곳에서 사업 철회 요구. → 정부가 공급 목표량을 더 키우는데, 주민 반대의견을 잠재우지 않고서는 공급량이 목표에 못 미칠 것으로 평가됨. → 주민들의 불신이 커지고 있는데, 토지 등 소유주들이 내야 할 분담금과 추정 수익률 등은 커녕 각 사업지의 이주 대책도 전혀 내놓지 못하고 있다. 석유 LNG값 30%대 급등… 한전, 이대로면 하반기도 대규모 적자. → 연료비가 올라 전기료도 올라야하는데, 한전이 정부 눈치보느라 못 올리고 있음. → 전기료를 올리면 서민부담이 커지고 내년 대선에 영향이 갈 것이므로 정부가 인상을 막았다는 기사. 스마트미러로 날씨 보고 로봇이 택배 배송… 똑똑해지는 아파트 → 건설사, 지능형 주거플랫폼 구축하여 IOT기술로 가전기기 자동 제어 → 기존 시스템은 홈 패드, 모바일 기기 등을 활용해 사용자가 설정을 제어하는 수준이었음. 하지만, 이제 AI가 입주민의 생활 패턴을 미리 분석해 선호나는 주거 환경에 맞춰 스스로 제어하게 해줌. → 삼성물산 - 삼선 SDS 협업해 ‘래미안A.IOT 플랫폼’개발. → GS건설 자이S&amp;amp;D와 ‘자이 AI플랫폼’ 개발. → 현대엔지니어링 ‘힐스테이트’에만 적용되는 IOT특화시스템 ‘하이오티 서비스’ 적용. → HDC현대산업개발, 대우건설, 포스코 건설 또한 다양한 IOT서비스를 제공함. → 스마트미러와 연계한 택배 배송 서비스 / 조명, 난방, 엘리베이터, 에어컨, 공기청정기, 로봇청소기 등 실생활과 밀접한 12종 가전을 모두 연동 제어. → 공동현관 출입 자동인식, 방문차량 예약 시스템 등 다양한 서비스 제공. 46만 몰린 갤럭시 ‘톰브라운 에디션’ → Z폴드3, 플립3 추첨 판매가 인기임. 온라인서 1만명 ‘대기열’까지 있었음. 가격은 S펜 포함 400만, 미포함 270만원. → 온라인에서 50~100만원의 웃돈을 붙여 거래되고 있음. 반도체주 바닥 다졌나 … 美 AMD 4%, 마이크론 1% 반등 잠실 일대 ‘재건축 최대어’ 주공5단지 호텔 대신 아파트 300가구 더 짓는다. → 원래는 호텔이 들어갈 자리였으나, 주거환경정비법에 따라 주거 관련한 부대시설만 넣을 수 있게 규정되어버림. 호텔을 지을 수 없다는 얘기 때문에 아파트를 추가 조성하기로 함. 인텔, 반도체 보조금 유치 사활 “亞에 뺏긴 주도권 되찾겠다” → 인텔 CEO 겔싱어, 전국 투어를 돌면서 보조금을 받고있음. → “공장 짓는데 투자해달라”고 요청하면서 미국, 프랑스, 네덜란드, 이탈리아 등 요청 → 인텔의 위기의식 때문이라는 현상. 인텔은 지난 ‘미국에서 가장 가치 있는 반도체 회사’ 자리를 엔비디아에 내줬음. 지난 2분기에는 매출 기준으로 세계 최대 반도체 제조사 자리를 삼성전자에 넘김. → 수개월째 반도체 품귀 현상이 지속되어 반도체 공급 주도권을 아시아 국가가 쥐고 있다는 점이 신경 쓰여 인텔의 목소리에 귀를 기울여주는 정부가 늘고 있음. ‘부동산 불패’ 강남도 거래 절벽 분양전환 빼면 하루 1건도 안돼 → 분양전환이란 : 임대의무기간 5년이 경과한 단지 가운데 입주민들이 조기분양전환 의사를 밝히는 단지에 한해 진행됨. 분양가를 지불하고 아파트 소유권을 넘겨받는 구조. 머지포인트 환불 진행했지만 “나는 못받았다” 민원 쇄도 → 현재 온라인 신청자는 결제 금액의 90%까지 환불 받은 것으로 알려짐. 하지만, 입금이 되지 않았다는 불만과 주변인 중에서 환불받은 이용자가 한 명도 없어 불안하다는 글 역시 꾸준하게 올라오고 있다. → 머지포인트를 결제한 카드사나 이커머스 업체에 환불을 요청하는 사례도 있었음. 일부 이커머스 업체는 미등록된 상품권에 한해 환불 처리를 진행하였음. → 금융당국에 대한 책임을 요구하는 입장도 나옴. 이유는 유사금융단체를 2년 넘도록 방치했다는 점 “과천 지정타, 당첨되면 사채라도 쓸 각오로 청약” → 23,24일 318가구 청약하는데 시세의 60% 수준에서 공급되는 ‘로또 분양’이다. → 하지만 입주 때 시세가 15억원을 넘겨버리면 대출이 불가능하여 분양가 100%를 모두 마련해야하는 상황이 올 수 있음. 현재는 8억원 초반. 주변 아파트 시세가 15~16억이라 8억의 차익을 볼 수 있다. 2~3년뒤를 예측해야해서 곤란. “목돈 쥔 영리치 잡아라”… 판교에 줄선 PB,수입차 딜러들 → 테크기업의 “영리치”가 늘어나자 판교에 증권사들이 많이 생겨남. 수입차를 구매하거나 미술 작품을 구매하는 직원도 많아짐. → 20~30대 남성을 위한 전문 명품매장도 늘고 있음. 2030세대를 겨냥한 키덜드(키드 + 어덜트) 마케팅도 강화하고 있음. 직장인 1100명, 우리사주 ‘10억대 잭팟’ → 6번 기사와 같은 내용. 네이버페이 놔두고 … “왜 카드사만 압박하나” → 수수료율 재산정 시기가 올해 말로 다가와짐. 정부나 정치권이 수수료를 더 내리라고 압박할 가능성이 크기 때문이다. → 일부 카드사들이 빅테크와 역차별을 한다고 말함. → 네이버, 카카오페이 등의 수수료가 카드사보다 비싼데 압력은 카드사에만 넣기 때문이다. → 반면, 빅테크기업들은 “전자지급결제대행 수수료, 망 운영비, 기타 부가서비스 등 다양한 원가가 간편결제 수수료에 반영돼 최소한만 받고 있다”고 반박하고 있음. 그리고 간편결제가 늘어날수록 카드사 수익도 증가한다며 강조. 경남 양산 등 전국 4700가구 이번주 비규제지역 위주 분양 → 전체 물량 가운데 수도권 외 지역에서 4014가구가 청약 접수를 진행함. 경영학계 쓴소리 “집값 올라 富사다리 끊겨” → 한국경영학회 351명 대상으로 올 상반기 경제 정책에 대해 설문조사를 하였음. 27.9%가 못했음. 35.6%가 매우 못했음을 찍음. 9.1%가 매우잘했음. 17.7%가 잘했음을 찍음. → 못했다의 입장 : 집값 급등에 따른 부의 이동 불가(30%), 52시간 근무제 확대로 중소기업, 자영업 부담확대(10.8%), 인건비 상승으로 인한 기업 경쟁력 약화(10%)로 뽑음. → 잘했다의 입장 : 코로나19 확산에도 경제 충격 최소화(20.2%) ‘리모델링 열품’부는 용인 수지 포스코건설, 잇따라 사업 수주 美, 1200兆 인프라시장 열린다. 건설장비 ‘골드러시’ 두근두근 → 인프라 예산안에는 향후 5년간 도로,교통,전력,철도,대중교통,수도 등 인프라 확충을 위해 5500억달러를 투자한다는 계획이 담겨짐에 따라 국내 관련 업체들이 발빠르게 움직이고 있음. → 굴착기 등 건설장비 업체들은 생산라인과 유동망을 확대중. → 북미 소형 건설장비 시장 점유율 1위 두산밥캣 : 5월에는 공장에 투자하여 증설에 들어갔고, 7월에는 두산에서 지게차 사업부를 인수해 제품 포트폴리오를 다양화함. → 두산인프라코어, 현대건설기계 : 수출 즈가에 대비해 확대해온 부품 공급망에 기대를 거는중. 두산인프라코어는 공급센터를 설립하였고, 맞춤형 조립센터를 설립. 현대건설기계는 부품 48시간배송 보증 서비스를 내놓으면서 AS를 강화하고 있음. 효산중공업 역시 일본 미쓰비시로부터 초고압 변압기 공장을 인수하여 선제 투자효과를 기대하고 있음. 전세난 장기화 … 민간임대에 청약 몰린다. → 매번 나오는 기사.. 택배기사 사용자는 원청 ? 하청 ? … 엇갈린 판결에 경영계 혼란 → 택배회사는 하청업체 근로자의 사용자인가에 대해 논란이 생김. → 잘 이해하지 못하였으므로 찾는 것이 좋아서 읽어보시길.. ㅠ " }, { "title": "2021.08.14(토).경제 정리노트", "url": "/posts/economy0814/", "categories": "Economy, DailyNote", "tags": "Economy", "date": "2021-08-15 00:50:50 +0900", "snippet": "2021.08.14 경제 헤드라인을 정리한 글입니다. 머지포인트 본사 난장판 … “내 돈 돌려줘” 수백명 몰려와 → 머지포인트 사건. → 가맹점이 6만5000여 곳에 달하는 머지포인트 서비스 : 무제한 20% 할인을 해주는 서비스 → 금융당국이 미등록 영업을 한 머지 포인트사를 수사 의로하기로 잠정 결론을 냄. → 전자금융거래법상 두 가지 업종 이상에서 포인트를 사용하려면 ‘전자금융업자’로 등록해야 하는데, 등록하지 않음. → 이후 머지 포인트는 서비스를 대폭 축소하고 등록 절차를 밟겠다고 했는데, 소비자들은 난리가 났음. 물린돈이 최대 천만원을 넘는 피해자도 있음. → 업계에서는 머지플러스가 으란바 ‘돌려 막기’를 한 게 아니냐고 우려함. 도쿄 ‘빈 사무실’ 7년 만에 최다 → 코로나로 인해 재택근무가 늘자 도심 공실률 6%로 ‘공급과잉’, 임대료는 전년 대비 8.5% 하락함. 현대차, 16년만에 美누적생산 500만대 돌파 → 2005년 5월 NF소나타 첫 생산, 500만번째는 싼타크루즈 → 소나타, 아반떼, 투싼, 싼타페 등 핵심 5개 차종 年37만대 생산 연료비 30% 올랐는데 … 정부 지지율 눈치에 전기료 그대로 → 국제 유가 등 급격한 연료비 상승과 정부가 값비싼 신재생에너지 발전 비중을 끌어올리면서 적자폭이 커짐.(정부의 눈치를 봄) → 전문가들은 이처럼 경제성을 따지지 않은 에너지 정책은 결국 미래 세대의 부담 증가로 이어질 것이라고 경고. 개인 40%가 ‘최상위’ … 신용점수 거품 심하다 → 4712만명 기준 1921만명(40%)의 신용점수가 1000점 만점에 900점 이상이다. → 949점인 사람은 대출 금리가 3% 후반이고 1000점을 달성했는데도 상위 3% 밖에 안 된다며 신용점수를 믿을 수 없다는 기사. → 이러한 현상이 나온 것은 금리가 인하되면서 이자 부담이 낮아지고 차주들의 연체율이 낮아진 결과라고 볼 수 있다. → 금리가 오르면 상향평준화 되었던 개인 신용점수가 한꺼번에 무너져내릴 위험이 있다. ‘3개의 화살’ 맞은 한국 … 원달러 환율 10개월만에 최고 → 환율이 최고치를 찍음. 3가지 이유가 있다는 기사. 미국의 조기 테이퍼링 가능성 반도체 전망이 밝지 않다고 기사가 나온 것. 백신 접종률이 OECD 국가 중 가장 낮음. 이 때문에 경제가 다시 좋아질려면 멀었다는 것. → 반박으로는 반도체 관련 주가가 떨어진 것이고, 저가 매수세가 들어올 것. 대만 TSMC와 삼전 등 동아시아 IT 주식들이 약세를 보인 것이지 한국 증시만 타깃이 된 것은 아니다. ‘1兆 몸값’ 판교 랜드마크 알파리움타워, 주인 찾기 나선다. → 판교의 알파리움타워 2개 등이 5년 만에 오피스빌딩 매매시장에 등장. → 투자 매력이 높아진 판교 오피스시장의 랜드마크 빌딩인 만큼 해당 빌딩이 1조원을 넘을지 지켜 보고 있음. → 현재 판교 오피스는 공실률이 0.0%로 비어있는 사무실이 거의 없음. 또한 IT업계, 게임업계들이 몰려 있어 한국의 실리콘 벨리라고 불려지고 있음. 미래에는 더 높은 위상을 가질 것이라고 기사에서 판단. 탈레반, 카불 장악 초읽기 … 美, 아프간에 병력 다시 보낸다. → 탈레반이 아프칸의 전체 34개 주도 가운데 17곳을 점령함. → 생각보다 빠르게 치고 올라오는 탈레반에 미국은 임시병력 3천명을 카불에 대치해, 대사관에서 일하고 있는 직원들의 조속한 귀국을 돕고 있음. → 미국 국무부는 최소 인력으로 카불 대사관을 계속 운영한다는 방침. 대사관을 폐쇄하는 건 아니라는 뜻이다. 또한, 대사관을 카불 공항으로 옮기는 비상대책도 세움. → 캐나다와 영국도 자국민 철수를 위한 병력 지원에 나서고 있음. 월급 한푼 안쓰고 모아도 수도권 내집마련 8년 걸려 → 1년전에는 6.8배(6.8년)이었는데, 현재는 8배로(8년)으로 급증. 내수 부진, 스태그플레이션 우려 큰데 금리 올린다고? → 금리를 올려야한다고 대다수가 동의하지만, ‘굳이 지금’이라는 회의론이 제기되고 있음. 5가지로 나뉨. 경기 회복 ‘착시’ 없나 코로나4차 대유행으로 경제 불확실성이 확대되고 있음. 스태그플레이션 우려 소비 성장률이 2분기 기준 12년 만에 최고 수준. 금리를 올렸을 때 경기 둔화 리스크가 있는 반면, 정작 물가가 잡힐지는 미지수라는 입장 사회 취약계층 이자 부담 괜찮냐 투자가 아닌 생계 목적으로 빚이 있는 사람들도 있는데 대책이 있는 것이냐는 것. 집값 하락 효과는 미지수 금리를 올린다해서 집값이 잡히겠냐는 뜻. 미국보다 빨리 올릴 필요 있나 D램 현물價 하락하자 ‘고점론’ 확산 … 외국인 ‘K반도체’ 연일 투매 → 삼전, SK하이닉스 주가 낮아진 얘기. → 하이닉스의 경우 장중 시총 2위 자리를 네이버에 내줬었음.(장 시작) 다행히도 네이버 주가가 하락 마감해 2위를 지켜냄. → 네이버가 하이닉스를 빠르게 추격 중. 하이닉스는 생각보다 D램 가격에 주가가 정해졌었음. 때문에 반도체 대한 비관적 전망 속에 SK하이닉스의 시총 2위 수성이 쉽지 않을 것이란 예측. “치킨 배달비 6000원, 남는 게 없다” 폐업률 78% → 치킨집이 폐업률이 78%임. → 현재는 코로나 때문에 치킨 배달이 올라가긴 했지만, 좋은 배달 업체를 쓰려면 최대 6000원을 내야함. 거기에 가격상승한 닭값과 최저임금이 높은 알바생을 쓰면 남는게 거의 없다는 것. 그래서 치킨집은 해도 손해 접어도 손해라는 말이 나오고 있다. 이재용 “국민께 정말 죄송 … 우려, 기대 잘 듣고 열심히하겠다.” → 이재용 부회장의 경영현안에 대한 기사. 어제 다루기도 하였으니, 자세한 건 검색을.. 개학 앞두고 …. 수요 몰린 목동 전세 1억 ‘껑충’ → 학구열이 높은 목동 지역에 자녀의 전학 등의 이유로 전세가 껑충 뛰어버림. → 뿐만 아니라 차라리 사자는 입장으로 매매가가 2억원 넘게 올랐음. 성범죄 방지가 저출산 대책? … 380兆 써도 ‘맹탕’인 이유 있었다. → 줄이겠다던 사교육비가 더 늘음. 수시, 정시 입시 구조가 계속 바뀌면서 공교육만으로는 해결할 수 없는 상황이라는 추측. → 저출산 대책과 상관없는 사업이 추진되고 있음. ‘성범죄자 재범 방지 조치 강화’ 사업 신혼부부 임대주택 공급사업이 계약률이 50%에 불과함. 주거면적이 너무 좁아서 출산장려금도 효과가 적음. 추세를 돌리기에는 역부족인 데다 장려금을 탄 뒤 다른지역으로 옮기는 사례가 많기 때문. “3040도 AZ 잔여백신 접종 허용” … 다급한 정부 ‘궁여지책’ → AZ 접종가능 연령대를 50세 이상에서 30세 이상으로 낮췄음. 한달만에 번복한 것. → 정부는 “원하는 사람에게만 접종 선택권을 부여한 것이기에 문제 없다”고 전함. → 면밀한 과학적 검토없이 변경. 안정성 판단 책임 개인에 떠넘긴다는 의견. → 18~49세 예약률도 60%에 그쳐 추석전 1차접종 70% 장담 못 하게 됨. ‘명품 황제株’ LVMH(루이비통모에헤네시), 시총 500조 향해 질주 → LVMH가 시총 1위 자리를 굳건히 지키는 중 (3569억9491유로) 2위 에르메스(1401억7015) 3위 케링(987억8968)를 합친 것보다도 많음. → M&amp;amp;A로 몸집을 계속 키운 것. LVMH에는 루이비통, 크리스찬디올, 불가리,팬디, 티파니, 토즈, 오픈화이트, 에트로, 주류시장에는 모엣, 둠페리뇽, 헤네시 등 고가 주류브랜드도 보유 중이다. → LVMH는 당분간 대형 M&amp;amp;A는 없다고 함. 삼성전자 사흘째 연저점 … 개미 수익률 비상 → 주가 떨어져서 현재 손실률이 10%달한다는 기사. ‘세계 3위’ 中항구 부분 폐쇄 … 물류 대란 덮치나 → 닝보항 직원 코로나 확진 판정으로 상하이항 선박 몰려 30척 대기함. → 닝보항 메이산터미널에 근무하는 직원이 코로나19 확진 판정을 받았는데, 근무지는 전체 물동량의 25%를 처리하는 핵심관문임. → 닝보항에 있는 다른 터미널도 코로나 19 확산 방지 차원에서 항구로 들어오는 화물과 인원 수를 제한했음. 이 날 40여 이 정박지 밖 바다에서 대기했음. → 물류대란이 일어날 수도 있고, 물류비 상승이 불가피하다는 전망도 제기 됨. 美 백인 인구 60% 깨졌다 … 아시아계 급증 → 인구조사 이래 첫 백인 감소 → 10년전보다 500만명 줄었음. 아시아인은 36% 최대폭 증가했고, 불법이민자도 21년 만에 최다라는 기사. → 히스패닉(중남미계 미국 이주민)의 출산율이 백인 여성의 출산율보다 높다. → 미국인의 출산율이 낮아지면서 고령화 속도는 빨라지고있음. → 대도시 집중화 현상도 감지 되었음. 뉴욕시 인구는 10년간 8% 가까이 증가하였는데 어느 도시보다도 증가폭이 컸음. → 불법 이민자는 도널드 트럼프 전 행정부와 달리 친화적 이미지를 보이는 조 바이든 행정부 때문이라는 추측. 그래도 국경 지역에서 체포된 불법 이민자의 45%가 멕시코로 송환되었음. HMM, 대한항공 ‘깜짝 실적’ 실어날랐다. → HMM은 영업익이, 전년동기 10배가 늘음. 상하이운임지수도 올해 47% 급등했음. → 보복소비가 글로벌 물동량 증가와 해상운임 급등으로 이어진 듯. → 대한항공의 경우 선박이 없어 수출을 못 하는 해운 화물대란이 일어나면서 항공 화물운송을 선택하는 사례도 늘어 전년 동기대비 영업익이 31% 늘음. 매출은 16% 늘음. → 운임비가 1월 기준 3.14달러였는데 현재 7.7달러로 달라진 것도 영향을 미치는 듯. 용두역세권, 신길4구역 “민간개발할 것 ….도심복합개발 후보서 빼달라” → 서울시 정비사업 활성화 나서자 후보지 56곳 중 7곳이 철회 요청을 했음. 복비 90만원 깎는 방안 놓고 … 팽팽한 기싸움 → 현행 6억~9억 최대 0.5%의 복비를 받을 수 있는데, 집 값이 오르면서 소비자 입장에서는 중개보수 부담을 낮추려고 0.4%로 상한선을 바꾸자고 함.(최대 90만원 이득) → 중개업 입장에서는 가뜩이나 거래가 급감해 수수료를 내릴 수 없다는 입장. 다만 고가 주택구간을 신설하는 방안에는 협회에서도 공감대가 있다고 함. 넷플릭스 독주 무너지나 디즈니+ 11월 한국 상륙 → KT,LG유플러스와 물밑 협상을 한 디즈니+, 넷플릭스와 망 이용 대가를 둘러싼 SK브로드밴드 틈새시장을 노리나 → 국내 OTT시장 장악을 노림. → 디즈니플러스는 디즈니, 마블, 픽사, 스타워즈, 내셔널지오그래픽 등 다양한 콘텐츠를 포함하고 있음. → 현재 북미부터 유럽, 아시아, 태평양, 중남미까지 전 세계 61개국에서 21개 언어로 서비스를 제공하는데, 태국에선 지난 6월 말 구글 플레이스토어와 앱스토어에서 다운로드 수 1위를 기록함. 미국인 26% “백신 거부” … 종교,정치색이 좌우 → 백신이 넘쳐나는데도 접종률이 정체 → 이유는 다양하지만, 종교와 정치성향에 공통점이 발견됨. →공화당 지지자의 대부분이 백신을 거부하는데 그들은 과학은 신뢰하지 않는다고 답변했기 때문. → 기업들이 접종 강제에 나섰는데, 처음에는 ‘인센티브’를 지급한다며 당근을 주었지만, 접종을 하지 않으면 해고를 하겠다며 채찍을 때리기 시작. 긴급보육 이용률 90%, 휴원령에도 어린이집 다시 북적 → 코로나 4단계 연장으로 가정돌봄의 피로도가 증가하면서 집에서 버티기 힘들어함. → 맞벌이 부부의 경우 긴급보육을 할 수 있고, 재택근무를 할 경우 가정돌봄을 강력히 권고하고 있다. → 하지만 재택근무의 특성상 일을하면서 육아를 하는 것은 매우 큰 부담이라 아예 그냥 회사를 가버림. → 현재 긴급보육에 제한이 없어서 사람들이 어떠한 이유라도 만들어서 긴급보육을 보내버림. 예를 들어 전업주부인데, 취업자로 위장하거나 구직활동을 보여주기 위해 터무니 없는 연봉을 제시하건 연락이 오지 않을 회사에만 구직활동을 하는 행보를 보임. → 반대로 전업주부의 비율이 높은 어린이집은 가정돌봄의 비율이 높아서 한 아이가 혼자서 어린이집에 아침 8시부터 6시까지 있느 경우도 있다. 고점 경고에도 … 거세진 아파트 매수심리 → 어제 정리한 기사에 있는 내용. " }, { "title": "2021.08.13(금).경제 정리노트", "url": "/posts/economy0813/", "categories": "Economy, DailyNote", "tags": "Economy", "date": "2021-08-14 00:50:50 +0900", "snippet": "2021.08.13 경제 헤드라인을 정리한 글입니다. 비둘기파 FOMC 위원도 “연내 테이퍼링 들어가야” → 미국 연방준비제도(Fed = 연준) 내에서 테이퍼링을 시작해야하는 목소리가 커지고 있음. → 연방준비제도 총재는 통화정책을 결정하는 연방공개시장위원회(FOMC)에서 투표권을 행사하기에 ‘테이퍼링을 해야한다’는 발언이 주목되는 이유. 또한 연준 내에서는 긴축에 신중한 경향을 보이는 ‘비둘기파’ 비둘기파 : 비둘기파는 평화를 상징하는 비둘기처럼 대화와 타협을 통해 문제를 해결한다는 걸 의미한다. ‘셀 반도체’에 1160원 깨졌다. 원화값 10개월 만에 최저 → 원화 값이 1160원 밑으로 내려갔음. → 그 이유로는 외국인들이 8.9일부터 4일동안 4조4870억을 매도해버렸음. 이것은 지난달 외국인 전체 순매도액(4.89조)와 맞먹음. → 외국인들이 이렇게 갑작스럽게 팔아버린 이유로는 어제 기사에서 밝힌 트랜드포스가 “D램 가격이 하락할 것”이라고 전망했기 때문에 SK하이닉스, 삼성전자 주식을 다 팔아버림. 원화값과 어떤 관계 ? : 수출 46% 늘었지만 … 원자재값 상승에 무역적자도 커져 → 수출이 전년 대비 8월 수출이 46% 늘었지만, 5조의 무역적자가 발생함. → 원자재를 수입하여 가공해 중간재, 완제품을 수출하는 우리나라의 산업 특성상 원자재 가격이 오르면 타격이 있을 수 밖에 없다. → 때문에 원자재값 상승이 그 원인이라고 판단. 빚투에 넘치는 유동성 … 상반기 통화량 220조 폭증 → 제로금리가 1년 넘게 이어지면서 올해 상반기에만 시중 통화량이 220조 원 넘게 폭증(전월 대비 0.8%증가) → 자세한 내용은 기사!! M2, M1에 대한 내용이 나와 설명하기 어려움. 취업자 줄고 취포자 최대 ‘위기의 30대’ → 무기력증에 빠져 취업을 포기한 30대가 많다는 내용. 2030고객 늘자 … 금융권 “MZ세대 배우자” 역멘토링 → 금융권에서 MZ세대가 임원들에게 문화를 가르치니는 ‘역멘토링’이 생김. → 임원들은 “의견 충돌이 생기지만, 지나고나면 직원들의 의견이 대부분 맞더라”고 함. → 신한카드는 2030팀이 임원에 제안하여 크루카드인 방탄소년단PLCC를 출시하였다. → KB국민은행은 역멘토링 프로그램 ‘아이디어 뱅크 보드’를 운영하여 상품에 ‘MBTI”를 활용하자는 의견을 냈음. → 이러한 것들은 2030대의 은행 대출이 점점 늘어, 임원들이 MZ세대의 문화를 배워야하기 때문에 나온 것으로 추측. 이즈미디어 -51%, 알체라 -30% … 메타버스 투자 주의보 → 메타버스가 신사업으로 주목받아 투자자들이 많았는데, 과도한 관심으로 주가가 급등했다가 폭락해버림. → 알체라事 : 사람들이 입소문으로 메타버스 회사라고 했는데 회사에서 ‘메타버스 관련 사업 모델은 없다’라고 해서 30% 떨어짐. → 이즈미디어事 : 메타버스 관련 사업을 하겠다고 하여 8천원이었던 주가가 4만원까지 뛰었는데, 기존 사업이 너무 불황이라 진척이 없을 것 같아서 51% 떡락 → 혜성옵틱스事 : 이즈미디어와 콘텐츠 공동 개발에 나선다고 밝혔지만 54% 떡락. 과도한 부채비율과 기존 사업 부진이 원인. → 코세스事 : 구체적 실적이 없어 9% 하락 → 맥스트事, 자이언트 스텝事 : 차익실현과 과열부담에 매물이 나온 것으로 추측되어 하락 가장 인기있는 테마 추려 166종목 모아놨다 … ‘끝판왕 ETF’ 등장 → 투자자 사이에 인기도 있고 수익률도 검증된 상품인 ‘앰플리파이 시매틱 올스타 ETF’가 출시. → 시장에서 가장 인기있는 테마형 ETF에서 각각 가장 인기 있는 종목들을 추려낸 ETF이다. 3일째 추락한 크래프톤 … 투자자는 울상, 창업자는 돈방석 → 中 당국의 게임규제 영향이 악재가 되어 외국인 투자자들이 3일간 3000억원 규모 이상을 팔아치움. → 결국 12일 크래프톤 주가는 공모가보다 18.5% 하락한 40만6000워네 마감하였고 시총은 첫날 대비 2조원 넘게 줄어든 19.8조 → 우리사주를 받은 크래프톤 직원들도 손실을 보게 되었음. → 우리사주는 기업이 상장을 앞두고 발행 주식의 20%를 자사 직원에게 우선 배정해주는 제도로, 1300명의 직원이 35만주를 공모가로 우선 배정 받았지만 주가가 떡락하면서 1인 평균 2400만원 이상의 손실을 보게 됨. → 하지만 창업자를 비롯한 임직원들은 대박이 났음. ‘황금알’이 된 지수 사업 … 대표 거위 MSCI, 2분기만 3000억원 벌었다. → 뉴욕 증권거래소에 상장된 MSCI라는 기업. → 2분기에 실적이 21.6% 증가한 매출을 올렸는데, 대단한 것은 영업이익이 51.7% 올랐다는 것.(3000억원) → 이 회사의 대표 상품은 지수(index = 指數)이다. 지수 : 생산지수처럼 어떠한 년도 기준으로 가치가 얼마나 상승했는 지 알려주는 지표. 예를 들어 10년 전 우리나라가 자동차 3대를 생산했고, 지금 9대를 생산한다면 지수가 300 → 뮤추얼 펀드의 위험성에 사람들이 인덱스 펀드, ETF로 몰림. → 인덱스 펀드는 뮤추얼 펀드 못지않게 장기적으로는 수익률이 뒤지지 않다는 것을 알아버림. → 지수사업은 아무나 하지 못한다. 전산시스템과 인건비 등 상당한 초기 투자 비용을 감수하며 시장을 잡고 있는 대형사들과 경쟁해야 한다. 이러한 돈으로 지수 사업자에게 지수 개발을 맡기는데 돈이 덜 든다는 말도 있음. → 한국거래소는 1년에 약 15개씩, 지금까지 400개 가까운 지수를 만들었지만 MSCI는 주식 관련 지수가 22만5000개가 넘고, 이를 추종하는 ETF는 1300여 개에 달함. S&amp;amp;P는 가상화폐 지수 등을 포함해 100만개 이상의 지수를 생한함. → 이들의 목적은 지수는 이론상 무한하게 만들 수 있기에, 모든 자산을 한꺼번에 담는 ‘궁극의 지수’를 만드는 것이 목표. 반도체 빅2, 왜 이러나 → 어제 기사를 보고 정리했으니 그걸 보는게 나을 듯. 삼성전자와 SK하이닉스 주가 하락 이유에 대해서. → 1. 트랜드포스의 D램 가격이 낮아질것. → 2. 전세계적 PC 수요 감소 → 3. 고객의 목소리가 강해짐. 완성도 확 높아진 ‘Z폴드3’ … 디자인 확 달라진 ‘Z플립3’ → 기사쓴 분이 직접 사용해본 후기 → Z폴드3 : S펜을 사용할 수 있고, 메인 디스플레이 카메라 구멍이 사라졌다는 장점. 카메라 성능과 배터리 성능이 소폭 낮아짐. → Z플립3 : 디스플레이가 전작에 비해 4배정도 커짐. 색상도 많아졌고, 삼성페이를 사용할 때 기존 스마트폰처럼 아래에서 위로 화면을 밀면 스마트폰을 펼치지 않아도 삼성페이를 사용할 수 있다는 장점. → 가격을 최대 40만 원 낮추면서 폴더블 대중화에 나섬. SK 이노, 유럽 합작법인. 각형 배터리 개발 추진 → SK 이노가 미국 2위 자동차 제조사인 포드와 유럽 전기차 시장 공략에 나설 예정. → 현재 SK이노는 5.2%점유율로 전세계의 6위에 그치지만 3위인 일본의 파나소닉(15%)를 제칠 것을 목표로 함. → 세계 2위(24.5%) LG에솔은 전기버스 제조업체 프로테라에 배터리 셀을 공급하기 위해 미국에 공장을 추가로 짓는 방안을 찾고 있다. 한화시스템, 3억 달러 우주기업 ‘원엡’에 투자 → 지분 8.8%를 확보한 한화시스템은 원웹의 최대 주주 → 원엡은 2012년에 창립한 위성 인터넷 스타트업 기억으로 지구 저궤도에 소형 위성을 띄워 전 세계에 인터넷을 제공하는 회사. → 2019년 세계 최초로 우주 인터넷용 위성 발사에 성공했고 현재 저궤도 위성 254기를 운영 중. 내년 말까지 위성 648기로 우주 인터넷망을 완성해 우주 인터넷 서비스를 본격 시작한다는 계획 → 한화시스템은 또한 세계 3대 통신 위성 기업인 프랑스의 유텔샛, 일본 소프트뱅크 그리고 영국 정부 등과 함께 이사회에 합류하여 ‘에어택시’라고 불리는 도심 항공 사업을 추진하여 시너지를 발휘할 것. 수도권 아파트값 1주새 0.39% 올라, 4주 연속 최고 상승률 상반기 수도권 비규제 지역 아파트 매매 2배로 급증 → 지난해에 비해 116%증가. (3263채 → 7077채) → 이천시 &amp;gt; 동두천시 &amp;gt; 포천시 &amp;gt; 여주시 &amp;gt; 양평군 &amp;gt; 연천군 &amp;gt; 가평군 으로 인기가 많음. 지난달 서울아파트 매매 3채중 1채는 6억 ~ 9억 → 대출규제를 완화시킴 LTV 우대 폭을 6억 원 이하에서 9억 원 이하로 완화시킨 결과로 6억 원 이하 매물이 급감하였음. ‘패닉 바잉’ 2030, 전국에서 아파트 54만가구 샀다. → 지금 아니면 못 산다라는 심리가 확산되면서 2030세대들이 아파트 매수에 나선 것으로 추측. 임대차법이 ‘영끌’ 부추겨 …. 수도권만 27만가구, 싼 노원에 몰려 → 위의 기사와 비슷한 내용 지방 아파트도 “사자” … 2030이 10건 중 2건 → 2030세대의 패닉바잉은 지방도 예외는 아님. → 울산은 33% 세종 29% 대전 28%가 매매된 아파트 중 2030이 매매한 것. 12만 대 1, 381 대 1 … 무주택자 희망고문하는 ‘로또청약’ → 난리난 공약 경쟁률 디에이치자이개포 경우 10억 넘는 차익을 거둘 수 있어서 경쟁률이 12만 대 1인 듯. → 40대 정모씨는 무주택 기간 11년에 아이가 둘인데 50점 중반대의 가점으로는 서울에 청약을 넣는게 무의미할 정도로 희망이 아닌 희망고문을 당하고 있다고.. 가뜩이나 민간 외면하는데… 공공정비에 ‘분상제’ 생기나 → 공공정비 : 공공 직접시행 정비사업 → 분양가가 계속 치솟자 분양가 상한제를 명시하자는 말이 나옴. → 이해하기 어려워서 pass 사전청약 4333가구에 9만명 몰려 … 인천계양 381 대 1 → 매 번 나오는 청약 기사 “아이돌 응원 말라, 술 권유도 금지” … 모든 걸 규제하는 중국 → 팬클럽 규제해 콘텐츠 15만건 삭제 → ‘우유사건’ 대두되었기 때문 우유사건 : 아이돌 육성 프로그램에서 좋아하는 아이돌연습생에게 팬들이 투표하게 하면서 협찬사 우유 제품에 투표를 위한 QR 코드를 부착하여 버려지는 우유만 20만 개가 넘어버림. → 중국 당국은 국가 기관을 총 동원해 아이돌 숭배 문화를 바로 잡겠다고 나섬. → 전자상거래 기업 알리바아의 여직원이 상사로부터 고객 접대 술자리에 참석하라하고 성추행을 당한 사건이 논란이 되자 ‘저승사자’라고 불리는 최고 사정 기관이 직접 나섰음. 이로 인해서 주류 업체들 주가가 하루 2% 이상 떨어짐. → 중국의 규제 때문에 기업의 미래는 예측이 불가능해짐. → IT 규제, 사교육 규제, 노래방 음악 단속, 팬클럽 규제, 술 규제 美, 애플. 구글 ‘인앱 결제’에 칼 빼들어 → 미 의회가 인앱 결제를 강제하며 수수료를 챙겨온 애플과 구글을 겨냥해 강력한 반독점 법안을 발의했음. → 앱 사용자들이 구글 플레이스토어나 애플 앱스토어에서 다운받은 앱 안에서 콘텐츠를 구매할 때 자사의 결제 시스템을 사용하도록 하는 인앱 결제를 강제하고 그 대가로 최대 30%를 수수료로 떼감. → 법안의 목적은 다른 앱 장터에서도 앱을 자유롭게 다운받을 수 있도록 한다는 게 핵심. → 도지의 일론 머스크님께서는 “애플의 앱스토어 수수료는 인터넷에서 사실상 글로벌 세금”이라고 비판하기도 함. → 실제로 구글은 약 98조, 구글과 애플 합쳐서 15조~30조의 수수료를 받고 있음. → 한국의 경우 이르면 8월 중 국회 본회의를 통과할 것으로 예쌍됐던 인앱 결제 방지법이 관할권 문제로 계류 중인 상태. 트위터도, 페이스북도 앱 안에 쇼핑 코너 … ‘소셜커머스’의 진격, 아마존까지 위협 → 페이스북은 ‘숍스’라는 소셜 커머스 개설, 외에도 트위터와 유튜브 위챗 등 다양한 기업에서 소셜커머스 사업에 발을 들임. → 2019년이 비해 25% 이용자가 늘어나면서 세계 최대 전자상거래 업체인 아마존과 경쟁할 수준이 되어버림. 아마존 이용자는 3억명이고 이 중 유료 회원인 ‘아마존 프라임’ 가입자는 1억 5000만 명 이상. → 왜 소셜커머스가 나왔을까? 기존 수익원인 맞춤형 광고의 판매가 어려워졌기 때문이다. 애플이 최근 아이폰 운영체제 업데이트를 통해 소셜미디어 업체의 사용자 개인 정보 수집을 어렵게 만들어 맞춤형 광고를 띄우기 어렵게 해버림. 이러한 개인 정보 보호 기능에 직면한 소셜미디어 기업들이 소셜커머스로 진출하게 되는 계기가 됨. 즉 생존을 위해 다양한 사업을 해보면서 몸부림을 치는 것. “내리막길 준비하라” 비관론의 습격 → 억만장자 투자자 스탠리 드러켄밀러, 로저스홀딩스의 짐 로저스 회장, 알리안츠의 모하메드 엘 엘리언 고문, 뉴욕대 누리엘 루비니 교수가 주장하는 것. ‘버핏 지수’라는 것이 있음. 증시에 거품이 끼어있는지 확인하는 대표적 지표 중 하나이다. 2000년 1분기 닷컴 버블이 터지기 직전일 때 최대 137%까지 치솟았는데, 지금은 200%를 넘겨버림. 즉 지금 시장이 너무 과열된 상태라는 것. 경기 정점을 지나버림. 회복 성장 기대가 꺾여 부양효과 1년후 소멸할 것으로 예상 스태그플레이션이 올 것. 물가 솟는데 경기는 침체되어있음. 1970년대처럼 될 조짐이 보인다고함. 스태그 플레이션 ? : 스태그플레이션은 ‘스태그네이션(stagnation)’과 ‘인플레이션(inflation)’의 합성어로, 거시경제학에서 고(高) 물가상승과 실직, 경기 후퇴가 동시에 나타나는 경우를 말한다. → 외에는 원자재 값 상승과 공급 부족으로 제조업 지수가 낮아진 것, 미 국채 금리가 급락한 것 등이 있다. → 반론도 존재한다. 억만장자 투자자 빌 에크먼 퍼싱스퀘어 회장은 5조달러 규모의 경기 부양책이 남아있고 실질 임금이 상승하고 있으며 가계 저축도 많이 쌓여 있다. 국채 금리 하락은 일시적인 현상이다.고 함. 골드만삭스는 “실업수당이 조기 종료된 25개 주에서 신규 실업수당 청구 건수가 감소하고, 식당 및 숙박업을 중심으로 구인난이 빠르게 완화되는 등 노동 공급이 회복되는 모습이 확인되고 있다.’며 경제 회복이 지속되리라 전망. JP모건의 데이비드 켈리 수석 글로벌 전략가는 “코로나가 네 번째 확산하고 있지만, 실제 경제적 파장은 단 한 번뿐이었다’며 기업과 소비자가 팬데믹 현상에 잘 적응하면서 미 경제는 바이러스에 덜 취약해졌다”고 함. " }, { "title": "leetcode(리트코드)-914 X of Kind in a Deck of Cards(PYTHON)", "url": "/posts/leetcode_X_of_a_Kind_in_a_Deck_of_Cards/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-08-13 03:34:50 +0900", "snippet": "leetcode 914 - X of Kind in a Deck of Cards 문제입니다.1. 문제https://leetcode.com/problems/x-of-a-kind-in-a-deck-of-cards/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 deck이 주어집니다. 같은 숫자끼리 분할해야하는데 분할한 자료구조의 요소갯수가 같도록 분할할 수 있으면 True 없다면 False를 리턴합니다.5. code코드설명pythonclass Solution: def hasGroupsSizeX(self, deck: List[int]) -&amp;gt; bool: def gcd(a, b): while b: a, b = b, a % b return a count = collections.Counter(deck).values() #print(count) return reduce(gcd, count) &amp;gt; 1 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "leetcode(리트코드)-1759 Count Number of Homogenous Substrings(PYTHON)", "url": "/posts/leetcode_Count_Number_of_Homogenous_Substrings/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-08-13 02:34:50 +0900", "snippet": "leetcode 1759 - Count Number of Homogenous Substrings 문제입니다.1. 문제https://leetcode.com/problems/count-number-of-homogenous-substrings/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.4. 문제 해석 s라는 문자열이 주어집니다. 예시처럼 반복되는 경우의 수를 모두 구해 더한 값을 리턴해야합니다.5. code코드설명pythonclass Solution: def countHomogenous(self, s: str) -&amp;gt; int: res = 0 idx = 0 mod = 10**9 + 7 while idx &amp;lt; len(s)-1: temp = 1 while idx &amp;lt; len(s)-1 and s[idx] == s[idx+1] : temp += 1 idx += 1 res += temp * (temp + 1) // 2 idx+=1 if idx != len(s) : res+=1 return res % mod 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "leetcode(리트코드)-1588 Sum of All Odd Length Sumarrays(PYTHON)", "url": "/posts/leetcode_Sum_of_All_Odd_Length_Subarrays/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-08-13 01:34:50 +0900", "snippet": "leetcode 1588 - Sum of All Odd Length Subarrays 문제입니다.1. 문제https://leetcode.com/problems/sum-of-all-odd-length-subarrays/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 arr가 주어집니다. 모든 연속된 인덱스를 홀수번 선택하여 더한 값을 리턴하세요.5. code코드설명pythonclass Solution: def sumOddLengthSubarrays(self, arr: List[int]) -&amp;gt; int: res = 0 for i in range(len(arr)): window = 0 while i + window &amp;lt; len(arr) : res += sum(arr[i:i+window+1]) window+=2 return res 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "2021.08.12(목).경제 정리노트", "url": "/posts/economy0812/", "categories": "Economy, DailyNote", "tags": "Economy", "date": "2021-08-13 00:50:50 +0900", "snippet": "2021.08.12 경제 헤드라인을 정리한 글입니다. “7말 8초 휴가지 감염 후 복귀 … 수도권 1400명 돌발급증 불러” → 사회적 거리두기 강화하자니 고강도 방역에 거리두기 피로감이 커져 자영업자 한계 → 고강도 방역이 지속되어도, 사람들의 피로감이 쌓여 결국 거리두기가 제대로 이행되지 않을 것일거라는 기사. 4차 대유행에 음식, 숙박 취업자 감소세로 … 8월이 더 두텁다. → 자영업자가 1인으로 운영하는 식당이 늘음.(고용원을 가지고 있는 자영업자가 줄어들음) 최태원 “탄소중립 막대한 투자 필요 … 정부가 지원 나서달라” 美 주식 295% 부동산 80% 뛸때 금투자 10년 수익률 - 0.02% → 더 이상 금이 안전자산이 아닐 수도 있다는 추측. → 다양한 분석이 나오는 중 → 1. 암호화폐 등 다양한 가치저장용 투자 수단이 등장해 금의 지위가 흔들림 → 2. 이미 금값이 너무 올라서 대체투자수단으로 활용하기 어려움. → 반론 → ‘디지털 금’으로 불리는 경쟁자 암호화폐가 극심한 가격 변동성으로 신뢰를 잃어 금의 지위 회복에 도움이 될 것. → 자산가들이 비트코인을 버리고 금 투자에 확대, 상반기 각국 중앙은행은 지난해보다 63%많게 금을 자산가들이 사들였다고 밝힘. 베트남戰 이후 달러가치 급락 … 닉슨 ‘달러=금 교환증’ 결국 포기 → 금본위제 : 금을 보유한 만큼 화폐를 발행해야하는 것. → 영국이 1819년 처음 도입. 금과 함께 화폐 기능을 하던 은의 가격이 상승하자 은화를 녹여버리는 사태가 발생하였고, 자연스레 금만 통화시장에 남게 됨. → 금 본위제가 1929년 경제위기가 닥치면서 무너졌다가 1944년 다시 부활함. → 1,2차 세계대전을 겪은 미국은 달러를 앞세워 통화국이 됨. → 그러나 베트남전에서 미국은 금 보유량을 넘어서는 무지성으로 달러를 찍어냈고, 달러의 가치 하락을 우려한 유럽의 미 국채 보유국을 중심으로 “달러를 금으로 교환해달라”는 요구가 빗발. → 닉슨 미대통령은 달러와 금의 교환을 중단하겠다고 선언. → 이러한 사건으로 금이 인플레이션을 해지할 수 있는 투자처로 각광받기 시작. → 하지만, 금 가격급등 사건을 제외하면 연평균 수익률은 3.6%에 불과함. 금리 뛰면 한도 더달어 줄어 … 대출자 ‘한숨’ → 주택 구입을 목표로 하고 있는 사람들에게 대출한도가 줄어들어 집을 살 수 있을 지 걱정이라는 기사 돈이 되고 싶지만 … 비트코인에겐 최악의 약점이 있다. → 가치가 안정성이 없다는 것. → 이쯤 되면 세계적으로 비트코인을 안 좋게 보려는 인식을 세뇌시키려는 것 같기도 하다.. 기사가 거의 부정적 올 수익률 75% 찍었다 … 전기차, 배터리의 질주 → 기사 그대로 전기차, 배터리 리튬 ETF 3개월간 수익률 63% 떡상 외국인의 변심 … “D램값 상승세 꺾인다” 전망에 1.6兆 팔아치워 → 삼성주가랑 SK하이닉스 주가가 떨어짐 왜? → 트랜드포스라는 곳에서 D램의 고정거래 가격(도매가격이라고 그냥 이해)이 하락할 것으로 전망했기 때문. → 또한, 현물가격이 추락하고 있음. 전 세계적으로 PC 수요가 줄어들고 있고 서버 기업들의 D램 수요가 예전같지 않다는 것. → 다른 이유로, 협상에 있어서 수요자들의 목소리가 커짐. 왜냐하면 아마존, 페이스북 등 서버용 반도체를 대량으로 구매하는 고객사들이 우리나라 인재들을 영입해가고 있기 때문이다. → 결국 공급의 문제라는 평이 있음. → 이재용 삼성전자 부회장이 반도체 공급을 늘릴 수도 있는데, 그러면 반도체 가격이 낮아질 수도 있다는 것. 공급량을 조절해야함. → 자동차, 산업 장비에 쓰이는 마이크로컨트롤러 공급난은 여전함. 주문을 하면 20주 뒤에 받는데, 그 기간도 점점 길어지고 있음. 일부 전문가는 반도체 구매업체가 재고를 과도하게 늘리면서 리드타임(기다리는 시간)이 길어졌다는 것. 반도체 업체들은 수급 안정을 위해 장기 계약을 희망하는 거래처가 늘면서 리드타임이 길어지고 있다.고함. 준법 강화. ESG 속도. 노사 상생 … ‘新삼성 경영’ 출발선 섰다. → 부회장 가석방을 통해 삼성전자가 달라질 것을 말함. → 크게 3개로 준법경영 강화, ESG 강화, 노사 관계 개선 실효성 있는 준법감시 위해 ‘삼성준법감시위원회’ 설치, 준법위 독립성과 지속적인 활동 보장 ESG 강화를 위한, 삼성물산 등 계열사 석탄산업 관련 투자 중단, 대표이사와 이사회 의장 분리, 이사회 내 지속가능위원회 설치, 취준생 1만명에게 SW교육 노사관계 개선을 위한 ‘무노조 경영’ 폐기, 이사회 산하에 외부 전문가로 구성된 노사 관계 자문그룹 설치, 삼전 / 삼성 디스플레이 노사 단체협약 체결 통신 끌고 신사업 밀고 … SKT, 2분기 호실적 → 올 2분기 호실적을 냄. 지난해 2분기 대비 매출 4.7%, 영업이익 10.8% 오름. → 신사업이 매출 3분의 1비중. 미디어 사업 매출 8.7% 늘음. IPTV콘텐츠웨이브의 OTT가입자가 늘어난 결과. SK브로드밴드 전년대비 40% 상승. ADT캡스를 필두로 한 융합보안(S&amp;amp;C) 사업 매출은 14.5% 증가. 무인화 사업 등 새 분야에 선제 투자를 벌이면서 비용이 늘었다는 설명. 커머스 사업 매출은 9.6% 늘음. e커머스 시장의 경쟁이 치열한데, 이에 대응하는 과정에서 손실을 많이 냈지만 11번가의 ‘오늘주문/내일도착’을 비롯한 빠른 배송 서비스를 새로 선보임. → 구독, 베타버스, 기업간 거래(B2B) 영역에서 신성장동력을 찾을 계획. K조선 질주 …LNG선 싹쓸이, 선박값 최고 → 3개월 연속 글로벌 수주 1위. 중국을 뛰어넘음. → 한국이 45% 중국이 44%로 수주 1등 먹음. → 가능했던 이유는 한국이 대규모의 수주계약을 따내면서 중국을 뒤쫓음. LNG 운반선 16척 전부(100%) 싹쓸이하고, VLCC 31척중 27척(87%), 초대형 컨테이너선의 50%를 쓸어해갔음. → 철광석 가격이 떨어지고, 후판의 가격도 협상이 이뤄지면서 조선업계가 안도의 한숨을 쉬는 중. (후판을 만드려면 철광석이 필요) 코로나 호황에 손놓은 게임 빅3 ‘어닝쇼크’ → 3N(넥슨, 엔씨소프트, 넷마블)의 실적이 충격 → 확률형 아이템 논란, 신작 부재, 직원 연봉 상승이 이유인 듯. → 넥슨의 경우 신작도 없고, 확률형 논란에, 일본법인이 비트코인을 사고 비트코인이 떡락했기에 영업이익이 42%감소. → 엔씨소프트 경우 카카오게임즈의 ‘오딘 : 발할라 라이징’에 모바일 게임 1위를 내주고, 직원 연봉 상승이 큰 요소. ‘리니지W’, ‘블소2’로 영업이익 상승을 노려야할 듯. → 넷마블의 경우 영업이익이 80% 감소. 하지만 ‘제2의나라’가 떡상조짐이 보이므로 좀 더 두고봐야할 듯. 또한, 마블코믹스와 협력한 ‘마블 퓨처 레볼루션’을 내놓는다. → 반면 중견사는 실적이 좋음. 쿠키런 킹덤으로 떡상한 데브시스터즈와 미르4로 이득을 많이본 위메이드 광효율 높은 경량 실리콘렌즈로 해외 공략 → 송성근 아이엘사이언스 대표. → 아이엘사이언스는 독자적으로 개발한 실리콘렌즈 기술이 있다. → 분사방식의 ‘디스펜싱’기술을 적용해 실리콘 렌즈를 만들었는데, 이러한 기술은 기존 양산이 어려운 실리콘 렌즈를 양산할 수 있게 도와주고, 불량률 또한 제로에 가깝고 별도의 금형 제작이 필요없어 원가와 납기에서 월등히 유리. → 여러군데에서 러브콜을 받아 생산라인을 4개에서 5개로 확대할 예정이다. → 아이엘사이언스는 미래 먹거리 사업으로 미래차를 정조준하고 있다. 또한 ‘카이룩스’라는 음성인식 주거공간 사물제어 플랫폼을 제작 3분기 출시 예정. 음성으로 주거공간 내 조명뿐만 아니라 각종 전자제품을 조절함. “저녁식사를 할거야”라고 하면 거실의 조명이 꺼지며, 식탁에 조명이 켜지고 음악이 흘러나오는 기능 → 두피 모발 케어 브랜드 ‘플리니크’를 통해 뷰티 플랫폼도 향후 신사업으로 육성할 계획. ‘미세전류 LED 두피케어기’ → 카메라로 두피 상태를 매일 분석해 관리법을 알려주는 등 뷰티 플랫폼 구축이라는 청사진도 그리고 있음. “디지털 기술 접목, 쇼핑이 재미있고 편리” → 12일 문여는 나이키 서울 디지털을 접목한 다양한 기술 → ‘스포츠와 도시, 그리고 소비자를 연결하겠다’는 콘셉트로 새롭게 선보인 매장. → 1층에는 ‘브로드캐스트 부스’ 나이키 직원과 원격으로 소통할 수 있는 공간. 제주도에 거주하고 있는 회원이 사전 신청을 통해 상담을 요청하면 지원이 부스에서 컴퓨터를 통해 실시간 컨설팅을 해줌. 제품 사이즈, 소재는 물론 일대일 스타일링도 제공. → 브로드캐스트 부스 반대편에는 운동 장비를 직접 골라 셀프 체크아웃을 할 수 있는 ‘그랩 앤 고’ 공간. 일상이 바쁜 현대인들도 도심에서 곧바로 운동을 즐길 수 있도록 간편한 스포츠 의류와 운동 보조용품, 건강음료를 비치 → ‘전자태그(RFID) 기술’이 적용된 ‘인사이드 트랙’ 소비자가 매장에서 원하는 신발을 골라 테이블 위에 올려놓으면 제품에 대한 각종 상세 정보가 디스플레이에 일목요연하게 뜸. 스펙과 리뷰는 물론 회원들의 누적 리뷰거리가 정보로 제공. → ‘나만의 티셔츠’ ‘시티리플레이’라는 공간에 스티커를 파는데 스티커를 골라 직원에게 건네면 열처리 과정을 거쳐 스티커가 부착된 티셔츠를 받을 수 있음. → 향후 ‘나이키 리페어’와 ‘업사이클링 워크숍 트래쉬랩’이라는 서비스도 운영할 계획 소비자가 신던 신발을 가져오면 수선해주거나 새롭게 디자인하여 신제품으로 만들어주는 것. 소비자들 주말 휴업 반대에 … 與 ‘쇼핑몰 규제’ 완화 → 복합쇼핑몰 규제에는 한 발 물러서 절충안을 마련하고 대형마트에는 규제 완화책을 마련하면서까지 법안을 추진하려는 與의 배경에는 소상공인 업계와 유통 업계의 이해관계가 팽팽하게 대립하기 때문. → 복합쇼핑몰은 백화점과 대형마트가 각종규제와 온라인 시장 성장으로 인한 매출 감소로 경쟁력을 잃어가는 상황에서 등장. 쇼핑 및 오락, 문화 등 다양한 체험형 시설을 마련하면서 소비자들사이에서도 새로운 유통 공간으로 주목 받음. → 유통업계에서는 복합쇼핑몰에서 의무휴업을 적용하려는 것이 중소기업과 자영업자 보호에 부합하지 않는다. 실제 복합 쇼핑몰의 운영 주체가 대기업인 것과 달리 실제 입점 업체의 대부분은 중소공인이다. (60 ~ 70%), 또한 주요 고객이 ‘주말 나들이객’이라는 점에서 의무휴업을 진행하는 것보다 피해가 적을 것이라는 입장. → 대형마트의 새벽배송 허용은 유통 업계의 의견을 적극 반영한다는 것으로 보임. 쿠팡과 마켓컬리와 같은 곳과의 경쟁을 고려하면 불공정하다는 문제 제기가 꾸준히 있었기 때문이다. 대형마트의 새벽배송은 결국 쿠팡과 같은 곳과의 경쟁이지 소상공인은 직접적인 경쟁자가 아니기 때문에 소상공인 피해와는 무관하다는 입장도 있다. 日은 ‘킹덤’, 韓은 ‘바람의 검심’ 1위… 콘텐츠 한일戰 ‘윈윈’ → 넷플릭스 인기 콘텐츠 세계 순위 판타지 사극 기준 킹덤 2위 바람의 검심이 4위지만 데이터를 보면 재밌는 부분들이 많다. → 아시아 쪽에서는 킹덤이 순위가 높고, 유럽쪽에서는 바람의 검심의 순위가 높다. → 일본 만화 고정팬층이 두터운 미국과 한인 교민이 많은 캐나다의 데이터 차이. → 재밌는 것은 킹덤이 인기를 끈 지역은 바람의검심도 인기를 끌음. 문화적 이질성보다 동질성이 큰 나라들이라고 문화평론가가 말함. 美 테이퍼링 예고에 인프라투자까지 … 신흥국 ‘자금이탈’ 공포 → 이해 못한 기사.. 어려움. 4.5조달러 인프라 예산 통과 바이든표 부양책 속도 낸다. → 미 행정부가 추진한 3.5조 규모의 인프라 예산안이 통과 → 찬50 : 반 49로 14시간 동안이나 공방이 오갔지만, 공화당 의원 1명이 표결에 참여하지 않기로 하면서 예산이 최종 통과 → 전날 1조달러 규모 인프라 예싼안은 찬성 69 대 반대 30으로 통과 → 복지,교육, 의료보험제도 확대, 기후 변화 대처 등 공화당이 반대하는 내용이 담겨져있음. 공화당은 나라빚이 늘어날 우려가 있다고 반대. → 민주당은 도로 다리 교통 수도 등공화당과 타협 가능한 예산안을 따로 편성해 통과시킴. → 미국 소비자물가가 두 달 연속 5%대 중반의 높은 상승률을 보여 인플레이션 우려가 커지고 있음. 8 ~ 9월 고용지표가 잘 나오면 조속히 테이퍼링을 시작하겠다는 입장. 탄핵 압박에 … 버티던 쿠오모(뉴욕주지사) 결국 “사퇴” → 직원 성추행 의혹을 받은 쿠오모 결국 사퇴. 혐의는 부인 → 뉴욕 첫 女주지사 탄생. 캐시 호컬 부지사가 맡음. → 뉴욕주에선 두 명의 주지사가 연속으로 ‘성 스캔들’에 휘말려 중도 하차하는 진기록을 쓰게 됨. 2008년 엘리엇 스피처 당시 주지사는 고급 매춘조직 고객이란 사실이 드러나 데이비드 패터슨 부지사에게 자리를 넘겼었음. ‘脫탄소’ 나선 美 전력사들 … SMR에 꽂혔다. → 미국 전력회사들이 소형모듈원전(SMR) 사업으로 눈돌리는 중. → SMR은 탄소배출을 줄이면서도 안정적으로 전력확보가 가능. → 대형 원전의 5~10% 크기지만 발전 용량은 고효율을 자랑한다. 탄소배출도 거의 없음. → 하지만, SMR이 상용화 되는데는 수년이 걸릴 전망. 시험 중인 SMR 가운데 정부의 규제 기준을 통과한 설계는 없음. 비용 부담이 문제다. 정확한 SMR 설치 비용은 공개되지 않았지만 전문가들은 수천만달러에서 수입억 달러가 소요될 것으로 보고 있음. → 미국은 앞으로 상장기업에서 자세 제품을 생산할 때 얼만큼의 탄소를 배출하는지 의무적으로 공개해야 할 수도 있을 것이라고 전망. 임대사업자 ‘마녀사냥’에 원룸 전월세 줄고 임대료 상승 역풍 → 70세 이모씨는 젊었을 때 일을 열심히하여 빌라 한 채 올리고 세를 받음. 노인 복지관에서 100만원 받고, 세로 380만원 받는데 세금은 5000만원을 내야함. → 어쩔 수 없이 자녀에게 3 가구를 넘겼는데 양도세만 8천만원. → 자녀들은 무주택자가 아니게 되므로, 청약 기회도 잃음. → 임대사업자에 대한 혜택을 폐지하면 세입자에게 임차료 전가로 이어질 수 밖에 없다는 것. 설익은 규제에 극심한 거래절벽 이달 서울매매 하루 20건도 안돼. → 7월에는 3182건 8월에는 188건. → 매물잠김 현상을 말함. 상가. 빌딩 거래 30% 급증 → 부동산 규제가 강화되자 오피스텔을 제외한 상가, 빌딩, 숙박시설 등 상업. 업무용 부동산 거래량이 최고치를 찍음. → 2019년 7.4만건 2020년 7.7만건 2021년 10.2만건 → 정부가 투기과열지구와 조정대상지역을 확대하고, 이들 지역에 새로 공급되는 100실 이상 오피스텔에 대한 분양권 전매 제한을 강화한 영향으로 풀이 된다고 설명. 차익 15억 … 개포 ‘무순위 청약’ 25만명 몰려 과천재건축 잰걸음 … 주공 10단지도 조합 인가 → 대규모 공급효과로 전세값이 주춤한 과천 아파트가 입주가 마무리되고 물량이 소진되면서 가격이 오르고 있다. 또한 과천 주공 10단지의 조합 설립 인가를 승인했다고 밝힘. 1월에 20억원대에 진입하고 5월에는 21억원을 돌파. 사전청약에 미룬 민간 분양 … 안양.용인 등 2만여가구 쏟아진다. 홍남기 “남양주 군부대 이전부지에 주택 3200가구 공급” 1주택자 12억까지 양도세 비과세 … 장기보유공제는 ‘최종 1주택자 된 날’부터 적용 중개수수료 논란 큰데… 공인중개사협, 반값수수료 또 고발 → 다윈중개라는 플랫폼이 있음. → 해당 플랫폼은 집주인이 매물을 직접 올리고, 등록된 공인중개사를 선택해 거래를 진행하는데, 매도자는 수수료를 내지 않고 매수자가 수수료의 절반을 내야함. → 예를 들어 10억원 아파트를 공인중개사를 통해 거래할 경우 매수.매도자가 각각 900만원의 중개수수료를 내야하지만, 다윈 중개를 이용하면 매도자는 0원 매수자는 450만원만 내면됨. → 다윈중개는 이용자가 10만명이 넘었고, 공인중개사 1000명 이상이 이 플랫폼을 이용중. → ‘공인중개사가 아닌 자는 공인중개사 또는 이와 유사한 명칭을 사용하지 못한다’라는 것을 주장으로 고소. → 하지만 다윈중개 측은 직접 중개를 하지 않고 플랫폼에서 소비자와 중개인을 연결하는 역할만 한다면서 반박. → 협회가 다윈중개를 고발한건 이번이 세 번째이고, 집토스, 트러스트 등도 고발. 뿐만아니라 네이버와 직방같은 대형 플랫폼 회사들이 중개시장에 뛰어들 것이란 염려 때문에 골치가 아픈 듯하다. 유럽 임대주택 모범국 보니 … 인기 지역 20년 기다려야 입주 → ‘임대 주택 천국’으로 유명한 스웨덴, 네달란드 등도 보면 집 때문에 난리가 나있다는 내용. " }, { "title": "leetcode(리트코드)-1582 Speical Positions in a Binary Matrix(PYTHON)", "url": "/posts/leetcode_Special_Positions_in_a_Binary_Matrix/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-08-12 01:34:50 +0900", "snippet": "leetcode 1582 - Speical Positions in a Binary Matrix 문제입니다.1. 문제https://leetcode.com/problems/special-positions-in-a-binary-matrix/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 ‘0’과 ‘1’로 이루어진 매트릭스가 주어집니다. ‘1’에 대해서 해당 열과 해당 행에서 유일하게 ‘1’로 존재한다면 이러한 ‘1’의 갯수를 찾아 리턴합니다.5. code코드설명pythonclass Solution: def numSpecial(self, mat: List[List[int]]) -&amp;gt; int: def checkj(mat,j): i = 0 sumres = 0 while i &amp;lt; len(mat) : if mat[i][j] == 1 : sumres += 1 if sumres &amp;gt; 1 : return 2 i += 1 return 1 row = len(mat) col = len(mat[0]) res = 0 for i in range(row): for j in range(col): if mat[i][j] == 1 and sum(mat[i]) == 1 and checkj(mat,j) == 1 : res += 1 return res 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "2021.08.10(화).경제 정리노트", "url": "/posts/economy0810/", "categories": "Economy, DailyNote", "tags": "Economy", "date": "2021-08-11 00:50:50 +0900", "snippet": "2021.08.10 경제 헤드라인을 정리한 글입니다. “연말쯤 테이퍼링, 너무 두려워할 건 없다.” → 미국이 연말쯤 테이퍼링을 할텐데, 말그대로 두려워할 필요 없다는 기사. 단, 연준이 노력한다면 → 연준이 미국 국채를 많이 사야 시장의 충격이 줄어들 것 美 ‘신중한 테이퍼링’ 추진해도 신흥국 시장 불안 가능성이 있다. → 뭔 말인지 모르겠다. ‘세계의 공장’ 중국 생산자물가 급등, 글로벌 인플레 압박 → 원자재값 상승에 7월 9% 치솟아, 한국 수입비중 22% 가장 영향 커 → 생산자물가지수(PPI)가 예상보다 크게 상승 → 원인으로는 원자재값의 상승인데, 중국 제조업 기업에 부담이되는 것을 해외 고객에게 전가할 가능성이 크다. → 한국은 전체 수입액에서 중국이 차지하는 비율이 22%이기에 꽤 타격이 있을 것. ‘델타; 늪에 빠진 하반기, 더블딥 빠져드나 → 4차 대유행 장기화로 인해 더블딥(이중 침체)에 빠져드냐는 내용 → 지난해 4분기부터 네 분기 연속 플러스 성장을 기록하였는데, 이번 4차 대유행 때문에 마이너스 성장을 하지 않을까라는 것. → 정부가 돈을 풀어야 3분기 성장률을 플러스로 지탱할 수 있을것이라는 말이 나옴. 하지만, 대면 소비를 촉직하는 재난지원금은 도화선이 될 수 있다는 우려의 목소리가 있다. ASF 날벼락 … “이미 金겹살인데 또 올라?” 장보러 가면 한숨만 → ASF : 아프리카 돼지 열병 → ASF가 강원도 고성에서 발생. 2300마리 정도로 전체의 0.02%가 살처분 → 하지만 단기적으로 ASF에 의한 일시 이동 중지 명령은 돼지고기 유통에 차질이 있을 수 있다. → 수입산 삼겹살 2등을 차지하던 독일에서도 ASF가 발생하면서 수입 금지 조치가 내려져 수입량 자체가 많이 줄었다. 수입산은 국내 공급의 약 35를 차지. → 원유 값의 상승으로 토스트, 케이크 등의 가격이 조금씩 올랐다. 카뱅, 상장 이틀만에 코스피 시총 9위 → 공모가 2배로… 셀트리온 제쳐 20일엔 MSCI지수 편입 예고 → 금융주 시총 2위인 KB금융(22조)와는 더 큰 격차. 카뱅의 시총은 37조정도. → 고평가 논란. 10조 날릴라 … 홍콩증시 급락에 ‘ELS 공포’ → ELS : 주가지수 등을 기초자산으로 삼아 이들의 가격을 6개월마다 평가, 조건 만족 시 약속된 수익을 지급하고 상환. 보통 ELS 만기는 2~3년이고 6개월마다 조기 상환 기준이 기준가 대비 5%씩 내려감. 2년짜리라면 만기시 기준가 대비 80% 이상, 3년짜리는 70% 이상이면 원금과 수익을 거둘 수 있다. → 중국 규제로 인해서 조건을 만족하지 못함 그 때문에 돈이 묶여있음. 1월초에 발행된 물량은 대부분 상환되었으나 전체의 4.5%정도 수준이고, 앞으로 이러한 상태가 지속된다면 돈을 못 받을 수도 있다는 것. → 만약 투자자가 임의로 중도 상환을 하면 증권사가 수수료를 떼가 원금 손실이 남. 토종 핀테크 기업 ‘인공지능 ETF’ 美 증시 잇단 노크 → 국내 토종 핀테크 기업들이 인공지능을 기반으로 한 상장지수펀드(ETF)를 미국 뉴욕 증시에 상장 → 파운트 : 메타버스, 구독경제를 테마로 한ETF 2종의 상장을 끝냄. → 크래프톤테크놀로지 : 2019년부터 뉴욕증시에 4종의 ETF를 상장해 좋은 성적 기록. 1년 전보다 9배의 순자산이 불음. → AI 금융은 가능성에 비해 규모가 작은 초기 시장이라며 기회가 열릴 수 있다는 크래프톤 대표의 입장. → 국내의 증시에서 AI가 운용하는 ETF는 미래에셋자산운용의 TIGER AI코리아그로스액티브 ETF뿐. 스틱 ‘국내 첫 美동박공장’ 일진에 1조 쏜다. → 동박 : 얇은 구리막을 뜻함. 2차전지 핵심 소재인 음극재를 만들 때 쓰임. → 국내에는 일진머티리얼즈, 두산솔루스, SKC라는 회사가 있음. → 고품질의 동박을 제조하는 회사는 일진머티리얼즈을 포함해 5~6곳 밖에 없음. → 일진머티리얼즈가 미국에 공장을 만든다니까 스틱의 투자금이 8000억에서 1조로 늘음. → 머티리얼즈는 세계 동박 시장 2위임.점유율은 9.7% 대만의 창춘이 12.9%로 1위 주먹구구식 가산금리… 은행별로 최대 4% 차이 → 대출 조절 명목으로 고무줄 책정 소비자 이자 부담만 늘어날 우려 → 가산금리는 대출 금리에 반영되는데 중,저 신용자가 고객층인 전북은행(6.6%)과 고신용자 고객층에게 주로 신용대출을 해주는 KDB산업은행(2.2%)와 4%이상 차이가 나게됨. → 뿐만아니라 시중은행에서도 최대 1.5%가 차이가 나면서 ‘경영 유의’ 통보를 받음. 코인 바닥쳤나 … 한달새 102개 중 99개 상승 → 이더리움 업그레이드인 ‘넘버2’ 때문에 암호화폐 시장 투자심리 살아남. → 업그레이드를 하면서 수수료가 낮아지고 발행량이 줄어들 것이라는 관측이 더해짐 → 블룸버그는 “미국 의회가 암호화폐에 대한 보고 의무화와 세금 부과 등 규제 방안을 추진하고 있어 여전히 불확실성이 남이 있다.”고 지적. 한화 김동관, 친환경 사업 드라이브 → 김동관(한화솔루션 사장)이 프랑스 기업 RES에 1조를 내며 인수 → 현재 전 세계적으로 10GW의 재생에너지 사업권을 보유하고 있었는데, 이번 일로 15GW의 재생에너지 사업권을 보유하게 됨. 삼성 한숨 돌렸지만 … 취업, 해외출장 제한 등 경영 걸림돌 여전 → 이재용 부회장 가석방이 결정 → 정부가 세계 반도체 시장을 의식하여 내린 결정같다 → 가석방 되면서 삼성SDI의 미국진출, 파인더리(반도체 위탁 생산업체) 증설이 될 지 기대 → 하지만,삼상 바이오 분식 회계 의혹, 경영권 부정 승계 등 사법 리스크를 100%를 해소하지 않음. 테슬라 제친 아이오닉5 … 국내 전기차시장 ‘대지진’ → 아이오닉5가 두달간 7400대를 팔어 판매 1위를 함. 테슬라는 4800대, 기아 EV6는 사전예약 3만대를 넘었음. → 대중들의 친환경 관심과, 전기차 관심이 그 이유인 것 같다는 내용. → 전기차 보조금 제도가 개편돼 전치가 판매에 악재로 작용할 것으로 예상했지만 럭셔리 전기차가 주목받으며 새로운 시장을 만들어내고 있음. 현대車-카카오모빌리티, 택시 전용 9인승 승합차 출시 → ‘스타리아 라운지’라는 9인승 승합차. 출고가가 3971만원이고 택시 사업자에 한해 판매함. → 자동으로 문이 열리도록 한 ‘스마트 파워 슬라이딩 도어’ 기능과 운전석과 조수석 사이에 17.3인치 ‘루프(지붕) 모티러’를 배치해 승객들이 2열 좌석에서도 영상 등을 볼 수 있도록 설계 애플카, LG . SK 누구 손 잡나 … 韓파트너사 주목 → 애플의 전기 자율주행차 프로젝트인 ‘타이탄 프로젝트’추진. → 완성차 업체인 현대, 기아, 폭스바겐 등에 협상 결렬 이후 배터리 와 자동차 부품에 강점을 가진 SK, LG에 협력 요청을 할 것 같다는 기사. → 세계 3위 자동차 부품사인 마그나와 LG전자와 합작한 ‘LG 마그나 이파워트레인’은 전기차에 필요한 모터, 인버터 등을 생산 LG디스플레이, 中이어 日철도에 투명 OLED 공급 → 중국에는 이미 지하철에 공급한 경험이 있음. → LG디스플레이는 세계에서 유일하게 투명 OLED를 양산하는 업체. → 이번에 JR동일본에서 운행하는 관광열차 차창을 약 55인치 크기의 투명 OLED로 구성할 예정이라는 것. → 투명 OLED는 유리를 통해 보이는 사물과 컨텐츠를 결합하는 AR을 구현하고 정보통신기술(ICT)을 활용해 고부가가치를 창출할 수 있다. → LG디스플레이는 투명 OLED를 집중 육성해 중국 기업 등 후발주자와 ‘초격차’를 확대한다는 구상. “고기 생각 안나네”… 대체식품에 꽂힌 회장님들 5억, 8억, 11억 … 한 아파트 세 전셋값 → 임대차법때문에 나타난 현상 → 11억은 신규 계약이고, 5억은 기존에 살고 있던 사람 → 8억의 경우는 세입자와 집주인이 협상을 한 것임. → 일부 “본인이나 직계가족이 실거주하면 계약갱신을 거부할 수 있다”는 점을 이용해 협박 카드로 사용하여 세입자와 딜을 함. 금리인상 ‘맷집’ 커졌는데 … 집값 잡겠다는 정부 사전청약자 절반 “분양가 오를까 불안” → 본청약때 확정 분야가가 정해지기에 청약자들이 ‘분양가격 인상’을 걱정 외곽 30평도 10억 .. 오세훈표 ‘스피드 공급’ 어디에 → 오세훈 시장이 재건축 규제 풀겠다, 24만 가구를 공급하겠다고 공약을 걸었으나 진척이 없는 상태 치솟는 집값에 … 무주택 서민 3종혜택 ‘유명무실’ → 청약, 대출, 취득세 감면이 집값이 오르면서 사실상 혜택이 사라짐. → 청약 ‘무주택’’ 인정 공시가 1억3000만, 대출은 집값이 5억을 넘으면 안되고, 취득세 감면도 4억 초과 땐 불가능하다. 압구정 재건축 ‘급류’ … 3구역도 도시계힉업체 선정 돌입. 인천 경매도 뜨겁다 … 낙차가율 ‘역대 최고’ → 서울과 경기의 낙차가율이 낮아짐. → 외각으로 빠지는 것 같다는 것. 인천의 오피스텔과 아파트 낙찰가율이 22.5% , 118.%로 늘어남. → 집값 급등 속 ‘저렴하다’ 인식 매매수오, 경매시장까지 몰려 중국, 규제 휘두르자 … 텐센트 등 창업자들 100조원 날렸다. → 중국의 빅테크 규제가 증시를 박살냈고, 그에 따른 창업자들 자본 손실이 엄청남. → 그와 반대로 신재생에너지, 자동차 부분의 기업 총수들의 자산을 오르고 있다. “2050년까지 글로벌 탄소 ‘0’ 실현해도, 북극 빙하 다 녹는다” → 를 막으려면 탄소배출을 급진적으로 줄여야 한다. " }, { "title": "leetcode(리트코드)-1576 Replace All&#39;?s to Avoid Consecutive Repeating Characters(PYTHON)", "url": "/posts/leetcode_Replace_All_'s_to_Avoid_Consecutive_Repeating_Characters/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-08-10 05:34:50 +0900", "snippet": "leetcode 1576 - Replace All’?s to Avoid Consecutive Repeating Characters 문제입니다.1. 문제https://leetcode.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 문자열에 대해 “?”에 임의의 문자를 넣습니다. 단 왼쪽 문자와 오른쪽 문자와 같으면은 안됩니다.5. code코드설명 랜덤함수 사용.pythonimport randomclass Solution: def modifyString(self, s: str) -&amp;gt; str: res = &quot;&quot; left = 0 right = 0 for i in range(len(s)): if s[i] == &quot;?&quot; : if i!= 0 : left = ord(res[i-1]) if i!= len(s)-1 : right = ord(s[i+1]) rand = random.randrange(97,122) while rand == left or rand == right : rand = random.randrange(97,122) res += chr(rand) else : res += s[i] return res 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "leetcode(리트코드)-926 Flip String to Monotone Increasing(PYTHON)", "url": "/posts/leetcode_Flip_String_to_Monotone_Increasing/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-08-10 04:34:50 +0900", "snippet": "leetcode 926 - Flip String to Monotone Increasing 문제입니다.1. 문제https://leetcode.com/problems/flip-string-to-monotone-increasing/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.4. 문제 해석 Monotone이란 내리막이 없는 수를 말합니다. “00000” 이나 “11111”, “0001111”와 같은 수를 말합니다. 수를 0이나 1로 뒤집을 수 있을 때 최소한으로 뒤집어서 Monotone를 만들어야합니다. 그 수를 리턴하세요.5. code코드설명 brute하게 풀면 시간초과가 나옵니다. “01”이 되는 구간을 찾아서 점화식을 구해서 풀었습니다. 점화식의 내용은 “01”구간에서 왼쪽구간에서 1의 개수 오른쪽 구간에서 남은 요소의 숫자 - (총 1의개수에서 + 왼쪽에 나온 1)의 갯수를 뺍니다. 왼쪽구간에서 구한 수와 오른쪽에서 구한 수를 더하면 됩니다.pythonclass Solution: def minFlipsMonoIncr(self, s: str) -&amp;gt; int: #re sz = len(s) totalone = s.count(&#39;1&#39;) totalzero = s.count(&#39;0&#39;) if totalone == sz or totalzero == sz : return 0 zero = 0 one = 0 res = 987564321 for i in range(sz-1) : if s[i] ==&#39;0&#39; and s[i+1] == &#39;1&#39; : res = min(res, sz - i - 1 - totalone + 2 * one) if s[i] == &#39;0&#39;: zero += 1 else : one += 1 return min(res, sz - s.count(&#39;1&#39;), sz - s.count(&#39;0&#39;))6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "leetcode(리트코드)-1556 Thousand Separtator(PYTHON)", "url": "/posts/leetcode_Thousand_Separator/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-08-10 03:34:50 +0900", "snippet": "leetcode 1556 - Thousand Separtator 문제입니다.1. 문제https://leetcode.com/problems/thousand-separator/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 n이 주어집니다. 금액에서 천단위로 ‘.’을 찍으시오.5. code코드설명pythonclass Solution: def thousandSeparator(self, n: int) -&amp;gt; str: n = str(n) res = &quot;&quot; for i in range(len(n)-1, -1,-1) : if (len(n)- i - 1) %3 == 0 : res+= &quot;.&quot; res+=n[i] return res[::-1][:-1] 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "leetcode(리트코드)-1807 Evaluate the Bracket Pairs of a String(PYTHON)", "url": "/posts/leetcode_Evaluate_the_Bracket_Pairs_of_a_String/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-08-10 02:34:50 +0900", "snippet": "leetcode 1807 - Evaluate the Bracket Pairs of a String 문제입니다.1. 문제https://leetcode.com/problems/evaluate-the-bracket-pairs-of-a-string/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.4. 문제 해석 ()안에 들어있는 것을 바꿔야합니다. knowledge들어있는 [0]번째 요소는 키값 [1]번째 요소는 value로 ()안에 있는 값과 일치하면 value값으로 바꿉니다. 만약 일치하는 key값이 없다면 “?”를 넣어줍니다.5. code코드설명pythonclass Solution: def evaluate(self, s: str, knowledge: List[List[str]]) -&amp;gt; str: #list to dic dic = {} for i in range(len(knowledge)): dic[knowledge[i][0]] = knowledge[i][1] #임시로 문자열을 담을 변수 temp = &quot;&quot; #결과 문자열 res = &quot;&quot; i = 0 sz = len(s) while i &amp;lt; sz: if s[i] ==&quot;(&quot; : i+=1 while i&amp;lt; sz and s[i] != &quot;)&quot;: temp += s[i] i+=1 if temp in dic : res+= dic[temp] else : res += &quot;?&quot; else : res += s[i] temp = &quot;&quot; i+=1 return res 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "leetcode(리트코드)-1694 Reformat Phone Number(PYTHON)", "url": "/posts/leetcode_Reformat_Phone_Number/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-08-10 01:34:50 +0900", "snippet": "leetcode 1694 - Reformat Phone Number 문제입니다.1. 문제https://leetcode.com/problems/reformat-phone-number/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 number가 주어집니다. number의 요소가 숫자인 것만 뽑고 3개씩 ‘-‘로 구분합니다. 만약 남은 숫자요소의 갯수가 4개라면 2개-2개로 분리합니다. 분리된 문자열을 리턴하세요.5. code코드설명pythonclass Solution: def reformatNumber(self, number: str) -&amp;gt; str: #brute list sz = len(number) resli = deque() count = 0 for i in range(sz): if number[i].isdigit(): count+=1 resli.append(number[i]) if count%3 == 0 : resli.append(&quot;-&quot;) if count%3 == 0 : resli.pop() if count%3 == 1 : resli[-3],resli[-2] = resli[-2], resli[-3] return &#39;&#39;.join(resli) 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "2021.08.09(월).경제 정리노트", "url": "/posts/economy0809/", "categories": "Economy, DailyNote", "tags": "Economy", "date": "2021-08-10 00:50:50 +0900", "snippet": "2021.08.09 경제 헤드라인을 정리한 글입니다. 파주 살면 26만원, 춘천은 0원 … “재난지원금 지역격차 서럽네” → 기사 그대로 코로나로 인해 피해는 전국민이 봤는데, 지역에 따라 지원금 격차가 나는 실태에 대한 내용. 고철값 고공행진 … 철강사들 석탄 대신 찾아 → 탄소중립때문에 그럼 → 원래는 철광석을 코크스로 녹여 쇳물로 만드는데, 코크스가 탄소을 많이 배출함. 때문에 철광석과 코크스 투입량을 줄이고, 고철 비중을 늘리는 방식으로 탄소배출량을 줄이기 시작. → 고철값이 오름. 이러한 현상의 중심은 포스코 고철 활용 비율을 올려서 조업 중이라고 밝혔기 때문이다. 부동산시장 내리막엔 신축 아파트 거품부터 빠진다. → 지난해 폭등 세종시 내리막 수도권도 하락 전환 대비 → 단기 급등, 신축 효과 주의 ‘입지’ 가치가 제일 중요. “비트코인 살아있네” … 다시 5000만원대 부산, 해운대 등 해수욕장 모두 문 닫는다 … 내일부터 4단계 격상 → 해운대에 22만명이 들렸었음. 부산에서 심각성을 느꼈는 지 4단계로 격상하고 해수욕장을 모두 닫기로함. → 속초 해수욕장도 야간개장을 일주일 앞당겨 빠르게 폐쇄하기로 함. 분양권 규제에 … 용인 임대주택도 4억 웃돈 → 뭔말인 지 모르겠음. 서울 거주자 ‘아파트 원정쇼핑’ 3만3420건 역대 최다 → 서울 아파트 매매가격과 전세가격이 오르자, 비규제지역에 단기 시세차익을 노린 투자 수요가 유입된 것으로 풀이 됨. ‘서민 연료’ LPG 쇼크까지 덮쳤다. → 1년새 프로판 43%, 부탄 28% 급등 7년만에 최고치. → 국제가격 뛰고 환율상승이 겹쳐서 그런 것 같다. 중소기업, 자영업자, 택시업계 등에 상당한 부담이 예상 年 5만명 넘는 파산자, 취업. 자격제한 없앤다. → 구시대적 발상이라는 것. → 자본주의 경제질서에서 파산은 개인의 경제활동, 진전에 따라 어느정도 불가피한 측면이 있지만 취업 기회를 박탈하는 등 반사회적, 범죄적 행위로 낙인을 찍는건 과도한 행위라는 입장. → 국회에서 추진 중. 서울 아파트 입주도 ‘절벽’ 올 집들이 물량 37% 줄어 → 서울 아파트와 서울 외 아파트의 매물이 계속 줄어들고 있음. → 정부의 초기부터 무리한 규제로 재건축, 재개발 사업을 지연시킨 결과라는 분석이 지배적 → 조합원이 재건축으로 얻은 이익의 최대 50%를 부담금으로 환수하는 초과이익환수제와 주변시세보다 낮은 분양가를 강요하는 분양가 상한제가 재건축, 재개발 사업을 가로막는 대표적 규제로 꼽힘. 네이버, 카페24 최대주주 된다. → 지분 20% 인수를 했음. 1500억 ~ 2000억 → 창업자의 경영의지가 강해 경영권은 남겨두었지만, 차후에 인수하는 방안도 검토 중. → 카페24 : 1999년에 설립되어 쇼핑몰 개설, 광고.마케팅, 결제, 물류 등 다양한 서비스를 제공하는 솔루션 회사. 개인과 법인 등 190만 명의 고객을 보유, 네이버 쿠팡 NHN 등을 넘어서는 국내 최대 규모의 솔루션업 현대, 대우, 롯데 등 건설사 컨소시엄 … ‘랜드마크 분양’ 큰 장 선다. → 컨소시엄 : 건설사 두 곳 이상이 아파트를 공동으로 짓는 것을 말한다. → 현대건설 + GS 건설 → 대우건설 + 현대건설 등… → 건설사 간의 시너지를 챙길 수 있어서 장점이 있다. → 조경과 커뮤니티 시설에 강점이 있는 건설사와 스마트홈 시스템에 특화된 건설사와 같이 시공하면 두 장점을 얻을 수 있다는 것. JP모간, 中서 지분 100% 증권사 설립 첫 허가받아 “중국 자본시장 개방 가속화” → 미국 투자은행 JP 모간이 중국에서 증권사를 운영하게 됨. → 중국증권관리감독위원회(CSRC)로부터 공식 허가를 받음. → 중국 당국의 규제로 외국인의 투자자 매수 심리가 위축되자 새로운 접근을 시도하는 것이 아니냐는 말도 있다. 폭염보다 무서운 LPG값 폭등 … 택시들 “대기할 땐 에어컨 끈다.” → 8번기사와 같다. “구글처럼 혁신적인 한국 기업 많아 … ESG 부족하면 투자 안한다” → 오프라인과 온라인을 통합한 ‘옴니라인’시대가 올 것. → 홈플러스에 투자한 것도 쿠팡에 위협을 받고 있지만, 온라인으로만 수익을 내는 쿠팡이 과연 맞는 방향인 지 모르겠다 라고 함. → MBK파트너스 회장은 ESG가 부족한 기업엔 투자하지 않겠다고 하면서 도덕성이 아닌 수익성 측면에서 좋기 때문이라고 함. 내년 입주 앞두고 ‘문화재 복병’ 검단신도시 3400가구 공사중단 → 인천 서구 검단신도시 아파트 단지들. → 2014년에 건설사가 인청도시공사한테 허가받은 땅과 건축물임. → 법이 개정되면서 개별심사를 다시 해야한다는게 문화재청의 입장. → 시공사들은 법원에 행정처분 집행정지 가처분 신청을 제기할 예정 머스크, 해운업 호황 수혜 2분기 영업익 3배 ‘폭풍성장’ → 세계 최대 해운업체인 덴마크 머스크가 2분기에 역대 가장 많은 이익을 거둔 것. → 물동량 급증, 운임비 상승 영향 → 벅셔해서웨이도 이익 21% 즈가 2분기에 자사주 60억 사들어 “110주 연속 오른 서울 전셋값, 임대차법 없애야 잡을 수 있다.” → 정부, 규제실패 인정하는 용기가 필요. → 민간주택 공급 숨통 터줘야한다 - 임대차법 폐지와 재건축 규제를 풀어야한다. ‘고액권 폐지’ 화폐개혁 바람 … 한국 5만원권은? → 베네수엘라가 화폐개혁하는데 뭔말인지 모르겠음. 집주인 - 세입자 분쟁만 키운 임대차법 → 임대차3법 시행 1년만에 법률상담 7200건 쏟아져 → 법원도 유사분쟁 해석이 달라 .. 대법 판단까진 혼선 → A씨가 실거주 목적으로 집을 매매했음. 그 집에는 이미 전세를 놓고 있었기에 집주인이 세입자에게 실거주 목적으로 나가달라했음. 세입자는 OK했기에 매매계약을 했는데 갑자기 입장을 바꿈. 입장을 바꿔서 집주인과 세입자에게 소송을 제기했는데, 법원에서 세입자에게 손을 들어줌. 근데 서울에서는(위는 수원) 비슷한 사건에서 집주인에게 손을 들어줬음. 중소 코인거래소 줄줄이 폐업 대형사도 트래블 룰에 ‘뒤숭숭’ → 거래소 신고 기한 한 달 앞두고 은행은 자금세탁방지 평가 강화 현대엔지니어링, 정비사업 수주 1조 돌파 → 리모델링 부문이 도시정비사업의 새로운 동력으로 성장할 것을 예상하고 영업, 견적, 설계 등 분야별 내부 전문가를 구성한 ‘리모델링 TFT’를 운영해 대응한 결실로 평가됨. 결혼식 49명인데 … 종교시설은 99명 허용? → 형평성 논란. → 예전에도 개인 카페는 되고, 프랜차이즈 카페는 매장내 취식이 불가능한 점과 일반 노래방은 되지만 코인노래방은 안되는 형평성 논란이 있었다. 한은 “올 물가 9년 만에 2% 넘을 것” 힘 받는 ‘8월 금리인상론’ → 기사제목 그대로 → 꾸준히 물가가 오를것이라는 인프레이션 기대가 물가의 지속적 상승을 부르는 인플레이션 소요돌이를 초래할 수도 있다. 거리두기 4단계 나몰라라 한강 선상카페 ‘노마스크 파티’ → 일반음식점인데 클럽처럼 운영하여 밤늦게까지 수십명 춤추고 놀았음. SNS로 유명해지면서 DM으로 예약제를 운영하여 손님을 받음. 계란 돼지고기 이어 우유대란 … 장바구니 덮치는 ‘밀크 인플레’ 또 매맞는 中 빅테크 … 텐센트 압박 → 테센트가 만든 위챗 “청소년 모드”가 청소년보호법에 위법한다고 검찰이 소송을 걸음. → 또한 메이퇀이라고 시장의 60%를 차지하고 있는 중국음식배달 회사가 독점 규정 위반으로 10억 달러의 벌금을 부과받을 것이라고 함. " }, { "title": "leetcode(리트코드)-1544 Make The String Great(PYTHON)", "url": "/posts/leetcode_Make_The_String_Great/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-08-09 06:34:50 +0900", "snippet": "leetcode 1544 - Make The String Great 문제입니다.1. 문제https://leetcode.com/problems/make-the-string-great/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 s가 주어집니다. 임의의 인덱스들에 대해 그 전의 인덱스값이 고른 인덱스의 소문자의 형태거나 그 반대(소문자인데 대문자)인 경우 요소를 삭제하여 남은 문자열을 리턴합니다.5. code코드설명 queue를 사용하였습니다.pythonclass Solution: def makeGood(self, s: str) -&amp;gt; str: dq = deque() for i in range(len(s)): if not dq : dq.append(s[i]) continue if dq[-1].isupper() and ord(dq[-1]) + 32 == ord(s[i]) : dq.pop() elif dq[-1].islower() and ord(dq[-1]) - 32 == ord(s[i]): dq.pop() else : dq.append(s[i]) return &#39;&#39;.join(dq) 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "leetcode(리트코드)-415 Add Strings(PYTHON)", "url": "/posts/leetcode_Add_Strings/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-08-09 04:34:50 +0900", "snippet": "leetcode 415 - Add Strings 문제입니다.1. 문제https://leetcode.com/problems/add-strings/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 num1과 num2이 string의 형태로 들어옵니다. num1과 num2를 더한 값을 string형태로 리턴하세요.5. code코드설명pythonclass Solution: def addStrings(self, num1: str, num2: str) -&amp;gt; str: return str(int(num1) + int(num2)) 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "leetcode(리트코드)-1352 Product of the Last K Numbers(PYTHON)", "url": "/posts/leetcode_Product_of_the_Last_K_Numbers/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-08-09 02:34:50 +0900", "snippet": "leetcode 1352 - Product of the Last K Numbers 문제입니다.1. 문제https://leetcode.com/problems/product-of-the-last-k-numbers/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.4. 문제 해석 구현문제입니다. add()함수는 리스트에 값들을 넣습니다. getProduct()함수는 안에 들어온 값을 기준까지 리스트 맨 뒤에서 세어서 그 값들을 곱한 값을 리턴해야합니다.5. code코드설명 product는 리스트입니다. zerobase는 가장 최근에 들어온 ‘0’의 위치값입니다. 추후 getproduct()를 해줬을 때 이 이 위치값을 기준으로 값을 바로 리턴해줄 것입니다. 일단 product리스트에 들어오는 요소를 다 곱해버립니다. 만약 최근에 들어온 값이 ‘0’인 경우 값을 그대로 넣습니다. pythonclass ProductOfNumbers: def __init__(self): self.product = deque() self.zerobase = -1 def add(self, num: int) -&amp;gt; None: if num == 0 : self.zerobase = len(self.product) if len(self.product) == 0 : self.product.append(num) else : if self.product[-1] != 0 : self.product.append(num * self.product[-1]) else : self.product.append(num) def getProduct(self, k: int) -&amp;gt; int: idx = len(self.product) - k #print(self.product,idx,self.zerobase) if idx &amp;lt;= self.zerobase : return 0 if idx &amp;gt; 0 : if self.product[idx-1] == 0 : return self.product[-1] else : return self.product[-1] // self.product[idx-1] else : return self.product[-1]# Your ProductOfNumbers object will be instantiated and called as such:# obj = ProductOfNumbers()# obj.add(num)# param_2 = obj.getProduct(k) 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "leetcode(리트코드)-1700 Number of Students Unable to Eat Lunch(PYTHON)", "url": "/posts/leetcode_Number_of_Students_Unable_to_Eat_Lunch/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-08-09 01:34:50 +0900", "snippet": "leetcode 1700 - Number of Students Unable to Eat Lunch 문제입니다.1. 문제https://leetcode.com/problems/number-of-students-unable-to-eat-lunch/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 students는 queue로 이루어져있고, sandwiches는 stack으로 이루어져 있다고 가정합니다. students의 맨 앞에 있는 숫자와 sandwiches의 맨 앞에 있는 숫자와 같으면 두 요소를 삭제시켜주고, 다르면 students의 맨 앞 요소를 맨 뒤로 보냅니다. 위의 과정을 반복할 때 남아있는 students의 수를 리턴하세요.5. code코드설명pythonclass Solution: def countStudents(self, students: List[int], sandwiches: List[int]) -&amp;gt; int: #brute students = deque(students) sandwiches = deque(sandwiches) check = True idx = 0 while check : check = False if len(sandwiches) != 0 : idx = sandwiches[0] for i in range(len(students)) : temp = students.popleft() if idx == temp : sandwiches.popleft() check = True break else : students.append(temp) return len(sandwiches) 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "leetcode(리트코드)-1922 Count Good Numbers(PYTHON)", "url": "/posts/leetcode_Count_Good_Numbers/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-08-08 05:34:50 +0900", "snippet": "leetcode 1922 - Count Good Numbers 문제입니다.1. 문제https://leetcode.com/problems/count-good-numbers/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.4. 문제 해석 n이 들어옵니다. n의 길이를 가지는 문자열이 있다고 가정합니다.(요소는 각각 0~9의 숫자를 갖는다.) n의 짝수번째 인덱스에는 짝수가 와야하고, 홀수번째 인덱스에는 홀수 + 소수인 값이 와야합니다. 만들어질 수 있는 경우의 수를 10**9 +7 로 나눈 값을 리턴하세요.5. code코드설명 짝수번째 인덱스의 경우의 수는 5, 홀수번째 인덱스의 경우의 수는 4입니다. 5 * 4 * 5 * 4 * 5 … 를 반복하면 됩니다. pow()와 x**y중 후자를 선택하였는데, 시간초과가 나옵니다. 전자도 시간초과가 나오는데, pow(x,y,mod)를 이용하면 좀 더 효율적으로 계산이 가능합니다.pythonclass Solution: def countGoodNumbers(self, n: int) -&amp;gt; int: mod = 10 ** 9 + 7 return (pow(20 , (n//2),mod) * pow(5 , (n%2),mod)) % mod 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "leetcode(리트코드)-1684 Count the Number of Consistent Strings(PYTHON)", "url": "/posts/leetcode_Count_the_Number_of_Consistent_Strings/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-08-08 03:34:50 +0900", "snippet": "leetcode 1684 - Count the Number of Consistent Strings 문제입니다.1. 문제https://leetcode.com/problems/count-the-number-of-consistent-strings/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 allowed와 words가 주어집니다. allowed에 들어있는 문자들은 ‘같은 취급합니다.’ 같은 취급을 하였을 때 words에 들어있는 word들에 대해서 연속된 문자열의 갯수를 구하세요 allowed가 ‘ab’이고 word가 ‘ab’여도 같은 취급을 하는 것입니다.5. code코드설명 좋지 않은 코드입니다. 반대로 특정 문자가 word안에 없으면 그 즉시 반복문을 깨는 코드로 작성하는 편이 좋습니다.pythonclass Solution: def countConsistentStrings(self, allowed: str, words: List[str]) -&amp;gt; int: ans = 0 for i in range(len(words)): res = 0 size = len(words[i]) for j in range(len(allowed)): res += words[i].count(allowed[j]) if res == size : ans += 1 return ans &#39;&#39;&#39;best code count = 0 for word in words: for w in word: if not w in allowed: count += 1 break return len(words)-count&#39;&#39;&#39;6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "leetcode(리트코드)-1716 Calculate Money in Leetcode Bank(PYTHON)", "url": "/posts/leetcode_Calculate_Money_in_Leetcode_Bank/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-08-08 01:34:50 +0900", "snippet": "leetcode 1716 - Calculate Money in Leetcode Bank 문제입니다.1. 문제https://leetcode.com/problems/calculate-money-in-leetcode-bank/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 n이 들어옵니다. 1원부터 시작해서 일주일간 1원씩 돈을 냅니다. 일주일이 지나면 돈은 초기화되면 전 주의 1원을 더한 값부터 위의 방식을 반복합니다. 위 두 과정을 반복하였을 때 지불한 금액을 리턴하세요.5. code코드설명 각 리스트의 요소는 사각형의 폭과 높이입니다. 변을 잘라서 정사각형을 만들 때 가장 폭이 긴 정사각형의 갯수를 리턴하세요.pythonclass Solution: def totalMoney(self, n: int) -&amp;gt; int: mod = n // 7 res = n % 7 ans = 0 for i in range(mod): ans += 28 + i * 7 for i in range(1,res+1) : ans += i + mod return ans 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "2021.08.07(토).경제 정리노트", "url": "/posts/economy0807/", "categories": "Economy, DailyNote", "tags": "Economy", "date": "2021-08-08 00:50:50 +0900", "snippet": "2021.08.07 경제 헤드라인을 정리한 글입니다. 94만 넘은 美 고용 테이퍼링 빨라지나. → 한달새 취업자 수 9만명이 늘은 미국. → 크리스토퍼 월러 이사가 7~8월 고용이 매달 80만 명 이상 증가할 경우 오는 10월부터 테이퍼링이 이뤄질 수 있다고 함. → 하지만, 코로나 19 신규 확진자 수가 2주 전 대비 119% 증가했고, 입원 환자도 82% 늘음. 그렇기에 변이 확산으로 정부가 새로운 방역 조치를 적용할 경우 경제가 다시 약화될 수 있다고 우려 상반기 경상 흑자 443억 …. 5년 최대 → 이번 상반기에 작년보다 133%의 이익을 냄. 2016년 534억, 2015년 497억에 이은 역대 3위 성적. → 자동차 50%, 자동차부품 42%, 화공품 39%, 철강 28%, 반도체 21% 등 대부분의 품목에서 수출이 늘음. 무인화에 사라지는 일자리 … 저숙련 노동자 설 곳 없다. → 코로나 비대면으로 일자리가 사라짐. → 농어업이나 건설업 같은 고인물들의 노하우가 필요한 일자리의 경우 저숙련 노동자에 대한 교육, 등 수단이 필요. 가치를 산다. 착해야 산다. → ESG경영의 중요성에 대한 내용 → 식품업계는 통조림 뚜껑을 없애 플라스틱 사용 절감, 대체육 개발로 탄소배출 감축 기여 → 패션 업계는 소각 처리되던 재고 의류를 ‘업사이클링’ → 뷰티업계는 다 쓴 화장품 용기 수거 캠페인, 원료부터 포장재까지 천연 소재로 제작 개장후 -5%서 상한가 급반전 … 거래액 3.7조로 코스피 1/4 삼켰다. → 카뱅 주식 떡상했다는 이야기 설비 투자 큰 제조업, 현금 창출 능력 ‘EBITDA’살펴야 → EBITDA : 감가상각비 반영 전 영업이익 : 이자, 법인세, 감가상각 비용을 반영하기 전 영업이익을 말함. 널뛰기 줄고, 주말 약세장 멈춰 … 비트코인 ‘공식’깨졌다. → 비트코인이 떡상함. 이유는 모름.. → 테슬라 입방정, 아마존 비트코인 결제 부인, 중국 규제 악재에도 상승장. → 주말 = 하락장 공식도 깨버림. 원전 부품기업 매출 반토막, 우수 인력 ‘썰물’ 백지화 지역 → 탈원전에 따른 원전 부품기업 매출이 반토마남. → 또한 무지성 탈원전을 하고, 친환경 에너지로 바꾼다 한들 상호보완적으로 해야지 무지성 탈원전은 위험하다는 것. 핵공학도 취업 못해 줄줄이 전과, 학생 없어 폐강 위기도 → 탈원전으로 인한 취업률 감소, 학생 수 감소 → SMR이라는 소형모듈원전 기술에 관심을 가져야함. 바이든 “2030년 美신차 절반은 친환경차로 팔 것” 6월 스마트폰 판매량 샤오미, 삼성전자 추ㅜ월 자본시장 꿰뚫고 M&amp;amp;A로 몸집 불려 … 시총 ‘100조 클럽’가입 SK “동남아 핀테크 시장 선점” 말레이 ‘빅페이’에 700억 베팅 → 인터넷전문은행 설립 공동 추진, 450억원 추가 투자 옵션도 확보 → 기존 기능에서 ‘할부 결제, 대출 및 고객 맞춤형 금융 상품 중개 서비스 등으로 모델을 확장할 듯.’ → ‘원스톱’ 핀테크 서비스를 제공 롯데케미칼, 3년만에 반기 영업익 1조 돌파 → 올해 상반기 석유화학제품 수요가 전체적으로 증가 추세를 보임 → 기초 소재 사업 내 올레핀 사업 부문이 친환경, 위생소재 등의 수요증가로 실적 증가 → 아로마틱 사업 부문도 식음료 용기 및 PIA 제품 수요로 이익증가 → 첨단 소재 산업은 전자,가전 등 전방 산업의 수요증가로 이익증가. → 일회용품 및 위생용품에 대한 높은 수요가 지속되어 롯데케미칼타이탄의 영업이익 증가. → 미래 신성장 동력 확보를 위해 지난달 발표한 ‘2030 수소 성장 로드맵’의 실행, 국내 최초 화학적 재활용 페트공장 신설 등 신사업을 본격 추진해 나갈 계획 한국조선해양 6,600억 해양플랜트 수주 → 美업체와 FPS(Flating Production System) 1기 공사 예약 → FPS : 천연가스를 생상할 수 있는 설비. 꼬꼬마 빌딩 없나요 … 강남 매물 씨 마르자 마포, 성동 ‘불티’ → 강남의 빌딩 매물이 사라지자, 마포구에 빌딩을 사는 사람이 많아지는 현상을 적은 기사. → 강남의 강점은 경기 하락시에도 가격이 견고하게 유지될 것이라는 공감대와 수요자가 항상 유입되는 강점. 매수 몰린 서울 노원 … 6억이하 매물 급감 → 사람들이 급하게 아파트를 사다보니 서민아파트 이미지를 가지고 있는 노원의 아파트 값이 5.5%정도 증가함. → 나오는 매물마다 가격이 최고치를 찍다보니 거래량도 감소하고 매물도 없는 현상이 나타남. “집값 고점” 정부 잇단 경고에도 서울 강북 매수심리 더 강해졌다. → 매매수급지수가 높아짐. : 아파트를 사려는 사람이 많아짐. → 특히 중저가 아파트인 ‘노원, 도봉, 강북구’ 쪽이 대폭 오름 정부가 “사지 말라”고 하자 …다시 영끌 매수 → 위의 기사와 똑같다. → 2.4 주택 공급대책 이후 매수 심리가 꺾였지만, 임대차보호법과 다주택자 양도세 중과 등 정부의 규제 정책으로 매물이 잠기고, 지자체와 주민 반발로 공급 대책이 사업 속도를 내지 못하면서 매수 심리는 되살아남. “2.6억 아파트, 6억까지 주담대?” 대출한도 제각각 대혼란 → 대출한도가 집값 2.6억 뛰어넘는 5억이라고 소개했음. → 해석을 다르게 해서 나온 결과 → 제 1 금융권은 ‘여신심사 시 소요 자금 규모를 고려’해야한다는 은행업 감독규정을 따름. → 제 2금융권은 “시세가 주택 구입을 위해 필요한 금액보다 클 경우 소요 금액을 넘는 주담대도 가능하다”라는 해석을 하였음. → 금융위 관계자는 이러한 현사을 파악하고 대책을 마련하겠다고 함. 임대차법이 불지른 전셋값 … 서초 재건축 시작하자, 용산 11% 치솟아 → 문정부 들어와서 아파트값 평균 5억원 늘음.ㅋㅋ 9억 아파트 중개료, 최대 절반 낮아진다. → 중개수수료 인하방안 이달 확정 → 9~12억원은 0.7% 12억 초과는 0.3~0.9%를 협의하여 중개수수료를 메김. → 9억원 짜리 아파트를 거래할 때 낼 수수료가 현재 810만원에서 480만원 수준으로 줄어들게 됨. 강남서 ‘15억 로또’ 줍줍 11일 ‘디에이치자이개포’ → 실거주 의무없는 5가구 모집. 6일기준 서울 무주택자만 → 청약통장 가입 여부 무관하고, 청약신청금도 없다. 경쟁류링 치열할 듯. 中, 미국 겨냥 핵미사일 격납고 110여개 건설중 → 중국이 핵탄두를 100기로 늘려야하는 주장을 하고 있다. → 미국에게 인정받고 싶고, 미국이 미사일 방어체제를 갖춰기에 소극적인 군비증가는 불필요하다고 중국은 판단. → 미국은 군비경쟁의 위험을 낮추는 실용적 방안에 대해 대화하길 원함. → 주국은 무시하고, 미국의 MD를 무력화할 수 있는 극초음속 무기 등 신무기를 계속 개발하고 있기에, 군비 경쟁의 가속화는 불가피해 보인다. ‘세입자 집주인’ 충돌, 분열하는 미국 → 임차인 퇴거금지 두달 더 유지에 따라 임대인들도 들고 일어난 기사. 바이든의 전기차 지원 행사에 … 테슬라는 왜 안 불렀나 → 미국 백악관에서 열린 국제 정책 발표 자리에 테슬라를 볼 수 없었음. → 전기차 관련 행사였기에, 미국 내 전기차 판매량의 74%를 담당하는 테슬라가 있어야 했다는 생각이지만, 제너럴 모터스(GM), 포드, 스텔란티스가 참여. → 테슬라는 反노조 성향이고, 바이든은 親노조 성향이기에 긁어부스럼을 만들기 싫다는 전문가들의 생각. 美민주, 에너지 공룡에 ‘징벌적 탄소세’ 추진 → 온실가스 배출 상위 에너지기업 571조원 규모 과세 법인 마련 홍수 등 이상기후 책임도 전가. &quot;터무니 없다&quot; 기업 반발 거세. " }, { "title": "2021.08.06(금).경제 정리노트", "url": "/posts/economy0806/", "categories": "Economy, DailyNote", "tags": "Economy", "date": "2021-08-07 00:50:50 +0900", "snippet": "2021.08.05 경제 헤드라인을 정리한 글입니다. 脫원전 집착에 신재생 비중 6 → 71% “전 국토에 태영광 덮을 판” → 석탄 원전 줄여 2050년에는 온실가스 96~100 줄인다고 계획을 짰지만, 그 과정에서 겪는 비용손실은 계산 못함. → 전기세가 오를 수도 있고, 태양광을 사용하기 위해서는 국토의 6%를 태영광 패널로 덮어야하는데, 밤에도 태영광을 사용하기 위한 전력 손실, 수소를 변환해 다시 전기로 변환할 경우 50%의 전력 손실을 계산하지 못 함. 계산할 경우 더욱 많은 패널로 국토를 덮어야함. 주택공급 헛돌자 … 관망하던 신혼부부도 ‘영끌’ 가세 → 아파트 매매값이 계속 상승하니까 사람들이 막차타기 위해 매매하는 사람들이 늘어남. → 신혼부부도 대출을 ‘영끌’해서 사는 것을 다룬 기사. 방배동 3년 만에 신축 입주 …. ‘전세가 없네’ → 방배동 그랑자이 80%가 입주 전세가 없다는 기사. 소상공인에 세금, 사회보험료 납부유예 검토 → 말그대로의 기사. 또한 회의에서 ‘희소금속 산업 발전대책2.0’도 논의 됨. → 반도체와 배터리 등의 소재로 사용되는 리튬 등 주요 희소금속 19종의 비축일수를 평균 100일까지 확대하는 것이 목표. → 또한, 정보 보안 역량이 취약한 중소기업에 데이터 백업과 백신관련 솔루션을 내년부터 지원할 계호기 실거주 의무 백지화 3주만에 .. 은마 전세물량 3배로 ‘쑥’ → 은미아파트라는 강남구 대치동 아파트의 물량이 3배 늘음. → 2년 실거주 의무 규제 폐지 후 물량이 증가하였고, 그 결과 전세 값이 석달 전에 비해 2~3억 줄어들었음. 美낸드 법인 CEO에 인텔 부사장 … SK하이닉스 ‘인사’ 묘수 → 인텔 출신 로버트 크룩 영입. 기존 인재 이탈 방지 차원. → 인텔로부터 낸드플래시 사업 인수를 추진중인 SK하이닉스가 미,중에 새 회사를 설립. 미국에서 출범하는 신설 법인은 로버트 크룩(인텔 부사장)이 이끔. → 中에도 신설 법인 설립 추진. 6년前 다짐 지킨 박현주(미래에셋증권회장) 해외법인 순이익도 매년 두 배 뛰어 → 미래에셋증권이 증권사 최초로 자기자본 10조 돌파. → 해외에 집중을 하였는데, 매 년 2배씩 순이익을 내며 올 상반기에 해외에서 1800억원을 만들어내, 연말에는 3000억을 돌파할 것이라는 전망. 빌라로 전세난 잡겠다더니 … 9개월째 ‘공회전’ 소상공인 하반기 세금,건보료 납부유예 (4번 기사랑 같음) 고성장 해상풍력 잡아라 … ‘조선 빅3’도 가세 → 해양풍력발전기에 중공업들이 관심을 가짐. → 2050년 탄소 중립 시나리오도 영향을 끼쳐, 토지가 부족한 우리나라의 특성상 해양풍력발전에 관심. → 또한 세아라는 그룹의 공격적인 투자가 풍력발전 시장을 확대시킴. → 풍력발전기 구조 중 ‘하부구조물’에 관심이 많은데, 이유는 뚜렷한 글로벌 기업이 없고, 해양플랜트 제조 경험을 갖춘 한국 기업들이 비교우위에 서 있는 분야기 때문이다. ‘평촌 엘프라우드’ 공급 “신재생 80% 땐 전기료 2배 이상 올라 국민 부담 늘고 산업경쟁력 약화될 것” → 2050탄소 시나리오를 말하는 것. 신재생 에너지 비중이 50%가 되면 전기요금 인상률이 61 ~ 66%, 80%가 되면 90~123% 늘 것으로 전망. 딜러와 짬짜미?… 중고차 캐피털 주의보 → 원래는 딜러가 금융사 직원과 함께 할부상품을 소개해주는 시스템이었는데, 법을 피해 금융사가 직접 딜러와 계약해 할부상품을 소개해주는 시스템이 생겨남. → 금소법 위반 가능성이 있다. 이러한 소비자 피해가 발생하는 이유 중 하나는 캐피터사 주력 시장이었던 할부금을 카드사들이 시장에 투입되 경쟁이 격화되었기 때문이라고 함. 카드사의 자동차 할부금융 자산은 17% 증가했지만, 캐피털사의 경우 2.7%늘음. 법인세 분담 놓고 시행자간 갈등 … 광교신도시 공사도 ‘삐그덕’ → 광교신도시의 개발 이익금 정산 문제를 놓고 GH와, 수원시,용인시가 싸우고 있음. → 법인세가 1500억원에 달하는데, GH는 신도시사업에서 빼야함(수원시, 용인시가 납부)해야한다고 하고, 수원시와 용인시는 재투자 사업을 이행하기 힘들며, GH가 얻어간 이익이기에 GH가 부담해야 된다고 함. → 주민들은 이 때문에 고통을 받고 있는데, 건강, 재산권 침해 드으로 송전탑 이설을 요구했고, 승낙을 받았지만 멈춘 상태. 미국車 빅3, 신차 절반 전기차로 채운다. → 미대통령이 2030년까지 미국 시장에서 판매하는 신차 중 40~50%를 전기차가 차지하도록 하겠다라는 내용을 발표. 롯데건설 “메타버스 모델하우스 오세요” → 롯데가 메타버스 플랫폼 ‘SKJUMP’를 활용해 홍보 서포터즈 발대식을 했음. → 프롭테크(부동산 property + 기술 techmology)를 결합한 분야에 뛰어들고 있다. → 메타폴리스에 공간을 마련하고 분양상담 및 광고, 모델하우스 관람 등 다양한 서비스를 제공할 계획 여의도 알짜땅 HMG가 개발한다. → 여의도에 개발여력이 남은 땅 중 하나인 곳을 HMG이 3030억을 주고 매입. → LH의 주택공급 계획과 관련이 있는 줄 알고 여론이 조성되었으나, LH측이 관련 없다며 일축. 1196가구 대구 ‘달서 SK뷰’ 분양 → SK에코플랜트가 분양 상반기 서울 아파트 분양. 착공 진나해 절반 수준으로 ‘뚝’ → 인허가 실적은 87% 증가. 국토부 “중장기 공급확대 기대” → 분양률은 지방이 51.8%가 증가. 자영업 고통 . 방역 피로감 커지는데 … 수도권 4단계 또 연장될 듯." }, { "title": "leetcode(리트코드)-1720 Decoded XORed Array(PYTHON)", "url": "/posts/leetcode_Decode_XORed_Array/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-08-06 03:34:50 +0900", "snippet": "leetcode 1720 - Decoded XORed Array 문제입니다.1. 문제https://leetcode.com/problems/decode-xored-array/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 encoded는 어떠한 리스트들의 인접한 값들끼리 XOR을하여 나온 결과입니다. first는 어떠한 리스트의 첫 번째 요소일 때 XOR하기 전의 리스트를 구해 리턴하세요.5. code코드설명 요소와 결과로 나온 encoded의 리스트의 요소를 다시 XOR연산을 해주면 XOR 해주기 전의 값이 나옵니다.pythonclass Solution: def decode(self, encoded: List[int], first: int) -&amp;gt; List[int]: res = [first] for i in range(len(encoded)): res.append(encoded[i]^ res[i]) return res 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "leetcode(리트코드)-1725 Number Of Rectangles That Can Form The Largest Square(PYTHON)", "url": "/posts/leetcode_Number_Of_Rectangles_That_Can_Form_The_Largest_Square/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-08-06 02:34:50 +0900", "snippet": "leetcode 1725 - Number Of Rectangles That Can Form The Largest Square 문제입니다.1. 문제https://leetcode.com/problems/number-of-rectangles-that-can-form-the-largest-square/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 5. code코드설명 각 리스트의 요소는 사각형의 폭과 높이입니다. 변을 잘라서 정사각형을 만들 때 가장 폭이 긴 정사각형의 갯수를 리턴하세요.pythonclass Solution: def countGoodRectangles(self, rectangles: List[List[int]]) -&amp;gt; int: res ={} maxnum = 0 for i in range(len(rectangles)): temp = min(rectangles[i][0],rectangles[i][1]) maxnum = max(maxnum,temp) if temp not in res : res[temp] = 1 else : res[temp] += 1 return res[maxnum] 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "leetcode(리트코드)-429 N ary Tree Order Traversal(PYTHON)", "url": "/posts/leetcode_N-ary_Tree_Level_Order_Traversal/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-08-06 01:34:50 +0900", "snippet": "leetcode 429 - N ary Tree Order Traversal 문제입니다.1. 문제https://leetcode.com/problems/n-ary-tree-level-order-traversal/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.4. 문제 해석 root라는 값이 들어옵니다. root에는 root 값과 children이라는 리스트가 주어집니다. 해당 정보들로 트리를 만들 때 Level에 맞게 값들을 리스트에 넣어 반환합니다.5. code코드설명 alex가 이길 수 밖에 없다고 합니다. 또한, 너무 쉽게 풀려서 Medium의 레벨이 아닌 것 같습니다. 가장 큰 것부터 뽑아 계산하여 풀었습니다.pythonclass Solution: def levelOrder(self, root: &#39;Node&#39;) -&amp;gt; List[List[int]]: res =[] def solution(root,depth,res): if root : if len(res) &amp;lt;= depth : res.append([]) res[depth].append(root.val) for i in range(len(root.children)) : solution(root.children[i],depth+1,res) solution(root,0,res) return res 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "2021.08.05(목).경제 정리노트", "url": "/posts/economy0805/", "categories": "Economy, DailyNote", "tags": "Economy", "date": "2021-08-06 00:50:50 +0900", "snippet": "2021.08.05 경제 헤드라인을 정리한 글입니다. “美경기, 델타 변이 영향 제한적” vs “4분기부터 급격 둔화” → 긍정적인 반응과 비판적인 반응이 대조적. → 긍정적인건 소비자 소비가 늘고 있다는 것. 비판적인 것은 올해 폭발적인 소비로 내년 소비는 감소할 것, 저축률이 34%에서 9%로 떨어진 점. 가계빚, 인플레와 코로나 악재 틈에서 .. 한은 금리인상 고차방정식 묘수 찾기 공급 하세월인데 … 금리만 올린다고 집값 잡힐까 → 금리랑 부동산 집값잡기랑 상관이 없다는 입장들이 있다. → 금리인상보다 중요한 것은 실횽성 있는 공급이라고 지적. “정부 압력에 이자 올려” vs “은행이 내릴 맘 없어” → 대출 금리가 올라가면서 은행 이자 수익이 최고치에 달함. → 또한 우대금리의 포인트 또한 하향 조정하면서 국만 부담이 커짐. → 은행 입장에서는 정부 규제 우려라고 하지만, 당국이 금리를 올리라 말라 할 수 있는 권한도 없고 방법도 없다면 서로 탓 중. 외인 사흘간 5.3조 폭풍매수 … 3,300 눈앞. → 코스피 이틀째 급등 3,280 안착 → 1조 쓸어담은 삼성전자 4.5% ↑ 돈 몰려온다, ETF ‘1조 공룡’만 15개 → 2017년 보다 1조원 넘는 ETF가 7개 늘어 15개가 됨. 사람들의 관심을 얻는 중. “가상화폐 시장은 서부 무법시대” SEC위원장 겐슬러 경고에 비트코인, 이더리움 등 하락 → 가상화폐는 “악성 해킹에 악용되거나 법을 피해 돈세탁이나 금융 제재 위반, 탈세에 활용되고 있는 상황”이라고 지적. → 겐슬러 위원장은 MIT 경영대학원과 미디어랩에서 가상 화폐 연구 프로젝트를 이끌었던 가상화폐 전문가. LG화학, 바이오 원료 적용 SAP첫 수출 → 국제 인증 받은 고흡수성수지 중동에 판매.. 기저귀 등 사용 → ISCC Plus라는 세계에서 가장 권위있는 자격(?)같은 것 인듯. → LG화학이 최근 론칭한 친환경 통합 브랜드인 LETZero가 적용된 첫 사례. → SAP는자기 무게의 약 200배에 해당하는 물을 흡수하는 고흡수성수지로 주로 기저귀 등 위생 용품에 사용됨. 대체식품에 관심 보인 최태원(SK그룹 회장) SK그룹 관련사업 투자 늘리나 배터리에 5년간 17조 투자 …2030년 생산능력 12배 키운다. → SK 이노 배터리사업 분할예정. → SK이노베이션은 앞서 미구 포드사와 합작법인 ‘블루오벌’을 설립하기로 하는 등 완성차업체와의 전략적 제휴도 늘리는 중. 제니시스 美 월판매 5,000대 돌파 ‘신기록’ → 원인으로는 타이거우즈 사고 당시 탄 차가 GV80이라는 것에 인지도가 높아짐. 역대급 실적 예고한 수입차 7월까지 누적 판매 17만대 → 국내차 지난달 14.5% 역주행 속 수입차는 23% 늘며 상승세 지속 플랫폼 장악한 카카오택시 호출료 인상, 타자마자 8800원 낼 수도 → 카카오 모빌리티가 정액요금제에서 탄력요금제로 바꿔 적용. → 돈을 더 내면 더 쉽게 택시를 잡게 해주는데, 최대 5000원까지 받겠다고 함. → 플랫폼 중개사업자로 등록한 반반택시와 아이엠택시는 중개요금을 최대 3000원을 받겠다고 신고했다. → 카모 입장에서는 “요금 인상이라기보다는 수요 . 공급의 불균형이 있는 곳에서도 배차가 잘되도록 요금제 설계를 바꾼 것”이라고 설명. 엄마 아빠도 배달앱 많이 쓰거든 … 5060 온라인 소비 증가율 1위 → 50대 배달 카드 결제액 163% 늘어, 쿠팡 결제는 60대 148% 증가율 1위 임대차분쟁 38% 급증, 조정위 가도 해결은 16% 뿐 → 세입자와 집주인과 분쟁이 38% 늘어남. → 해결하기 위해 조정위를 가도 둘 중 한 명이 불응하면 시작조차 못하고 끝나버림. 조정안 자체를 강제하지 않았기 때문. → 조정위 권한을 강화하거나 충분한 사례를 제공하는 등 갈등을 원만하게 해결할 수 있는 방법을 찾아야 한다는 지적. " }, { "title": "leetcode(리트코드)-877 Stone Game(PYTHON)", "url": "/posts/leetcode_Stone_Game/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-08-05 03:34:50 +0900", "snippet": "leetcode 877 - Stone Game 문제입니다.1. 문제https://leetcode.com/problems/stone-game/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.4. 문제 해석 piles라는 짝수의 크기를 가진 배열이 들어옵니다. alex와 lee가 돌아가면서 수를 뽑을 때 합계 포인트가 가장 많은 사람이 이깁니다. alex가 이길 수 밖에 없으면 True 아니라면 False를 리턴하세요.5. code코드설명 alex가 이길 수 밖에 없다고 합니다. 또한, 너무 쉽게 풀려서 Medium의 레벨이 아닌 것 같습니다. 가장 큰 것부터 뽑아 계산하여 풀었습니다.pythonclass Solution: def stoneGame(self, piles: List[int]) -&amp;gt; bool: piles.sort() dq = deque(piles) alex = 0 lee = 0 while dq : alex += dq.pop() lee += dq.pop() return True if alex &amp;gt; lee else False 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "leetcode(리트코드)-1736 Latest Time by Replacing Hidden Digits(PYTHON)", "url": "/posts/leetcode_Latest_Time_by_Replacing_Hidden_Digits/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-08-05 02:34:50 +0900", "snippet": "leetcode 1736 - Latest Time by Replacing Hidden Digits 문제입니다.1. 문제https://leetcode.com/problems/latest-time-by-replacing-hidden-digits/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 time이 주어집니다 ”?”로 된 곳에 임의의 숫자를 넣을 때 가장 오래된 시간을 만들어서 리턴하세요 (00:00 ~ 23:59)5. code코드설명 하드코딩pythonclass Solution: def maximumTime(self, time: str) -&amp;gt; str: res = &quot;&quot; for i in range(len(time)): if time[i] == &quot;?&quot;: if i == 0 : if time[1] == &quot;?&quot; or time[1] &amp;lt;&quot;4&quot;: res +=&quot;2&quot; else : res +=&quot;1&quot; elif i == 1 : if res[0] == &quot;2&quot;: res += &quot;3&quot; else : res += &quot;9&quot; elif i == 3 : res += &quot;5&quot; elif i == 4 : res += &quot;9&quot; else: res += time[i] return res 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "leetcode(리트코드)-1732 Find the Highest Altitude(PYTHON)", "url": "/posts/leetcode_Find_the_Highest_Altitude/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-08-05 01:34:50 +0900", "snippet": "leetcode 1732 - Find the Highest Altitude 문제입니다.1. 문제https://leetcode.com/problems/find-the-highest-altitude/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 gain이 주어집니다. 주어진 숫자를 더해 나갈 때 가장 큰 값을 리턴하세요. 단, 0보다는 커야합니다. 0보다 작을 경우 0을 리턴합니다.5. code코드설명pythonclass Solution: def largestAltitude(self, gain: List[int]) -&amp;gt; int: res = 0 tmpsum = 0 for i in range(len(gain)): tmpsum += gain[i] res = max(tmpsum,res) return res 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "2021.08.04(수).경제 정리노트", "url": "/posts/economy0804/", "categories": "Economy, DailyNote", "tags": "Economy", "date": "2021-08-05 00:50:50 +0900", "snippet": "2021.08.04 경제 헤드라인을 정리한 글입니다. 월러 “두달간 고용 좋으면 10월 테이퍼링” → 미국의 일자리가 코로나19 대유행 때 첫 두달동안 2,240만 개의 일자리가 사라진 뒤 최근 1,560만 개가 다시 생김. → 점차 미국 경제가 좋아진다는 의미이며 8, 9월 고용보고서에서 일자리 증가가 80만개 수준으로 이뤄지면 테이퍼링을 하겠다는 것. → 테이퍼링 : 경제 위기에 따른 돈을 푼 것을 점차 줄이겠다는 것. ‘매파본색’ 금통위 …6명 중 5명 “금리인상 고려해야” → 한은, 7월 금통위 의사록 공개, 4차 대유행에 금리 동결했지만 통화정책 완화 정도 조절 공감대 치솟는 소비자물가, 추석 전 풀릴 지원금이 부채질 우려 → 소비자물가는 늘어나는데, 국민의 88%에게 재난지원금을 주려고 함. → 이로인해서 인플레이션 효과가 나타나고 소비자시장더 비싸지지 않을까 우려. → 계란값은 57%가 올라, 정부가 가격 담함 등의 조짐이 보이면 조사하기로함. 또한, 계란을 수입하면서 가격조정에 힘을 쓰고 있다는 것. “대출만 성공하면 아파트로 떼돈” 기대심리에 정책 약발 안 받아 → 대출금리를 올리고, 우대금리를 줄이는 등으로 당국 규제에 맞추는 상태. 하지만, 대출 증가세가 꺾이지 않음. 코스피 지쳤나? ‘IPO 골리앗’ 크래프톤 참패 … ‘다윗’ 원티드랩에도 밀렸다. → 크래프톤 일반청약이 마감. 저조한 성적표 → 원인으로는 고평가 논란, 중국의 게임규제를 하겠다는 말 때문인 듯. → 심지어 원티드랩에게도 공모가를 짐. 원티드랩의 공모가는 5.5조 크래프톤은 5.3조 원티드랩의 경쟁률은 1,700대1 크래프톤은 7.8대 1 외인 6,200억 ‘사자’ …삼성전자 5개월 최대 상승 → 이번 분기에 인텔을 제치고 삼성이 ‘반도체 분기 매출 1위’라는 타이틀을 걸자 많은 사람들이 투자를 하고, 주가가 상승함. → 이재용 부회장의 부재, 반도체 업황에 대한 불확실성 등이 주가를 끌어내림. → 사성전자는 2분기에 분기 기준 사상 최대 매출액을 달성했음에도 불구하고 말이다. 돈 몰리는 리튬생산기업 … 국내외 ETF 투자 붐. → 전기차 등에 사용되는 리튬이 요즘 주목받고 있다. “탄소 배출 대처가 생사 가를 수도” … 수출경쟁력 지키지 절실 → 정부가 탄소세 도입을 추진할 것. → 제조업산업이 큰 우리나라에게는 큰 도전이자 이로인해서 수출 등 줄어들 것. 프랑스는 탄소세 도입 후 2년 만에 시위로 인해서 폐지 반도체용 기판설비 2년 대기 …EUV 장비는 ‘입도선매’ 전쟁 포르쉐 2.8km 갈때 기아 EV6 5.6km 간다. → 전기차에 관한 내용. → 전기차 충전 요금 할인이 내년 중반 이후 폐지될 것으로 보아 연비에도 관심이 많음. 원래는 주행거리가 소비자들의 관심사 → 전기차 가운데 가장 연비가 좋지 않은 포르쉐의 타이칸 터보S로 1kWh당 주행거리가 2.8km → 타이칸의 연간 충전비는 90만원 안팎인 반면 EV6은 46만원 정도 충전 요금 할인이 폐지되면 이 격차가 더 커질 수도 있다. 충전시간이 돈이다. 전기차 ‘10분 전쟁’ → 배터리 충전시간 줄이기에 사활 → 충전시간을 줄여 내연기관(휘발유나 디젤차) 경쟁력 확보가 목표. → 고전압 고전력으로 충전을 빨리할 수 있지만, 국내에 있는 공공 충전소는 그에 비해 약한 전력을 제공. 내년에 급속충전소를 설치할 것인데, 업체들은 앞다퉈 고전압 시스템을 활용해 충전시간을 단축할 기술을 개발 중. LG엔솔, 中 CATL에 1위 내주고 …테슬라 등 내재화 속도전 → LG가 글로벌 배터리 시장점유율을 CATL에 내줌. → 사실 CATL은 중국 시장을 제외한 시장에서는 9.9%에 불과하지만, 중국이 보조금을 쏟고 내수 시장이 워낙 거대, 자국에서 생산한 배터리들을 탑재하도록 했기에 이런 결과. → CATL은 ‘나트륨 이온 배터리’를 공개했음. 기존 리튬 기반 배터리와 달리 저렴하고 충전시간이 짧아짐. 한화, 수소 혼소 발전 상용화 착수 → 한화종합화학과 한국서부발전이 수소 혼소 발전 프로젝트에 착수 → 프로젝트에 성공하면 액화천연가스(LNG)에 50%이상 수소를 혼소해 이산화탄소 배출량을 대폭 감소시킬 수 있다. 파업 . 과징금 두가지 악재 해운 대란 더 심해지나 → HMM노조와 지금 협상단계를 가지고 있으나, 공정위에서 과징금을 물겠다고함. 최대 8000억원에 이르는 과징금 → 뿐만 아니라, 외국 선사들에게도 과징금을 물기에 우리나라 화물을 거부하는 ‘한국 패싱’ 현상이 심화할 수 있다는 우려. “맞수에게 배우자” 닮아가는 쿠팡. 네이버 → 쿠팡의 약점 : 판매자 지원, 네이버 약점 : 쇼핑 편의성 → 두 약점을 서로 보완하였음. → 쿠팡의 경우는 ‘윙’이라는 모바일 앱으로 판매자의 물품관리를 지원함. → 네이버의 경우 NFA라는 빠른 배송, 신선식품 특화 배송 등 물류연합을 출범. 집콕에 상반기 배달수요 쏙 배민 결제액 2배 늘어 8.5조 → 6월에만 1,330만명이 1.4조 썼음. 요기요 등 이용자 올 24% 즈가 입주 많다는 정부 통계 … 3040 가족용은 없어 → 정부에서 집계를 4만1000가구가 서울 입주 물량 통계로 잡힘. → 실제로는 4,501건 중 민간 아파트 분양 단 1건 나머지는 원룸 이나 청년주택 서대문, 약수역 등 4곳 고밀개발 → 국토부, 서울 3곳 . 울산 1곳 6차 도심복합사업 후보지로 4,500가구 주택 공급 가능. 연봉 1억도 입주 공공임대 과천, 남양주서 12월 첫 선 → 국토부 ‘통합공공임대’ 도입 2곳서 1,181가구 시범 공급 → 통합공공임대 : 중위소득 150% 이하(맞벌이 180% 이하)로 통합. 이를 환산하면 맞벌이 기준 약 1억 창신뉴타운 재개발 ‘부활의 닻’ 양포세(양도세 상담을 포기한 세무사) → 다주택자를 겨냥한 양도세가 급진적으로 계속 바뀌어 세무사들조차 상담을 포기한 상황 → 1인가구 1주택자도 영향을 미침. ‘부자 감세’에 반대하는 당내 강경파를 달래기 위해 ‘고가 1주택자’의 양도세의 부담을 늘림. → 2019년 8가지였던 양도세율을 경우의 수가 급증해 189가지로 늘림. 모바일앱으로 강남 빌디 쪼개 사는 MZ세대 → 주식처럼 부동산 소액 투자 2시간만에 완판된 강남 빌딩. 투자자 절반이 2030 → 한 주당 돈을 받고 월세 등 임대 수익으로 3개월에 한 번씩 배당금을 준다. 구글도 ‘반도체 독립’ …. 픽셀6(차기 스마트폰)에 자체 설계 칩 ‘텐서’ 탑재 → 4년 쏟은 모바일 AI딥러닝 칩 ‘공룡’ 퀄컴에 의존 탈피 의지. → 구글에서 자체 제작한 ‘프로세서 칩’을 탑재한다. 퀄컴에 의지하지 않고 반도체 독립에 나서겠다는 의미 → 텐서의 기능은 흐릿한 사진을 AI가 선명하게 바꿔주고, 음성을 바로 문자로 바꿔주는 기능도 수행 구글은 “텐서가 할 수 있는 일 중 일부에 불과하다”며 기대감을 높임. → 픽셀6의 가격은 대략 115만원 정도로 보고 있다. → 하지만 칩 독립까지는 시간이 조금 걸릴 듯. → AI 기능을 돕는 TPU(Tensor Processing Unit)은 구글이 설계했지만, CPU, GPU 등은 아직까지 자체 설계 기술을 확보하지 못 함. “게임은 정신 아편” 中 매체 한마디에 게임주들 폭락 → 중국이 “게임 심사, 운영, 홍보 등에 대한 강력한 규제가 필요하다”며 대형규제를 발표. → 텐센트는 아예 바짝 엎드려 미성년자 게임 시간 대폭 축소안, “12세 미만은 아예 게임 금지”제안도 검토하기로 함. 샤오미가 이번 2분기에 삼성을 추격해오고 있다는 기사" }, { "title": "leetcode(리트코드)-1742 Maximum Number of Balls in a Box(PYTHON)", "url": "/posts/leetcode_Maximum_Number_of_Balls_in_a_Box/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-08-04 05:34:50 +0900", "snippet": "leetcode 1742 - Maximum Number of Balls in a Box 문제입니다.1. 문제https://leetcode.com/problems/maximum-number-of-balls-in-a-box/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 lowLimit과 highLimit이 주어집니다. lowLimit부터 highLimit까지 적힌 숫자공이 있다고 가정합니다. 각자리 숫자의 합에 해당하는 박스에 공을 넣는다고 가정할 때 (16이면 1 + 6 = 7인 박스) 공이 가장 많긴 박스의 공의 개수를 리턴하세요.5. code코드설명pythonclass Solution: def countBalls(self, lowLimit: int, highLimit: int) -&amp;gt; int: res = [0] * 100 ans = 0 for i in range(lowLimit,highLimit+1): #brute temp = str(i) sumnum = 0 for k in range(len(temp)): sumnum += int(temp[k]) res[sumnum] += 1 ans = max(ans,res[sumnum]) return ans 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "leetcode(리트코드)-1748 Sum of Unique Elements(PYTHON)", "url": "/posts/leetcode_Sum_of_Unique_Elements/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-08-04 04:34:50 +0900", "snippet": "leetcode 1748 - Sum of Unique Elements 문제입니다.1. 문제https://leetcode.com/problems/sum-of-unique-elements/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 nums가 주어집니다. 2번 이상 중복되지 않는 요소에 대하여 값들을 더해 더한 값을 리턴하세요.5. code코드설명 데이터가 크지 않아서 밑의 방식으로 해결할 수 있습니다.pythonclass Solution: def sumOfUnique(self, nums: List[int]) -&amp;gt; int: res = [0] * 101 ans = 0 for i in range(len(nums)): res[nums[i]] +=1 for i in range(len(res)): if res[i]== 1 : ans+=i return ans 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "leetcode(리트코드)-113 Path Sum II(PYTHON)", "url": "/posts/leetcode_Path_Sum_II/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-08-04 03:34:50 +0900", "snippet": "leetcode 113 - Path Sum II 문제입니다.1. 문제https://leetcode.com/problems/path-sum-ii/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.4. 문제 해석 Tree가 주어지고, targetSum이 주어집니다. Tree들의 자식들을 따라 내려가면서 값들을 더할 때 targetsum이 되고, 마지막 노드인 경우 해당 경로를 리스트에 담아 리턴하세요.5. code코드설명 자식들을 따라가면서 경로를 temp에 담아주고, 자식노드들에게 임시합들을 더해줍니다. 만약 임시 합이 targetSum과 같고, 마지막노드인 경우(root.left == None and root.right == None) temp리스트에 저장된 경로들을 결과 리스트에 넣고 리턴합니다.python# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def pathSum(self, root: TreeNode, targetSum: int) -&amp;gt; List[List[int]]: res = [] if root == None : return None if root.left == None and root.right == None : if root.val == targetSum : res.append([root.val]) return res def DFS(root : TreeNode, val, targetSum,dis,res) : if root : dis.append(root.val) root.val = root.val + val if root.val == targetSum and root.left == None and root.right ==None: res.append(dis) else : DFS(root.left,root.val,targetSum,dis[:],res) DFS(root.right,root.val,targetSum,dis[:],res) DFS(root.left,root.val,targetSum,[root.val],res) DFS(root.right,root.val,targetSum,[root.val],res) return res 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "leetcode(리트코드)-1752 Check if Array Is Sorted and Rotated(PYTHON)", "url": "/posts/leetcode_Check_if_Array_Is_Sorted_and_Rotated/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-08-04 02:34:50 +0900", "snippet": "leetcode 1752 - Check if Array Is Sorted and Rotated 문제입니다.1. 문제https://leetcode.com/problems/check-if-array-is-sorted-and-rotated/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 nums가 주어집니다. nums를 회전했을 때 오름차순으로 정렬되어 있으면 True를 회전을 아무리 해도 오름차순으로 정렬될 수 없다면 False를 리턴합니다.5. codepythonclass Solution: def check(self, nums: List[int]) -&amp;gt; bool: temp = nums[:] temp.sort() nums = deque(nums) temp = deque(temp) for i in range(len(nums)): if temp == nums: return True else: shift = nums.popleft() nums.append(shift) return False 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "leetcode(리트코드)-1758 Minimum Changes To Make Altenating Binary String(PYTHON)", "url": "/posts/leetcode_Minimum_Changes_To_Make_Alternating_Binary_String/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-08-04 01:34:50 +0900", "snippet": "leetcode 1758 - Minumum Changes To Make Altenating Binary String 문제입니다.1. 문제https://leetcode.com/problems/minimum-changes-to-make-alternating-binary-string/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 0과 1로 이루어진 문자열s가 주어집니다. 0이나 1이나 연속되지 않아야 합니다. 0을 1로, 1을 0으로 바꿀 수 있을 때 최소한으로 바꾸어 원하는 문자열을 만들어야합니다. 최소값을 구하세요.5. code코드설명 ‘0’으로 시작했을 때 “01010101…“이 문자열의 길이만큼 될 것입니다. 이미 “0101010…“을 만들었다고 생각하고 틀린 문자를 찾아 그 갯수를 저장합니다. ‘1’로 시작했을 때 “1010101….”인데 위에서 구한 갯수를 s의 길이에서 빼주면 ‘1’로 시작했을 때의 값이 됩니다.(반전이므로)pythonclass Solution: def minOperations(self, s: str) -&amp;gt; int: # start 0 # start 1 checknum = 0 for i in range(len(s)): if i%2 == 0 : if s[i] == &quot;0&quot;: continue checknum += 1 else : if s[i] ==&quot;1&quot;: continue checknum += 1 return min(checknum, len(s) - checknum) 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "2021.08.03(화).경제 정리노트", "url": "/posts/economy0803/", "categories": "Economy, DailyNote", "tags": "Economy", "date": "2021-08-04 00:50:50 +0900", "snippet": "2021.08.03 경제 헤드라인을 정리한 글입니다. 지난달 서울 매매 아파트 20,30대가 10채 중 4채 삼. 2030 1인가구 1년새 95만 급증 “집값 너무 올라 결혼을 못해요.” → 1인 가구가 15년도에 비해 4%가 급증함. 또한, 평균 가구원 수가 줄어들음. OECD도 ‘집값 광풍’ 30년만에 최고 상승률 → OECDE 회원국 1분기 9.4% 집값이 오름.(40개국중 37國) → 원인으로는 코로나로 인한 낮은 금리와 높은 가계 저축이 집값 상승을 부추긴 것. 5만가구 정부주도 재건축 실제 추진 1580가구 그쳐 → 공공재건축 목표 달성률 3% → 국토부가 사전 수요조사를 생략하는 등 시장 의견을 듣지 않음. → 국토부 관계자는 “대책 내용이 보안사항이고 새어나가면 안 되기 때문에 사전조사는 하지 않는다.”고 말함. 헛도는 정보주도 개발 … “강남, 과천에 임대주택 짓겠다는 게 문제” → 정부의 첫 대규모 공급 정책인 “8.4 공급 대책”을 내놓은 지 1년이 됨. → “서울 권역을 중심으로 신규 택지를 발굴해 3만3000가구를 공급하는 등 2028년까지 총 13만2000가구 이상을 공급하겠다.”고함. → 근데 현황은 초라함. → 이유는 3가지 → 1. 임대주택에 대한 국민 거부감 간과 → 2. 용지 선정 과정에서 주민들과 소통 부족 → 3. 주민들에게 약속한 인센티브가 충분하지 않음. LH, 이달 공공분야 . 임대주택 5252가구 공급 → 공공분야 . 임대주택은 주변 시세보다 최대 40% 저렴한 가격에 공급돼 수요자들의 관심이 높음. → 경기 파주 다율동, 경기 시흥 장곡동에서 공급 된다. 무주택자들 대상으로 분양. 문래동 ‘노후 3인방’ 재건축 사업 속도낸다. → 여등포구 문래동의 &amp;lt;남성,진주,국화맨션&amp;gt;이 재건축될 것. → 1980년대에 지어진 것으로 거의 40년이 다되어감. → 이로 인해 집 값이 2억원정도 상승한 상태. 하지만 매물이 없다. → 대부분이 실거주자로 파려는 사람보다 재건축을 기다리는 사람이 많다는 것. 지하철역 이름 ‘쩐의 전쟁’ 역삼역 별칭 최소 2억원대 → “이번 역은 서대문, 강북삼성병원역입니다.” → 위처럼 역이름에 병기하여 부역명을 붙이는 것을 말한다. → 2017년 이후 5년만에 중단된 사업이 시작되었다. → 역삼역(2.3억) → 을지로4가역(2.2억) → .. 등 총 8개역이 입찰가가 올라옴. → 과거 기업은행은 2016년 3.8억을 주고 을지로입구역(IBK기업은행)이란 이름을 따냄. 또한 SC제일은행도 2017년 종각역을 따냄. 서울, 인천 공사비 마찰로 연결 불발 … ‘환승지옥’된 김포공항역 → 서울지하철 9호선은 당초 예정대로라면 공항철도와 직결돼 인천공항을 이용하는 서울시민들이 환승없이 한 번에 갈 수 있도록 하려고 했음. → 서울시와 인천시의 비용부담 문제 때문에 불발이 되어버림. 매달 4차례 주민과 회의 끝에 아파트 앞 버스정류장 세웠다. → 대구 금포 5리에 버스정류장이 없었기에 노선을 바꾸자 했는데, 금포 1리 시민의 반대로 불발 되었다가 ‘살기 좋은 동네를 함께 만들어보자’라는 말에 협상이 되었음. 2년 5개월 만에 갈등해소. 중개사 반발에 … 네이버, 허위매물 방지책 포기 → 네이버가 ‘부동산 허위매물’ 검증 대책으로 네이버계정과 집주인 전화번호를 기재하는 것을 의무화할 것을 함. → 한국공인 중개사 협회에서 위의 방식으로 얻은 정보를 갖고 네이버가 따로 부동산 플랫폼을 만들 수 있다는 것에 반발 → 네이버 취소 → 직방의 ‘온택트파트너스’ 플랫폼을 출시, 매물 확인을 VR로 할 수 있게끔 함. → 한국공인 중개사 협회에서 “골목 상권을 위협한다” 며 반발. → 로톡(변호사 소개어플)은 대한변호사 협회에서 “비변호사가 변호사 소개 알선하는 것은 변호사법 위반”이라며 반발 → 강남언니(성형 광고 어플)은 대한의사 협회에서 의료광고 심의 기준을 낮춰서 규제를 해야한다고 함. 세금 내는 정규직 대신 … 세금 먹는 ‘단기 일자리’ 76만개 양산 → 생산인력(15세~65세) 인구는 감소 하고 있지만, 실업자는 늘어나고 있음. → 수요. 공금의 미스매칭이 문제. 또한 세금으로 만든 ‘철새 감시요원, 빈강의실 소등 인력 등’ 단기 아르바이트가 76만 8천개가 급증하여 사실상 실업자만 양산하고 있다. 소상공인 죽겠다는데… 지원금 1.1조 또 남았다. → 정부가 총 14.5조 규모의 소상공인 지원금을 편성했지만, 실질적으로 12.9조를 씀. “20억 전세 살면 지원금 받고, 15억 집 있으면 못 받는다니…“ → 건강보험료를 기준으로 재난지원금을 지급한다고 했는데, 납세자연맹에서 이를 불공정하다고 비판함. → 또한, 국민건강보험공단 역시 건보료를 재난지원금의 소득 기준으로 삼는데 난색을 보임. → 또한, 보유 재산의 액수가 아니라 종류에 따라 지금 여부가 결정되는 점 역시 비판. → 주식, 채권, 가상자산이 20억원 이상이나 전세보증금을 20억원 갖고 있으면 재난지원금을 받을 수 있지만, 재산세과세표준 9억원, 공시가격 15억원을 초과하는 재산을 보유하거나 예금기준 13억원 초과 시 제외. 경기도 ‘100% 재난지원금’ 정부는 안 막나, 못 막나.. 3년前 퇴직연금에 美상장주펀드 담았다면 … 80% 넘는 수익 ‘거뜬’ 백신값 인상소식에 …. 국내 바이오 들썩 → 화이자, 모더나가 백신가격을 올리자 한국 바이오주가 반등. → 삼성바이오로직스는 모더나와 백신 위탁생산을 계약 → SK바이오사이언스는 순이익이 910.6%급등. 아스트라제네카, 노바백스 위탁생산 계약을 맺음. → 셀트리온은 자체 개발 중인데 대중들이 바이오주에 관심을 가지면서 상승. 네이버, 카카오 빼곤 …. ‘BBIG7’ 이름값 못하네. → LG화학, 삼성SDI, 삼성바이오로직스, 셀트리온,네이버, 카카오,엔씨소프트 등 7개의 종목 중 네이버와 카카오를 제외하고 눈에 띄는 성장을 못 보여줌. 방중혁(넷마블 의장)의 야심 … 60억 소셜카지노 게임 시장 노린다. → 5년전에도 플레이티카라는 소셜카지노 인수를 하려했으나 중국 자본에 밀려서 하지 못함. → 이번에 스핀엑스를 인수하면서 소셜카지노 시장을 키울 생각. → 한국은 규제가 있지만, 글로벌 시장에서는 소셜 카지노 시장이 성장 중이다. → 넷마블의 약점으로 지적된 ‘자체 지식재산권 결핍’도 해결할 수 있을 듯. 마지막 중복청약 크래프톤, 공모 첫날 흥행저조 → 경쟁률 2.79대 1 .. 증거금 1.8조 카카오 뱅크의 경우 37.8대 1 증거금 12조 → 일반 청약 물량만 8000억원에 달하다보니 마감직전까지 살펴보겠다는 고객이 대다수였다. 각국 백신 확보경쟁 더 거세진다 … 韓 2차접종 초비상 → 모더나, 화이자 가격을 올리면서 문제. → 나라마다 2차 접종, 부스터샷을 진행하여야하고, 안정성이 확보되어 수요가 급증하여 가격을 올려버림. → 우리나라는 1차 접종률이 30%이고, 2차와 부스터샷까지 가려면 시간이 많이남음. → 백신 수요에 늑장을 부려 백신 공급받기가 힘들지 않을까 우려의 목소리가 많다. → 국내 백신 개발에 투자하려고 한다. 하지만 전문가들은 대안이 없다면 부정적인 인식. → 모더나, 화이자 같은 경우 이미 수익을 많이 올렸고, 상당한 규모의 국가보조금을 받아 개발된 의약품이기에 가격을 올리는 것이 마땅한가에 대한 비판이 있다. 백신부족은 남일 …. 英, 3200만명 부스터샷 → 영국은 1차 88.5%, 2차 72.5% 접종이 완료 다음달부터 50대이상, 면역력 약한 사람들의 대상으로 3,200만명 부스터샷을 할 예정. “美증시와 소통하겠다” 뒷북수습 나선 中 → 주국이 자국을 규제하자 박살난 증시 때문에 미국이 중국 기업의 주식 상장 심사를 강화하자 중국이 미국과 소통을 확대하겠다고 하면서 달램. 中도 델타 변이 전국 확산 … “우한 이후 최악” → 베이징에서 델타 변이 감염자가 늘어, 정부는 규제를 강화중. 확진자 다시 10만명 넘은 美 “접종 충분 재봉쇄 없을 것” → 6개월만에 신규 감염자 10만명을 돌파한 미국 → 하지만, 재봉쇄는 없을 것. → 백신을 맞지 않은 사람들의 델타바이러스 전파 가능성. → 미국 의회에서 코로나19바이러스가 중국 우한 바이러스연구소에서 유출됐다는 의혹이 제기 → 연구소에서 2년 미만인 공기.폐기물 처리 시설의 대규모 개보수를 위한 입찰을 의뢰했다. → 시설 가동을 시작한 지 얼마 지나지 않아 대대적인 개보수를 하는 것은 일반적이지 않다며, 코로나19 발생 전 연구소의 위험 폐기물 처리시설 등이 제대로 작동했는지에 의문 제기 코로나에 접촉 꺼린 시민들 작년 지하철, 버스 덜 탔다. → 뱅크샐러드 데이터 분석(850만명의 소비, 지출 데이터 15억개) → 택시 결제 건수 25.5% 증가 대중교통, 시외버스, 철도 20%정도 줄음. “캠퍼스도 못 밟아보고 졸업” … 전문대 ‘코로나 학번’의 좌절 → 20,21학번들이 코로나로 인해 취업길이 막힘. → 실습시간을 채워야하는데 코로나로 인해서 기관에서 받아주질 않음. → 휴학을 하자니 취업난이 풀릴지도 모르고 난처 → 정부에서는 전문대생에게 1인당 70만원씩 지원하기로 하였지만, 문제는 실습을 해야하는거기에 기관출입을 허용해달라는 지적. " }, { "title": "leetcode(리트코드)-90 Subsets_II(PYTHON)", "url": "/posts/leetcode_Subsets_II/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-08-03 01:34:50 +0900", "snippet": "leetcode 90 - Subsets_II 문제입니다.1. 문제https://leetcode.com/problems/subsets-ii/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.4. 문제 해석 nums가 주어집니다. 정렬했을 때 중복되지 않는 subsets들을 구해 리스트에 담아 리턴합니다.5. code코드설명 subset을 구하고 정렬해서 set()에 있는 지 확인합니다.pythonclass Solution: def subsetsWithDup(self, nums: List[int]) -&amp;gt; List[List[int]]: self.result = [] self.s = set() self.solution(0,nums,[]) return self.result def solution(self, depth : int, nums : List[int], temp : List[int]): if depth == len(nums): temp.sort() temp = tuple(temp) if temp not in self.s : self.result.append(list(temp)) self.s.add(temp) return temp.append(nums[depth]) self.solution(depth+1,nums,temp[:]) temp.pop() self.solution(depth+1,nums,temp[:]) 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "2021.08.02(월).경제 정리노트", "url": "/posts/economy0802/", "categories": "Economy, DailyNote", "tags": "Economy", "date": "2021-08-03 00:50:50 +0900", "snippet": "2021.08.02 경제 헤드라인을 정리한 글입니다. 월수출 554억 달러 역대 최고, 반도체 착시 넘어 고루 날았다. → 반도체, 석유, 일반기계, 자동차, 석유제품, 철강, 차부품, 선박, 디스플레이 등 15개 품목 수출이 늘음. 외식하자니 냉면 1만7000원, 집밥 먹자니 시금치 4300원 → 농축산물 가격이 큰 폭으로 오름. 기후의 영향, 기름값 인상으로 인한 물류비용 증가가 요인. 상장사 10곳 중 6곳, 예상보다 더 벌었다. → 화학업종 떡상, 조선은 적자폭 키워 ISA 증권사로 대이동 5개월새 80만명 늘어 → ISA는 여러 금융 상품을 한 계좌에서 운용하도록 한 정책, 1월까지만 해도 가입자가 15만8000면으로 은행의 10분의 1도 안되었지만, 7월에는 79만2000명이 늘어난 반면 은행 가입자는 82만6000여명이 줄음. → ISA는 비교적 낮은 세율로 분리 과세하는 장점을 가짐. ‘중복청약 마지막 대어’ 크래프톤 증권사 3곳 최소청약에 747만원 → 미래에셋, NH, 삼성 증권으로 중복청약이 가능. 하지만3곳에 모두 넣으려면 총 747만원이 필요. REC 거래시장 개장 … RE100 참여 기업 구매 늘 듯. → 신재생에너지공급인증서(REC) 거래시장이 열림. → 신재생에너지를 사고 팔 수 있는 거래시장으로 원래는 REC를 구매한 사업자는 그만큼 재생에너지 발전 실적을 인정받게 되는데 그동안은 발전 사업자만 REC를 구입할 수 있었다. → 플랫폼 거래방식으로 운영되고, ESG 활동에 영향을 끼칠 듯. 김승연의 한화 40년, 몸집 288배 키웠다. → 1일 40주년, 총 자산 7548억 → 218조원 → 매출액 1조 1000억원 → 65조 4400억원 → 임직원 수 1만 1600명 → 4만 3680명 → 계열사 수 19개 → 83개 → 해외 거점 7곳 → 469곳 → 1980년 석유파동의 불황 속에서 한양화학과 한국 다우 케미칼을 인수 → 1년만에 흑자. → 대한생명(현 한화생명)을 2002년 인수해 자산 127조 보험사로 키움. → 2012년 파산했던 독일의 큐셀 인수, 2015년에 삼성의 방산 및 석유화학 부문 4개사를 인수하여 업계 1위를 달성. LG엔솔, 2050년 탄소중립 달성 … 그린배터리 생태계 구축. → RE100 : 기업이 사용하는 전력량의 100%를 2050년까지 재생에너지로 충당하겠다는 목표의 국제 캠페인. → REC구매를 통해 폴란드와 미국 사업장에 대해서 재생에너지 100% 전환을 완료. → 글로벌 관점의 다양성 관리, 제품 친환경성 관리 체계 강화, 공급망 ESG 리스크 관리 체계 개선 등 핵심 과제도 실행해나가겠다는 방침. 대한항공, 2년 연속 국제화물수송 세계 5위 → 코로나에도 가동률이 25% 상승 → 1위는 카타르 항공, 이어 페덱스, 에미레이트항공, 캐세이퍼시픽항공 순. → 대한항공은 1분기에 적자를 냈지만 2분기부터 화물 사업을 강화하며 흑자를 내고 있다. 이름 바꾸고 기술력 입힌 카카오웹툰 … ‘공룡’ 네이버에 도전 → 설계부터 글로시장을 겨냥한 카카오 웹툰 → 애니메이션 적용, AI 기반 개인 맞춤형 추천, 카카오페이지, 픽코마, 타파스 등 흥행 중인 콘텐츠까지 함께 제공. → 네이버는 신작 담아 ‘라인망가’ 개편해서 1위 재탈환 노림. → 웹툰시장에서 확장성이 있는데, 웹툰으로 드라마 등을 만들면 그 시장규모가 10배가 됨. 그렇기에 현지에서도 흥행하는 핵심 콘텐츠를 얼마나 보유하고 있느냐가 경쟁력에 영향을 미침. 숙박앱선 45만원짜리 펜션, 전화 예약하니 “42만원에 드릴게요.” → 앱을 통한 예약은 수수료 때문에 이러한 사태가 발생. → 어떤 모텔은 한달 매출의 60% 앱 매출인데, 수수료 등을 빼면 매출이 많이 빠짐. → 그래도 60%가 매출을 차지하기에 대안이 없다. 우리집 전세 2.5억 오른대요. 도둑질 않고 어떻게 마련하죠. → 20년 동안 큰 싸움 한 번 없던 부부가 거의 매일 싸우고 있음. 아파트를 살 수 있었지만, 집 값을 잡겠다는 정부를 믿고 기다렸다. 3억짜리 전셋집이 5억5천이 되면서 2억5천을 어디서 버냐.. 이런 내용. 전세 65 % 월세 35% 입대차법 시행 1년새 반전세 - 월세 늘었다. → 최근 1년간 서울 아파트 전.월세 거래 3건 중 2건만 전세. → 그러나 전세 비중이 점차 감소 중. 1년 동안 71.9%에서 6.8% 감소 내년말까지 다주택 안팔면 양도세 급증. → 2023년까지 집을 다 팔지 않으면 양도세 폭탄 맞음. → 이로인해서 다주택자가 ‘똘똘한 한 채’만 남기는 현상이 더 심해질 수 있다. 자녀 없으면 신혼희망타운, 자녀 많으면 신혼특공 당첨 노려라. → 신혼특공은 무주택자, 예비 부부, 7세 미만 자녀를 둔 한부모 가정에게 입주자격이 있음. 외에도 여러 조건이 있음. → 신혼희망타운은 신혼특공과 다르게 혼인 2년 이내, 혹은 2세 이하 자녀를 둔 신혼 부부와 한부모 가족, 예비 부부에게 물량의 30%를 먼저 공급. 나머지 70%는 1단계에서 떨어진 사람들을 대상으로 다시 당첨자를 추림. → 사전청약 당첨 확률을 높이는 효과적인 방법은 ‘지역우선공급’을 공략하는 것. 주택공급 지역 주민에게 청약 우선권을 주는 것. 예를 들어서 인천 계양의 경우 인천 거주자에게 물량의 50%를 우선공급. 노원 ‘광운대역세권 개발’ 본 궤도 올랐다. → 항운 노조, 현대산업개발 갈등을 중재. ‘49층 랜드마크’ 주상복합 등 내년 착공 예정. → 구는 10여년 간의 기다림 끝에 겨우 이뤄낸 광운대역세권 개발을 어떠한 이유로든 늦출 수 없다고 판단하고 갈등 해결에 나섬. ‘부동산 4건’ 김현아 SH사장 후보자 사퇴 “애플 넘어 2023년 삼성 추월” 샤오미의 도발, 현실로? → 샤오미가 최근 애플을 제치면서 삼성한테 도발함. → 1억 800만 화소 휴대폰 카메라를 세계 최초로 선보였고, 카메라를 화면 아래에 숨기는 언더 디스플레이 카메라(UDC) 기술을 선도하고 있다. 최근에는 8분 만에 배터리를 완전히 충전할 수 있는 기술도 공개. → 연구.개발에 집중 투자한 결실을 보고 있다. → 레이 쥔 회장은 “올해는 R&amp;amp;D 투자액이 130억 위안을 넘을 것” 이라녀 “5000명 넘는 엔지니어를 추가로 채용할 것”이라고 말했다. → 미국의 제재로 추락할 뻔 했지만, 합의를 통해 해결되어 샤오미가 날개를 달았다라는 평가가 나옴. 디즈니랜드, 세계서 가장 저렴 … 일본은 어쩌다 물가 싼 나라’ 됐나 → 일본의 물가가 2000년이랑 같음. 심지어 스벅 라떼는 한국보다 더 쌈. → 이유는 임금이 늘어나지 않아서 소비자들이 가격에 민감해짐. → 고령화로 인한 수요 감소가 요인일 수도 있다. → 이유는 국내 물가 수준을 정하는건 국내 투자인데, 일본 기업들도 군내보다 해외 투자를 많이 하고 있다. 인구감소와 경기침체 장기화로 미래 수요에 대한 기대가 없기 때문. → 또한 임금이 거의 오르지 않다보니 고급 인재들이 더 나은 처우와 연봉을 찾아 해외로 떠나는 경우도 늘음. → 한국도 출산율 저하와 대기업 중소기업의 임금 격차 확대, 고용의 불안정 들 일본보다 취약한 구조에 놓여있다는 것. 中 부동산, 사교육, IT기업 규제에 美 “늦기전에 돈 빼자” → 중국에 부동산, 사교육, IT기업에 규제를 때려버려서 주가가 개폭락해버림. 美, 집세 못 낸 세입자 보호조치 종료 … 수백만명 강제퇴거 위기 → 코로나 감염 우려로 작년 9월부터 도입한 “퇴거 유예 조치” → 공화당 반대로 연장 불발 - 7월로 끝 → 임대료 체납자 최대 740만명 달해 집주인들이 공권력을 통해 전부 쫓아낼 듯. 총들고 그냥 세입자를 내보내는 가차없이 진행 됨. " }, { "title": "leetcode(리트코드)-901 Online Stock Span(PYTHON)", "url": "/posts/leetcode_Online_Stock_Span/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-08-02 03:34:50 +0900", "snippet": "leetcode 901 - Online Stock Span 문제입니다.1. 문제https://leetcode.com/problems/online-stock-span/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.4. 문제 해석 순차적으로 들어오는 데이터에 대해 몇 번째 인덱스를 기준으로 항상 상승폭이었는 지를 리턴합니다.5. code코드설명 잘 모르겠어서 discuss를 참고하여 스택으로 풀었습니다.pythonclass StockSpanner: def __init__(self): self.dq = deque() def next(self, price: int) -&amp;gt; int: res = 1 while self.dq and self.dq[-1][0] &amp;lt;= price : res += self.dq.pop()[1] self.dq.append((price,res)) return res# Your StockSpanner object will be instantiated and called as such:# obj = StockSpanner()# param_1 = obj.next(price) 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "leetcode(리트코드)-1768 Merge Strings Alternately(PYTHON)", "url": "/posts/leetcode_Merge_Strings_Alternately/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-08-02 02:34:50 +0900", "snippet": "leetcode 1768 - Merge Strings Alternately 문제입니다.1. 문제https://leetcode.com/problems/merge-strings-alternately/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 word1과 word2가 들어옵니다. 두 문자열을 지그재그식으로 확인하여 문자열을 만들 때 그 문자열을 리턴하세요.5. code코드설명pythonclass Solution: def mergeAlternately(self, word1: str, word2: str) -&amp;gt; str: size1 = len(word1) size2 = len(word2) i = 0 j = 0 res = &quot;&quot; while i + j &amp;lt; size1 + size2: if i &amp;lt; size1 : res += word1[i] i+=1 if j &amp;lt; size2 : res += word2[j] j+=1 return res 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "leetcode(리트코드)-1952 Three Divisors(PYTHON)", "url": "/posts/leetcode_Three_Divisors/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-08-02 01:34:50 +0900", "snippet": "leetcode 1952 - Three Divisors 문제입니다.1. 문제https://leetcode.com/problems/three-divisors/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 n이 들어옵니다. n이 3개의 약수를 가지면 True 아니면 False를 리턴하세요.5. code코드설명pythonclass Solution: def isThree(self, n: int) -&amp;gt; bool: count = 0 for i in range(1,n+1): if n % i == 0 : count+=1 if count &amp;gt;3 : return False return True if count == 3 else False 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "2021.07.31(토).경제 정리노트", "url": "/posts/economy0731/", "categories": "Economy, DailyNote", "tags": "Economy", "date": "2021-08-01 00:50:50 +0900", "snippet": "2021.07.31 경제 헤드라인을 정리한 글입니다. 델타 변이. 이상 기후, 세계 공급망 흔들려 수출 먹구름 5개월 좋아지더니… 기업 체감경기 다시 꺾여 → BSI(기업경기실사지수) = 100을 기준으로 높을수록 향후 경기에 대한 낙관적인 시각이 우수 → BSI가 5개월 만에 악화됨. 88에서 87로 1포인트가 하락하였지만, 시장에선 “올해 정부가 목표한 4.2% 성장률 달성이 어려워지는 것이 아니냐”라는 우려가 나옴. → 제조업(98 → 97), 비제조업(81 → 79), 예술, 스포츠(74 → 63), 숙박업(70 → 62)로 내려짐. 대기업 기준(107 → 107), 중소기업(88 → 85)로 줄어들음. 지난달 생산 역대 최고 수준 … 델타 변이 확산이 ‘찬물’ → 위의 기사와 비슷한 내용. 하지만, 1차 확산 때와 같은 급격한 경기 위축은 일어나지 않을 것. 사전에 대비할 것이기 때문에. 라면, 채소값 줄줄이 치솟아… 밥상 물가 심상치 않다. → 오뚜기 이어 농심 평균 6.8% 인상, 주원료인 소맥과 괌유 등의 가격이 급등했기 때문에. → 폭염 탓에 시금치 99%, 상추 40% 급등. 19개월만에 테슬라 판 서학개미, 메타버스 올라탔다. → 테슬라 실적 좋지만 주가는 약세, 서학개미(해외 주식을 사는 국내 투자자들)이 메타버스(로블록스, 페북 등)에 관심을 보임 외국인 200만명 시대 “틈새 금융고객 잡자” → 200만 명의 국내 체류 외국인 대상 영업이 신규 틈새 시장으로 주목 받는 중. 상품이 다양해지고 있고, 일부 은행은 내국인과 마찬가지로 전세자금 대출이나 신용대출 서비스를 내놓음. → 외국인 전용 모바일뱅킹 애플리케이션도 출시. ‘3중악재’에 두 달간 지킨 코스피 3,200선 위태 - 델타 변이, 피크아웃 논란 때문에 외국인이 매도 물량을 쏟아내고 있다. 中 ‘리튬인산철’에 맞설 ‘하이니켈’ 다음 주자는 ? → 전기차 배터리로 쓰이는 LFP(리튬인산철)배터리와 하이니켈 배터리가 있다. → LFP는 가격과 안정성을 경쟁력으로 내세움. → 하이니켈 배터리는 가격은 비싸지만, 배터리 성능이 좋다. 안정성은 낮다. → 둘 다 니켈과 코발트를 포함하고 있는데, 니켈의 함량이 높아질수록 전기차의 주행거리는 늘지만, 열에 의한 폭발 위험도가 높다. → 코발트는 비싸기 때문에 코발트보다 니켈을 함량을 올리는 게 도움이 될 수도 있다. → 때문에 국내 기업들은 니켈의 함량을 높이면서 안정성을 확보할 수 있는 기술을 개발하고 있다. → 중국에서는 전기차 보조금을 단계적으로 축소하기로 하면서 LFP배터리가 가격 경쟁력 면에서 더욱 선호될 것으로 보임. SM그룹, HAAH 등 9곳 출사표 … ‘1조 자금력’ 승패 가를 듯. → 쌍용차 인수전에 9개의 그룹이 참가하였지만, 쌍용차를 인수하기 위한 1조가 있는 지는 모르겠음. 결국 산업은행의 지원이 관건이라는 기사. 포스코, 네이버클라우드와 IT기업 육성 → 두 그룹이 MOU(벤처기업 육성을 위한 업무협약)체결. → 포스코가 운영 중인 ‘벤처밸리’에서 유망 벤처기업을 발굴해 추천하면 네이버클라우드가 선정된 벤처기업을 대상으로 국내외 판로 개척을 지원하는 클라우드 플랫폼과 ‘SaaS 프로그램’을 제공할 계획이다. HMM(현대 상선), 창사이래 첫 파업 위기 …중기 물류난 가중되나 → 노조 - 임금 25% 인상 요구안 vs HMM - 임금 5.5% 인상, 월 기본금 100%에 해당하는 격려금 지급안 협상 결렬 → HMM이 실적이 늘어났지만, 3조 원이 넘는 공적 자금을 갚아야하는 만큼 두 자릿수 임금 인상은 무리라는 입장. 에어택시 비싸지만 빠른 틸트로더 vs 느리지만 값싼 멀티로더 → 마지막 승부처는 자율비행 에어택시보다 ‘에어메트로’ 먼저 안착할 듯. → 지상보다 상대적으로 장애물이 적고, 조종사의 인건비가 비싸기 대문에 자율기술이 필요. 기술 구현은 쉽겠지만 안정성이 확보되어야 함. → 또한, 실시간 통신으로 연결되는 관제 시스템과 공항 격인 버티포트가 필요한데 이를 실현하기가 쉽지 않다는 것. 사람들의 두려움을 해소하는 것도 쉽지 않다. 여덟 가족 단칸방 살던 소년 … 한국 최고부자 됐다. → 카카오 의장 로봇, 인구감소 보완해 줄 대체 노동력 … 문제는 잉여인력의 복지시스템 전세 이중가격 - 한 아파트 같은 평인데 아랫집 3억9000, 윗집 8억 → 5%룰 때문이다. 임대료 인상 폭 5% 제한에 걸린 갱신 계약이냐, 이런 제약을 받지 않는 신규 계약이냐 여부가 전셋값을 극단적으로 나눔. 신규 계약 임대료 규제나 표준 임대료 등 추가적인 규제가 필요. 서울 아파트 하반기 전년대비 34% 줄었는데, 공급 충분하다고? → 정부가 공급 충분하다고 했음. 세금 더 옥죄자 … 1년새 증여 10만건 넘었다. → 정부가 양도세, 보유세, 취득세를 엄청 올렸는데 보유세 때문에 사람들이 집을 팔아야하는데… 양도세마저 너무 올려버려서 안좋은 집은 팔고 좋은집들은 자식에게 증여해버림. 그래서 매물이 없음. 포르셰도 테슬라처럼 우주산업 투자 / 로켓 제조 스타트업(이자르 에어로스페이스)에 859억 투자 니콜라 창업자 기소, 머스크에 불똥 → 니콜라의 창업자가 수소전기트럭 기술을 보유했다고 거짓말친게 들통났음. 투자자들이 사기혐의로 재판 넘겼는데, 머스크도 테슬라에 대한 개인 생각을 툭하면 던져 투자자가 피해를 입었으니 소환되어야하는 것 아니냐. 아마존 성장세 ‘주춤’ 매출 27% 증가 그쳐 → 2분기 기대 이하의 실적을 거둬, 아마존의 성장세가 꺾인것 아니냐는 분석. " }, { "title": "2021.07.30(금).경제 정리노트", "url": "/posts/economy0730/", "categories": "Economy, DailyNote", "tags": "Economy", "date": "2021-07-31 00:50:50 +0900", "snippet": "2021.07.30 경제 헤드라인을 정리한 글입니다. 체감경기 하락 ‘집값 상승’ 전망은 확산 폭염에 따른 가축들이 폐사하여 고기값들이 오름(한우 8%, 삼겹살 10%, 닭고기 13%) 코로나로 인해 결혼식 연기 - 취소 늘어 5월의 결혼, 40년만에 가장 적었다. 주식은 불안하고 펀드는 불편.. 전세계 ETF 1경원 몰렸다. 미래 먹거리 산업인 BBIG(배터리,바이오, 인터넷, 게임) 중 바이오만 주춤 → 카카오게임즈 109%, SK이노 36% 증가 셀트리온 30%안팍 떨어짐. 주금공 ‘초기증액형’, ‘정기증가형’ 연령대 따라 수령방식 변경 가능 → 8.2부터 3,5,7,10년 중 선택이 가능. → 초기증액형 ? → 5년을 선택한 경우 처음 5년동안은 정액형 보다 27.1% 많이 받지만, 6년 차부터 최초 수령액의 70%만 받음. → 정기증가형 ? → 최초 연금 수령 이후 3년마다 4.5% 수령액이 늘어나는 방식. 가상화폐 신규 투자자 ‘4월 165만 → 6월 12만명’ 급감. 현차 2분기 최대 실적 떡상 중. 외에 포스코, LG전자, SK하이닉스 → 억눌렸던 소비가 폭발하는 보복소비가 이유 중 하나라는 말.(차, 철강 IT 떡상, / 원자재값 상승으로 인한 조선, 여행, 항공 떡락) → 건설기계가 지난해 말부터 수요가 공급을 못 따라감. 샤오미 떡상. 세계시장에서 애플 제치고 점유율 2위를 먹음. 1위는 삼성이기에 쫓기고 있다. 한국시장에서 LG의 빈자리를 애플이 노림. 이제 LG베스트샵에서 애플을 팔 예정. OLED의 힘으로 LG디스플레이 상반기 영업익 1조 벽 깸. 두산중공업 흑자 → 두산중공업은 탄소중립 정책으로 미국과 유럽연합(EU)을 중심으로 소형원자로모듈(SMR) 건설이 가시화 되는 중. 폐배터리 리튬 회수 및 폐플라스틱을 활용한 수소생산 등 자원 재순환 프로젝트도 진행 중 현대 오토에버 미래차 SW에 2026년까지 1조 5000억 투자. → 차량 SW 플랫폼 확대, 개발 환경 플랫폼 구축, 클라우드 기반 차량 연동 서비스 중점 서비스 → 자동차의 하드웨어와 소프트웨어가 분리되는 추세에따라 차량 내 소프트웨어 내재화와 표준화가 중요해진다. 고 대표가 말함. → 국제 표준 SW 플랫폼 오토사를 기반으로 한 차량 소프트웨어 플랫폼 ‘모빌진 클래식’과 ‘모빌진 어댑티브’를 개발. → 각각 차량 제어의 기본 프로세서(MCU - Micro Controller Unit)와 고성능 반도체(AP - Application Processor)에 적용되는 운영체제 몸집키운 모빌리티 “이젠 수익성 강화 올인” → 카카오 T경우 월 99,000을 내면 호출 수요가 많은 곳을 알려줌. → 또한, 다른 가맹택시 업체들에게 카카오 T 호출 이용 수수료 요구 ☞ 해당 요구를 받아 업무협악을 맺음.(반반택시, 마카롱 택시) → 쏘카는 구독 서비스를 통한 수익성 강화. → 티맵은 대리운전 시장에 진출. → 놀라운 것은 쏘카, 카카오 모빌리티 모두 흑자를 달성한 적이 없음. 티맵은 경우는 1분기에 손실을 봄. “대체육 괜찮네” 2040년엔 육류시장 넘어선다. 시장 24% 성장함. 홍남기 부동산 관련 국민 남탓 존나한 기사 명동상가 코로나로 인해 10곳 중 4곳이 비어. 정부가 집값 떨어진다고 해도, 세종자이더시티 청약 경쟁률 199.7대 1 6500만원 이하는 인테리어 공사 안함. 요즘 인테리어는 부르는 게 값? → 유명 인테리어 업체가 6500만원 이하는 아예 공사 안한다고 함. 결국 동네 업체에서 4800만원에 공사하기로 했는데 추가비용 땜에 토탈 5300만원이 듦. → 20 ~ 30년 된 집이 많아서 리모델링, 인테리어 시장이 붐. 높아진 소비자의 눈높이도 한 몫. 또한 디자인, 소재 때문에 가격 표준화도 어려움. 한국 아파트는 중국인들 사이에서 인기있는 투자상품. → 가격이 내릴 가능성이 없고, 거리가 가까워서 관리하기 편함. 시베리아가 39도, 물속 연어는 부패 시베리아 산불로 두 달째 불타 강원도와 비슷한 면적 피해를 입어. → 호주의 해양 관광 명소인 ‘그레이트 배리어 리프’는 수온 상승때문에 유네스코 세계유산 지위에 위협. 산호초가 죽어버림. 중국이 배달업체에 규제를 내림. 인건비를 강화시켜버림." }, { "title": "leetcode(리트코드)-677 Map Sum Pairs(PYTHON)", "url": "/posts/leetcode_Map_Sum_Pairs/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-07-30 04:34:50 +0900", "snippet": "leetcode 677 - Count Items Matching a Rule 문제입니다.1. 문제https://leetcode.com/problems/map-sum-pairs/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.4. 문제 해석 Mapsum을 만들어야 합니다. insert()값으로 키와 값이 들어오는데 같은 값이 중복으로 들어올 시 해당 키에 저장된 값을 갱신해주면 됩니다. sum()값으로는 문자열이 들어옵니다. prefix로 문자열 맨 앞에 나타나야 합니다. sum() 함수를 호출하면 해당 prefix를 가진 키들의 값을 합해 리턴합니다. 5. code코드설명pythonclass MapSum: def __init__(self): self.dic = {} def insert(self, key: str, val: int) -&amp;gt; None: self.dic[key] = val def sum(self, prefix: str) -&amp;gt; int: res = 0 for word in self.dic : idx = word.find(prefix) if idx == 0 : res += self.dic[word] return res 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "leetcode(리트코드)-931 Minimum Falling Path Sum(PYTHON)", "url": "/posts/leetcode_Minimum_Falling_Path_Sum/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-07-30 03:34:50 +0900", "snippet": "leetcode 931 - Minimum Falling Path Sum 문제입니다.1. 문제https://leetcode.com/problems/minimum-falling-path-sum/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.4. 문제 해석 파스칼 삼각형처럼 matrix를 순차적으로 내려갑니다. 내려가면서 나온 숫자들을 더할 때 가장 작은 값을 리턴하세요.5. code코드설명 세 가지 경우가 있습니다. col의 사이즈가 1인경우 그냥 흘러내려가면 됩니다. col의 사이즈가 2 이상인 경우 위의 폭포의 ↖, ↑, ↗의 경우를 살펴줘야합니다. 파이썬의 특성상 범위를 벗어나도 파이썬 자체가 커버를 쳐주는 부분이 있어서 밑의 코드에서 예외처리를 안 해줬습니다.pythonclass Solution: def minFallingPathSum(self, matrix: List[List[int]]) -&amp;gt; int: row = len(matrix) col = len(matrix[0]) if col == 1: res = 0 for i in range(row): res += matrix[i][0] return res for i in range(1,row): for j in range(col): if j == col-1 : matrix[i][j] = min(matrix[i-1][j],matrix[i-1][j-1]) + matrix[i][j] elif j != 0 : matrix[i][j] = min(matrix[i-1][j-1],matrix[i-1][j],matrix[i-1][j+1]) + matrix[i][j] else : matrix[i][j] = min(matrix[i-1][j],matrix[i-1][j+1]) + matrix[i][j] return min(matrix[row-1]) 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "leetcode(리트코드)-1773 Count Items Matching a Rule(PYTHON)", "url": "/posts/leetcode_Count_Items_Matching_a_Rule/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-07-30 02:34:50 +0900", "snippet": "leetcode 1773 - Count Items Matching a Rule 문제입니다.1. 문제https://leetcode.com/problems/count-items-matching-a-rule/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 ruleKey와 ruleValue가 주어지는데 items에서 일치하는 값들을 찾아 그 갯수를 리턴합니다.5. code코드설명pythonclass Solution: def countMatches(self, items: List[List[str]], ruleKey: str, ruleValue: str) -&amp;gt; int: res = 0 idx = -1 if ruleKey == &quot;type&quot; : idx = 0 elif ruleKey == &quot;color&quot;: idx = 1 else : idx = 2 for i in range(len(items)): if items[i][idx] == ruleValue : res+=1 return res 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "leetcode(리트코드)-1784 Check if Binary String Has Most One Segment of Ones(PYTHON)", "url": "/posts/leetcode_Check_if_Binary_String_Has_at_Most_One_Segment_of_Ones/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-07-30 01:34:50 +0900", "snippet": "leetcode 1784 - Check if Binary String Has Most One Segment of Ones 문제입니다.1. 문제https://leetcode.com/problems/check-if-binary-string-has-at-most-one-segment-of-ones/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 1이 다 나온 뒤에 0 이나오는건 상관이 없지만 1이 다 나오지 않고 0이 나오면 False를 리턴합니다.5. code코드설명pythonclass Solution: def checkOnesSegment(self, s: str) -&amp;gt; bool: if len(s) == 1 : return True for i in range(len(s)-1,0,-1): if s[i] == &quot;1&quot; and s[i-1] == &quot;0&quot; : return False return True 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "leetcode(리트코드)-542 01 Matrix(PYTHON)", "url": "/posts/leetcode_01_Matrix/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-07-29 04:34:50 +0900", "snippet": "leetcode 542 - 01 Matrix 문제입니다.1. 문제https://leetcode.com/problems/01-matrix/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.4. 문제 해석 matrix가 주어집니다. 1을 기준으로 가장 가까운 0과의 거리를 찾아 matrix에 저장하고 리턴하세요.5. code코드설명 1을 기준으로 찾으면 시간초과가 뜹니다. discuss를 참조하여 0을 기준으로 코드를 작성하니 풀리더군요.pythonclass Solution: def updateMatrix(self, mat: List[List[int]]) -&amp;gt; List[List[int]]: row = len(mat) col = len(mat[0]) dx = [1,0,-1,0] dy = [0,1,0,-1] dq = deque() for i in range(row): for j in range(col): if mat[i][j] == 0 : dq.append((i,j)) else : mat[i][j] = 987654321 while dq : x,y = dq.popleft() for k in range(4): newx,newy = x + dx[k] , y + dy[k] z = mat[x][y]+1 if 0 &amp;lt;= newx and newx &amp;lt; row and 0 &amp;lt;= newy and newy &amp;lt; col and mat[newx][newy] &amp;gt; z : mat[newx][newy] = z dq.append((newx,newy)) return mat 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "leetcode(리트코드)-1094 Car Pooling(PYTHON)", "url": "/posts/leetcode_Car_Pooling/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-07-29 03:34:50 +0900", "snippet": "leetcode 1094 - Car Pooling 문제입니다.1. 문제https://leetcode.com/problems/car-pooling/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.4. 문제 해석 trips가 주어집니다. capacity가 주어집니다. trips[0]은 사람 수 , trips[1]은 탑승 시간, trips[2]는 내린 시간이라고 합니다. capacity만큼 사람들을 수용할 수 있을 때 모든 사람들을 수용할 수 있는 지 확인하여 리턴하세요.5. code코드설명pythonclass Solution: def carPooling(self, trips: List[List[int]], capacity: int) -&amp;gt; bool: lifetime = [0] * 1001 for i in range(len(trips)): lifetime[trips[i][1]] += trips[i][0] lifetime[trips[i][2]] -= trips[i][0] for i in range(1001): if capacity &amp;lt; 0 : return False capacity -= lifetime[i] return True 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "leetcode(리트코드)-1790 Check if One String Swap Can Make Strings Equal(PYTHON)", "url": "/posts/leetcode_Check_if_One_String_Swap_Can_Make_Strings_Equal/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-07-29 02:34:50 +0900", "snippet": "leetcode 1790 - Check if One String Swap Can Make Strings Equal 문제입니다.1. 문제https://leetcode.com/problems/check-if-one-string-swap-can-make-strings-equal/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 s1과 s2가 주어집니다. 둘의 문자가 다른 경우 하나의 알파벳을 스왑하여 같게 만들 수 있습니다. 만약 두 개 이상의 알파벳을 스왑하여 같게만들어야 하는경우는 False를 리턴하세요. 또는 같게 만들게 할 수 없는 경우 False를 리턴하세요.5. code코드설명pythonclass Solution: def areAlmostEqual(self, s1: str, s2: str) -&amp;gt; bool: if len(s1) != len(s2): return False check = 0 for i in range(len(s1)): if s1[i] != s2[i] : if check &amp;gt;=2 : return False else : if s2.find(s1[i]) != -1: check+=1 else : return False return True if check %2 == 0 else False 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "leetcode(리트코드)-1791 Find Center of Star Graph(PYTHON)", "url": "/posts/leetcode_Find_Center_of_Star_Graph/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-07-29 01:34:50 +0900", "snippet": "leetcode 1791 - Find Center of Star Graph 문제입니다.1. 문제https://leetcode.com/problems/find-center-of-star-graph/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 그래프가 주어졌을 때 중앙값을 찾아 리턴하세요.5. code코드설명pythonclass Solution: def findCenter(self, edges: List[List[int]]) -&amp;gt; int: dic ={} n = len(edges) for i in range(len(edges)): first,second = edges[i] if first not in dic : dic[first] = 1 else : dic[first] += 1 if second not in dic : dic[second] = 1 else : dic[second] += 1 for i in dic : if dic[i] == n : return i 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "leetcode(리트코드)-1796 Second Largest Digit in a String(PYTHON)", "url": "/posts/leetcode_Second_Largest_Digit_in_a_String/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-07-27 02:34:50 +0900", "snippet": "leetcode 1796 - Second Largest Digit in a String 문제입니다.1. 문제https://leetcode.com/problems/second-largest-digit-in-a-string/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 s가 주어집니다. s안에 숫자들이 주어집니다. 숫자 중에서 2번째로 큰 값을 찾아서 리턴하세요.5. code코드설명pythonclass Solution: def secondHighest(self, s: str) -&amp;gt; int: check = [0] * 10 for i in range(len(s)): if s[i].isdigit(): check[ord(s[i]) -48] +=1 first = False for i in range(len(check)-1,-1,-1): if check[i] != 0 : if first == False : first = True else : return i return -1 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "leetcode(리트코드)-1800 Maximum Ascending Subarray Sum(PYTHON)", "url": "/posts/leetcode_Maximum_Ascending_Subarray_Sum/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-07-27 01:34:50 +0900", "snippet": "leetcode 1800 - Maximum Ascending Subarray Sum 문제입니다.1. 문제https://leetcode.com/problems/maximum-ascending-subarray-sum/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 nums가 주어집니다. 연속되는 부분배열들의 합중 가장 큰 것을 찾아 그 합을 리턴하세요.5. code코드설명pythonclass Solution: def maxAscendingSum(self, nums: List[int]) -&amp;gt; int: DP = [0] * len(nums) res = nums[0] DP[0] = nums[0] for i in range(1,len(nums)): if nums[i-1] &amp;lt; nums[i] : DP[i] = DP[i-1] + nums[i] else : DP[i] = nums[i] res = max(res,DP[i]) return res 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "leetcode(리트코드)-1941 Check if All Characters Have Equal Number of Occurrences(PYTHON)", "url": "/posts/leetcode_Check_if_All_Characters_Have_Equal_Number_of_Occurrences/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-07-26 03:34:50 +0900", "snippet": "leetcode 1941 - Check if All Characters Have Equal Number of Occurrences 문제입니다.1. 문제https://leetcode.com/problems/check-if-all-characters-have-equal-number-of-occurrences/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 s라는 문자열이 들어옵니다. 문자열의 각 알파벳이 동일하게 카운트되면 True를 리턴하고 아니면 False를 리턴합니다.5. code코드설명pythonclass Solution: def areOccurrencesEqual(self, s: str) -&amp;gt; bool: dic = {} pivot = 0 for i in range(len(s)): if s[i] not in dic : dic[s[i]]=1 else : dic[s[i]]+=1 pivot = dic[s[i]] for count in dic : if dic[count] != pivot: return False return True 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "leetcode(리트코드)-935 Knight Dialer(PYTHON)", "url": "/posts/leetcode_Knight_Dialer/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-07-26 02:34:50 +0900", "snippet": "leetcode 935 - Knight Dialer 문제입니다.1. 문제https://leetcode.com/problems/knight-dialer/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.4. 문제 해석 체스의 knight라고 생각하고 전화번호를 누른다고 가정합니다. ” 1 2 3 “ ” 4 5 6 “ ” 7 8 9 “ ” * 0 # “ 이라고 할 때 숫자만 눌러야합니다. n자리수의 전화번호를 만들 때 가능한 경우의 수를 10^9+7로 나누어 리턴합니다.5. code코드설명 일단 5번을 누르는 경우는 n이 1인 경우말고는 없습니다. 마지막으로 누른 번호가 4와 6번인 경우에는 각 3가지의 경우가 있습니다. 마지막으로 누른 번호가 4와 6번이 아닌 경우는 각 2가지의 경우가 있습니다.pythonclass Solution: def knightDialer(self, n: int) -&amp;gt; int: x0 = x1 = x2 = x3 = x4 = x5 = x6 = x7 = x8 = x9 = 1 for i in range(n-1) : x0,x1,x2,x3,x4,x6,x7,x8,x9 = \\ x4 + x6, x6 + x8, x7 + x9,\\ x4 + x8, x3 + x0 + x9, x0 + x1 + x7,\\ x2 + x6, x1 + x3, x2 + x4 res = x0 + x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8 + x9 if n != 1: res-=1 return (res) % (10**9 + 7) 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "leetcode(리트코드)-1945 Sum of Digits of String After Convert(PYTHON)", "url": "/posts/leetcode_Sum_of_Digits_of_String_After_Convert/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-07-26 01:34:50 +0900", "snippet": "leetcode 1945 - Sum of Digits of String 문제입니다.1. 문제https://leetcode.com/problems/sum-of-digits-of-string-after-convert/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 s와 k가 들어옵니다. s는 문자열이고 해당 문자들을 알파벳 순서대로 반환하여 각자리에 나타냅니다. 나타낸 수를 k만큼 반복하여 자리마다 수를 더해 결과값을 리턴합니다.5. code코드설명pythonclass Solution: def getLucky(self, s: str, k: int) -&amp;gt; int: res = 0 convert = &quot;&quot; loop = 0 while loop &amp;lt;= k : if loop == 0 : for i in range(len(s)): convert += str((ord(s[i]) - 96)) else : res = 0 for i in range(len(s)): res += int(s[i]) convert = str(res) loop+=1 s = convert convert = &quot;&quot; return res 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "leetcode(리트코드)-838 Push Dominoes(PYTHON)", "url": "/posts/leetcode_Push_Dominoes/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-07-21 01:34:50 +0900", "snippet": "leetcode 838 - Push Dominoes 문제입니다.1. 문제https://leetcode.com/problems/push-dominoes/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.4. 문제 해석 dominoes가 들어온다. dominoes의 R은 오른쪽으로 도미노이고 L은 왼쪽으로 도미노한다.. 예제처럼 2개가 쌓여있다해서 힘이 더 쌔고 그런건 없는 것같다.5. code코드설명 ’.’을 기준으로 왼쪽와 오른쪽을 탐색해서 “LL,LR,RL,RR”인 경우마다 처리를 다르게 해주어 해결했다.pythonclass Solution: def pushDominoes(self, dominoes: str) -&amp;gt; str: idx = 0 dominoes = list(dominoes) while idx &amp;lt; len(dominoes) : if dominoes[idx] == &#39;.&#39; : left = idx right = idx while left &amp;gt; 0 and dominoes[left] == &#39;.&#39; : left-=1 while right+1 &amp;lt; len(dominoes) and dominoes[right] == &#39;.&#39; : right+=1 if dominoes[right] == &#39;L&#39; : if dominoes[left] == &#39;R&#39;: while left+1 &amp;lt; right-1 : dominoes[left+1] = &#39;R&#39; dominoes[right-1] = &#39;L&#39; left+=1 right-=1 else : while left &amp;lt; right : dominoes[left] = &#39;L&#39; left+=1 else : if dominoes[left] == &#39;R&#39; : while left &amp;lt;= right : dominoes[left] = &#39;R&#39; left+=1 idx+=1 return &#39;&#39;.join(dominoes) 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "Programmers_2021 KAKAO Intership 숫자 문자열과 영단어(python)", "url": "/posts/Programmers_stringandenglish/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-07-19 03:34:40 +0900", "snippet": "프로그래머스 - 숫자 문자열과 영단어 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/813012. 분류 및 난이도Programmers 문제입니다.2021 kakao 카카오 채용연계형 인턴쉽 문제입니다.Level 1난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 문자열의 길이가 길지 않아서 아무렇게나 풀어도 됩니다.4. 접근 방법을 적용한 코드def solution(s): answer = &quot;&quot; dic = {} dic[&quot;zero&quot;]=0 dic[&quot;one&quot;]=1 dic[&quot;two&quot;]=2 dic[&quot;three&quot;]=3 dic[&quot;four&quot;]=4 dic[&quot;five&quot;]=5 dic[&quot;six&quot;]=6 dic[&quot;seven&quot;]=7 dic[&quot;eight&quot;]=8 dic[&quot;nine&quot;]=9 temp = &quot;&quot; for i in range(len(s)): if s[i].isalpha() : temp+=s[i] if temp in dic : answer += str(dic[temp]) temp = &quot;&quot; else : answer += str(s[i]) return int(answer)5. 결과필요시. c++ 짜드리겠습니다. 설명이 필요시 댓글달아주세요." }, { "title": "leetcode(리트코드)-137 Single Number II(PYTHON)", "url": "/posts/leetcode_Single_Number_II/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-07-19 02:34:50 +0900", "snippet": "leetcode 137 - Single Number II 문제입니다.1. 문제https://leetcode.com/problems/single-number-ii/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.4. 문제 해석 nums가 주어집니다. nums에 한 값만 빼고 3번씩 반복된다고 할 때 반복되지 않는 한 요소를 리턴하세요.5. code코드설명pythonclass Solution: def singleNumber(self, nums: List[int]) -&amp;gt; int: #하나 빼고 전부 3번 반복될 때 나머지 1개 dic = {} for i in range(len(nums)): if nums[i] not in dic : dic[nums[i]]=1 else : dic[nums[i]]+=1 if dic[nums[i]] == 3 : del[dic[nums[i]]] res = list(dic.keys()) return res[0]6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "leetcode(리트코드)-1805 Number of Different Integers in a String(PYTHON)", "url": "/posts/leetcode_Number_of_Different_Integers_in_a_String/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-07-19 01:34:50 +0900", "snippet": "leetcode 1805 - Number of Different Integers in a String 문제입니다.1. 문제https://leetcode.com/problems/number-of-different-integers-in-a-string/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 word가 주어집니다. 숫자만 뽑아낼 때 중복없이 뽑아내야합니다. 뽑아낸 숫자의 갯수를 리턴하세요.5. code코드설명pythonclass Solution: def numDifferentIntegers(self, word: str) -&amp;gt; int: s = set() i = 0 while i &amp;lt; len(word) : temp = &quot;&quot; while i &amp;lt;len(word) and word[i].isdigit() : temp += word[i] i+=1 if temp != &quot;&quot; : temp = int(temp) s.add(temp) temp = &quot;&quot; i-=1 i+=1 return len(s) 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "leetcode(리트코드)-235 Lowest Common Ancestor of a Binary Search(PYTHON)", "url": "/posts/leetcode_Lowest_Common_Ancestor_of_a_Binary_Search_Tree/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-07-19 01:34:50 +0900", "snippet": "leetcode 235 - Lowest Common Ancestor of a Binary Search 문제입니다.1. 문제https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 root와 p,q가 주어집니다. p와 q값을 찾았을 때 공통된 가장 낮은(low level) 레벨의 조상을 리턴하세요. Eazy문제이지만, 생각보다 어려워서 discuss를 참고하였습니다.5. code코드설명python# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def lowestCommonAncestor(self, root: &#39;TreeNode&#39;, p: &#39;TreeNode&#39;, q: &#39;TreeNode&#39;) -&amp;gt; &#39;TreeNode&#39;: if not root : return None if max(p.val,q.val) &amp;lt; root.val : return self.lowestCommonAncestor(root.left,p,q) elif min(p.val,q.val) &amp;gt; root.val : return self.lowestCommonAncestor(root.right,p,q) else : return root 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "leetcode(리트코드)-1812 Determine Color of a Chessboard Square(PYTHON)", "url": "/posts/leetcode_Determine_Color_of_a_Chessboard_Square/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-07-18 04:34:50 +0900", "snippet": "leetcode 1812 - Determine Color of a Chessboard Square 문제입니다.1. 문제https://leetcode.com/problems/determine-color-of-a-chessboard-square/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 coordinates는 어떠한 열과 행에 대한 이름입니다. 그 열과 행에 해당되는 부분이 Black인지 White인지 확인하여 black이면 False를 리턴 White는 True를 리턴하세요.5. code코드설명pythonclass Solution: def squareIsWhite(self, coordinates: str) -&amp;gt; bool: res = (ord(coordinates[0]) - 97) + int(coordinates[1]) return False if res%2 == 1 else True6. 결과 및 후기, 개선점필요시 c++로 작성해드립니다.모르겟으면 댓글 부탁드립니다." }, { "title": "leetcode(리트코드)-25 Reverse Nodes in k Group(PYTHON)", "url": "/posts/leetcode_Reverse_Nodes_in_k-Group/", "categories": "leetcode, Hard", "tags": "leetcode", "date": "2021-07-18 03:34:50 +0900", "snippet": "leetcode 25 - Reverse Nodes in k Group 문제입니다.1. 문제https://leetcode.com/problems/reverse-nodes-in-k-group/2. Input , Output3. 분류 및 난이도Hard 난이도 문제입니다.4. 문제 해석 head와 k가 주어집니다. k만큼 그룹을 묶고 그 그룹에 해당하는 값들의 순서를 바꿔버립니다.5. code코드설명python# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def reverseKGroup(self, head: ListNode, k: int) -&amp;gt; ListNode: #list에 넣고 돌리자. if k == 1 : return head node = ListNode() dq = [] res = [] while head : dq.append(head.val) head = head.next idx = 0 while idx+k &amp;lt;= len(dq) : temp = dq[idx:idx+ k] temp.reverse() res += temp idx = idx + k res += dq[idx:] temp = node for i in range(len(res)): temp.next = ListNode(res[i]) temp = temp.next return node.next 6. 결과 및 후기, 개선점필요시 c++로 짜드립니다.설명이 필요하다면 댓글을 달아주세요." }, { "title": "leetcode(리트코드)-1905 Count Sub Islands(PYTHON)", "url": "/posts/leetcode_Count_Sub_Islands/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-07-18 02:34:50 +0900", "snippet": "leetcode 1905 - Count Sub Islands 문제입니다.1. 문제https://leetcode.com/problems/count-sub-islands/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.4. 문제 해석 grid1과 grid2가 주어집니다. grid2의 인접한 섬들이 모두 grid1에 종속될 때 count를 하나 증가시킵니다. 최종 count값을 리턴합니다.5. code코드설명pythonclass Solution: def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -&amp;gt; int: row = len(grid2) col = len(grid2[0]) res = 0 dx =[-1,0,1,0] dy = [0,-1,0,1] v = [0] * row for i in range(row) : v[i] = [0] * col for i in range(row) : for j in range(col): if v[i][j] == 0 and grid2[i][j] == 1 : if grid1[i][j] == 0 : continue else : dq = deque() dq.append((i,j)) v[i][j] = 1 check = False while dq : x,y = dq.popleft() for k in range(4) : newx,newy = x + dx[k] , y + dy[k] if 0&amp;lt;= newx and newx &amp;lt;row and 0 &amp;lt;= newy and newy &amp;lt; col and grid2[newx][newy] == 1: if v[newx][newy] == 1 : continue else : if grid1[newx][newy] == 0 : check = True dq.append((newx,newy)) v[newx][newy] = 1 if check == False : res+=1 return res 6. 결과 및 후기, 개선점필요시 c++로 작성해드립니다.모르겟으면 댓글 부탁드립니다." }, { "title": "leetcode(리트코드)-1935 Maximum Number of Words You Can Type(PYTHON)", "url": "/posts/leetcode_Maximum_Number_of_Words_You_Can_Type/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-07-18 01:34:50 +0900", "snippet": "leetcode 1935 - Maximum Number of Words You Can Type 문제입니다.1. 문제https://leetcode.com/problems/maximum-number-of-words-you-can-type/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 text와 brokenLetters가 주어집니다. brokenLetters은 키보드가 박살난 것들입니다. text를 공백을 기준으로 나누었을 때 몇개의 텍스트를 완벽히 타이핑이 가능한 지 리턴합니다.5. code코드설명pythonclass Solution: def canBeTypedWords(self, text: str, brokenLetters: str) -&amp;gt; int: text = text.split() chrlist = [0] * 26 for i in range(len(brokenLetters)) : chrlist[ord(brokenLetters[i])-97] = 1 res = 0 for word in text: check = False for j in range(len(word)): if chrlist[ord(word[j])-97] == 1: check = True break if not check: res+=1 return res6. 결과 및 후기, 개선점" }, { "title": "leetcode(리트코드)-1910 Remove All Occurrences of a Substring(PYTHON)", "url": "/posts/leetcode_Remove_All_Occurrences_of_a_Substring/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-07-17 02:34:50 +0900", "snippet": "leetcode 1910 - Remove All Occurrences of a Substring 문제입니다.1. 문제https://leetcode.com/problems/remove-all-occurrences-of-a-substring/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.4. 문제 해석 input과 part가 주어집니다. part를 input에서 찾아 모든 부분 문자열을 지워버린 문자열을 리턴합니다.5. code코드설명pythonclass Solution: def removeOccurrences(self, s: str, part: str) -&amp;gt; str: size = len(part) while True : idx = s.find(part) if idx == -1 : break else : s = s[:idx] + s[idx + size:] return s 6. 결과 및 후기, 개선점" }, { "title": "leetcode(리트코드)-1822 Sign of the Product of an Array(PYTHON)", "url": "/posts/leetcode_Sign_of_the_Product_of_an_Array/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-07-17 01:34:50 +0900", "snippet": "leetcode 1822 - Sign of the Product of an Array 문제입니다.1. 문제https://leetcode.com/problems/sign-of-the-product-of-an-array/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 nums가 주어집니다. 배열의 모든 요소를 곱한 결과가 양수면1, 0이면 0, 음수면 -1을 리턴합니다.5. code코드설명pythonclass Solution: def arraySign(self, nums: List[int]) -&amp;gt; int: res = 1 for i in range(len(nums)): if nums[i] == 0 : return 0 elif nums[i] &amp;lt; 0 : res *= -1 return res6. 결과 및 후기, 개선점" }, { "title": "leetcode(리트코드)-611 Valid Triangle Number(PYTHON)", "url": "/posts/leetcode_Valid_Triangle_Number/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-07-16 01:34:50 +0900", "snippet": "leetcode 611 - Valid Triangle Number 문제입니다.1. 문제https://leetcode.com/problems/valid-triangle-number/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.4. 문제 해석 nums에 3개를 요소를 골랐을 때 그 요소들로 삼각형을 만들 수 있으면 갯수를 셉니다. 최대 갯수를 리턴하세요.5. code코드설명PYTHONclass Solution: def triangleNumber(self, nums: List[int]) -&amp;gt; int: nums.sort() size = len(nums) ans = 0 for k in range(2,size) : i = 0 j = k-1 while i &amp;lt; j : if nums[i] + nums[j] &amp;gt; nums[k] : ans += j - i j-=1 else: i+=1 return ans 6. 결과 및 후기, 개선점" }, { "title": "leetcode(리트코드)-791 Custom Sort String(PYTHON)", "url": "/posts/leetcode_Custom_Sort_String/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-07-14 04:34:50 +0900", "snippet": "leetcode 791 - Custom Sort String 문제입니다.1. 문제https://leetcode.com/problems/custom-sort-string/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.4. 문제 해석 order와 str이 주어집니다. order는 정렬을 할 때의 우선순위이고, str을 order의 우선순위에 맞게 재정렬하면 됩니다.5. code코드설명 먼저, 결과 string에 우선순위의 카운트에 맞게 문자들을 더해줍니다. str을 돌면서 dic에 저장되지 않은 문자는 우선순위가 중요하지 않으므로 그대로 res string에 추가합니다.pythonclass Solution: def customSortString(self, order: str, str: str) -&amp;gt; str: counting = 0 res = &quot;&quot; dic = {} for word in (order): res += str.count(word) * word dic[word] = 1 for word in str : if word in dic : continue else : res += word print(res) return res 6. 결과 및 후기, 개선점" }, { "title": "leetcode(리트코드)-77 Combinations(PYTHON)", "url": "/posts/leetcode_Combinations/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-07-14 03:34:50 +0900", "snippet": "leetcode 77 - Combinations 문제입니다.1. 문제https://leetcode.com/problems/combinations/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.4. 문제 해석 n과 k가 주어집니다. [1,2,3,… ,n]까지의 리스트가 있을 때 k의 combination을 구해 리턴하세요.5. code코드설명pythonclass Solution: def combine(self, n: int, k: int) -&amp;gt; List[List[int]]: li = [x+1 for x in range(n)] li = list(combinations(li, k)) return li6. 결과 및 후기, 개선점" }, { "title": "leetcode(리트코드)-596 Classes More Than 5 Students(SQL)", "url": "/posts/leetcode_Classes_More_Than_5_Students/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-07-14 02:34:50 +0900", "snippet": "leetcode 596 - Classes More Than 5 Students 문제입니다.1. 문제https://leetcode.com/problems/classes-more-than-5-students/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 student 컬럼과 class 컬럼이 있습니다. class의 해당되는 student가 5명 이상인 것을 추출하는 쿼리를 작성하세요. 중복으로 값이 들어올 수 있습니다.5. code코드설명SQL# Write your MySQL query statement belowSELECT classFROM coursesGROUP BY classHAVING count(distinct student) &amp;gt;= 56. 결과 및 후기, 개선점" }, { "title": "leetcode(리트코드)-1827 Minumum Operations to Make the Array Increasing(SQL)", "url": "/posts/leetcode_Minimum_Operations_to_Make_the_Array_Increasing/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-07-14 01:34:50 +0900", "snippet": "leetcode 1827 - Minimum Operations to Make the Array Increasing 문제입니다.1. 문제https://leetcode.com/problems/minimum-operations-to-make-the-array-increasing/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 nums가 주어집니다. 해당 nums를 오름차순으로 만들어야합니다. 각 요소를 1씩 올릴 수만 있을 때 최소한의 방법으로 오름차순을 만들 수 있게하세요. 1을 올린 카운트를 리턴하세요.5. code코드설명PYTHONclass Solution: def minOperations(self, nums: List[int]) -&amp;gt; int: res = 0 if len(nums) == 1 : return 0 else : for i in range(1,len(nums)): if nums[i] &amp;lt;= nums[i-1] : res += nums[i-1] - nums[i]+1 nums[i] = nums[i-1] + 1 return res 6. 결과 및 후기, 개선점" }, { "title": "leetcode(리트코드)-1179 Reformat Department Table(SQL)", "url": "/posts/leetcode_Reformat_Department_Table/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-07-13 02:34:50 +0900", "snippet": "leetcode 1179 - Reformat Department Table 문제입니다.1. 문제https://leetcode.com/problems/reformat-department-table/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 id에 맞는 month들의 revenue합을 구하는 쿼리를 작성하세요.5. code코드설명SQL# Write your MySQL query statement belowSELECT id, SUM(CASE WHEN month = &#39;Jan&#39; THEN revenue ELSE NULL END) as Jan_Revenue,SUM(CASE WHEN month = &#39;Feb&#39; THEN revenue ELSE NULL END) as Feb_Revenue,SUM(CASE WHEN month = &#39;Mar&#39; THEN revenue ELSE NULL END) as Mar_Revenue,SUM(CASE WHEN month = &#39;Apr&#39; THEN revenue ELSE NULL END) as Apr_Revenue,SUM(CASE WHEN month = &#39;May&#39; THEN revenue ELSE NULL END) as May_Revenue,SUM(CASE WHEN month = &#39;Jun&#39; THEN revenue ELSE NULL END) as Jun_Revenue,SUM(CASE WHEN month = &#39;Jul&#39; THEN revenue ELSE NULL END) as Jul_Revenue,SUM(CASE WHEN month = &#39;Aug&#39; THEN revenue ELSE NULL END) as Aug_Revenue,SUM(CASE WHEN month = &#39;Sep&#39; THEN revenue ELSE NULL END) as Sep_Revenue,SUM(CASE WHEN month = &#39;Oct&#39; THEN revenue ELSE NULL END) as Oct_Revenue,SUM(CASE WHEN month = &#39;Nov&#39; THEN revenue ELSE NULL END) as Nov_Revenue,SUM(CASE WHEN month = &#39;Dec&#39; THEN revenue ELSE NULL END) as Dec_RevenueFROM DepartmentGROUP BY id6. 결과 및 후기, 개선점" }, { "title": "leetcode(리트코드)-1832 Check if the Sentence Is Pangram(python)", "url": "/posts/leetcode_Check_if_the_Sentence_Is_Pangram/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-07-13 01:34:50 +0900", "snippet": "leetcode 1832 - Check if the Sentence Is Pangram 문제입니다.1. 문제https://leetcode.com/problems/check-if-the-sentence-is-pangram/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 pangram이란, sentence로 주어진 문자열에 모든 소문자 영어 알파벳이 한 번 이상 나오면 True이고 아니면 False인 문자열을 말합니다. pangram를 판단하세요.5. code코드설명pythonclass Solution: def checkIfPangram(self, sentence: str) -&amp;gt; bool: dic = {} for word in sentence: if word not in dic : dic[word] = 1 if len(dic) == 26 : return True return False6. 결과 및 후기, 개선점필요시 c++로 짜드리겠습니다." }, { "title": "leetcode(리트코드)-82 Remove Duplicates from Sorted List II(python)", "url": "/posts/leetcode_Remove_Duplicates_from_Sorted_List_II/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-07-12 06:34:50 +0900", "snippet": "leetcode 82 - Remove Duplicates from Sorted List II 문제입니다.1. 문제https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.4. 문제 해석 Linked List가 주어집니다. 중복되는 값은 제거한 LinkeList를 리턴하세요.5. code코드설명한 번에 처리하려고 햇지만, 잘 되지 않아서 임시 리스트와 중복 판단을 위한 dictionary를 선언하여 관리하였습니다.python# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def deleteDuplicates(self, head: ListNode) -&amp;gt; ListNode: temp = [] dic = {} while head : if head.val in dic : dic[head.val] = 2 else : dic[head.val] = 1 head = head.next for k in dic: if dic[k] == 2 : continue else : temp.append(k) temp.sort() res = ListNode() finall = res for i in range(len(temp)): res.next = ListNode(temp[i]) res = res.next return finall.next 6. 결과 및 후기, 개선점필요시 c++로 짜드리겠습니다." }, { "title": "leetcode(리트코드)-61 Rotate List(python)", "url": "/posts/leetcode_Rotate_List/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-07-12 05:34:50 +0900", "snippet": "leetcode 61 - Rotate List 문제입니다.1. 문제https://leetcode.com/problems/rotate-list/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.4. 문제 해석 head가 주어집니다. k만큼 rotate한 link list를 반환하세요.5. code코드설명임시 deque list를 만들어서 값들을 담고, k를 갱신해줍니다.갱신한 k만큼 python내장함수인 rotate()을 이용해서 옮기고 노드들에 값들을 옮겨줍니다.python# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def rotateRight(self, head: ListNode, k: int) -&amp;gt; ListNode: if head == None : return None temp = deque() res = head while head : temp.append(head.val) head= head.next k = k % len(temp) finall = res temp.rotate(k) for i in range(len(temp)) : res.val = temp[i] if i != len(temp)-1 : res.next = ListNode() res = res.next return finall6. 결과 및 후기, 개선점필요시 c++로 짜드리겠습니다." }, { "title": "leetcode(리트코드)-24 Swap Nodes in Pairs(python)", "url": "/posts/leetcode_Swap_Nodes_in_Pairs/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-07-12 04:34:50 +0900", "snippet": "leetcode 24 - Swap Nodes in pairs 문제입니다.1. 문제https://leetcode.com/problems/swap-nodes-in-pairs/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.4. 문제 해석 head가 주어집니다. 해당 링크드 리스트에서 인접한 2개는 swap을 하여 리스트를 반환하세요.5. code코드설명python# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def swapPairs(self, head: ListNode) -&amp;gt; ListNode: res = head if head == None or head.next == None : return res curr = head fast = head.next while True: curr.val, fast.val = fast.val, curr.val if curr.next == None or curr.next.next == None or fast.next == None or fast.next.next ==None: break curr = curr.next.next fast = fast.next.next return res 6. 결과 및 후기, 개선점필요시 c++로 짜드리겠습니다." }, { "title": "leetcode(리트코드)-627 Swap Salary(SQL)", "url": "/posts/leetcode_Swap_Salary/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-07-12 03:34:50 +0900", "snippet": "leetcode 627 - Swap Salary 문제입니다.1. 문제https://leetcode.com/problems/swap-salary/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 Salary 테이블에서 sex의 값이 ‘f’이면 ‘m’으로 바꾸고 ‘m’이면 ‘f’로 바꿔야합니다.5. code코드설명SQLUPDATE SalarySET sex = IF (sex = &#39;f&#39;,&#39;m&#39;,&#39;f&#39;) 6. 결과 및 후기, 개선점필요시 c++로 짜드리겠습니다." }, { "title": "leetcode(리트코드)-1925 Count Square Sum Triples(python)", "url": "/posts/leetcode_Count_Square_Sum_Triples/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-07-12 02:34:50 +0900", "snippet": "leetcode 1925 - Count Square Sum Triples 문제입니다.1. 문제https://leetcode.com/problems/count-square-sum-triples/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 n이 들어옵니다. n이 삼각형의 한 변이라고 생각했을 때 n까지의 직각삼각형의 갯수를 구하세요.5. code코드설명pythonclass Solution: def countTriples(self, n: int) -&amp;gt; int: dic = {} res = 0 for i in range(1,n+1) : dic[i**2] = 1 for i in range(n,1,-1) : for j in range(i-1,0,-1): if (i**2) - (j**2) in dic : res+=1 return res 6. 결과 및 후기, 개선점필요시 c++로 짜드리겠습니다." }, { "title": "leetcode(리트코드)-1929 Concatenation of Array(python)", "url": "/posts/leetcode_Concatenation_of_Array/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-07-12 01:34:50 +0900", "snippet": "leetcode 1929 - Concatenation of Array 문제입니다.1. 문제https://leetcode.com/problems/concatenation-of-array/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 nums라는 배열이 들어옵니다. nums를 두 번 반복한 배열을 리턴합니다.5. code코드설명pythonclass Solution: def getConcatenation(self, nums: List[int]) -&amp;gt; List[int]: return nums + nums 6. 결과 및 후기, 개선점필요시 c++로 짜드리겠습니다." }, { "title": "leetcode(리트코드)-1837 Sum of Digits in Base K(python)", "url": "/posts/leetcode_Sum_of_Digits_in_Base_K/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-07-08 01:34:50 +0900", "snippet": "leetcode 1837 - Sum of Digits in Base K 문제입니다.1. 문제https://leetcode.com/problems/sum-of-digits-in-base-k/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 n이라는 숫자가 들어옵니다. k진법으로 바꿨을 때 숫자의 각 자리를 더해서 리턴합니다.5. code코드설명pythonclass Solution: def sumBase(self, n: int, k: int) -&amp;gt; int: res = &quot;&quot; while n : res += str(n % k) n = n // k sumres = 0 for i in range(len(res)): sumres += int(res[i]) return sumres6. 결과 및 후기, 개선점필요시 c++로 짜드리겠습니다." }, { "title": "leetcode(리트코드)-595 Big Countries(sql)", "url": "/posts/leetcode_Big_Countries/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-07-07 03:34:50 +0900", "snippet": "leetcode 595 - Big Countries 문제입니다.1. 문제https://leetcode.com/problems/big-countries/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 population이 25 million이 넘거나 area가 3 million이 넘는 것들의 name, population, area를 출력하는 쿼리를 작성하세요.5. code코드설명SQLSELECT name, population, areaFROM WorldWHERE population &amp;gt; 25000000 or area &amp;gt; 3000000;6. 결과 및 후기, 개선점" }, { "title": "leetcode(리트코드)-620 Not Boring Movies(sql)", "url": "/posts/leetcode_Not_Boring_Movies/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-07-07 02:34:50 +0900", "snippet": "leetcode 620 - Not Boring Movies 문제입니다.1. 문제https://leetcode.com/problems/not-boring-movies/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 id가 홀수이면서 description이 ‘boring’이 아닌 데이터를 rating의 내림차순으로 정렬하는 쿼리를 작성하세요.5. code코드설명SQLSELECT * FROM CinemaWHERE id % 2 = 1 AND description NOT LIKE &#39;boring&#39;ORDER BY rating DESC;6. 결과 및 후기, 개선점" }, { "title": "leetcode(리트코드)-1844 Replace All Digits with Characters(python)", "url": "/posts/leetcode_Replace_All_Digits_with_Characters/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-07-07 01:34:50 +0900", "snippet": "leetcode 1844 - Replace All Digits with Characters 문제입니다.1. 문제https://leetcode.com/problems/replace-all-digits-with-characters/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 input으로 string이 주어집니다. 숫자의 의미는 전에 나온 문자를 그 숫자만큼 더하란 것입니다. 즉 a에 1을 더한 것은 b입니다.-완성된 문자열을 리턴하세요.5. code코드설명pythonclass Solution: def replaceDigits(self, s: str) -&amp;gt; str: res = &quot;&quot; for i in range(len(s)): if i%2 == 0 : temp = ord(s[i]) res += s[i] else : res+= chr(temp+ int(s[i])) return res6. 결과 및 후기, 개선점필요시 c++로 짜드리겠습니다." }, { "title": "leetcode(리트코드)-1848 Minimum Distance to the Target Element(python)", "url": "/posts/leetcode_Minimum_Distance_to_the_Target_Element/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-07-06 03:34:50 +0900", "snippet": "leetcode 1848 - Minimum Distance to the Target Element 문제입니다.1. 문제https://leetcode.com/problems/minimum-distance-to-the-target-element/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 target으로 들어오는 값을 찾아 start와의 절댓값 뺄셈이 가장 작은 값을 리턴하세요. 일반적으로 푸나 탐색을 start에서 시작하나 수행시간이 크게 다르지 않습니다.5. code코드설명pythonclass Solution: def getMinDistance(self, nums: List[int], target: int, start: int) -&amp;gt; int: left = start right =start while 1: if nums[left] == target : return abs(left - start) elif nums[right] == target : return right-start if left &amp;gt;0 : left-=1 if right+1 &amp;lt; len(nums): right+=1 6. 결과 및 후기, 개선점필요시 c++로 짜드리겠습니다." }, { "title": "leetcode(리트코드)-1920 Build Array from Permutation(python)", "url": "/posts/leetcode_Build_Array_from_Permutation/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-07-06 01:34:50 +0900", "snippet": "leetcode 1920 - Build Array from Permutation 문제입니다.1. 문제https://leetcode.com/problems/build-array-from-permutation/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 nums가 들어옵니다. 해당 인덱스에 들어있는 숫자를 가진 배열을 리턴해야합니다.5. code코드설명pythonclass Solution: def buildArray(self, nums: List[int]) -&amp;gt; List[int]: res = deque() for i in nums: res.append(nums[i]) return res6. 결과 및 후기, 개선점필요시 c++로 짜드리겠습니다." }, { "title": "leetcode(리트코드)7월06일 challenge1338-Reduce Array Size to The Half(python)", "url": "/posts/leetcode_Reduce_Array_Size_to_The_Half/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-07-06 01:01:56 +0900", "snippet": "leetcode July 06일 - Reduce Array Size to The Half 문제입니다.1. 문제https://leetcode.com/problems/reduce-array-size-to-the-half/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.7월 06일자 챌린지 문제입니다.4. 문제 해석 arr가 주어집니다. 배열의 요소를 고릅니다. 고른 뒤 배열에서 해당 요소값들을 제거하였을 때, arr의 size가 최대한 절반이 되는 최소한의 배열의 요소 개수를 구해서 리턴합니다.5. codepythonclass Solution: def minSetSize(self, arr: List[int]) -&amp;gt; int: dic = {} temp = [] size = len(arr) for i in range(size): if arr[i] not in dic : dic[arr[i]]=1 else: dic[arr[i]]+=1 for num in dic : temp.append(dic[num]) temp.sort(reverse = True) res = 0 sumd = 0 for i in range(len(temp)): if sumd &amp;lt; size//2 : sumd += temp[i] res+=1 else : return res return 16. 결과 및 후기, 개선점필요시 c++로 풀어드립니다." }, { "title": "leetcode(리트코드)-1863 Sum of All Subset XOR Totals(python)", "url": "/posts/leetcode_Sum_of_All_Subset_XOR_Totals/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-07-03 02:34:50 +0900", "snippet": "leetcode 1863 - Sum of All Subset XOR Totals 문제입니다.1. 문제https://leetcode.com/problems/sum-of-all-subset-xor-totals/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 nums의 모든 요소들끼리 XOR를 한 결과를 더해 리턴합니다. 재귀연습하기에 좋습니다. 재귀모르면.. 어케풀지? 어려워서 2주일 뒤에 다시 풀었습니다.5. code코드설명pythonclass Solution: def subsetXORSum(self, nums: List[int]) -&amp;gt; int: def sums(term,idx): if idx == len(nums) : return term return sums(term,idx+1) + sums(term ^ nums[idx],idx+1) return sums(0,0) 6. 결과 및 후기, 개선점필요시 c++로 짜드리겠습니다." }, { "title": "leetcode(리트코드)-1909 Remove One Element to Make the Array Strickly Increasing(python)", "url": "/posts/leetcode_Remove_One_Element_to_Make_the_Array_Strictly_Increasing/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-07-03 01:34:50 +0900", "snippet": "leetcode 1909 - Remove One Element to Make the Array Strictly Increasing 문제입니다.1. 문제https://leetcode.com/problems/remove-one-element-to-make-the-array-strictly-increasing/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 nums가 들어옵니다. 해당 문자열에서 1개만 지웠을 때 오름차순으로 정렬된 리스트로 만들 수 있는 지 확인해야합니다. 2가지 상태가 있습니다. 일단 i-1(이전 요소)보다 i가 작은 경우에서 i-2보다도 작은 경우라면 False입니다. 이전요소보다 i가 작은 경우에는 i를 i-1로 갱신해주면 됩니다.5. code코드설명pythonclass Solution: def canBeIncreasing(self, nums: List[int]) -&amp;gt; bool: res = 0 for i in range(1,len(nums)): if nums[i-1] &amp;gt;= nums[i] : res+=1 if i &amp;gt;1 and nums[i-2] &amp;gt;= nums[i] : nums[i] = nums[i-1] return res &amp;lt; 2 6. 결과 및 후기, 개선점필요시 c++로 짜드리겠습니다." }, { "title": "Programmers_연습문제 오랜 기간 보호한 동물(2)(SQL)", "url": "/posts/Programmers_old_animal2/", "categories": "Algorithm, Programmers", "tags": "Programmers, MYSQL", "date": "2021-07-02 22:34:40 +0900", "snippet": "프로그래머스 -오랜 기간 보호한 동물(2) 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/594112. 분류 및 난이도Programmers 문제입니다.연습문제 문제입니다.Level 3난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) join4. 접근 방법을 적용한 코드-- 코드를 입력하세요SELECT OUTS.ANIMAL_ID, OUTS.NAMEFROM ANIMAL_INS INS RIGHT JOIN ANIMAL_OUTS OUTSON INS.ANIMAL_ID = OUTS.ANIMAL_IDORDER BY OUTS.DATETIME - INS.DATETIME DESCLIMIT 25. 결과" }, { "title": "Programmers_연습문제 오랜 기간 보호한 동물(1)(SQL)", "url": "/posts/Programmers_old_animal/", "categories": "Algorithm, Programmers", "tags": "Programmers, MYSQL", "date": "2021-07-02 21:34:40 +0900", "snippet": "프로그래머스 -오랜 기간 보호한 동물(1) 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/590442. 분류 및 난이도Programmers 문제입니다.연습문제 문제입니다.Level 3난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) join4. 접근 방법을 적용한 코드-- 코드를 입력하세요SELECT INS.NAME, INS.DATETIMEFROM ANIMAL_INS INS LEFT JOIN ANIMAL_OUTS OUTSON INS.ANIMAL_ID = OUTS.ANIMAL_IDWHERE OUTS.ANIMAL_ID IS NULLORDER BY INS.DATETIMELIMIT 35. 결과" }, { "title": "Programmers_연습문제 있었는데요 없었습니다.(SQL)", "url": "/posts/Programmers_exits_nonexits/", "categories": "Algorithm, Programmers", "tags": "Programmers, MYSQL", "date": "2021-07-02 20:34:40 +0900", "snippet": "프로그래머스 -있었는데요 없었습니다. 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/590432. 분류 및 난이도Programmers 문제입니다.연습문제 문제입니다.Level 3난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) JOIN4. 접근 방법을 적용한 코드-- 코드를 입력하세요SELECT INS.ANIMAL_ID, INS.NAMEFROM ANIMAL_INS INS INNER JOIN ANIMAL_OUTS OUTSON INS.ANIMAL_ID = OUTS.ANIMAL_IDWHERE INS.DATETIME &amp;gt; OUTS.DATETIMEORDER BY INS.DATETIME5. 결과" }, { "title": "Programmers_연습문제 잃어버린 기록 찾기(SQL)", "url": "/posts/Programmers_find_delete_page/", "categories": "Algorithm, Programmers", "tags": "Programmers, MYSQL", "date": "2021-07-02 19:34:40 +0900", "snippet": "프로그래머스 -잃어버린 기록 찾기 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/590422. 분류 및 난이도Programmers 문제입니다.연습문제 문제입니다.Level 3난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) JOIN4. 접근 방법을 적용한 코드-- 코드를 입력하세요SELECT OUTS.ANIMAL_ID, OUTS.NAME FROM ANIMAL_OUTS OUTS LEFT JOIN ANIMAL_INS INSON OUTS.ANIMAL_ID = INS.ANIMAL_IDWHERE INS.ANIMAL_ID IS NULLORDER BY OUTS.ANIMAL_ID;5. 결과" }, { "title": "Programmers_연습문제 입양 시각 구하기(1)(SQL)", "url": "/posts/Programmers_hourtime/", "categories": "Algorithm, Programmers", "tags": "Programmers, MYSQL", "date": "2021-07-02 17:34:40 +0900", "snippet": "프로그래머스 -루시와 엘라 찾기 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/594122. 분류 및 난이도Programmers 문제입니다.연습문제 문제입니다.Level 2난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) SQL 잘 몰라서 참고했습니다.4. 접근 방법을 적용한 코드-- 코드를 입력하세요SELECT HOUR(DATETIME) AS HOUR, COUNT(DATETIME) AS COUNTFROM ANIMAL_OUTSGROUP BY HOURHAVING HOUR BETWEEN 9 AND 19ORDER BY HOUR5. 결과" }, { "title": "Programmers_연습문제 중성화 여부 파악하기(SQL)", "url": "/posts/Programmers_findINTAKE/", "categories": "Algorithm, Programmers", "tags": "Programmers, MYSQL", "date": "2021-07-02 15:34:40 +0900", "snippet": "프로그래머스 -중성화 여부 파악하기 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/594092. 분류 및 난이도Programmers 문제입니다.연습문제 문제입니다.Level 2난이도의 문제입니다. LIKE Query가 보기에 안좋아서 다시 작성하고 싶은데..3. 생각한 것들(문제 접근 방법) SQL IF4. 접근 방법을 적용한 코드-- 코드를 입력하세요SELECT ANIMAL_ID, NAME, IF(SEX_UPON_INTAKE LIKE &#39;Neutered%&#39; OR SEX_UPON_INTAKE LIKE &#39;Spayed%&#39;, &#39;O&#39;,&#39;X&#39;) AS &quot;중성화&quot;FROM ANIMAL_INSORDER BY ANIMAL_ID ASC;5. 결과" }, { "title": "Programmers_연습문제 중복 제거하기(SQL)", "url": "/posts/Programmers_distinctname/", "categories": "Algorithm, Programmers", "tags": "Programmers, MYSQL", "date": "2021-07-02 14:34:40 +0900", "snippet": "프로그래머스 -중복 제거하기 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/594082. 분류 및 난이도Programmers 문제입니다.연습문제 문제입니다.Level 2난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) SQL GROUP BY가 아니라는 점.4. 접근 방법을 적용한 코드-- 코드를 입력하세요SELECT COUNT(DISTINCT NAME) AS count FROM ANIMAL_INSWHERE NAME IS NOT NULL5. 결과" }, { "title": "Programmers_연습문제 DATETIME에서 DATE로 형 변환(SQL)", "url": "/posts/Programmers_datetime_format_date/", "categories": "Algorithm, Programmers", "tags": "Programmers, MYSQL", "date": "2021-07-02 13:34:40 +0900", "snippet": "프로그래머스 -DATETIME에서 DATE로 형 변환 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/594142. 분류 및 난이도Programmers 문제입니다.연습문제 문제입니다.Level 2난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) SQL date_format()이라는 함수를 알고 있었습니까?4. 접근 방법을 적용한 코드-- 코드를 입력하세요SELECT ANIMAL_ID, NAME, date_format(DATETIME,&#39;%Y-%m-%d&#39;) AS &#39;날짜&#39;FROM ANIMAL_INSORDER BY ANIMAL_ID5. 결과" }, { "title": "Programmers_연습문제 NULL 처리하기(SQL)", "url": "/posts/Programmers_null_preset/", "categories": "Algorithm, Programmers", "tags": "Programmers, MYSQL", "date": "2021-07-02 12:34:40 +0900", "snippet": "프로그래머스 -NULL 처리하기 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/594102. 분류 및 난이도Programmers 문제입니다.연습문제 문제입니다.Level 2난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) SQL IFNULL()이라는 것을 알고 있었습니까?4. 접근 방법을 적용한 코드-- 코드를 입력하세요SELECT ANIMAL_TYPE, IFNULL(NAME,&#39;No name&#39;), SEX_UPON_INTAKEFROM ANIMAL_INSORDER BY ANIMAL_ID5. 결과" }, { "title": "Programmers_연습문제 동명 동물 수 찾기(SQL)", "url": "/posts/Programmers_find_equalnameanimal/", "categories": "Algorithm, Programmers", "tags": "Programmers, MYSQL", "date": "2021-07-02 11:34:40 +0900", "snippet": "프로그래머스 -이름에 el이 들어가는 동물 찾기 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/590412. 분류 및 난이도Programmers 문제입니다.연습문제 문제입니다.Level 2난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) SQL GROUP, HAVING4. 접근 방법을 적용한 코드-- 코드를 입력하세요SELECT NAME, COUNT(NAME) AS COUNTFROM ANIMAL_INSGROUP BY NAMEHAVING COUNT(NAME) &amp;gt;=2ORDER BY NAME ASC5. 결과" }, { "title": "Programmers_연습문제 이름에 el이 들어가는 동물 찾기(SQL)", "url": "/posts/Programmers_find_elnameanimal/", "categories": "Algorithm, Programmers", "tags": "Programmers, MYSQL", "date": "2021-07-02 10:34:40 +0900", "snippet": "프로그래머스 -이름에 el이 들어가는 동물 찾기 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/590472. 분류 및 난이도Programmers 문제입니다.연습문제 문제입니다.Level 2난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) SQL LIKE4. 접근 방법을 적용한 코드-- 코드를 입력하세요SELECT ANIMAL_ID, NAMEFROM ANIMAL_INSWHERE ANIMAL_TYPE = &#39;Dog&#39; AND NAME LIKE &#39;%el%&#39;ORDER BY NAME5. 결과" }, { "title": "Programmers_연습문제 루시와 엘라 찾기(SQL)", "url": "/posts/Programmers_findlucyella/", "categories": "Algorithm, Programmers", "tags": "Programmers, MYSQL", "date": "2021-07-02 09:34:40 +0900", "snippet": "프로그래머스 -루시와 엘라 찾기 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/590462. 분류 및 난이도Programmers 문제입니다.연습문제 문제입니다.Level 2난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) SQL IN4. 접근 방법을 적용한 코드-- 코드를 입력하세요SELECT ANIMAL_ID, NAME, SEX_UPON_INTAKEFROM ANIMAL_INSWHERE NAME IN (&#39;Ella&#39;,&#39;Lucy&#39;,&#39;Pickle&#39;,&#39;Rogan&#39;,&#39;Sabrina&#39;,&#39;Mitty&#39;);5. 결과" }, { "title": "Programmers_연습문제 동물 수 구하기(SQL)", "url": "/posts/Programmers_count_animal2/", "categories": "Algorithm, Programmers", "tags": "Programmers, MYSQL", "date": "2021-07-02 08:34:40 +0900", "snippet": "프로그래머스 -동물 수 구하기 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/594062. 분류 및 난이도Programmers 문제입니다.연습문제 문제입니다.Level 2난이도의 문제입니다. Level 2 치고는 너무 쉬운..듯하다.3. 생각한 것들(문제 접근 방법) SQL4. 접근 방법을 적용한 코드-- 코드를 입력하세요SELECT count(ANIMAL_ID)FROM ANIMAL_INS5. 결과" }, { "title": "Programmers_연습문제 고양이와 개는 몇 마리 있을까(SQL)", "url": "/posts/Programmers_cat_and_dog/", "categories": "Algorithm, Programmers", "tags": "Programmers, MYSQL", "date": "2021-07-02 07:34:40 +0900", "snippet": "프로그래머스 -고양이와 개는 몇 마리 있을까 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/590402. 분류 및 난이도Programmers 문제입니다.연습문제 문제입니다.Level 2난이도의 문제입니다. 롯데 pt면접에서 나왔던….3. 생각한 것들(문제 접근 방법) SQL4. 접근 방법을 적용한 코드-- 코드를 입력하세요SELECT ANIMAL_TYPE, COUNT(ANIMAL_TYPE) AS countFROM ANIMAL_INSGROUP BY ANIMAL_TYPEORDER BY ANIMAL_TYPE ASC5. 결과" }, { "title": "Programmers_연습문제 상위 n개 레코드(SQL)", "url": "/posts/Programmers_n_recode/", "categories": "Algorithm, Programmers", "tags": "Programmers, MYSQL", "date": "2021-07-02 06:34:40 +0900", "snippet": "프로그래머스 -상위 n개 레코드 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/594052. 분류 및 난이도Programmers 문제입니다.연습문제 문제입니다.Level 1난이도의 문제입니다. 떄문에 어렵지 않습니다.3. 생각한 것들(문제 접근 방법) SQL LIMIT를 써야한다는 특이점.4. 접근 방법을 적용한 코드-- 코드를 입력하세요SELECT NAMEFROM ANIMAL_INSORDER BY DATETIMELIMIT 1;5. 결과" }, { "title": "Programmers_연습문제 여러 기준으로 정렬하기(SQL)", "url": "/posts/Programmers_many_sort/", "categories": "Algorithm, Programmers", "tags": "Programmers, MYSQL", "date": "2021-07-02 05:34:40 +0900", "snippet": "프로그래머스 -아픈 동물 찾기 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/594042. 분류 및 난이도Programmers 문제입니다.연습문제 문제입니다.Level 1난이도의 문제입니다. 떄문에 어렵지 않습니다.3. 생각한 것들(문제 접근 방법) SQL4. 접근 방법을 적용한 코드-- 코드를 입력하세요SELECT ANIMAL_ID, NAME, DATETIMEFROM ANIMAL_INSORDER BY NAME, DATETIME DESC;5. 결과" }, { "title": "Programmers_연습문제 동물의 아이디와 이름(SQL)", "url": "/posts/Programmers_animal_name_id/", "categories": "Algorithm, Programmers", "tags": "Programmers, MYSQL", "date": "2021-07-02 04:34:40 +0900", "snippet": "프로그래머스 -동물의 아이디와 이름 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/594032. 분류 및 난이도Programmers 문제입니다.연습문제 문제입니다.Level 1난이도의 문제입니다. 떄문에 어렵지 않습니다.3. 생각한 것들(문제 접근 방법) SQL4. 접근 방법을 적용한 코드-- 코드를 입력하세요SELECT ANIMAL_ID, NAMEFROM ANIMAL_INSORDER BY ANIMAL_ID5. 결과" }, { "title": "Programmers_연습문제 아픈 동물 찾기(SQL)", "url": "/posts/Programmers_find_sick_animal/", "categories": "Algorithm, Programmers", "tags": "Programmers, MYSQL", "date": "2021-07-02 03:34:40 +0900", "snippet": "프로그래머스 -아픈 동물 찾기 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/590362. 분류 및 난이도Programmers 문제입니다.연습문제 문제입니다.Level 1난이도의 문제입니다. 떄문에 어렵지 않습니다.3. 생각한 것들(문제 접근 방법) SQL4. 접근 방법을 적용한 코드-- 코드를 입력하세요SELECT ANIMAL_ID, NAMEFROM ANIMAL_INSWHERE INTAKE_CONDITION = &#39;Sick&#39;5. 결과비슷한 문제로, 어린동물 찾기https://programmers.co.kr/learn/courses/30/lessons/59037가 있습니다." }, { "title": "Programmers_연습문제 역순 정렬하기(SQL)", "url": "/posts/Programmers_reverse_sortsql/", "categories": "Algorithm, Programmers", "tags": "Programmers, MYSQL", "date": "2021-07-02 02:34:40 +0900", "snippet": "프로그래머스 -역순 정렬하기 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/590352. 분류 및 난이도Programmers 문제입니다.연습문제 문제입니다.Level 1난이도의 문제입니다. 떄문에 어렵지 않습니다.3. 생각한 것들(문제 접근 방법) SQL4. 접근 방법을 적용한 코드-- 코드를 입력하세요SELECT NAME, DATETIMEFROM ANIMAL_INSORDER BY ANIMAL_ID DESC;5. 결과" }, { "title": "Programmers_연습문제 SUM, MAX, MIN(SQL)", "url": "/posts/Programmers_SUM_MAX_MIN/", "categories": "Algorithm, Programmers", "tags": "Programmers, MYSQL", "date": "2021-07-02 01:34:40 +0900", "snippet": "프로그래머스 -SUM, MAX, MIN 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/594152. 분류 및 난이도Programmers 문제입니다.연습문제 문제입니다.Level 1난이도의 문제입니다. 떄문에 어렵지 않습니다.3. 생각한 것들(문제 접근 방법) SQL4. 접근 방법을 적용한 코드SELECT MAX(DATETIME)FROM ANIMAL_INS5. 결과비슷한 문제로 https://programmers.co.kr/learn/courses/30/lessons/59038가 있습니다." }, { "title": "leetcode(리트코드)-182 Duplicate Emails(SQL)", "url": "/posts/leetcode_Duplicate_Emails/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-06-30 06:34:50 +0900", "snippet": "leetcode 182 - Duplicate Emails 문제입니다.1. 문제https://leetcode.com/problems/duplicate-emails/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 중복되는 Email을 찾아서 리턴합니다.5. code코드설명MYSQLselect Emailfrom Persongroup by Emailhaving count(*) &amp;gt; 1/*-- 내가 작성한 것.SELECT distinct p.Email FROM Person p, Person p2WHERE p.Id &amp;lt;&amp;gt; p2.Id and p.Email = p2.Email */ 6. 결과 및 후기, 개선점필요시 c++로 짜드리겠습니다." }, { "title": "leetcode(리트코드)-181 Employees Earning More Than Their Managers(SQL)", "url": "/posts/leetcode_Employees_Earning_More_Than_Their_Managers/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-06-30 05:34:50 +0900", "snippet": "leetcode 181 - Employees Earning More Than Their Managers 문제입니다.1. 문제https://leetcode.com/problems/employees-earning-more-than-their-managers/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 Employees 테이블에서 자신의 Manager보다 Salary를 많이 받는 사원의 이름을 검색해서 리턴합니다.5. code코드설명MYSQL/*SELECT e1.Name AS EmployeeFROM Employee AS e1, Employee AS e2WHERE e1.ManagerId = e2.Id and e1.Salary &amp;gt; e2.Salary;*/-- 조인을 사용SELECT emp.Name EmployeeFROM Employee emp INNER JOIN Employee manageron emp.ManagerId = manager.IdWHERE emp.Salary &amp;gt; manager.Salary; 6. 결과 및 후기, 개선점필요시 c++로 짜드리겠습니다." }, { "title": "leetcode(리트코드)6월29일 challenge1004-Max Consecutive Ones III(python)", "url": "/posts/leetcode_Max_Consecutive_Ones_III/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-06-30 04:01:56 +0900", "snippet": "leetcode June 29일 - Max Consecutive Ones III 문제입니다.1. 문제https://leetcode.com/problems/max-consecutive-ones-iii/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.6월 29일자 챌린지 문제입니다.4. 문제 해석 nums가 주어집니다. k 만큼 0을 1로 바꿀 수 있을 때 연속된 1의 길이가 가장 긴 값을 리턴하세요.5. codepythonclass Solution: def longestOnes(self, nums: List[int], k: int) -&amp;gt; int: i = 0 for j in range(len(nums)): k-= 1 - nums[j] if k &amp;lt; 0 : k+= 1-nums[i] i +=1 return j-i+16. 결과 및 후기, 개선점필요시 c++로 풀어드립니다." }, { "title": "leetcode(리트코드)-176 Second Highest Salary(SQL)", "url": "/posts/leetcode_Second_Highest_Salary/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-06-30 03:34:50 +0900", "snippet": "leetcode 176 - Second Higest Salary 문제입니다.1. 문제https://leetcode.com/problems/second-highest-salary/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 2번째로 큰 Salary를 뽑는 SQL문을 작성합니다.5. code코드설명MYSQL-- 가장 큰 Salary보다 작은 값들 중에서 가장 큰 Salary를 뽑는 SQL입니다.SELECT MAX(Salary) AS SecondHighestSalary FROM EmployeeWHERE Salary &amp;lt; (SELECT MAX(Salary) FROM Employee); 6. 결과 및 후기, 개선점필요시 c++로 짜드리겠습니다." }, { "title": "leetcode(리트코드)-1047 Remove All Adjacent Duplicates In String(python)", "url": "/posts/leetcode_Remove_All_Adjacent_Duplicates_In_String/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-06-30 02:34:50 +0900", "snippet": "leetcode 1047 - Remove All Adjacent Duplicates In String 문제입니다.1. 문제https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 연속되는 문자는 제거합니다. 남는 문자열을 리턴합니다. 삭제하고 난 뒤도 검사를 해줘야하므로 스택을 사용하는 것이 편합니다.5. code코드설명pythonclass Solution: def removeDuplicates(self, s: str) -&amp;gt; str: res = &quot;&quot; st = deque() for i in range(len(s)): if st : if st[-1] == s[i] : st.pop() else : st.append(s[i]) else : st.append(s[i]) while st : res+=st.popleft() return res 6. 결과 및 후기, 개선점필요시 c++로 짜드리겠습니다." }, { "title": "leetcode(리트코드)-1913 Maximum Product Difference Between Two Pairs(python)", "url": "/posts/leetcode_Maximum_Product_Difference_Between_Two_Pairs/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-06-30 01:34:50 +0900", "snippet": "leetcode 1913 - Maximum Product Difference Between Two Pairs 문제입니다.1. 문제https://leetcode.com/problems/maximum-product-difference-between-two-pairs/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 리스트의 (a,b,c,d)를 뽑아서 (c * d) - (a * b)의 값이 최대치가 되는 값을 리턴하세요. 정렬해서 하면 참 쉽겠죠?5. code코드설명pythonclass Solution: def removeDuplicates(self, s: str) -&amp;gt; str: res = &quot;&quot; st = deque() for i in range(len(s)): if st : if st[-1] == s[i] : st.pop() else : st.append(s[i]) else : st.append(s[i]) while st : res+=st.popleft() return res 6. 결과 및 후기, 개선점필요시 c++로 짜드리겠습니다." }, { "title": "CS-우아한 형제 블로그 - 좋은 퍼블리셔란? 정리", "url": "/posts/CS-Publisher/", "categories": "기술블로그", "tags": "", "date": "2021-06-25 03:34:50 +0900", "snippet": "2016.07.15 Naver D2글좋은 퍼블리셔란? - https://woowabros.github.io/woowabros/2016/07/15/good_publisher.html을 제 입 맛대로 정리한 글입니다.우리나라에 얼마나 많은 사람이 표준을 볼까?글쓴이는 “표준을 봐야한다”라는 말을 듣고 표준을 보기 시작함. 4년차가 되면서 “이렇게 좋은 걸 왜 안 읽을까?”라는 고민을 하게 되었고 단순한 문제가 있는 것을 알게 됨. 영어, 영어인데 어려운 영어, 영어인데 기술문서 라는 문제글쓴이는 그래서 번역을 시작하였는데, 번역된 표준도 사람들이 잘 읽지 않는다.왜 표준을 읽어야할까? 웹에서 표준 기술이라는 건 모든 브라우저에서 표준을 따르기로 협의 되어있다. 즉 표준을 따르지 않은 것은 ‘특출’이 아닌 ‘도태’된 것. 한국에서는 여러 이해관계로 인해 오래된 브라우저를 쓰는 사람도 많지만 그럼에도 불구하고 표준을 제대로 따르면 어느정도 상황까지 구현 가능. 표준을 적용하고, 문제가 발생했을 때 문제의 원인을 추측해나가는 과정에서, 표준에 명시되어있는 내용이라면 바로 해결이 가능. 그런 상황이 아니라면 브라우저의 문제점이라는 것을 알 수 있다. → 즉 문제 해결과정이 단순해진다. 표준을 잘 지킨다는 건 표준을 준수하는 모든 브라우저에서 내 웹사이트가 잘 나올 걸 기대 표준을 지키지 않고 개발하는 건 너무 쉽기에 사람들이 표준을 지키지 않는다. 하지만 이는 이슈가 발생했을 때 후회를 하게 되고, 결국 레거시를 안다가 코드를 바꾸는 경우가 대다수 좋은 퍼블리셔란?글쓴이가 생각하는 좋은 퍼블리셔란 표준을 잘 이해하고 활용할 수 있는 사람. 미래의 표준을 사전에 대비할 수 있는 사람." }, { "title": "CS-WebSocket,Socket.io정리", "url": "/posts/CS-WebSocket_socket.io/", "categories": "기술블로그", "tags": "Network", "date": "2021-06-25 02:34:50 +0900", "snippet": "2011.12.22 Naver D2글WebSocket, socket.io에 관하여 - https://d2.naver.com/helloworld/1336을 제 입 맛대로 정리한 글입니다.웹 소켓(Web Socket)이 있기까지1989년 CERN에서 웹 역사가 시작 되었을 때 사용자와의 상호작용은웬 개발에서 큰 부분을 차지하지 않았다. → 점점 차지하게 되어 나오게 됨.브라우저 렌더링 방식은 HTTP 요청에 대한 HTTP 응답을 받아서 브라우저 화면을 지우고 다시 그리면서 깜빡임이 생기게 된다. 이러한 깜빡임 없이 원하는 부분만 그리며 실시간으로 사용자와 상호작용하는 방식이 나타나고 사용자와 상호작용하는 웹 서비스를 선호하는 사용자가 증가하면서 RIA(Rich Internet Application) 기술의 발달이 촉진. RIA? 위키 정리 : 웹 애플리케이션의 장점은 유지, 웹 브라우저 기반 인터페이스의 단점인 늦은 응답 속도, 데탑 앱에 비해 떨어지는 조작성 등을 개선하기 위한 기술의 통칭 ex) Ajax, 상호작용하는 웹 서비스를 위해 숨겨진 프레임(Hidden Frame)을 이용한 방법이나 Long Polling, Stream 등 다양한 방법을 사용. Long Polling, Stream ? Polling : Polling 방식은 클라이언트가 주기적으로 웹서버에게 새로운 내용이 있는 지 물어보는 방식 Long Polling : 클라이언트가 웹서버에게 새로운 내용이 있는 지 요청시 웹서버에 내용이 없다면 대답해주지 않다가 새로운 내용이 생기면 대답해주는 방식 Streaming : 클라이언트와 서버가 계속 접속을 유지한 상태에서 이벤트가 발생할 때마다 클라이언트로 데이터를 보내는 방식 그림 및 참고 : &amp;lt;https://blog.naver.com/cache798/220895150211&amp;gt; 하지만 위의 방식들은 단방향 메시지 교환이기에 상호작용하는 웹 페이지를 복잡하고 어려운 코드로 구현해야 했음.보다 쉽게 상호작용하기 위한 양방향 메시지 송수신이 필요. 때문에 HTML5 표준안의 일부로 WebSocket API가 등장.WebSocket : 소켓을 이용하여 자유롭게 데이터를 주고 받을 수 있음.WebSocket 프로토콜WebSocket의 API는 W3C(World Wide Web Consortium)에서 관장, 프로토콜은 IETF(Internet Engineering Task Force)에서 관장다른 HTTP 요청과 마찬가지로 80번 포트를 통해 연결, 당연한 이야기지만, 클라이언트인 브라우저와 마찬가지로 웹 서버도 WebSocket 기능을 지원해야 한다.GET /... HTTP/1.1 Upgrade: WebSocket Connection: Upgrade브라우저는 Upgrade : WebSocket 헤더 등과 함께 랜덤하게 생성한 키를 서버에 보냄. 서버는 키를 바탕으로 토큰을 생성한 후 브라우저에 돌려줌. 이런 과정으로 WebSocket 핸드 쉐이킹이 이뤄짐.그 뒤 Protocol Overhead 방식으로 웹 서버와 브라우저가 데이터를 주고 받음. Protocol Overhead ? 여러 TCP 커넥션을 생성하지 않고 하나의 80번 포트 TCP커넥션을 이용하고, 별도의 헤더 등으로 논리적인 데이터 흐름 단위를 이용하여 여러 개의 커넥션을 맺는 효과. Socket.io ?WebSocket은 다가올 미래의 기술이라 써 볼 수 있는 기술이 아니다.그에 비해 Socket.io는 바로 사용할 수 있는 기술. JS를 이용하여 브라우저 종류에 상관없이 실시간 웹을 구현할 수 있도록 한 기술.Socket.io는 WebSocket, FlashSocket, AJAX Long Polling … 등들을 하나의 API로 추상화한 것. 브라우저와 웹 서버의 종류 버전을 파악하여 가장 적합한 기술을 선택하여 사용. Flash Plugin이 설치 되어 있으면 FlashSocket을 사용하고, 없으면 AJAX Long Polling 방식을 사용." }, { "title": "leetcode(리트코드)-219 Contains Duplicate II(python)", "url": "/posts/leetcode_Contains_Duplicate_II/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-06-25 01:34:50 +0900", "snippet": "leetcode 219 - Contains Duplicate II 문제입니다.1. 문제https://leetcode.com/problems/contains-duplicate-ii/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 nums배열이 들어옵니다. 같은 수인 어떤 인덱스 2개를 집었을 때 그 인덱스들의 값이 k보다 작거나 같으면 True를 리턴하고, 그런 인덱스가 없다면 False를 리턴합니다.5. code코드설명pythonclass Solution: def containsNearbyDuplicate(self, nums: List[int], k: int) -&amp;gt; bool: dic = {} for i in range(len(nums)): if nums[i] in dic : if abs(i - dic[nums[i]]) &amp;lt;=k : return True else : dic[nums[i]] = i else: dic[nums[i]] = i return False 6. 결과 및 후기, 개선점필요시 c++로 짜드리겠습니다." }, { "title": "JAVA_CS-Garbage Collection에 대해서 정리", "url": "/posts/CS-Java_Garbage_Collection/", "categories": "Java, CS", "tags": "JAVA", "date": "2021-06-24 02:34:50 +0900", "snippet": "2011.12.22 Naver D2글Java Garbage Collection 에 대해서 - &amp;lt;https://d2.naver.com/h&amp;gt;elloworld/1329&amp;gt;을 제 입 맛대로 정리한 글입니다.모든 사진에 대한 출처는 https://d2.naver.com/helloworld/1329글을 쓴 이유 : 주관적인 판단으로 GC에 대해 잘 알고 있어야 좋은 Java 개발자라고 생각하심.가비지 컬렉션 과정 - Cenertional Garbage Collection stop-the-world : GC를 실행하기 위해 JVM이 어플리케이션 실행을 멈추는 것. 즉, GC를 실행하는 쓰레드 외 모든 작업을 멈춤. 어떤 알고리즘을 사용하더라도 stop-the-world는 발생한다. GC튜닝이란 이 stop-the-world 시간을 줄이는 것 메모리 해제 시 객체를 null로 지정하는 방식, System.gc() 메서드를 호출하는 방식이 있다. System.gc()를 호출하는 것은 시스템 성능에 매우 큰 영향을 끼치므로 사용하지 말아야한다. JAVA에서는 개발자가 명시적으로 메모리 해제를 하지 않기에 GC가 필요없는 객체를 찾아 지우는 작업을 한다. 두 가지 가설(전제 조건)에 만들어짐. 대부분의 객체는 금방 접근 불가능 상태가 된다. 오래된 객체에서 젊은 객체로의 참조는 아주 적게 존재. 이러한 두 가설을 ‘weak generational hypothesis’라고 한다. HotSpot VM에서는 이 가설의 장점을 살리기 위해 2개의 물리공간(Young, Old)영역으로 나눔. Young영역 : 새롭게 생성한 객체의 대부분이 여기 위치. 첫 가설에 의해 많은 객체가 생기고 사라진다. 이 영역에서 객체가 사라질 때 Minor GC가 발생한다고 한다. Old 영역 : Young영역에서 살아남은 객체가 여기로 복사 된다. GC는 상대적으로 적게 발생하고, 여기서 객체서 사라질 때 Major GC(Full GC)가 발생한다고 한다. Permanent Generation 영역은 Method Area라고도 한다. 객체나 억류(intern)된 문자열 정보를 저장하는 곳. 이 영역에서도 GC가 발생할 수 있고 발생하면 Major GC의 횟수에 포함됨.그러면 “Old영역에 있는 객체가 Young영역의 객체를 어떻게 참조하는 경우 어떻게 처리 되는가?”에 대한 것은 Old 영역에는 512 바이트의 덩어리(chunk)로 되어 있는 카드 테이블(card table)이 존재. 카드 테이블에는 Old 영역에 있는 객체가 Young 영역의 객체를 참조할 때마다 정보가 표시됨. 따라서 Young영역의 GC를 실행할 때에는 Old 영역에 있는 모든 객체를 참조하지 않고, 카드 테이블만 뒤져서 GC대상인지 확인 카드 테이블은 write barrier를 사용하여 관리. Minor GC를 빠르게 하도록 도와줌. 오버헤드는 발생하지만 전반적인 GC시간은 줄어든다.Young 영역의 구성객체가 제일 먼저 생성되는 Young 영역은 3개의 영역으로 나뉜다. Eden Survivor (2개로 나뉨) 새로 생성한 대부분의 객체는 Eden 영역에 위치 Eden에서 GC가 발생하고 살아남은 객체는 Survivor 영역 중 하나로 이동 하나의 Suvivor의 영역이 가득 차게 되면 그 중 살아남은 객체를 다른 Suvivor영역으로 옮기고, 가득찬 Suvivor 영역은 비어짐. 이 과정을 반복하다가 계속해서 살아남아 있는 객체는 Old 영역으로 이동. 따라서 Suvivor 영역 중 하나는 반드시 비어 있어야함. 아니라면 시스템이 정상적인 상황이 아니라고 생각하면 된다. HotSpot VM에서는 빠른 메모리 할당을 위해 2가지 기술을 사용. bump-the-point : 스택마냥 마지막 객체의 위치만 본다. 새로 들어오는 객체가 Eden 영역에 넣기 적당하면 넣고, 마지막 객체 정보를 갱신한다. 마지막에 추가된 객체만 점검하면 되기에 빠른 메모리 할당 가능. TLABs(Thread-Local Allocation Buffers) : 위의 방식은 멀티 스레드 환경에서는 lock이 발생하여 성능이 떨어진다. 그래서 나온게 TLABs, 각각의 스레드가 각각의 몫에 해당하는 Eden 영역의 작은 덩어리를 가질 수 있도록 함. Old 영역에 대한 GCOld 영역에 대한 GC는 JDK 7 기준으로 5가지 방식이 있다. Serial GC Parallel GC Parallel Old GC(Parallel Compacting GC) Concurrent Mark &amp;amp; Sweep GC( = CMS) G1(Garbage First) Gc운영 서버에서 절대 사용하면 안 되는 방식이 Serial GC 이유는 데스크톱의 CPU 코어가 하나만 있을 때 사용하기 위해서 만든 방식. 성능이 떨어짐.1. Serial GC(-XX:+UseSerialGC)Old 영역의 GC는 mark-sweep-compact라는 알고리즘을 사용한다. mark : Old 영역에 살아 있는 객체를 식별(mark) Sweep : 힙(heap)의 앞 부분부터 확인하여 살아 있는 것만 남김. Compaction : 각 객체들이 연속되게 쌓이도록 힙 가장 앞부분부터 채워서 객체가 존재하는 부분과 없는 부분으로 나눔.적은 메모리와 CPU 코어 개수가 적을 때 적합2. Parallel GC(-XX:+USeParallelGC, = Throughput GC)Serial GC와 알고리즘은 같다. but Parallel GC는 GC를 처리하는 쓰레드가 여러 개. 그렇기에 Serial GC보다 빠르게 객체 처리 가능.메모리가 충분하고 코어의 개수가 많을 때 유리3. Parellel Old GC(-XX:+UseParallelOldGC)JDK5 update 6부터 제공한 GC방식.Parallel GC와 비교하여 Old 영역의 GC 알고리즘만 다름.Mark-Summary-Compaction 단계를 거친다.Summary는 앞의 Serial GC의 Sweep 보다 약간 더 복잡한 단계를 거침.4. CMS GC(-XX:+UseConcMarkSweepGC) inital Mark단계 : 클래스 로더에서 가장 가까운 객체 중 살아 있는 객체만 찾는 것으로 끝냄. 따라서 멈추는 시간(stop-the-world)이 매우 짧다. Concurrent Mark 단계 : 방금 살아있다고 확인한 객체에서 참조하고 있는 객체들을 따라가면서 확인. 다른 스레드가 실행중인 상태에서 진행가능 Remark 단계 : Concurrent Mark 단계에서 새로 추가되거나 참조가 끊긴 객체를 확인(stop-the world). Concurrent Sweep 단계 : 쓰레기를 정리하는 작업을 실행. 이 작업도 다른 스레드가 실행되고 있는 환경에서 진행.stop-the-world 시간이 매우 짧고, 모든 애플리케이션의 응답속도가 매우 중요할 때 CMS GC를 사용, Low Latency GC라고도 부름.하지만 단점도 존재한다. 다른 GC방식보다 메모리와 CPU를 많이 사용. Compaction 단계가 기본적으로 제공되지 않음.따라서 조각난 메모리가 많아 Compaction을 실행하면 다른 GC의 stop-the-world시간보다 더 늘어날 수 있다.5. G1 GCYoung 영역, Old 영역이란 것이 없다.바둑판의 각 영역에 객체를 할당하고 GC 실행. 그러다가 해당 영역이 꽉 차면 다른 영역에서 객체를 할당하고 GC를 실행. CMS GC를 대체하기 위해 만들어짐. 성능 : 어떤 GC 방식보다도 빠름. JDK7에서 G1 GC 정식 제공." }, { "title": "leetcode(리트코드)-1854 Maximum Population Year(python)", "url": "/posts/leetcode_Maximum_Population_Year/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-06-24 01:34:50 +0900", "snippet": "leetcode 1854 - Maximum Population Year 문제입니다.1. 문제https://leetcode.com/problems/maximum-population-year/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 logs에 들어오는 것은 어떤 사람의 출생기록입니다. [i][0]은 출생 년도, [i][1]은 사망연도 입니다. 사망연도는 인구수에 포함시키지 않을 때 인구수가 가장 많았을 때의 연도를 리턴하세요. Eazy문제라서 만만하게 봤는데, 생각보다 빠르게 처리가 불가능해서 하드코딩으로 작성하였습니다. 그래도 96% 나오는 거 보니 하드코딩해서 푸는게 맞는 것 같습니다.5. code코드설명pythonclass Solution: def maximumPopulation(self, logs: List[List[int]]) -&amp;gt; int: #Hardcoding countinglist = [0] * 150 for i in range(len(logs)): for j in range(logs[i][0], logs[i][1]): countinglist[j-1950] +=1 #카운트가 가장 많이 쌓인 인덱스를 반환하여 + 1950을 해줍니다. return countinglist.index(max(countinglist)) + 19506. 결과 및 후기, 개선점필요시 c++로 짜드리겠습니다." }, { "title": "leetcode(리트코드)-175 Combine Two Tables(SQL)", "url": "/posts/leetcode_Combine_Two_Tables/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-06-23 04:34:50 +0900", "snippet": "leetcode 175 - Combine Two Tables 문제입니다.1. 문제https://leetcode.com/problems/combine-two-tables/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 두 테이블이 주어졌습니다. FirstName과 LastName은 Person 테이블에 있습니다. City, State는 Address 테이블에 있습니다. 위의 4개를 select하는 구문을 작성합니다.5. code코드설명SQLselect Person.FirstName, Person.LastName, Address.City, Address.State from Person left join Addresson Person.PersonId =Address.PersonId 6. 결과 및 후기, 개선점" }, { "title": "leetcode(리트코드)-1859 Sorting the Sentence(python)", "url": "/posts/leetcode_Sorting_the_Sentence/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-06-23 03:34:50 +0900", "snippet": "leetcode 1859 - Sorting the Sentence 문제입니다.1. 문제https://leetcode.com/problems/sorting-the-sentence/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 input으로 문자열이 들어옵니다. 띄어쓰기를 기준으로 각 문자열의 끝에 번호가 주어집니다. 해당 번호 순서대로 문자열을 재배치하여 리턴합니다.5. code코드설명pythonclass Solution: def sortSentence(self, s: str) -&amp;gt; str: stsp = s.split(&quot; &quot;) resli = [&quot;&quot;] * len(stsp) res = &quot;&quot; for i in range(len(stsp)): resli[int(stsp[i][-1])-1] = stsp[i][:-1] for i in range(len(resli)): res += resli[i] + &quot; &quot; return res[:-1] 6. 결과 및 후기, 개선점필요시 c++로 짜드리겠습니다." }, { "title": "leetcode(리트코드)6월23일 challenge92-Reverse Linked List II(python)", "url": "/posts/leetcode_Reverse_Linked_List-II/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-06-23 02:01:56 +0900", "snippet": "leetcode June 23일 - Reverse Linked List II 문제입니다.1. 문제https://leetcode.com/problems/reverse-linked-list-ii/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.6월 23일자 챌린지 문제입니다.4. 문제 해석 링크드 리스트가 주어집니다. left와 right 범위내의 값들의 순서를 바꿔야합니다. 대칭으로 바꾸면 됩니다.5. codepython# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def reverseBetween(self, head: ListNode, left: int, right: int) -&amp;gt; ListNode: #left와 right 감지용 변수 count = 1 #stack을 통해 값들을 바꿔줄 것입니다. st = deque() lnode = head rnode =head # rnode는 right를 가리키는 노드인데, 그 값을 찾으면 다음 노드는 문제에서 중요하지 않으므로 탐색해주지 않습니다. while rnode : #left노드를 찾으면 right노드도 찾습니다. 찾는동안 스택에 값들을 저장합니다. if count == left : lnode = rnode while rnode and count != right+1 : count+=1 st.append(rnode.val) rnode = rnode.next break else : rnode = rnode.next count+=1 #스택이 없어질 때까지 값들을 넣으면 완성. while st : lnode.val = st.pop() lnode = lnode.next return head 6. 결과 및 후기, 개선점필요시 c++로 풀어드립니다." }, { "title": "OS복습", "url": "/posts/OSReview/", "categories": "OS", "tags": "OS", "date": "2021-06-23 01:34:50 +0900", "snippet": "OS복습1. 운영체제 ?1. 운영체제의 목적 사용자 편의성 증대(사용자 입장), 컴퓨터 하드웨어 관리(컴퓨터 입장)2. 부팅 과정 CPU에서 ROM을 읽는다. ROM에는 Post(Power of Self-Test), 부트 로더(Boot Loader)가 저장되어 있음. Post는 전원이 켜지면 가장 처음에 실행되는 프로그램, 현재 컴퓨터의 상태를 검사 Boot Loader는 하드디스크에 저장되어 있는 운영체제를 찾아 RAM(메인 메모리)에 가져옴. Post → 부트로더 과정을 부팅 과정이라고 한다.3. 커널, 명령어 해석기 커널은 운영체제의 핵심, 운영체제가 하는 모든 것이 저장되어 있다. 명령어 해석기는 CLI, GUI 같은 운영체제에게 요청하는 명령을 해석하여 커널에 요청하고, 결과값을 출력2. 운영체제 역사 배치 시스템(Batch Processing System)→ CPU가 아무 일도 하지 않는 idle 상태가 나타나면서 비효율적 해결하기 위해 MultiProgramming System이 나옴. 다중 프로그래밍(MultiProgramming)→ CPU가 어떤 프로그램을 선택해야하는 지에 대한 CPU 스케쥴링이 생겨남. 시분할 시스템(Time sharing System) 인터럽트 기반 시스템(Interrupt base System) 하드웨어 인터럽트 → 마우스, 키보드로 발생시키는 인터럽트 소프트웨어 인터럽트 → 직접 명령어를 쳐서 발생시키는 인터럽트 내부 인터럽트 → 프로그램을 수행하다가 발생하는 인터럽트(0으로 나누는 등) 3. 이중 모드와 보호1. 이중모드(Dual Mode) 사용자(User) 모드 - 비트 1, 관리자(Supervisor)모드 = 특권(Privileged)모드 - 비트 02. 하드웨어 보호 입출력 장치 보호, 메모리 보호(MMU가 관리), CPU 보호(독점 보호 - Timer를 두어 인터럽트 발생)4. 운영체제 서비스1. 프로세스 관리(process management) 프로세스 : 실제 메모리에 실행중인 프로그램, 즉 어떠한 요청에 의해 메인 메모리에 할당하여 CPU를 사용하게 되면서 사용되는 프로그램. 프로세스 생성, 소멸, 활동 일시 중지, 활동 재게, 통신, 동기화, 교착상태 처리2. 주기억장치 관리(main memory management) 프로세스에게 메모리공간 할당, 프로세스 추적 및 감시, 메모리 회수, 가상 메모리3. 파일 관리(file management) 파일 생성과 삭제, 디렉토리 생성과 삭제, 백업4. 보조기억장치 관리(Secondary storage management) 빈 공간 관리(Free space management) 저장공간 할당(Storage allocate) 디스크 스케쥴링(Disk schduling)5. 입출력 장치 관리(I/O device management) 장치 드라이브(device drivers) 입출력 장치의 성능 향상(buffing, caching, spooling)6. 시스템 콜(System call) 유저 프로세스에서 운영체제 서비스가 필요로 할 때 이를 받기 위해 사용하는 호출5. 프로세스 관리1. 프로세스 프로세스 상태에는 5가지가 존재한다. New : 프로그램이 메인 메모리에 할당. Ready : 할당된 프로그램이 초기화와 같은 작업을 통해 실행되기 위한 모든 준비를 마침. Running : CPU가 해당 프로세스를 실행 Waiting : 프로세스가 끝나지 않은 시점에서 I/O를 통해 CPU를 사용하지 않고 다른 작업을 한다. Terminated : 프로세스를 완전히 종료한다. PCB(Process Control Block) : 프로세스에 대한 모든 정보가 있다. TCB(Task Control Block)이라고도 함. 프로세스 큐(Process Queue) 에는 3가지 종류가 있다 Job Queue : 하드디스크에 있는 프로그램이 실행되기 위해 메인 메모리 할당순서를 기다리는 큐 Ready Queue : CPU의 점유순서를 기다리는 큐 Device Queue : I/O를 하기 위한 여러장치가 있는데, 각 장치를 기다리는 큐가 각각 존재 2. 멀티 프로그래밍(Multiprogramming) Degree of Multiprogramming : 현재 메모리에 할당되어 있는 프로세스의 개수 I/O bound Process , CPU bound Process : I/O, CPU 작업비중이 높은 프로세스를 말함. Medium - term scheduler : Long term 보다는 짧게 short term 보다는 자주 발생하는 스케쥴 Context-Swtiching : CPU가 한 프로세스에서 다른 프로세스로 옮겨감.6. CPU 스케쥴링1. preemptive vs nonpreemptive 선점, 비선점 / 선점이란 어떤 프로세스가 CPU를 점유하고 있는 동안, 인터럽트, 작업이 끝난 것도 아닌데 다른 프로세스가 해당 프로세스의 CPU를 점유해버림. 비선점이란 프로세스가 실행 → 대기 or 실행 → 종료가 되기 전 까지는 다른 프로세스가 CPU를 점유할 수 없음.2. Scheduling criteria 스케쥴링의 효율을 분석하는 기준들 Cpu utilization(이용률) : CPU가 수행되는 비율 Throughput (처리량) : 단위시간당 처리하는 작업의 수 Turnaroundtime(반환량) : 프로세스가 시작하고 종료될때 까지의 시간, 적을수록 좋다. Wating Time(대기시간) : 프로세스가 Ready queue에서 대기한 시간 Response Time(응답시간) : 대화형 시스템같은 시스템에서 입력에 대한 응답시간 3. Cpu Scheduling Algorithms FCFS(First come First Served) : 선입선저장, Non - preemptive, 이러한 것을 convey effect라고 하는 것 같다. SJF(Shortest-job-First) : 가장 짧은 프로세스 우선처리 → 현실적으로 불가능한 알고리즘 (각 프로세스 처리시간을 알기 힘드므로) preemptive, non preemptive 둘 다 가능하다. Priority : 우선순위가 높은 프로세스 먼저 처리. → 문제점 Starvation 우선순위가 낮은 프로세스는 영영 실행 안 될 가능성이 있음. → 해결방법 aging 너무 오래 기다리면 우선순위를 높여줌. Round Robin(RR) : 한바퀴 돌아가면서 Quantum에 따라 처리 Quantum은 10~100ms를 갖는다. Multilevel Queue : 프로세스는 기준에 따라 여러 그룹으로 나눌 수 있는데 이를 한 큐에 처리하는 것이 아닌 여러 큐로 처리하는 방식 / 큐마다 우선순위 지정 가능. Multilevel Feedback Queue : 위의 방식에서 큐에서 오래기다리면 밑의 큐로 이전, 위의 큐로 이전 하는 방식.7. 쓰레드(Thread)1. 프로세스의 생성과 종료 운영체제가 하는 일 중 하나는 초기 프로세스(init)을 생성한다. 새로운 프로세스를 만드는 시스템콜을 fork()라고 한다. 어떠한 파일을 실행하기 위한 시스템콜을 exec()라고 한다. 어떤 프로세스를 종료시키기 위한 시스템콜을 exit() 라고 한다.2. 쓰레드 프로그램의 내부 흐름 맥int main(){ cout&amp;lt;&amp;lt;&quot;hello&quot;&amp;lt;&amp;lt;&#39;\\n;} 하나의 프로그램에 이러한 맥이 2개 이상 있는 경우를 다중 쓰레드라고 한다. 한 프로그램에서 이러한 쓰레드가 2개 이상 존재할 수 있는 이유는 이러한 쓰레드들이 빠르게 스위칭 되기에 한 동작으로 보이는 착시를 일으키기 때문. 하나의 CPU에서 이러한 스위칭이 나타나는 현상을 concurrent라고 한다. 여러 CPU에서 이러한 스위칭이 나타나는 현상을 simultaneous라고 한다. Context Switching은 프로세스 단위가 아닌 쓰레드 단위.8. 프로세스 동기화 1 Cooperating process : 한 프로세스가 다른 프로세스에게 영향을 주거나 받는 프로세스 Independent process : 영향 안 받음. 데이터 흐름에 대한 동기화(Synchronization)이 중요. Bank Account Problem(은행 계좌 문제) : 공통 변수(잔액 / common variable)을 동시에 제어(concurrent update) 하는 경우 데이터가 다르게 나오는 문제. 공통변수를 관리하는 구역을 임계구역이라고 한다. 임계 구역을 해결하기 위한 3조건 Mutual Exclusion(상호 배타) : 한 쓰레드만 접근 가능하고 다른 쓰레드는 한 쓰레드가 사용하는 동안 접근할 수 없다. Progress(진행) : 한 임계구역을 접근하는 쓰레드를 결정하는 것은 유한시간내에 이루어져야한다. Bounded waiting(유한 대기) : 임계구역으로 들어가기 위해 대기하는 쓰레드들은 유한시간내에 들어갈 수 있어야한다. 세마포어 : 대표적인 동기화 도구 P, V로 나뉨. P : value를 감소시키고 0보다 작아지면 해당 임계구역에 다른 프로세스가 존재한다는 의미이므로 접근하지 못하도록 막는다. V : value를 1증가시키고 0보다 작거나 같으면 임계구역에 접근하려는 프로세스가 큐에 있으므로 꺼내서(wake) 수행한다. 일반적으로 Mutual Exclusion을 위해 사용된다. ordering(실행순서 제어)를 위해서도 사용된다. 9. 프로세스 동기화 21.생성자 소비자 문제 bouned buffer(크기가 정해진 유한 버퍼)에서 생산자와 소비자가 같은 버퍼에 있는 자원(buffer 자체, 데이터 갯수 등)에 접근하면서 동기화 문제가 생긴다. 세마포어로 해결이 가능하지만, busy waitng 문제가 생김. busy waiting이란 생산자가 소비자가 접근하기 전 버퍼가 비어있는 지에 대한 함수. 무한루프구문이라 비효율적이다. 이를 해결하는 것도 세마포어 → full, empty라는 세마포어를 더 둠.2. Readers - writers 문제 데이터베이스는 여러 프로세스가 접근하기 때문에 동기화 문제가 생기는데 이를 방지하고자 Mutual Exclusion을 하면 데이터베이스의 비효율적 문제가 생긴다. 때문에 Reader는 읽기만 하므로 여러 reader프로세스가 접근하는 것은 허용하지만, Writer는 데이터를 수정하므로 Mutual Exclusion을 보장한다. Reader와 Writers가 동시에 들어올 때 알고리즘이 있다. The First R/W problem(Reader 우선순위), The Second R/W problem(Writers 우선순위), The Third R/W problem(우선순위 없음)이 있음.3. Dining Philosopher Problem 식사하는 철학자 문제, 각 테이블에 학자 5명과 젓가락 5개가 있고 식사를 하려면 젓가락 2개가 필요할 때 모든 학자가 식사하려면? 학자가 왼쪽 젓가락과 오른쪽 젓가락을 순서대로 들고 식사를 마치고 똑같은 순서로 젓가락을 놓을 때 해결가능. 하지만 Starvation 문제가 발생. 학자가 동시에 젓가락을 들어버리면 교착상태(DeadLock)상태가 걸려버림.10. 프로세스 동기화 31. 교착상태 필요조건 4가지에 해당된다해서 무조건 교착상태에 걸리는 것은 아니다. Mutual Exclusion(상호 배타) : 한 프로세스가 자원을 사용하고 있으면 다른 프로세스는 접근할 수 없다. Hold and wait(보유 및 대기) : 한 프로세스가 자원을 가지고 있는 상태에서 대기한다. No Preemptive(비선점) : 한 프로세스가 자원을 수행하는 도중에는 다른 프로세스가 끼어들 수 없다. Circular wait(환형대기) : 프로세스가 요구하는 자원의 방향들이 원형을 이룸.2. 교착상태 처리 교착상태 방지(DeadLock prevention) 상호배타를 방지하려면 자원을 공유하게 만들어야하는데 사실상 불가능. 보유 및 대기를 방지하려면 자원을 할당할 수 있는 곳에만 할당하고, 자원을 반납 받음. 하지만, 자원의 활용률을 저하시키고 Starvation을 발생시킬 수 있다. 비선점을 방지하는 것은 사실상 불가능. 환형대기를 방지하기 위해서는 자원에 번호를 붙여 오름차순으로 자원을 할당 등 방법을 사용. 하지만 자원 활용률을 저하시킬 수 있다. 교착상태 회피(DeadLock Avoidance) 교착상태를 자원 요청에 대한 잘못된 승인으로 판단. 안전한 할당(Safe allocation)과 불안전한 할당(Unsafe allcation)- 결국 교착상태에 빠짐이 있다. 교착상태 회피를 Banker’s Algorithms 이라고도 함. 교착상태 검출 및 복구(Dead Lock Detection &amp;amp; Recovery) 주기적으로 교착상태가 발생하였는 지 검사한다. 교착상태 무시 교착상태가 잘 발생하지 않고, 해결하는데 오버헤드가 발생하므로 그냥 교착상태를 무시해버림. 11. 모니터 는 생략. condition queue, mutual exclusion queue 이해.12. 주기억장치 관리 논리주소 : CPU가 사용하는 주소 물리주소 : 실제 메모리에서 사용하는 주소 동적적재 : 프로그램이 실행하는데 반드시 필요한 루틴/자원 적재. 동적연결(DLL) : 여러 프로그램에서 사용되는 공통 라이브러리를 하나의 라이브러리로 메모리에 올림. swap out : 메모리 → Backing store swap in : Backing store → 메모리 메모리에 여러 프로세스를 올리다보면 단편화문제가 생김. 외부 단편화 : 남은 메모리들을 모으면 프로세스를 할당할 수 있는 문제. 메모리 할당방식 First Fit Best Fit : 이 방식을 사용해도 전체 메모리의 1/3 낭비. Worst Fit Compaction : 여러곳에 흩어져 있는 hole을 모으는 방법. 하지만 hole을 옮기는데에 오버헤드가 크고, 옮기는 방식에 대한 최적의 알고리즘이 없음.13. 페이징 Compaction이 사용하기 어렵기에 고려된 방법. 프로세스를 작은 크기로 나눠서 외부 단편화를 해결하려는 방식 프로세스를 나눈 조각을 page, 메모리를 나눈 조각을 frame이라고 한다. cpu가 나눠진 프로세스 조각을 주소변환을 통해 받아 프로세스를 실행한다. 페이징은 내부 단편화 발생. 프로세스의 크기가 프레임의 크기의 배수가 아닐 경우 발생. 마지막 페이지는 마지막 프레임에 전부 채워질 수 없다. 하지만 최악의 경우 페이지의 크기-1 만큼 메모리 낭비가 있고, 이는 무시할 수 있다. 보호와 공유 보호는 페이지테이블에 r,w,x에 대해 비트를 두어 해당 비트가 활성화 되어있는 경우에만 작업이 가능. 활성화 되어 있지 않은데 작업을 하려는 경우 인터럽트. 14. 세그멘테이션페이징은 프로세스를 물리적으로 나누어 작업을 하였지만, 세그멘테이션은 논리적(code+stack +data영역 등)으로 나누어 메모리에 배치. 하지만 현재는 페이징 기법을 많이 쓴다. 이유는 세그멘테이션은 논리적으로 나누기에 크기가 다양하다. 이로인해서 외부 단편화가 발생하기 쉽다. 페이징과 세그멘테이션을 합친 페이징 세그멘테이션 방법이 있지만, CPU → 세그멘테이션 테이블 → 페이징테이블을 거쳐야하는 단점이 존재한다.15. 가상 메모리필요한 부분만 메모리에 올려 적재하여 메모리 낭비를 줄여 실행시키는 방식. 지역성의 원리(Locality of reference) : 메모리 접근은 시간적 지역성과 공간적 지역성으로 나뉨. 시간적 지역성 : CPU는 어느 메모리를 읽은 후 다시 그 메모리를 읽을 확률이 높다는 것. 공간적 지역성 : CPU가 메모리를 읽을 때는 인접한 범위에서 읽는다는 것. (프로그램이 대체로 절차적으로 만들어져 있어서)16. 페이지 교체 알고리즘 FIFO Belody’s anomaly : 프레임 수가 증가하면(메모리가 커지면) page fault 수가 줄어들어야 정상이지만 오히려 커지는 현상. OPT(optimal) : 가장 오래동안 사용되지 않을 페이지를 교체하는 방식이지만 현실적으로 불가능. LRU(Least- Recently - Used) : 최근에 사용되지 않으면 나중에도 사용되지 않을 것을 교체 (대부분 LRU사용.17. 프레임 할당Global Replacement vs Local Replacement : Global은 메모리상의 모든 프로세스에 대해 교체, Local은 메모리상의 자기 자신의 프로세스에 대해 교체 / 일반적으로 Global이 메모리 사용 효율성이 좋음.프레임 할당 쓰레싱(Thrashing) 메모리에 올라가는 프로세스가 많을수록 CPU사용률이 올라가야한다고 생각하지만 일정 범위를 넘어가면 그와 반대로 오히려 사용률이 내려가는 현상. 메모리와 Back Store 사이에서 I/O 작업이 일어나는데, 이는 CPU를 사용하지 않으므로 프로세스가 반복되면 위의 작업이 계속 반복됨. → CPU가 사용되지 않는 경우가 생김. 해결 방법은 2가지 Global 대신 Local Replacement를 쓴다. → 메모리 사용 효율성이 낮아짐. 프로세스당 충분한적절한 프레임을 할당. 이 또한 2가지 할당 방법이 있다. 정적 할당(Static Allocation) : 동일 할당 : 모든 프로세스에 똑같이 할당, 프로세스의 크기가 전부 다르므로 비효율적 / 비례 할당 : 프로세스의 크기에 따라 할당. 프로세스의 크기가 크더라도 전부 사용하지 않으므로 비효율적 동적 할당(Dynamic Allcation) : 실행중에 프레임 할당. 특정 시간대에는 일정 범위의 페이지를 주로 참조한다는 점을 이용. 프로세스를 미리 실행해봐야 안다는 단점 때문에 나온 것이 Working set방식 - 미래가 아닌 과거를 봄 PFF(Page - Fault - Frequency) : 상한선(upper bound)와 하한선(lower bound)를 설정하여, 상한선보다 많은 페이지 부재가 발생하면 프레임 할당을 많이해주고, 하한선보다 적은 페이지 부재가 발생하면 프레임 할당을 줄여줌. 페이지 크기에 따른 성능 내부 단편화 : 내부 단편화를 줄이려면 페이지 크기는 작은 것이 좋다. Page-in, Page-out 시간 : 페이지 크기가 크면 클수록 한 번의 Seektime마다 많은 페이지를 읽을 수 있으므로, 페이지 부재 빈도가 줄어듦. 페이지 테이블 크기 : 페이지 크기가 클수록 페이지의 개수는 줄어드므로, 그만큼 페이지 테이블도 줄일 수 있다. Memeory resolution(해상도) : 메모리에 필요한 데이터가 있을 확률. 페이지 크기가 작을수록 높다. 페이지 크기가 크면 다른 필요없는 부분이 있을 확률이 크기 때문. Page Fault 발생확률 : 발생확률을 줄이려면 페이지의 크기가 큰 것이 좋다. 대부분 프로세스는 일정 범위 이내인 경우가 많으므로 페이지 크기가 크면 필요한 부분이 있을 확률이 높다. 18. 파일 할당 platter: 실제 데이터를 기록하는 자성을 가진 원판이다. platter는 그림과 같이 여러 개가 존재하고 앞뒤로 사용할 수 있다. 한 platter는 여러 개의 track으로 이루어져 있다. track: platter의 동심원을 이루는 하나의 영역이다. sector: 하나의 track을 여러 개로 나눈 영역을 sector라 한다. sector size는 일반적으로 512 bytes이며 주로 여러 개를 묶어서 사용한다. cylinder: 한 cylinder는 모든 platter에서 같은 track 위치의 집합을 말한다앞서 sector는 여러 개로 묶어서 사용한다고 했는데, 이를 블록(block)이라 한다. 하드디스크는 블록 단위로 읽고 쓰기 때문에 block device 라고 불리기도 한다.따라서 디스크는 비어있는 블록들의 집합이라고 볼 수 있다.(pool of free blocks) 그렇다면 운영체제는 각각의 파일에 대해 free block을 어떻게 할당할까?파일 할당 연속 할당(Contiguous Allocation) :장점 : 디스크 헤더의 이동 최소화 → I/O 성능을 높일 수 있다, 순차접근, 직접접근 가능.단점 : 파일을 할당하고 지우고를 반복하다보면 중간 중간에 빈 공간(hole)이 생기는데 연속 할당은 연속된 공간을 찾아야 하기 때문에 이전 메인 메모리 할당에서 살펴본 것과 같이 외부 단편화 문제가 발생한다., 또 다른 문제는 파일을 저장할 때 실제 크기를 알 수 없다. 특히, 계속해서 사용하는 파일의 경우 크기가 계속 증가 할 수 있기 때문에 이를 지속해서 연속적으로 할당하기에는 매우 부적절하다. 연결 할당(Linked Allocation) :장점 : 파일이 커져도 블록을 연결만 해주면 되므로 외부 단편화가 없다.단점 : 순차 접근은 가능하지만, 직접 접근은 불가능. 포인터를 저장하는 4byte이상의 손해 발생. 낮은 신뢰성(링크가 도중에 끊어버리는 경우), 낮은 속도(포인터를 계속 옮기면서 읽는 과정) FAT(File Allocation Table) : 연결 할당의 단점 보완.FAT 시스템은 다음 블록을 가리키는 포인터들만 모아서 하나의 테이블(FAT)을 만들어 한 블록에 저장한다.FAT 시스템을 사용하면 기존의 연결 할당의 문제점 대부분을 해결할 수 있다. FAT를 한 번만 읽으면 직접 접근이 가능하고, FAT만 문제가 없다면 중간 블록에 문제가 생겨도 FAT를 통해 그 다음 블록은 여전히 읽을 수 있다. 그리고 FAT는 일반적으로 메모리 캐싱을 사용하여 블록 위치를 찾는데는 빠르지만 실제 디스크 헤더가 움직는 것은 블록이 흩어져 있으므로 여전히 느리다고 볼 수 있다. 마지막으로 FAT는 매우 중요한 정보이므로 손실 시 복구를 위해 이중 저장을 한다. 색인 할당(indexd Allocation)색인 할당은 인덱스 블록에 할당된 블록을 순서대로 저장하기 때문에 직접 접근이 가능하다. 그리고 연속적으로 할당할 필요가 없으므로 외부 단편화 문제 또한 발생하지 않는다. 색인 할당은 Unix/Linux에서 주로 사용한다.색인 할당의 단점은 작은 크기의 파일인 경우에도 하나의 블록을 인덱스 블록으로 사용하기 때문에 저장 공간이 손실된다. 그리고 하나의 인덱스 블록을 가지고는 크기가 큰 파일을 저장할 수 없다.이를 해결하기 위해 Linked, Multilevel index, 둘을 합친 Combined 방식이 있다. 리눅스는 Combined방식.19. 디스크 스케쥴링디스크에 접근하는 시간은 Seek time(탐색 시간) + rotational delay + transfer time 으로 계산할 수 있는데, 이 중에서 seek time(head를 움직이는 시간)이 가장 크다.디스크 탐색 시간을 줄이기 위한 방법들을 디스크 스케쥴링이라고 한다. FCFS(first Come First Served) : 가장 공평하고 간단한 방법. SSTF(Shortest Seek Time First) : 현재 헤더가 다음 요청을 처리하기 위해 움직여야하는 거리가 가장 짧은 것을 선택. - 최적의 알고리즘 아니다. Scan(헤드가 지속적으로 디스크를 앞뒤로 검사) 1 C-Scan : 한 방향으로만 움직이는 것이 마치 원형과 같다. 움직이는 거리는 더 길어질 수 있지만, 처음 위치로 되돌아갈 때에는 데이터를 읽지 않으므로 더 빠른 속도로 이동가능 2 Look : Scan알고리즘은 한 방향으로 가기에 0번째 실린더까지 이동하는 데 이는 불필요한 이동이다. 최소 범위와 최대 범위를 지정하여 Scan하는 방식을 Look. 참고 : scan예제 3C-Look : Look에서 Circular를 추가한 것으로 위의 Look의 최소, 최대 범위에서 한 방향으로만 이동한다. " }, { "title": "leetcode(리트코드)-1869 Longer Contiguous Segments of Ones than Zeros(python)", "url": "/posts/leetcode_Longer_Contiguous_Segments_of_Ones_than_Zeros/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-06-21 04:34:50 +0900", "snippet": "leetcode 1869 - Longer Contiguous Segments of Ones than Zeros 문제입니다.1. 문제https://leetcode.com/problems/longer-contiguous-segments-of-ones-than-zeros/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 문자열이 들어옵니다. 연속되는 1과 0을 찾아서 그 길이를 얻었을 때 연속되는 1의 최대의 길이가 연속되는 0의 최대의 길이보다 크면 True 아니라면 False를 리턴하세요.5. code코드설명pythonclass Solution: def checkZeroOnes(self, s: str) -&amp;gt; bool: zero = 0 one = 0 count = 0 i = 0 while i &amp;lt; len(s): while i &amp;lt; len(s) and s[i] == &quot;0&quot; : i+=1 count+=1 zero = max(zero,count) count= 0 while i&amp;lt;len(s) and s[i] == &quot;1&quot; : i+=1 count+=1 one = max(one,count) count= 0 return one&amp;gt;zero 6. 결과 및 후기, 개선점필요시 c++로 짜드리겠습니다." }, { "title": "leetcode(리트코드)-1876 Substrings of Size Three with Distinct Characters(python)", "url": "/posts/leetcode_Substrings_of_Size_Three_with_Distinct_Characters/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-06-21 03:34:50 +0900", "snippet": "leetcode 1876 - Substrings of Size Three with Distinct Characters 문제입니다.1. 문제https://leetcode.com/problems/substrings-of-size-three-with-distinct-characters/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 문자열 s가 들어옵니다. 크기가 3인 substring으로 나누었을 때 그 속에 반복되는 문자가 없는 문자열의 개수를 리턴하세요.5. code코드설명pythonclass Solution: def countGoodSubstrings(self, s: str) -&amp;gt; int: ans = 0 for i in range(len(s) - 2) : temp = s[i:i+3] st = set() for j in range(3) : if temp[j] in st : break st.add(temp[j]) if j == 2 : ans+=1 return ans 6. 결과 및 후기, 개선점필요시 c++로 짜드리겠습니다." }, { "title": "leetcode(리트코드)-1893 Check if All the Integers in a Range Are Covered(python)", "url": "/posts/leetcode_Check_if_All_the_Integers_in_a_Range_Are_Covered/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-06-20 03:34:50 +0900", "snippet": "leetcode 1893 - Check if All the Integers in a Range Are Covered 문제입니다.1. 문제https://leetcode.com/problems/check-if-all-the-integers-in-a-range-are-covered/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 ranges라는 범위가 주어집니다. left와 right가 주어질 때 해당 값들 left 2 right 5라면 (2,3,4,5)가 ranges에 포함되면 Truef를 리턴하고, 포함되지 않으면 False를 리턴하세요. input의 크기가 크지 않아서 brute하게 풀 수 있지만, 시간을 아끼기 위한 방법을 고려했습니다. 5. code코드설명pythonclass Solution: def isCovered(self, ranges: List[List[int]], left: int, right: int) -&amp;gt; bool: ranges.sort() num = left for i in range(len(ranges)) : while num &amp;lt;=right and ranges[i][0] &amp;lt;= num and num &amp;lt;= ranges[i][1] : num+=1 if num &amp;gt; right: return True return False 6. 결과 및 후기, 개선점필요시 c++로 짜드리겠습니다." }, { "title": "leetcode(리트코드)-1880 Check if Word Equals Summation of Two Words(python)", "url": "/posts/leetcode_Check_if_Word_Equals_Summation_of_Two_Words/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-06-20 02:34:50 +0900", "snippet": "leetcode 1880 - Check if Word Equals Summation of Two Words 문제입니다.1. 문제https://leetcode.com/problems/check-if-word-equals-summation-of-two-words/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 숫자가 들어있는 정사각형이 주어집니다. 정사각형을 90도씩 돌렸을 때 target과 일치하면 True 아니면 False를 리턴합니다.5. code코드설명pythonclass Solution: def isSumEqual(self, firstWord: str, secondWord: str, targetWord: str) -&amp;gt; bool: firstnum = &quot;&quot; secondnum =&quot;&quot; targetnum = &quot;&quot; for i in range(len(firstWord)): firstnum += str(ord(firstWord[i])-97) for i in range(len(secondWord)): secondnum += str(ord(secondWord[i]) - 97) for i in range(len(targetWord)) : targetnum += str(ord(targetWord[i]) - 97) return int(targetnum) == (int(firstnum) + int(secondnum)) 6. 결과 및 후기, 개선점필요시 c++로 짜드리겠습니다." }, { "title": "leetcode(리트코드)-1897 Redistribute Characters to Make All Strings Equal(python)", "url": "/posts/leetcode_Redistribute_Characters_to_Make_All_Strings_Equal/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-06-20 02:34:50 +0900", "snippet": "leetcode 1897 - Redistribute Characters to Make All Strings Equal 문제입니다.1. 문제https://leetcode.com/problems/redistribute-characters-to-make-all-strings-equal/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 문자열을 가진 배열이 들어옵니다. 어느 문자열로 골라도 다른 문자열과 같게 만들어야합니다. 에제에서 “aabc” 와 “bc”는 “abc”와 같게 만드려면 첫 문자열의 ‘a’를 “bc”의 앞에 가져다 놓으면 배열의 모든 문자열이 같게 됩니다.5. code코드설명pythonclass Solution: def makeEqual(self, words: List[str]) -&amp;gt; bool: chrli = [0] * 26 maxnum = 0 size = len(words) if size == 1 : return True for i in range(size): for j in range(len(words[i])): chrli[ord(words[i][j]) - 97]+=1 for i in range(len(chrli)): if chrli[i] != 0 and chrli[i] % size !=0 : return False return True 6. 결과 및 후기, 개선점필요시 c++로 짜드리겠습니다." }, { "title": "leetcode(리트코드)-1886 Determine Whether Matrix Can Be Obtained By Rotation Equal(python)", "url": "/posts/leetcode_Determine_Whether_Matrix_Can_Be_Obtained_By_Rotation/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-06-20 01:34:50 +0900", "snippet": "leetcode 1886 - Determine Whether Matrix Can Be Obtained By Rotation 문제입니다.1. 문제https://leetcode.com/problems/determine-whether-matrix-can-be-obtained-by-rotation/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 숫자가 들어있는 정사각형이 주어집니다. 정사각형을 90도씩 돌렸을 때 target과 일치하면 True 아니면 False를 리턴합니다.5. code코드설명pythonclass Solution: def findRotation(self, mat: List[List[int]], target: List[List[int]]) -&amp;gt; bool: def rotate(mat): new = copy.deepcopy(mat) for i in range(len(mat)): for j in range(len(mat[i])): new[j][len(mat[i]) - i - 1] = mat[i][j] return new for i in range(4): if mat == target : return True mat = rotate(mat) return False 6. 결과 및 후기, 개선점필요시 c++로 짜드리겠습니다." }, { "title": "leetcode(리트코드)-1903 Largest Odd Number in String(python)", "url": "/posts/leetcode_Largest_Odd_Number_in_String/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-06-20 01:34:50 +0900", "snippet": "leetcode 1903 - Largest Odd Number in String 문제입니다.1. 문제https://leetcode.com/problems/largest-odd-number-in-string/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 문자열로 숫자가 들어옵니다. 각 substring에서 가장 길고 홀수인 substring을 찾아 리턴하세요.5. code코드설명pythonclass Solution: def largestOddNumber(self, num: str) -&amp;gt; str: for i in range(len(num)-1, -1, -1): if int(num[i]) % 2 == 1 : return num[0:i+1] return &quot;&quot; 6. 결과 및 후기, 개선점필요시 c++로 짜드리겠습니다." }, { "title": "leetcode(리트코드)-205 Isomorphic Strings(python)", "url": "/posts/leetcode_Isomorphic_Strings/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-06-18 01:34:50 +0900", "snippet": "leetcode 205 - Isomorphic Strings 문제입니다.1. 문제https://leetcode.com/problems/isomorphic-strings/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 s의 패턴과 t의 패턴이 같으면 True를 리턴 다르면 False를 리턴합니다. 각 문자는 1:1로 매칭되어야하므로 dic자료구조를 이용해서 저장시켜줍니다. 만약 이미 저장되었으면 하나의 리스트에서 검사를 해서 False를 리턴해줄 수 있도록 합니다.5. code코드설명pythonclass Solution: def isIsomorphic(self, s: str, t: str) -&amp;gt; bool: dic = {} #150은 아스키코드 갯수. 이미 들어와있는데 dic에 추가하면 False를 리턴 check = [False] * 150 for i in range(len(s)): if s[i] not in dic : if check[ord(t[i])] == True: return False dic[s[i]] = t[i] check[ord(t[i])] = True else : if dic[s[i]] != t[i]: return False return True 6. 결과 및 후기, 개선점필요시 c++로 짜드리겠습니다." }, { "title": "Programmers_연습문제 하노이 탑(python)", "url": "/posts/Programmers_Hanoi_top/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-06-16 02:34:40 +0900", "snippet": "프로그래머스 -하노이 탑 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/129462. 분류 및 난이도Programmers 문제입니다.연습문제 문제입니다.Level 3난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 하노이탑은 유명하여 자세하게 설명이 나온 내용들이 많으므로 생략하겠습니다.참고 : https://shoark7.github.io/programming/algorithm/tower-of-hanoi4. 접근 방법을 적용한 코드def hanoi(n,start,end,between,answer) : if n == 1: answer.append([start,end]) else : hanoi(n-1,start,between,end,answer) answer.append([start,end]) hanoi(n-1,between,end,start,answer)def solution(n): answer = [] hanoi(n,1,3,2,answer) return answer5. 결과필요시. c++ 짜드리겠습니다. 설명이 필요시 댓글달아주세요." }, { "title": "leetcode(리트코드)-203 Remove Linked List Elements(python)", "url": "/posts/leetcode_Remove_Linked_List_Elements/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-06-16 01:34:50 +0900", "snippet": "leetcode 203 - Remove Linked List Elements 문제입니다.1. 문제https://leetcode.com/problems/remove-linked-list-elements/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 링크드 리스트가 주어지는데, val로 들어온 값을 제거한 링크드 리스트를 리턴하세요.5. code코드설명python# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def removeElements(self, head: ListNode, val: int) -&amp;gt; ListNode: def solve(head,val): #범위를 벗어나지 않게. if head and head.next : if head.next.val == val : if head.next.next == None : head.next = None else: head.next = head.next.next solve(head,val) else : solve(head.next,val) #처음 들어온 값들이 val과 같은 값인 경우. while head and head.val == val : head = head.next res = head solve(head,val) return res 6. 결과 및 후기, 개선점필요시 c++로 짜드리겠습니다." }, { "title": "leetcode(리트코드)6월15일 challenge473-Matchsticks to Square(python)", "url": "/posts/leetcode_Matchsticks_to_Square/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-06-15 04:01:56 +0900", "snippet": "leetcode June 15일 - Matchsticks to Square 문제입니다.1. 문제https://leetcode.com/problems/matchsticks-to-square/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.6월 15일자 챌린지 문제입니다.4. 문제 해석 리스트로 값들이 주어집니다. 해당 값들을 이용해서 각 길이가 같은 정사각형을 만들 수 있으면 True 없으면 False를 리턴하세요. discuss의 도움을 받아 DFS로 풀었습니다. 값을 돌면서 matchsticks의 target의 값을 갱신해줍니다. 5. codepythonclass Solution: def makesquare(self, matchsticks: List[int]) -&amp;gt; bool: sumnum = sum(matchsticks) if sumnum%4 !=0: return False target = [sumnum//4] * 4 matchsticks.sort(reverse = True) def bfs(num,depth,target) : if depth == len(num) : return True for i in range(4): if target[i] &amp;gt;= num[depth] : target[i] -= num[depth] if bfs(num,depth+1,target) : return True target[i] += num[depth] return False return bfs(matchsticks,0,target)6. 결과 및 후기, 개선점필요시 c++로 풀어드립니다." }, { "title": "Programmers_월간 코드 챌린지 시즌2 110 옮기기(python)", "url": "/posts/Programmers_replace_110/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-06-15 03:34:40 +0900", "snippet": "프로그래머스 -110 옮기기 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/778862. 분류 및 난이도Programmers 문제입니다.월간 코드 챌린지 시즌2 문제입니다.Level 3난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 문제는 직관적이나 효율성을 많이 따지는 문제입니다. 맨 처음 생각한 것은 110을 찾아서 그 앞에서 1이 끝나는 시점에 넣어주는 것입니다. 넣어준 곳을 기준으로 다시 110을 찾고 맨 끝까지 도달하거나 110을 찾을 수 없으면 반복문을 벗어납니다. 예제는 위와같은 방법으로 해결할 수 있으나 다른 예제들이 틀려서 접근 방법이 틀렸습니다. 위 방법으로 해결해본 코드def findone(s,idx): while idx &amp;gt;= 0 and s[idx] == &quot;1&quot;: idx-=1 return idxdef solution(s): answer = [] for word in s : idx = word.find(&quot;110&quot;) while idx &amp;lt; len(word) and word.find(&quot;110&quot;,idx,len(word)) != -1 : idx = word.find(&quot;110&quot;,idx,len(word)) findnum = findone(word,idx) print(&quot;~findnum&quot;,word[:findnum+1], &quot;findnum ~idx&quot;,word[findnum+1:idx], &quot;idx~&quot;,word[idx+3:]) word = word[:findnum+1] + &quot;110&quot; + word[findnum+1 : idx] + word[idx+3 :] print(&quot;findnum : &quot;,findnum, &quot;idx : &quot;,idx,&quot;res : &quot;,word) idx = findnum + 3 answer.append(word) return answer 질문하기 게시판에서 힌트를 얻었습니다. 먼저 “110”을 다 빼줍니다. 그 후 남은 문자열에 “11”을 찾고 그 앞에 전부 넣거나 없으면 “0”을 찾아 그 뒤에 다 넣습니다. 이 부분이 보기에는 쉬우나 효율성 부분에서 많이 틀렸습니다. python의 replace()함수로 “110”을 ““으로 바꾸는 것도 효율성에서 탈락했습니다. 또한, 문자열이 땡겨지면서 새로 생긴 “110”을 고려해줘야합니다. 문자열을 합치는 것도 효율성에서 틀립니다. s[:idx] + s[idx+3:]이런 식의 코드는 틀립니다. #초기 check는 1 while check : check = word.count(&quot;110&quot;) count+=check word = word.replace(&quot;110&quot;,&quot;&quot;,check) #뻑납니다. 많은 고민을 하고, 문자열을 stack처럼 생각하여 사용하였습니다. 문자열을 돌면서 임시 문자열에 저장하다가 “0”이 나오면 앞의 두 값이 “11”일 경우 임시 문자열의 “11”을 없애주고 count를 갱신해줍니다. 4. 접근 방법을 적용한 코드def solution(s): answer = [] for word in s : count=0 st = &quot;&quot; for i in range(len(word)): #만약 st에 쌓은 것 앞의 2개가 &quot;11&quot;일 경우 count를 갱신해주고, st도 빼줍니다. if word[i] ==&quot;0&quot; and st[-2:] == &quot;11&quot;: st = st[:-2] count+=1 else : st += word[i] idx = st.find(&quot;11&quot;) #&quot;11&quot;을 찾고 있으면 그 다음 인덱스에 다 넣습니다. #없으면 rfind(뒤에서 0을 찾아)그 앞에 다 넣습니다. if idx == -1: idx2 = st.rfind(&quot;0&quot;) st = st[:idx2+1] + &quot;110&quot; * count + st[idx2+1:] else : st = st[:idx] + &quot;110&quot; * count +st[idx:] answer.append(st) return answer5. 결과필요시. c++ 짜드리겠습니다. 설명이 필요시 댓글달아주세요." }, { "title": "leetcode(리트코드)-395 Longest Substring with At Least K Repeating Characters(python)", "url": "/posts/leetcode_Longest_Substring_with_At_Least_K_Repeating_Characters/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-06-15 02:34:50 +0900", "snippet": "leetcode 175 - Longest Substring with At Least K Repeating Characters 문제입니다.1. 문제https://leetcode.com/problems/longest-substring-with-at-least-k-repeating-characters/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.4. 문제 해석 부분 문자열에서 모든 문자들이 k만큼 반복되거나 커야합니다. 해당 부분 문자열 중에서 가장 긴 값을 리턴하세요.5. code코드설명pythonclass Solution: def longestSubstring(self, s: str, k: int) -&amp;gt; int: if len(s) == 0 or k &amp;gt; len(s) : return 0 if k ==0 : return len(s) #기존 코드 효율성 있게 바꾸기. &#39;&#39;&#39; dic = {} for i in range(len(s)): if s[i] not in dic : dic[s[i]] = 1 else: dic[s[i]] += 1 idx = 0 while idx &amp;lt; len(s) and dic[s[idx]] &amp;gt;=k : idx+=1 &#39;&#39;&#39; idx = 0 while idx &amp;lt; len(s) and s.count(s[idx]) &amp;gt;=k : idx+=1 if idx == len(s): return len(s) left = self.longestSubstring(s[:idx],k) right = self.longestSubstring(s[idx+1:],k) return max(left,right) 6. 결과 및 후기, 개선점필요시 c++로 짜드리겠습니다." }, { "title": "leetcode(리트코드)-168 Excel Sheet Column Title(python)", "url": "/posts/leetcode_Excel_Sheet_Column_Title/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-06-15 01:34:50 +0900", "snippet": "leetcode 168 - Excel Sheet Column Title 문제입니다.1. 문제https://leetcode.com/problems/excel-sheet-column-title/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 숫자가 들어오면 Excel에서의 행과 열의 값을 구해 리턴하세요.5. code코드설명pythonclass Solution: def convertToTitle(self, columnNumber: int) -&amp;gt; str: dic = {} res = &quot;&quot; for i in range(26): #숫자를 아스키코드로 변환 asc = chr(i+65) dic[i+1] = asc while columnNumber : temp = columnNumber%26 if temp == 0 : res+=&quot;Z&quot; if columnNumber == 26 : break else: res += dic[temp] #나누어 떨어지는 경우를 고려 columnNumber = (columnNumber-1)//26 return res[::-1] 6. 결과 및 후기, 개선점필요시 c++로 짜드리겠습니다." }, { "title": "leetcode(리트코드)6월14일 challenge1710-Maximum Units on a Truck(python)", "url": "/posts/leetcode_Maximum_Units_on_a_Truck/", "categories": "leetcode, Eazy", "tags": "leetcode, AlgorithmStudy", "date": "2021-06-14 02:01:56 +0900", "snippet": "leetcode June 14일 - Maximum Units on a Truck 문제입니다.1. 문제https://leetcode.com/problems/maximum-units-on-a-truck/2. Input , Output3. 분류 및 난이도Eazy 난이도입니다.6월 14일자 챌린지 문제입니다.4. 문제 해석 리스트에 두 가지 값이 들어옵니다. 첫 번째 값은 박스의 갯수입니다. 두 번째 값은 박스안에 들어있는 unit의 갯수입니다. trucksize만큼 박스를 실을 때 최대가 되는 unit의 갯수를 리턴하세요.5. codepythonclass Solution: def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -&amp;gt; int: boxTypes.sort(key = lambda x :x[1],reverse = True) res = 0 for nob,noupb in boxTypes: if truckSize &amp;lt; nob : res += truckSize * noupb return res else: res += (noupb * nob) truckSize -= nob return res 6. 결과 및 후기, 개선점필요시 c++로 풀어드립니다." }, { "title": "Programmers_2018 KAKAO BLIND RECRUITMENT [1차] 추석 트래픽(python)", "url": "/posts/Programmers_Traffic_of_chuseok/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-06-14 01:34:40 +0900", "snippet": "프로그래머스 -추석 트래픽 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/176762. 분류 및 난이도Programmers 문제입니다.KAKAO BLIND RECRUITMENT(2018) - [1차] 문제입니다.Level 3난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 처음 풀어본 KAKAO LEVEL3문제입니다. python의 datetime 라이브러리를 사용하였습니다. 구간 설정 하는데에 시간을 많이 썼는데 결과적으로 모든 line을 돌면서 line마다의 끝 시간 + 1초 구간을 정해 카운트를 세줘야합니다. 예제 2에서 힌트를 얻었는데, 왜 인지는 모르겠습니다. 문제에서 1초는 시작 시간과 끝 시간을 포함합니다. 즉 5초의 1초는 5:000s ~ 5.999s입니다.4. 접근 방법을 적용한 코드# 자료구조 꺼내를 빠르게 하기 위함.from collections import deque# datetime은 시간라이브러리, timedelta는 시간 연산을 위한 라이브러리 같습니다.from datetime import datetime,timedeltadef solution(lines): answer = 0 dq = [] # compare은 가장 빨리 끝나는 line을 저장합니다. compare = datetime(2018,1,1,1,1,1) # last는 가장 늦게 끝나는 line을 저장합니다. last = datetime(2014,1,1,1,1,1) # line을 돌면서 시간에 대해 전처리를 해준 뒤 리스트에 넣습니다. for i in range(len(lines)): # &quot;-&quot;로 먼저 구분합니다. year,mon,day = lines[i].split(&quot;-&quot;) day,mod,query = day.split(&quot; &quot;) # 끝의 s를 제거 query = query[:-1] querys = query.split(&quot;.&quot;) queryms = 0 # 2.0s와 2s를 동일하게 여겨야합니다. 또한, 2.321s같이 들어올 경우 마이크로 초를 구분해줘야합니다. # 연산이 이렇게 되는 이유는 기본적으로 timedate에서 제공하는 microseconds의 범위는 0 ~ 100000입니다. 문제에서는 소수점 3자리까지만 나타내므로 전처리를 해줘야합니다. if len(querys) &amp;gt; 1 : queryms = int(querys[1]) * 1000000 //(10**len(querys[1])) querys = int(querys[0]) h,m,s = mod.split(&quot;:&quot;) s,ss = s.split(&quot;.&quot;) # end는 line으로 들어온 값입니다. end = datetime(int(year),int(mon),int(day),int(h),int(m),int(s),int(ss)*1000) # 제일 늦게끝난 것은 last에 빨리 끝난 것은 compare에 저장합니다. if end &amp;gt; last : last = end if compare &amp;gt; end : compare =end # start는 위에서 전처리해준 T값을 빼준 시간입니다. start = end - timedelta(seconds = querys, microseconds = queryms) + timedelta(microseconds=1000) # 리스트에 넣습니다. dq.append((start,end)) # 리스트를 돌 것인데, 정렬되어있지 않으므로 전부 두 번씩 돌아줍니다. for s,e in dq : count = 0 compare = e for s,e in dq : # 만약 범위를 벗어났으면 continue합니다. if compare &amp;gt; e or compare + timedelta(microseconds = 999000) &amp;lt; s: continue else: count+=1 answer = max(answer,count) return answer5. 결과필요시. c++ 짜드리겠습니다. 설명이 필요시 댓글달아주세요." }, { "title": "leetcode(리트코드)6월10일 challenge729-My Calendar I(python)", "url": "/posts/leetcode_My_Calendar_I/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-06-11 01:01:56 +0900", "snippet": "leetcode June 10일 - My Calendar I 문제입니다.1. 문제https://leetcode.com/problems/my-calendar-i/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.6월 10일자 챌린지 문제입니다.4. 문제 해석 도서관 대여시스템을 생각하면 됩니다. start와 end까지 누군가 빌렸다고 생각하고 새로운 start와 end가 들어왔을 때 이미 빌린 시점이라면 False 아니라면 True를 리턴합니다.5. codepythonclass MyCalendar: def __init__(self): self.dq = [] def book(self, start: int, end: int) -&amp;gt; bool: for s,e in self.dq : if start &amp;lt; e and end &amp;gt; s : return False self.dq.append([start,end]) return True# Your MyCalendar object will be instantiated and called as such:# obj = MyCalendar()# param_1 = obj.book(start,end)6. 결과 및 후기, 개선점필요시 c++로 풀어드립니다." }, { "title": "leetcode(리트코드)-167 Two Sum II Input array is sorted(python)", "url": "/posts/leetcode_Two_Sum-II_-_Input_array_is_sorted/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-06-08 01:34:50 +0900", "snippet": "leetcode 167 - Two Sum II input array is sorted 문제입니다.1. 문제https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 배열의 요소 2개를 뽑아내서 target을 만들어낼 수 있습니다. 그 2 요소의 인덱스를 리턴하세요.5. code코드설명pythonclass Solution: def twoSum(self, numbers: List[int], target: int) -&amp;gt; List[int]: dic = {} for i in range(len(numbers)): if target - numbers[i] in dic : return [dic[target - numbers[i]],i+1] else: dic[numbers[i]] = i+16. 결과 및 후기, 개선점필요시 c++로 짜드리겠습니다." }, { "title": "leetcode(리트코드)6월07일 challenge746-Min Cost Climbing Stairs(python)", "url": "/posts/leetcode_Min_Cost_Climbing_Stairs/", "categories": "leetcode, Eazy", "tags": "leetcode, AlgorithmStudy", "date": "2021-06-07 01:01:56 +0900", "snippet": "leetcode June 07일 - Min Cost Climbing Stairs 문제입니다.1. 문제https://leetcode.com/problems/min-cost-climbing-stairs/2. Input , Output3. 분류 및 난이도Eazy 난이도입니다.6월 07일자 챌린지 문제입니다.4. 문제 해석 비용(Cost)가 주어집니다. 해당 칸에 도착했을 때 비용을 지불하고 계단을 1이나 2씩 오를 수 있습니다. 위와 같은 방식으로 계단을 오를 때 최소환의 비용을 리턴하세요.5. codepythonclass Solution: def minCostClimbingStairs(self, cost: List[int]) -&amp;gt; int: cost.append(0) res = [0] * (len(cost)) res[0] = cost[0] res[1] = cost[1] for i in range(2,len(cost)): res[i] = min(res[i-2] + cost[i], res[i-1] + cost[i]) return res[len(res)-1] 6. 결과 및 후기, 개선점필요시 c++로 풀어드립니다." }, { "title": "Programmers_Summer/Winter Coding(~2018) 스티커 모으기2(python)", "url": "/posts/Programmers_gather_sticker/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-06-06 02:34:40 +0900", "snippet": "프로그래머스 -스티커 모으기2 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/129712. 분류 및 난이도Programmers 문제입니다.Summer/Winter Coding(~2018) 문제입니다.Level 3난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 똑같은 문제가 프로그래머스에 있습니다. DP04 연습문제입니다. DP04 연습문제는 Level이 4인데 왜 이건 3인지..?https://kkminseok.github.io/posts/Programmers_DP04/4. 접근 방법을 적용한 코드def solution(sticker): size = len(sticker) if size ==1 : return sticker[0] #처음 스티커를 떼어냄. first = [0] * size #두 번째 스티커를 떼어냄. second = [0] * size first[1] = first[0] = sticker[0] second[0] = 0 second[1] = sticker[1] for i in range(2,size) : if i != size-1 : first[i] = max(first[i-2] + sticker[i], first[i-1]) second[i] = max(second[i-2]+sticker[i],second[i-1]) return max(first[size-2], second[size-1])5. 결과필요시. c++ 짜드리겠습니다. 설명이 필요시 댓글달아주세요." }, { "title": "leetcode(리트코드)6월06일 challenge128-Longest Consecutive Sequience(python)", "url": "/posts/leetcode_Longest_Consecutive_Sequenced/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-06-06 01:01:56 +0900", "snippet": "leetcode June 06일 - Longest Consecutive Sequience 문제입니다.1. 문제https://leetcode.com/problems/longest-consecutive-sequence/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.6월 06일자 챌린지 문제입니다.4. 문제 해석 부분 문자열을 합쳐서 가장 긴 연속된(1,2,3,4 … 이런 식) 문자열의 길이를 리턴하세요.5. codepythonclass Solution: def longestConsecutive(self, nums: List[int]) -&amp;gt; int: if len(nums) == 0: return 0 nums.sort() res = 0 count = 1 print(nums) for i in range(len(nums)-1): if nums[i] == nums[i+1]: continue if nums[i]+1 == nums[i+1] : count+=1 else : res = max(res,count) count=1 return max(res,count)6. 결과 및 후기, 개선점필요시 c++로 풀어드립니다." }, { "title": "Programmers_Summer/Winter Coding(~2018) 숫자 게임(python)", "url": "/posts/Programmers_int_game/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-06-05 02:34:40 +0900", "snippet": "프로그래머스 -숫자 게임 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/129872. 분류 및 난이도Programmers 문제입니다.Summer/Winter Coding(~2018) 문제입니다.Level 3난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) B입장에서 가장 기분 좋은 승리는 무엇일까?를 생각해봤습니다. B입장에서 가장 기분 좋게 승리하는 방법은 A낸 카드에서 제일 근소한 차이를 내며 이기는 방법이 좋은 승리라고 생각했습니다. 예를 들어서 A가 [1,3,5,7]를 들고 있고 B가 [8,6,4,2]를 들고 있으면 [2,4,6,8]로 가장 근소한 차이로 승점을 4개를 챙길 수 있습니다. 이러한 방식을 대입하려면 A와 B를 정렬해야한다고 생각했습니다.(문제에서 어차피 A의 패를 알고 B는 그에 맞춰 내기 때문에 순서는 상관없음.) 근데 만약 [1,3,5,7]를 들고 있는데, B가 [2,2,6,8] 이렇게 들고 있으면 어떻게해야할까? 간단합니다. 문제가 되는 두 번째 [2] 카드를 그냥 버리고 6을 내면 됩니다. 앞에서 지나 뒤에서 지나 똑같기 때문입니다.4. 접근 방법을 적용한 코드def solution(A, B): answer = 0 A.sort() B.sort() Aidx = 0 Bidx = 0 #A의 끝을 보면 A를 다 이긴 것이고, B의 끝을 보면 B에서 더 이상 이길 수 있는 카드가 없다는 것입니다. while Aidx &amp;lt; len(A) and Bidx &amp;lt; len(B) : if A[Aidx] &amp;lt;B[Bidx] : answer+=1 Aidx +=1 Bidx+=1 #이기는 카드를 찾을 때 까지. else : Bidx+=1 return answer5. 결과필요시. c++ 짜드리겠습니다. 설명이 필요시 댓글달아주세요." }, { "title": "Programmers_Summer/Winter Coding(~2018) 기지국 설치(python)", "url": "/posts/Programmers_stations_install/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-06-05 01:34:40 +0900", "snippet": "프로그래머스 -기지국 설치 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/12979#2. 분류 및 난이도Programmers 문제입니다.Summer/Winter Coding(~2018) 문제입니다.Level 3난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) brute하게 접근하면 당연히 시간초과가 뜰 것이라고 생각했습니다.(N이 최대 2억까지 들어옴.) 결국 최소한으로 기지국을 설치하려면 최대한 넓은 영역에 신호가 미치도록 설치해야하는 것은 맞습니다. 이 부분에서 설치할 기지국은 (남은 영역) / (전파가 영향을 끼치는 영역)으로 구할 수 있습니다. 그 영역들은 이전 stations의 +w 그 다음 stations의 -w의 차이가 남은 영역입니다. 예제 1에서 stations가[4,11] 으로 (4+1) 과 (11-1)인 5 부터 10까지가 빈 영역입니다. 조심해야할 것은 10-5해서 5가 빈 영역이 아닌 10-5-1인 4가 빈 영역입니다. (범위에 10과 5가 둘 다 포함되어 있으므로) 마찬가지로 가장 처음 기지국을 설치할 영역과 마지막에 기지국을 설치할 영역을 따로 구해주면 풀 수 있습니다.(배열안에 마지막(N)과 처음(1)이 없으므로)4. 접근 방법을 적용한 코드def solution(n, stations, w): answer = 0 #기지국이 전파를 미치는 영향 예제 1 기준 3 / 2 기준 5 area = w*2 +1 #처음 check = stations[0] - w # 만약 뺀 값이 범위를 벗어나면 skip을 하고 아니면 계산해줍니다. if check &amp;gt;1 : #영역이 1부터 시작하므로 check-1을 해줍니다. answer += (check -1 ) // area # 나머지가 있다면 어찌되었든 기지국 1개를 설치해야합니다. if (check-1) %area != 0 : answer+=1 #기지국 정보에 따른 값을 수정합니다. for i in range(len(stations)-1): #빈 영역 계산 1을 빼주는 이유는 설명에서 말했습니다. check = (stations[i+1]-w) - (stations[i]+w)-1 #인접하거나 겹치는 경우 skip합니다. if check &amp;lt;= 0 : continue else : answer += (check) // area if check %area!=0: answer+=1 #끝 부분 check = stations[len(stations)-1] + w #끝의 기지국의 영향이 n을 넘어가면 skip합니다. if check &amp;lt;n : answer += (n - check) // area if (n-check) % area != 0 : answer +=1 return answer5. 결과필요시. c++ 짜드리겠습니다. 설명이 필요시 댓글달아주세요." }, { "title": "leetcode(리트코드)6월04일 challenge752-Open the Lock(python)", "url": "/posts/leetcode_Open_the_Lock/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-06-04 06:01:56 +0900", "snippet": "leetcode June 04일 - Open the Lock 문제입니다.1. 문제https://leetcode.com/problems/open-the-lock/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.6월 04일자 챌린지 문제입니다.4. 문제 해석 초기값이 ‘0000’인 슬롯이 있습니다. 해당 슬롯을 위아래(0인 경우 9가 아래 9인 경우 0이 위)로 움직여서 target을 만들어야합니다. deadends는 슬롯이 해당 숫자에 도달하면 더 이상 작동하지 않기에 해당 값에 도달하지 않도록 해야합니다. 만들 수 없으면 -1을 리턴하고 만들 수 있다면 최소값을 리턴하세요.5. codepythonclass Solution: def openLock(self, deadends: List[str], target: str) -&amp;gt; int: #BFS deadset = set(deadends) #방문처리 v = set(&#39;0000&#39;) dq = deque([(&#39;0000&#39;,0)]) while dq : slot,counting = dq.popleft() if slot == target : return counting elif slot in deadset : continue for i in range(4) : digit = int(slot[i]) for move in [-1,1]: #0 - 1 %10은 나머지가 9입니다. 10을 1번 빼주고 (-10)에서 -1이 되려면 나머지 9를 더해야하기 때문입니다. newdigit = (digit + move)%10 newslot = slot[:i] + str(newdigit) + slot[i+1:] #방문처리 if newslot not in v: v.add(newslot) dq.append((newslot,counting+1)) return -1 6. 결과 및 후기, 개선점필요시 c++로 풀어드립니다." }, { "title": "leetcode(리트코드)-162 Find Peak Element(python)", "url": "/posts/leetcode_Find_Peak_Element/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Interview", "date": "2021-06-04 05:34:50 +0900", "snippet": "leetcode 162 - Find Peak Element 문제입니다.1. 문제https://leetcode.com/problems/find-peak-element/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.4. 문제 해석 인덱스를 기준으로 그 왼쪽값, 오른쪽값 보다 큰 인덱스를 찾아 리턴합니다. 양쪽 끝의 그 왼쪽, 오른쪽값은 (-무한대)라고 가정합니다. 무조건 중간값을 기준으로 한쪽은 결과가 나올 수 밖에 없습니다.(증명은 못하겠습니다. 반례가 나오지 않음.)5. code코드설명pythonclass Solution: def findPeakElement(self, nums: List[int]) -&amp;gt; int: def binary(left,right,nums): if left == right : return left mid = (left + right) //2 mid2 = mid+1 if nums[mid] &amp;gt; nums[mid2] : return binary(left,mid,nums) else : return binary(mid2,right,nums) return binary(0,len(nums)-1,nums)6. 결과 및 후기, 개선점필요시 c++로 짜드리겠습니다." }, { "title": "leetcode(리트코드)-119 Pascal&#39;s Triangle II(python)", "url": "/posts/leetcode_Pascal's_Triangle_II/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-06-04 04:34:50 +0900", "snippet": "leetcode 119 - Pascal’s Triangle II 문제입니다.1. 문제https://leetcode.com/problems/pascals-triangle-ii/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 파스칼 삼각형을 구현하여, 문제에서 주어진 rowIndex에 해당하는 행의 값들을 리턴합니다.5. code코드설명pythonclass Solution: def getRow(self, rowIndex: int) -&amp;gt; List[int]: DP =[0] * (rowIndex+1) for i in range(len(DP)): DP[i] = [0] * (i+1) DP[0][0] = 1 for i in range(rowIndex+1) : for j in range(i+1) : if j ==0 or j == i : DP[i][j] = 1 else : DP[i][j] = DP[i-1][j-1] + DP[i-1][j] return DP[rowIndex] 6. 결과 및 후기, 개선점필요시 c++로 짜드리겠습니다." }, { "title": "Programmers_월간 코드 챌린지 시즌1 풍선 터트리기(python)", "url": "/posts/Programmers_pop_ballon/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-06-04 03:34:40 +0900", "snippet": "프로그래머스 -풍선 터트리기 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/686462. 분류 및 난이도Programmers 문제입니다.월간 코드 챌린지 시즌1 문제입니다.Level 3난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) a의 길이가 최대 백만이 들어오므로 brute하게 풀면 시간초과가 뜹니다. 기준 값을 중심으로 한쪽에 있는 배열중 가장 작은 값이 기준값보다 크면 다른 한쪽에 있는 배열중 가장 작은 값은 기준값보다 커야합니다. 이유는 토너먼트 방식으로 기준값의 왼쪽 배열, 오른쪽 배열 풍선 1개씩 남겨둘 수 있는데, 그 중 하나가 기준 값보다 작으면 문제에서 나온 대로 작은 값을 없애버릴 수 있지만 만약 둘 다 작은 경우(기준값이 두 값보다 큰 경우) 풍선을 터트릴 수 없게됩니다. 매 번 왼쪽 배열의 최소값, 오른쪽 배열의 최소값을 직접 구하면 시간초과가 뜨기에 오른쪽 배열의 최소값들은 따로 리스트에 저장해두었습니다. 위와 같은 방식으로 맨앞 경우 오른쪽 배열에서 가장 작은 값, 맨 뒤 경우 왼쪽 배열에서 가장 작은값만 남기는데, 그 값이 기준 값보다 커도 상관 없고, 작아도 상관없기에(작은 값을 지워버림.) a의 길이가 2보다 크거나 같다면 기본 return값은 2가 됩니다.4. 접근 방법을 적용한 코드def solution(a): answer = 1 #a의 길이가 1인 경우 if len(a) == 1: return 1 #아닌 경우 default는 2 answer+=1 #right는 기준 값을 기준으로 오른쪽 배열에서 가장 작은 값들을 저장해놓은 리스트입니다. right = [0]* len(a) #초기값 설정 rightmin = a[len(a)-1] #리스트를 돌면서 초기화 for i in range(len(a)-2,0,-1) : right[i] = rightmin if rightmin &amp;gt; a[i]: rightmin = a[i] #왼쪽배열중 가장 작은 값 초기화 leftmin = a[0] #맨 왼쪽과 맨 오른쪽은 제외 for i in range(1,len(a)-1) : #만약 맨왼쪽의 최소값보다 작은 값이 나타난 경우 갱신 if leftmin &amp;gt; a[i-1] : leftmin = a[i-1] # 기준값이 최소값들보다 큰 경우 skip if leftmin &amp;lt; a[i] and right[i] &amp;lt; a[i] : continue answer+=1 return answer5. 결과필요시. c++ 짜드리겠습니다. 설명이 필요시 댓글달아주세요." }, { "title": "Programmers_연습문제 단어 변환(python)", "url": "/posts/Programmers_convert_string/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-06-04 02:34:40 +0900", "snippet": "프로그래머스 -단어 변환 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/431632. 분류 및 난이도Programmers 문제입니다.연습문제 문제입니다.Level 3난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 어렵지 않은 DFS문제입니다.4. 접근 방법을 적용한 코드# 문자와 문자가 1개만큼 차이나는 지 확인하는 함수def searchword(begin,target): counting = 0 for i in range(len(begin)): if begin[i] != target[i]: counting+=1 if counting &amp;gt;1 : return False return Truedef DFS(begin,target,words,v,count,res) : if begin == target : res.append(count) for i in range(len(words)): #방문한 적이 없고 문자와 문자 차이가 1일 때 if v[i] == 0 and searchword(begin,words[i]) : v[i] = 1 DFS(words[i],target,words,v,count+1,res) v[i] = 0 def solution(begin, target, words): #DFS #방문 처리 v= [0] * len(words) res = [] DFS(begin,target,words,v,0,res) # 리스트가 비어있으면 0 리턴 return min(res) if res else 05. 결과필요시. c++ 짜드리겠습니다. 설명이 필요시 댓글달아주세요." }, { "title": "Programmers_연습문제 줄 서는 방법(python)", "url": "/posts/Programmers_stand_line_making/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-06-04 01:34:40 +0900", "snippet": "프로그래머스 -줄 서는 방법 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/12936#2. 분류 및 난이도Programmers 문제입니다.연습문제 문제입니다.Level 3난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) brute하게 모든 경우의 수를 구하는 방법(python의 combinations)은 시간초과가 뜹니다. 고등학교 때 배운 경우의 수를 생각하면 먼저 한자리를 정해놓고 [정한수, ?, ?, ? ] 3가지를 세우는 방법은 3!입니다. 전체 경우의 수는 n인 4인 기준으로 3! * 3! * 3! * 3!의 경우의 수입니다. (맨 앞이 1인 경우 , 2인 경우, 3인 경우, 4인 경우 4가지 해서) 그렇기에 n!의 경우의 수가 나오고, 문제에서도 최대 20!까지 나온다고 써있습니다. 각 자리수는 (k-1)(찾는 수) // 남은 자릿수의 팩토리얼로 나타낼 수 있습니다. k-1인 이유는 0부터 찾는게 아닌, 1부터 찾는 문제이기 때문에 맨 끝의 경계선을 고려했기 때문입니다. k -= (나눈몫 * 팩토리얼값)으로 나타납니다. n이 4 이고, k = 24인 경우 [4,3,2,1]로 나타내야하는데, 위에서 4를 골라주고 k -=(몫 * 팩토리얼값)[18]은 6이 됩니다. 6은 n이 3이고, k = 6인 경우 [3,2,1]을 나타내는 수와 동일하므로 이런 식으로 경우의 수를 줄여가는 것입니다. del을 해주는 이유는 배열을 비워놔야 위에서 구한 인덱스들을 잘 찾아가기 때문입니다.4. 접근 방법을 적용한 코드def makefact(num) : res =1 for i in range(1,num+1) : res*=i return resdef solution(n, k): answer = [] person = [0] * n for i in range(n) : person[i] = i+1 for i in range(n) : fact = makefact(n-i-1) answer.append(person[(k-1)//fact]) mod = (k-1)//fact del person[mod] k -=(mod* fact) return answer5. 결과필요시. c++ 짜드리겠습니다. 설명이 필요시 댓글달아주세요." }, { "title": "leetcode(리트코드)6월03일 challenge1465-Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts(python)", "url": "/posts/leetcode_Maximum_Area_of_a_Piece_of_Cake_After_Horizontal_and_Vertical_Cuts/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-06-03 03:01:56 +0900", "snippet": "leetcode June 03일 - Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts 문제입니다.1. 문제https://leetcode.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.6월 03일자 챌린지 문제입니다.4. 문제 해석 h,w의 값을 맵을 그려, 수직선과 수평선 값들이 들어옵니다. 들어온 수직선과 수평선을 기준으로 맵을 자른다고 생각했을 때 자른 사각형중 가장 넓이가 큰 값의 사각형의 넓이를 리턴하세요.5. code 첫 부분과 끝 부분에도 사각형이 자동으로 생기므로 그 좌표값인 (0,0), (h,w)를 추가해주었습ㄴ니다. 수직선과 수평선을 돌면서 다음 값의 차이가 가장 큰 값이 해당 길이가 됩니다.pythonclass Solution: def maxArea(self, h: int, w: int, ho: List[int], ve: List[int]) -&amp;gt; int: ho.append(0) ho.append(h) ve.append(0) ve.append(w) ho.sort() ve.sort() maxrow = 0 maxcol = 0 for i in range(1,len(ho)): if ho[i] - ho[i-1] &amp;gt; maxrow : maxrow = ho[i]-ho[i-1] for i in range(1,len(ve)): if ve[i] - ve[i-1] &amp;gt; maxcol : maxcol = ve[i] - ve[i-1] return (maxrow*maxcol)%(pow(10,9)+7)6. 결과 및 후기, 개선점필요시 c++로 풀어드립니다." }, { "title": "Programmers_연습문제 거스름돈(python)", "url": "/posts/Programmers_countProblem/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-06-03 02:34:40 +0900", "snippet": "프로그래머스 -거스름돈 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/129072. 분류 및 난이도Programmers 문제입니다.연습문제 문제입니다.Level 3난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 백준의 동전1이 똑같은 문제입니다. DP로 풀면 해결할 수 있습니다. 문제의 핵심은 동전의 갯수가 중심이라서, 그 부분을 찾아 1씩 추가해주는 것입니다.4. 접근 방법을 적용한 코드def solution(n, money): money.sort() mod = 1000000007 DP = [0] * (n+1) DP[0] = 1 for j in range(len(money)): for i in range(1,n+1): if i-money[j] &amp;gt;=0: DP[i] +=( DP[i-money[j]])%mod return DP[n]%mod5. 결과필요시. c++ 짜드리겠습니다. 설명이 필요시 댓글달아주세요." }, { "title": "Programmers_연습문제 멀리 뛰기(python)", "url": "/posts/Programmers_Broad_Jump/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-06-03 01:34:40 +0900", "snippet": "프로그래머스 -멀리 뛰기 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/129142. 분류 및 난이도Programmers 문제입니다.연습문제 문제입니다.Level 3난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 비슷한 유형의 문제가 많습니다. DP로 해결할 수 있습니다. DP[i-1] + 1(점프)을 하는 경우와 DP[i-2] + 2(점프)하는 경우로 나누엇 생각하면 DP[i] = DP[i-1] + DP[i-2] 라는 점화식이 나옵니다.4. 접근 방법을 적용한 코드def solution(n): mod = 1234567 DP =[0] * (n+1) DP[1] = 1 if n == 1 : return 1 DP[2] = 2 for i in range(3,n+1) : DP[i] = (DP[i-1] + DP[i-2])%mod return DP[n]%mod5. 결과필요시. c++ 짜드리겠습니다. 설명이 필요시 댓글달아주세요." }, { "title": "Programmers_연습문제 가장 긴 펠린드롬(python)", "url": "/posts/Programmers_Longest_Pail/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-06-02 12:34:40 +0900", "snippet": "프로그래머스 -가장 긴 펠린드롬 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/129042. 분류 및 난이도Programmers 문제입니다.연습문제 문제입니다.Level 3난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) leetcode 5번이 똑같은 문제입니다. 하나의 인덱스를 기준으로 pailndrome을 찾고 확장합니다.4. 접근 방법을 적용한 코드def solution(s): if len(s) &amp;lt;= 1 : return 1 max_len =1 min_left = 0 max_right = len(s)-1 mid = 0 while mid &amp;lt; len(s) : left = mid right = mid while right &amp;lt; max_right and s[right] == s[right+1] : right+=1 mid = right+1 while right &amp;lt; max_right and left &amp;gt; 0 and s[right+1] == s[left-1] : right+=1 left-=1 newlen = right-left+1 if newlen &amp;gt; max_len : max_len = newlen return max_len5. 결과필요시. c++ 짜드리겠습니다. 설명이 필요시 댓글달아주세요." }, { "title": "leetcode(리트코드)6월02일 challenge97-Interleaving String(python)", "url": "/posts/leetcode_Interleaving_String/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-06-02 05:01:56 +0900", "snippet": "leetcode June 02일 - Interleaving String 문제입니다.1. 문제https://leetcode.com/problems/interleaving-string/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.6월 02일자 챌린지 문제입니다.4. 문제 해석 두 개의 문자열이 들어옵니다. 각 문자열을 적절히 조합해서 s3라는 문자열을 만들 수 있으면 True를 리턴하고 만들 수 없으면 False를 리턴합니다. s1에서 뽑은 경우와 s2에서 뽑은 경우를 계산해야해서 DP를 사용합니다. Discuss를 보고 힌트를 얻었습니다. 이러면 안되는데.. DP방식은 염기서열 문제와 비슷합니다. 5. codepythonclass Solution: def isInterleave(self, s1: str, s2: str, s3: str) -&amp;gt; bool: row = len(s1)+1 col = len(s2)+1 if row + col-2 != len(s3) : return False DP = [0] * (row) for i in range(row) : DP[i] = [0] * (col) for i in range(row) : for j in range(col): if i == 0 and j == 0: DP[i][j] = 1 elif i == 0 : DP[i][j] = (1 if DP[i][j-1] and s2[j-1] == s3[i+j-1] else 0) elif j == 0: DP[i][j] = (1 if DP[i-1][j] and s1[i-1] == s3[i+j-1] else 0) else : DP[i][j] = 1 if (DP[i-1][j] and s1[i-1] == s3[i+j-1]) or (DP[i][j-1] and s2[j-1] == s3[i+j-1]) else 0 #print(DP) return DP[row-1][col-1]6. 결과 및 후기, 개선점필요시 c++로 풀어드립니다." }, { "title": "leetcode(리트코드)-112 Path Sum(python)", "url": "/posts/leetcode_Path-Sum/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-06-02 04:34:50 +0900", "snippet": "leetcode 112 - Path Sum 문제입니다.1. 문제https://leetcode.com/problems/path-sum/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 트리의 경로를 탔을 때 targetSum을 만들 수 있는 지 만들 수 있다면 해당 노드가 뿌리노드까지 닿은건지 확인하여 return합니다.5. code코드설명python# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def hasPathSum(self, root: TreeNode, targetSum: int) -&amp;gt; bool: def DFS(root,targetSum,curr): if root: curr += root.val #만약 트리노드의 끝이고, targetSum과 같다면 if curr == targetSum and root.left == None and root.right == None: return True return DFS(root.left,targetSum,curr) or DFS(root.right,targetSum,curr) return DFS(root,targetSum,0)6. 결과 및 후기, 개선점필요시 c++로 짜드리겠습니다." }, { "title": "Programmers_연습문제 야근 지수(python)", "url": "/posts/Programmers_Overtime_count/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-06-02 03:34:40 +0900", "snippet": "프로그래머스 -야근 지수 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/12927#2. 분류 및 난이도Programmers 문제입니다.연습문제 문제입니다.Level 3난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 문제는 직관적이고, n만큼 돌아도 문제가 풀릴 것이라 생각했습니다. Level3 답게 일반적인 방법으로는 안풀립니다. Priority Queue로 풀면 시간초과가 뜨고 heap으로 풀면 시간초과가 뜨지 않습니다.(python 기준)4. 접근 방법을 적용한 코드#우선순위 큐로 푼 흔적from queue import PriorityQueueimport heapqdef solution(n, works): answer = 0 heap = [] # 우선순위를 위해 -로 바꿔 넣습니다. for work in works : heapq.heappush(heap,-work) #n만큼 돌면서 우선순위를 갱신해줍니다. while n : work = -(heapq.heappop(heap)) work-=1 heapq.heappush(heap,-work) n-=1 # -h가 음수인 경우는 고려할 필요가 없습니다. for h in heap: if -h &amp;lt; 0 : continue #어차피 - 곱하기 - 는 양수이므로 그냥 곱해버렸습니다. answer += h*h return answer5. 결과필요시. c++ 짜드리겠습니다. 설명이 필요시 댓글달아주세요." }, { "title": "Programmers_연습문제 최고의 집합(python)", "url": "/posts/Programmers_best_set/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-06-02 02:34:40 +0900", "snippet": "프로그래머스 -최고의 집합 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/129382. 분류 및 난이도Programmers 문제입니다.연습문제 문제입니다.Level 3난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 첫 예제에서 어떻게하면 4,5로 나올 지 생각해 봤습니다. 또한 n이 3이고 s가 9일 때 3,3,3이 최고의 집합인데, 이 경우의 수가 어떻게 나오는 지 생각해봤습니다. 매 번 s에서 n으로 나눈 몫이 최선의 수라고 생각하였고, 코드를 작성하였습니다.4. 접근 방법을 적용한 코드def solution(n, s): answer = [] if n &amp;gt;s : return [-1] while s : nums = s//n answer.append(nums) n -=1 s -=nums return answer5. 결과필요시. c++ 짜드리겠습니다. 설명이 필요시 댓글달아주세요." }, { "title": "Programmers_DFS/BFS 가장 먼 노드(python)", "url": "/posts/Programmers_to_be_far_node/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-06-02 01:34:40 +0900", "snippet": "프로그래머스 -가장 먼 노드 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/491892. 분류 및 난이도Programmers 문제입니다.그래프 문제입니다.Level 3난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 처음에는 다익스트라로 풀었지만, 시간초과가 나왔습니다. 다익스트라는 가중치값을 넣어서 풀었는데 모든 노드의 거리가 1로 같으므로 BFS로 바꿔서 풀었더니 통과하였습니다.4. 접근 방법을 적용한 코드from collections import dequedef solution(n, edge): # 방문처리겸 거리를 담아놓을 리스트입니다. v = [0] * (n+1) # 그래프 graph = [[] for _ in range(n+1)] for i in range(len(edge)) : graph[edge[i][0]].append(edge[i][1]) graph[edge[i][1]].append(edge[i][0]) #BFS dq = deque() # 두번째값은 거리입니다. dq.append([1,1]) v[1] = 1 while dq: x,count = dq.popleft() for i in range(len(graph[x])) : if v[graph[x][i]] == 0 : dq.append([graph[x][i],count+1]) v[graph[x][i]] = count+1 #리스트 내에서 가장 큰 값을 찾습니다. maxN = max(v) #큰 값을 기준으로 갯수를 세줍니다. return v.count(maxN)5. 결과필요시. c++ 짜드리겠습니다. 설명이 필요시 댓글달아주세요." }, { "title": "leetcode(리트코드)-18 4Sum(python)", "url": "/posts/leetcode_4Sum/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-06-01 08:34:50 +0900", "snippet": "leetcode 18 - 4Sum 문제입니다.1. 문제https://leetcode.com/problems/4sum/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.4. 문제 해석 3Sum 문제와 비슷하게 리스트에서 4개를뽑아 target을 만들어야합니다. 중복을 허용하지 않고, 순서바꾸는 것도 허용하지 않습니다.5. code코드설명 필요하시면 말씀해주세요.pythonclass Solution: def fourSum(self, nums: List[int], target: int) -&amp;gt; List[List[int]]: nums.sort() size = len(nums) res = [] for i in range(size-3): if i==0 or (i&amp;gt;0 and nums[i] !=nums[i-1]): for j in range(i+1,size-2): if j == i+1 or (j &amp;gt; i+1 and nums[j] != nums[j-1]) : lo,hi,ts = j+1,size-1,target-(nums[i] +nums[j]) while lo &amp;lt; hi : if nums[lo] + nums[hi] == ts : res.append([nums[i],nums[j],nums[lo],nums[hi]]) while lo &amp;lt;hi and nums[lo] == nums[lo+1] : lo+=1 while lo &amp;lt; hi and nums[hi] == nums[hi-1] : hi-=1 lo+=1 hi-=1 elif nums[lo] + nums[hi] &amp;lt; ts : lo+=1 else: hi-=1 return res6. 결과 및 후기, 개선점필요시 c++로 짜드리겠습니다." }, { "title": "leetcode(리트코드)-1816 Truncate Sentence(python)", "url": "/posts/leetcode_Truncate_Sentence/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-06-01 07:34:50 +0900", "snippet": "leetcode 1816 - Truncate Sentence 문제입니다.1. 문제https://leetcode.com/problems/truncate-sentence/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 k로 들어온 수만큼 어절을 리턴합니다.5. code코드설명pythonclass Solution: def truncateSentence(self, s: str, k: int) -&amp;gt; str: splitlist = s.split() res=&quot;&quot; for i in range(k): res+=splitlist[i]+&quot; &quot; return res[:-1]6. 결과 및 후기, 개선점필요시 c++로 짜드리겠습니다." }, { "title": "leetcode(리트코드)6월01일 challenge695-Max Area of Island(python)", "url": "/posts/leetcode_Max_Area_of_Island/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-06-01 05:01:56 +0900", "snippet": "leetcode June 01일 - Max Area of Island 문제입니다.1. 문제https://leetcode.com/problems/max-area-of-island/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.6월 01일자 챌린지 문제입니다.4. 문제 해석 Island라는 맵이 주어집니다. 1로 이어진 부분은 Island의 영역으로 각기 다른 Island의 넓이중 가장 큰 값을 찾아 리턴하세요.5. codepython#좌표 이동 값dx=[-1,0,1,0]dy=[0,1,0,-1]class Solution: def maxAreaOfIsland(self, grid: List[List[int]]) -&amp;gt; int: def BFS(i,j,row,col,grid,v): area = 1 dq = deque() dq.append([i,j]) v[i][j] = 1 while dq : x,y = dq.popleft() for k in range(4): newx,newy = x+dx[k], y+dy[k] if 0&amp;lt;=newx and newx&amp;lt;row and 0&amp;lt;=newy and newy&amp;lt;col and grid[newx][newy] == 1 and v[newx][newy] == 0 : v[newx][newy] = 1 dq.append([newx,newy]) area+=1 return area row = len(grid) ans = 0 col = len(grid[0]) v = [0] * row for i in range(row) : v[i] = [0] * col for i in range(row) : for j in range(col): if grid[i][j] == 1 and v[i][j] ==0: ans = max(ans,BFS(i,j,row,col,grid,v)) return ans 6. 결과 및 후기, 개선점필요시 c++로 풀어드립니다." }, { "title": "leetcode(리트코드)-111 Minimum Depth of Binary Tree(python)", "url": "/posts/leetcode_Minimum_Depth_of_Binary_Tree/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-06-01 04:34:50 +0900", "snippet": "leetcode 111 - Minimum Depth of Binary Tree 문제입니다.1. 문제https://leetcode.com/problems/minimum-depth-of-binary-tree/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 트리의 자식 노드중에서 가장 작은 Level에 있는 자식을 찾아 그 Level를 리턴합니다.5. code코드설명python# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def minDepth(self, root: TreeNode) -&amp;gt; int: if root : left = self.minDepth(root.left) right = self.minDepth(root.right) #자식이 두 개인 경우와 아닌 경우를 분리해서 판단합니다. return left + right + 1 if left == 0 or right == 0 else min(left,right) + 1 else : return 06. 결과 및 후기, 개선점필요시 c++로 짜드리겠습니다." }, { "title": "Programmers_연습문제 N-Queen(python)", "url": "/posts/Programmers_N_Queens/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-06-01 03:34:40 +0900", "snippet": "프로그래머스 -N-Queen 타일링 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/129522. 분류 및 난이도Programmers 문제입니다.연습문제 문제입니다.Level 3난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 유명한 문제입니다. leetcode에서는 Hard로 분류되어있고, 효율성까지 따지는 문제라 Level3 문제는 아닌 것 같은데..4. 접근 방법을 적용한 코드def promising(i,col): k = 0 switch = True while k &amp;lt; i and switch == True : if col[i] == col[k] or abs(col[i] - col[k]) == i -k : switch = False k+=1 return switchdef queens(n,i,col,res): if promising(i,col) : if i == n-1 : size = len(res) res.append([]) for j in range(len(col)): find = col[j] res[size].append(1) else: for j in range(0,n): col[i+1] = j queens(n,i+1,col,res)def solution(n): col = n *[0] res = [] queens(n,-1,col,res) return len(res)5. 결과필요시. c++ 짜드리겠습니다. 설명이 필요시 댓글달아주세요." }, { "title": "Programmers_연습문제 2*n 타일링(python)", "url": "/posts/Programmers_2multi_n/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-06-01 02:34:40 +0900", "snippet": "프로그래머스 -2*n 타일링 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/129002. 분류 및 난이도Programmers 문제입니다.연습문제 문제입니다.Level 3난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 유명한 문제이므로 자세한 내용은 생략하겠습니다. 점화식은 DP[i] = DP[i-1] + DP[i-2]입니다.4. 접근 방법을 적용한 코드def solution(n): answer = 0 mod = 1000000007 DP = [1] * (n+1) for i in range(2,n+1) : DP[i] = (DP[i-1] + DP[i-2])%mod answer = DP[n]%mod return answer5. 결과필요시. c++ 짜드리겠습니다. 설명이 필요시 댓글달아주세요." }, { "title": "Programmers_DFS/BFS 여행경로(python)", "url": "/posts/Programmers_travel_nav/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-06-01 01:34:40 +0900", "snippet": "프로그래머스 -여행경로 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/43164#2. 분류 및 난이도Programmers 문제입니다.깊이/너비 우선 탐색 DFS/BFS 문제입니다.Level 3난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 백트래킹 방법을 사용하지 않으면 시간초과가 뜹니다. python에서 재귀 동작방식에 대한 이해가 부족하여 결과값들을 다 넣고 앞부분만 잘랐습니다. 개선이 필요합니다.4. 접근 방법을 적용한 코드from collections import dequedef DFS(templi,dic,start,finish,v,answer): #결과값은 항상 주어진 tickets 리스트의 크기 +1입니다. if len(templi) == finish : # 결과값을 다 넣어버립니다. for i in range(len(templi)): answer.append(templi[i]) return templi #dictionary에 값이 있을 때 if start in dic : for i in range(len(dic[start])) : # 방문 처리가 되지 않은 것들을 돕니다. if v[start][i]==0 : #templi에 추가 templi.append(dic[start][i]) #방문처리 v[start][i] = 1 # 재귀 DFS(templi,dic,dic[start][i],finish,v,answer) #맨 뒤의 값을 제거 및 방문처리 제거합니다. templi.pop() v[start][i] = 0 return templi def solution(tickets): answer = [] dic = {} v = {} finish = len(tickets)+1 #dic에 dic[출발지] = 도착지 값들을 deque형태로 저장합니다. 방문처리를 위한 v도 마찬가지로 저장합니다. 0은 방문하지 않은 것 1은 방문한 것입니다. for i in range(len(tickets)): start = tickets[i][0] end = tickets[i][1] if start not in dic: dic[start] = deque() v[start] = deque() dic[start].append(end) v[start].append(0) else : dic[start].append(end) v[start].append(0) #정렬 for i in dic : dic[i] = sorted(dic[i]) DFS([&quot;ICN&quot;],dic,&quot;ICN&quot;,finish,v,answer) # 결과값들을 다 넣었으므로 앞부분을 자릅니다. 이미 정렬을 했기에 앞부분이 정답일 수 밖에 없습니다. return answer[:finish]5. 결과필요시. c++ 짜드리겠습니다. 설명이 필요시 댓글달아주세요." }, { "title": "leetcode(리트코드)5월29일 challenge52-N-Queens II(python)", "url": "/posts/leetcode_N-Queens_II/", "categories": "leetcode, Hard", "tags": "leetcode, AlgorithmStudy", "date": "2021-05-29 01:01:56 +0900", "snippet": "leetcode May 29일 - N-Queens II 문제입니다.1. 문제https://leetcode.com/problems/n-queens-ii/2. Input , Output3. 분류 및 난이도Hard 난이도입니다.5월 29일자 챌린지 문제입니다.4. 문제 해석 얼마 전에 푼 N-Queen 문제의 2번째 버전입니다. 첫 번째 문제는 리스트를 반환했지만, 이번 문제는 그 리스트의 길이를 반환하면 되는 문제라 I을 풀었으면 이번 문제는 어렵지 않게 해결할 수 있습니다.5. codepythonclass Solution: def totalNQueens(self, n: int) -&amp;gt; int: def promising(i,col): k = 0 switch = True while k &amp;lt; i and switch == True : if col[i] == col[k] or abs(col[i] - col[k]) == i -k : switch = False k+=1 return switch def queens(n,i,col,res): if promising(i,col) : if i == n-1 : size = len(res) res.append([]) for j in range(len(col)): resstr = &quot;&quot; find = col[j] for k in range(len(col)): if k ==find : resstr+=&quot;Q&quot; else : resstr+=&quot;.&quot; res+=1 else: for j in range(0,n): col[i+1] = j queens(n,i+1,col,res) col = n *[0] res = [] queens(n,-1,col,res) return res 6. 결과 및 후기, 개선점필요시 c++로 풀어드립니다." }, { "title": "Programmers_2018 KAKAO BLINE RECURITMENT[3차] n 진수 게임(python)", "url": "/posts/Programmers_game_of_nexp/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-05-28 03:34:40 +0900", "snippet": "프로그래머스 -n진수 게임 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/17687?language=python32. 분류 및 난이도Programmers 문제입니다.2018 KAKAO BLIND RECURITMENT 문제입니다.Level 2난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) DP로 풀까하다가 힘들것 같아서brute하게 풀었습니다.4. 접근 방법을 적용한 코드def makestr(i,n) : res = &quot;&quot; nums = &quot;0123456789ABCDEF&quot; while i : res= nums[i%n] + res i=i//n return resdef solution(n, t, m, p): answer = &#39;&#39; #for문을 돌면서 원하는 진법으로 만들어주는데 0이 들어갈 경우 위 함수의 while문을 돌지 않으므로 따로 추가해줍니다. binarystr = &quot;0&quot; for i in range(t*m) : binarystr += makestr(i,n) p = p -1 for i in range(t) : answer+=(binarystr[p]) p +=m return answer5. 결과필요시. c++ 짜드리겠습니다. 설명이 필요시 댓글달아주세요." }, { "title": "Programmers_연습문제 가장 큰 정사각형 찾기(python)", "url": "/posts/Programmers_Find_Largest_Lectangle/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-05-28 01:34:40 +0900", "snippet": "프로그래머스 -가장 큰 정사각형 찾기 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/129052. 분류 및 난이도Programmers 문제입니다.연습문제 문제입니다.Level 2난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 재귀함수로 풀어야한다는 생각에 접근하지 못했습니다. DP로 풀 수 있습니다. 대각선, 바로 위의 열, 옆의 열을 검사하여 값을 갱신하면 됩니다.4. 접근 방법을 적용한 코드def solution(board): row = len(board) col = len(board[0]) DP = [0] * row size = 0 for i in range(row): DP[i] = [0] * col for i in range(row) : for j in range(col) : if i ==0 or j== 0 or board[i][j] == 0 : DP[i][j] = board[i][j] else : DP[i][j] = min(DP[i-1][j-1],min(DP[i-1][j],DP[i][j-1])) + 1 size = max(size,DP[i][j]) return size*size5. 결과필요시. c++ 짜드리겠습니다." }, { "title": "leetcode(리트코드)-145 Binary Tree Postorder Traversal(python)", "url": "/posts/leetcode_Binary_Tree_Postorder_Traversal/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-05-26 05:34:50 +0900", "snippet": "leetcode 145 - Binary Tree Postorder Traversal 문제입니다.1. 문제https://leetcode.com/problems/binary-tree-preorder-traversal/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 postorder해서 값들을 리스트에 담고 리턴합니다.5. code코드설명직관적이므로 따로 설명하지 않겠습니다. 모르겠는 분은 질문남겨주세요.python# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def dfs(self,root,res) : if root : self.dfs(root.left,res) self.dfs(root.right,res) res.append(root.val) def postorderTraversal(self, root: TreeNode) -&amp;gt; List[int]: res= [] self.dfs(root,res) return res 6. 결과 및 후기, 개선점필요시 c++로 짜드리겠습니다." }, { "title": "leetcode(리트코드)-144 Binary Tree Preorder Traversal(python)", "url": "/posts/leetcode_Binary_Tree_Preorder_Traversal/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-05-26 04:34:50 +0900", "snippet": "leetcode 144 - Binary Tree Preorder Traversal 문제입니다.1. 문제https://leetcode.com/problems/binary-tree-preorder-traversal/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 preorder해서 값들을 리스트에 담고 리턴합니다.5. code코드설명직관적이므로 따로 설명하지 않겠습니다. 모르겠는 분은 질문남겨주세요.python# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def dfs(self,root,res) : if root : res.append(root.val) self.dfs(root.left,res) self.dfs(root.right,res) def preorderTraversal(self, root: TreeNode) -&amp;gt; List[int]: res= [] self.dfs(root,res) return res 6. 결과 및 후기, 개선점필요시 c++로 짜드리겠습니다." }, { "title": "leetcode(리트코드)5월26일 challenge1689-Partitioning Into Minimum Number Of Deci Binary(python)", "url": "/posts/leetcode_Partitioning_Into_Minimum_Number_Of_Deci_Binary_Numbers/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-05-26 03:01:56 +0900", "snippet": "leetcode May 26일 - Partitioning Into Minimum Number Of Deci Binary 문제입니다.1. 문제https://leetcode.com/problems/partitioning-into-minimum-number-of-deci-binary-numbers/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.5월 26일자 챌린지 문제입니다.4. 문제 해석 왜 Medium난이도인지 모르겠습니다. 2진수들을 더해서 n의 값을 만들 때 몇 번 더해야하는 지 리턴하는 것인데.. ‘00001’이런것도 되어서 사실상 가장 큰값을 리턴하면됩니다.5. codepythonclass Solution: def minPartitions(self, n: str) -&amp;gt; int: return int(max(n)) 6. 결과 및 후기, 개선점필요시 c++로 풀어드립니다." }, { "title": "Programmers_2021 KAKAKO BLIND RECURITMENT 순위 검색(python)", "url": "/posts/Programmes_search_rank/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-05-26 01:34:40 +0900", "snippet": "프로그래머스 -순위 검색 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/724122. 분류 및 난이도Programmers 문제입니다.2021 KAKAO BLIND RECURITMENT 문제입니다.Level 2난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 문제의 핵심은 효율성 부분입니다. 많은 사람들이 효율성 때문에 틀리고, 저 또한 효율성으로 2시간이나 잡고 있었습니다… 실전이었으면 이미 탈락. 다 풀고나서는 코드가 그리 길지않고 생각하는 게 어렵지 않다고 느껴서 Level 2답네 라고 했지만.. 진짜 이게 Level 2 문제인가? 싶기도 합니다.4. 접근 방법을 적용한 코드첫 코드는 정보를 튜플로 만들어서 매 인덱스마다 정렬을 해줬습니다. 틀린 코드입니다.처음에 삽질한 코드 효율성 제로, 틀림.import copydef solution(info, query): answer = [] infolist = [] for i in range(len(info)) : #info tuple에 담기 temptp = info[i].split(&#39; &#39;) temptp = (temptp[0][0],temptp[1][0],temptp[2][0],temptp[3][0],int(temptp[4])) infolist.append(temptp) #정렬 infolist = sorted(infolist, key = lambda tp : tp[0]) for i in range(len(query)): #query 처리문 querytemp = query[i] querytemp = querytemp.split(&quot; and &quot;) querylast = querytemp[3].split(&#39; &#39;) del querytemp[3] querytemp.append(querylast[0]) querytemp.append(querylast[1]) #print(querytemp) start = 0 end = len(info)-1 templist = copy.deepcopy(infolist) for qidx in range(4): k = 0 while k &amp;lt; len(templist): #print(templist) findlist = templist[k][qidx] findquery = querytemp[qidx][0] if findquery ==&quot;-&quot; : templist = sorted(templist, key = lambda tp : tp[qidx+1]) #print(&quot;templist : &quot;,templist) break if findlist == findquery : start = k while k&amp;lt; len(templist) and templist[k][qidx] == findquery : k+=1 end = k #print(start,end) del templist[:start] del templist[end-start:] templist = sorted(templist, key = lambda tp : tp[qidx+1]) #print(&quot;templist : &quot;,templist) else : k+=1 #print(&quot;최종 : &quot;,start,end,templist) count = 0 for res in range(len(templist)): if int(querytemp[4]) &amp;lt;= templist[res][4]: #print(querytemp[4], templist[res][4]) count+=1 answer.append(count) return answer정답인 코드# 쿼리문 조건에 맞는 것들을 계속 리턴합니다.def findstr(idx,char,infolist) : res = [] for k in infolist: if k[idx] == char : res.append(k) return res# lower boundary를 이용합니다. (타겟과 같거나 처음으로 큰 값 나타나는 인덱스 리턴)def binary_search(array,target,start,end): while start &amp;lt; end : mid = (start + end) //2 if array[mid] == target : end = mid elif array[mid] &amp;lt; target: start = mid + 1 elif target &amp;lt; array[mid]: end = mid return end def solution(info, query): answer = [] dic = {} for i in range(len(info)) : #dic에 담기 temptp = info[i].split(&#39; &#39;) score = int(temptp[4]) temptp= (temptp[0][0] + temptp[1][0] + temptp[2][0] + temptp[3][0]) if temptp not in dic : lt = [] dic[temptp] = lt dic[temptp].append(score) else : dic[temptp].append(score) #나중에 이진탐색을 할 것이므로 정렬을 미리 해둡니다. for k in dic: dic[k].sort() for i in range(len(query)): #query 처리문 querytemp = query[i] querytemp = querytemp.split(&quot; and &quot;) querylast = querytemp[3].split(&#39; &#39;) first = querytemp[0][0] + querytemp[1][0] + querytemp[2][0] + querytemp[3][0] qscore = int(querylast[1]) # 있는 경우 if first in dic : count = 0 for k in (dic[first]) : if k &amp;gt;= qscore : count+=1 answer.append(count) else : count = 0 infolist = dic.keys() totalsize = 0 for k in range(4) : if first[k]==&quot;-&quot; : continue else : infolist = findstr(k,first[k],infolist) for lt in infolist : size = len(dic[lt]) idx = binary_search(dic[lt],qscore,0,size) if size != idx: count += (size - idx) answer.append(count) return answer5. 결과필요시. c++ 짜드리겠습니다." }, { "title": "leetcode(리트코드)5월25일 challenge150-Evaluate Reverse Polish Notation(python)", "url": "/posts/leetcode_Evaluate_Reverse_Polish_Notation/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-05-25 05:01:56 +0900", "snippet": "leetcode May 25일 - Evaluate Reverse Polish Notation 문제입니다.1. 문제https://leetcode.com/problems/evaluate-reverse-polish-notation/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.5월 25일자 챌린지 문제입니다.4. 문제 해석 연산자 후위표기법에 관한 문제입니다. 음수 나눗셈에 대한 처리를 잘 해주면 어렵지 않은 문제입니다.5. codepythonclass Solution: def evalRPN(self, tokens: List[str]) -&amp;gt; int: #stack st =deque() for i in range(len(tokens)): token = tokens[i] #음수일 경우 digit()함수로 판단이 불가능 하므로 따로 분기문을 정해주었고, 값을 음수로 바꾸어 넣어줬습니다. if token[0] == &quot;-&quot; and len(token) &amp;gt;1 : minus = int(token[1:]) minus = -minus st.append(minus) # 양수인 경우 stack에 넣습니다. elif token.isdigit() : st.append(int(token)) # 연산자인경우 else : second = st.pop() first = st.pop() if token == &quot;+&quot; : st.append(first+second) elif token == &quot;-&quot;: st.append(first-second) elif token == &quot;*&quot; : st.append(first*second) else : # 만약 둘 중하나가 음수인 경우는 절대값을 계산하여 -를 넣어줘야합니다. # 6//-132 같은 경우 0이 리턴되어야하는데, 1인지 몫이 생겨버려서 이와같은 로직을 거쳐야합니다. if (first &amp;lt; 0 and second &amp;gt; 0) or (first &amp;gt; 0 and second &amp;lt;0): res = abs(first) // abs(second) st.append(-res) #둘 다 음수거나 양수인경우 else : st.append(first//second) #st[0]에는 최종값이 저장되어 있습니다. return st[0] 6. 결과 및 후기, 개선점필요시 c++로 풀어드립니다." }, { "title": "leetcode(리트코드)-110 Balanced Binary Tree(python)", "url": "/posts/leetcode_Balanced_Binary_Tree/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-05-25 04:34:50 +0900", "snippet": "leetcode 110 - Balanced Binary Tree 문제입니다.1. 문제https://leetcode.com/problems/balanced-binary-tree/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 트리의 모든 자식의 높이가 1이상 차이가 날 경우 False 아닌 경우 True를 리턴합니다. 직관적인 문제입니다. 재귀를 잘 짜지못하여 discuss를 봤습니다. 추후 다시 풀어야겠습니다.5. code코드설명직관적이므로 따로 설명하지 않겠습니다. 모르겠는 분은 질문남겨주세요.python# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def checkdepth(self,root : TreeNode) -&amp;gt; int: if root : left = self.checkdepth(root.left) if left == -1 : return -1 right = self.checkdepth(root.right) if right == -1 : return -1 if abs(left-right) &amp;gt; 1 : return -1 return max(left,right) +1 else : return 0 return count def isBalanced(self, root: TreeNode) -&amp;gt; bool: res = self.checkdepth(root) return False if res == -1 else True6. 결과 및 후기, 개선점필요시 c++로 짜드리겠습니다." }, { "title": "Programmers_2018 KAKAKO BLIND RECURITMENT[3차] 파일명 정렬(python)", "url": "/posts/Programmers_File_name_sort/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-05-25 02:34:40 +0900", "snippet": "프로그래머스 -파일명 정렬 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/176862. 분류 및 난이도Programmers 문제입니다.KAKAO BLIND RECURITMENT[3차] 문제입니다.Level 2난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 직관적으로 풀었습니다. 정렬 조건이 2개 존재합니다. 문자열은 사전순, 숫자는 오름차순으로 정렬해야해서 따로따로 떼줍니다. 뒤의 문자(tail)은 생각하지 않았습니다.4. 접근 방법을 적용한 코드#문자열을 잘라줍니다. 자른곳까지의 문자들과 인덱스를 리턴합니다.#인데스를 리턴하는 이유는, 다음에 찾아야할 숫자에 대한 정보를 빠르게 찾기 위함입니다.def dif_chat(string) : res = &quot;&quot; i=0 for i in range(len(string)): if string[i].isdigit(): return res.lower(),i res+=string[i] return res.lower(),i# 위의 함수에서 받은 인덱스 정부터 끝까지 돌면서 정수인경우 값을 임시 문자열에 넣고 반환합니다. def dif_num(string,idx): res = &quot;&quot; while idx &amp;lt; len(string) and string[idx].isdigit(): res+= string[idx] idx+=1 return res def solution(files): answer = [] tp =[] for i in range(len(files)): # filestr에는 문자들이, idx에는 자른 위치에대한 정보값이 들어가 있습니다. filestr,idx = dif_chat(files[i]) # filenum에는 숫자들이 문자열형태로 들어있습니다. filenum = dif_num(files[i],idx) # 이런식으로 하면 0012는 12로 변환되어 무시할 수 있게됩니다. filenum = int(filenum) # Key값 정렬을 위해 tuple로 넣어줬습니다. temptuple = (filestr,files[i],filenum) tp.append(temptuple) #print(tp) # tup[0]에 대한 정렬을 먼저한 뒤, tup[2]에대해 정렬을 합니다. # tup[0]는 filestr로 자른 문자열, tup[2]에는 숫자에대한 정보가 들어있습니다. tp = sorted(tp, key=lambda tup: (tup[0],tup[2])) # 정렬된 뒤 tp[i][1]에는 원본 문자열이 들어있으므로 해당 값을 결과값에 넣어줍니다. for i in range(len(tp)): answer.append(tp[i][1]) return answer5. 결과필요시. c++ 짜드리겠습니다." }, { "title": "Programmers_2018 KAKAKO BLIND RECURITMENT[3차] 압축(python)", "url": "/posts/Programmers_Zip/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-05-25 01:34:40 +0900", "snippet": "프로그래머스 -압축 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/176842. 분류 및 난이도Programmers 문제입니다.KAKAO BLIND RECURITMENT[3차] 문제입니다.Level 2난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 직관적으로 풀었습니다.4. 접근 방법을 적용한 코드def solution(msg): answer = [] dic = {} chat = &quot;A&quot; #ASCII 코드로 변환하면서 dictionary에 넣어줍니다. for i in range(26): ctoi = ord(chat) dic[chat] = i+1 ctoi+=1 chat = chr(ctoi) i=0 #사전 접근 인덱스 dicidx = 27 while i &amp;lt; len(msg): dicchat = msg[i] answeridx = dic[dicchat] #다음 문자들을 포함한 것이 사전에 있는 지 확인합니다. while i+1 &amp;lt; len(msg) and dicchat + msg[i+1] in dic : dicchat = dicchat + msg[i+1] answeridx = dic[dicchat] i+=1 #배열을 벗어나지 않게 사전에 없는 정보를 추가해줍니다. if i+1 &amp;lt; len(msg) : dic[dicchat+ msg[i+1]] = dicidx dicidx+=1 #결과값에 사전에서 찾은 값을 넣어줍니다. answer.append(answeridx) i+=1 return answer5. 결과필요시. c++ 짜드리겠습니다." }, { "title": "Programmers_2018 KAKAO BLIND RECRUITMENT[3차] 방금그곡(python)", "url": "/posts/Programmers_now_sing/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-05-24 07:34:40 +0900", "snippet": "프로그래머스 -방금그곡 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/17683#2. 분류 및 난이도Programmers 문제입니다.KAKAO BLIND RECRUITMENT[3차] 문제입니다.Level 2난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) KMP으로 풀었습니다. ’#’에 대한 처리가 굉장히 힘들었습니다.4. 접근 방법을 적용한 코드#KMP table 만들기def maketable(m): size = len(m) li = [0] * size j = 0 for i in range(1,size): while j &amp;gt; 0 and m[i] != m[j] : j = li[j-1] if m[i] == m[j] : j+=1 li[i] =j return li#kmpdef KMP(m,li,table): msize = len(m) lisize = len(li) j = 0 for i in range(lisize): while j &amp;gt; 0 and li[i] != m[j] : j = table[j-1] if li[i] == m[j] : if j == msize-1 : #마지막인데, 만약 비교대상의 뒤가 #인경우 # 즉 패턴은 ABC인데, 비교대상이 ABC#인 경우 업데이트하고 걸러줌. if i+1 &amp;lt;lisize and li[i+1] ==&quot;#&quot;: j= table[j] else: return True else : j+=1 return False # 총 시간을 계산합니다. def calcutime(start,end): starthour,startmin = start.split(&quot;:&quot;) endhour,endmin = end.split(&quot;:&quot;) hour = int(endhour) - int(starthour) mini = int(endmin) - int(startmin) return hour*60 + mini def solution(m, musicinfos): answer = &quot;&quot; anstime = 0 # m(패턴)에 대한 테이블을 미리 만들어둡니다. table = maketable(m) for i in range(len(musicinfos)): start,end,name,li = musicinfos[i].split(&#39;,&#39;) totaltime = calcutime(start,end) #temp는 #을고려해서 문자열을 재배치한 문자열입니다. temp= &quot;&quot; lisize = len(li) idx = 0 #재배치 과정 for k in range(totaltime) : temp += li[idx%lisize] idx+=1 if(li[idx%lisize] == &quot;#&quot; ) : temp += &quot;#&quot; idx+=1 #print(start,end,name,temp,totaltime) #KMP if KMP(m,temp,table): #만약 들어온 값보다 재생시간이 더 큰값이 들어오면 갱신합니다. 같은 경우는 어차피 이미 들어온값이 작거나 먼저나온 것이므로.. 고려 안합니다. if anstime &amp;lt; totaltime : anstime = totaltime answer = name #None if answer ==&quot;&quot;: return &quot;(None)&quot; return answer5. 결과필요시. c++ 짜드리겠습니다." }, { "title": "leetcode(리트코드)-40 Combination Sum II(python)", "url": "/posts/leetcode_Combination_Sum_II/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Interview", "date": "2021-05-24 04:34:50 +0900", "snippet": "leetcode 40 - Combination Sum II 문제입니다.1. 문제https://leetcode.com/problems/combination-sum-ii/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.Top Interview 문제입니다.4. 문제 해석 주어진 리스트의 요소를 통해 target을 만들어야합니다. 만들 수 있는 경우의 수를 리스트에 넣어 반환합니다. DFS를 이용하면 풀 수 있습니다.5. code코드설명pythonclass Solution: def combinationSum2(self, candidates: List[int], target: int) -&amp;gt; List[List[int]]: res = [] self.DFS(sorted(candidates),target,0,[],res) return res def DFS(self, nums,target,idx,path,res): if target == 0 : res.append(path) elif target &amp;lt; 0 : return for i in range(idx,len(nums)): #중복 처리 if i &amp;gt; idx and nums[i] == nums[i-1]: continue self.DFS(nums,target-nums[i],i+1,path + [nums[i]],res) 6. 결과 및 후기, 개선점필요시 c++로 짜드리겠습니다." }, { "title": "Programmers_Summer/Winter Coding(~2018) 스킬트리(python)", "url": "/posts/Programmers_Skill_Tree/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-05-24 02:34:40 +0900", "snippet": "프로그래머스 -스킬트리 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/499932. 분류 및 난이도Programmers 문제입니다.Summer/Winter Coding(~2018) 문제입니다.Level 2난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) brute하게 풀면 됩니다. 예외처리를 잘 생각해야합니다. 선행스킬을 찾지 못한 경우에서 다음 스킬은 찾은 경우 값을 세주지 않았습니다.4. 접근 방법을 적용한 코드def solution(skill, skill_trees): answer = 0 for i in range(len(skill_trees)): #skill_tree는 들어온 문자열 중 하나입니다. skill_tree = skill_trees[i] check = True minN = -1 for j in range(len(skill)): # 주어진 스킬트리에서 기존 선행 스킬을 찾습니다. findidx = skill_tree.find(skill[j]) # 찾지 못한 경우 False로 저장해놓습니다. 만약 다음 스킬을 찾아버리면 반복문을 탈출합니다. if findidx == -1 : check = False else: # 찾았지만, 선행스킬보다 스킬을 먼저 배우는 경우 탈출합니다. if minN &amp;gt;findidx : check = False break # 찾았는데, 선행스킬을 배우지 않은 경우 탈출합니다. elif check == False: break check = True minN = findidx #완벽하게 수행했으면 answer+=1을 해줍니다. if j == len(skill)-1 : answer+=1 return answer5. 결과필요시. c++ 짜드리겠습니다." }, { "title": "Programmers_Summer/Winter Coding(~2018) 배달(python)", "url": "/posts/Programmers_Delivery/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-05-24 01:34:40 +0900", "snippet": "프로그래머스 -배달 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/129782. 분류 및 난이도Programmers 문제입니다.Summer/Winter Coding(~2018) 문제입니다.Level 2난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 다익스트라 알고리즘 문제입니다. 마을에 대한 거리값이 중복해서 들어올 경우가 있습니다. 이 경우를 해결해주면 어렵지 않습니다.4. 접근 방법을 적용한 코드from queue import PriorityQueuedef solution(N, road, K): answer = 0 res = [987654321] * (N+1) map = [0] * (N+1) que = PriorityQueue() for i in range(N+1): map[i] = [0] * (N+1) for i in range(len(road)): row,col,dis = road[i][0],road[i][1],road[i][2] if map[row][col] != 0 : if map[row][col] &amp;gt; dis : map[row][col] = dis map[col][row] = dis else: map[row][col] = dis map[col][row] = dis res[1] = 0 que.put([1,0]) while not que.empty() : curr,distance = que.get() distance = -distance if res[curr] &amp;lt; distance : continue for i in range(len(map[curr])): if map[curr][i] != 0 : next = i nextdis = map[curr][i] + distance if nextdis &amp;lt; res[next] : res[next]= nextdis que.put([next,-nextdis]) for k in range(1,len(res)): if res[k] &amp;lt;=K: answer+=1 print(res) return answer5. 결과필요시. c++ 짜드리겠습니다." }, { "title": "leetcode(리트코드)-83 Remove Duplicates from Sorted List(python)", "url": "/posts/leetcode_Remove_Duplicates_from_Sorted_List/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-05-23 06:34:50 +0900", "snippet": "leetcode 83 - Remove Duplicates from Sorted List 문제입니다.1. 문제https://leetcode.com/problems/remove-duplicates-from-sorted-list/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 직관적인 문제입니다. list가 중복되면 그 값을 거하여 1개만 존재하게 하면 됩니다.5. code코드설명dictionary 자료형에 값이 이미 들어와있으면 중복된 것이므로 현재 인덱스에서 dic에 저장된 최초의 인덱스를 빼서 큰 값을 갱신해줍니다.python# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def deleteDuplicates(self, head: ListNode) -&amp;gt; ListNode: #결과값은 맨 앞을 가르켜야하므로 res = head def solve(root): if root : if root.next != None and root.val == root.next.val : root.next = root.next.next # 1 -&amp;gt; 1 -&amp;gt; 1 같은 중복이 연속될 경우가 있습니다. solve(root) else: solve(root.next) solve(head) return res6. 결과 및 후기, 개선점필요시 c++로 짜드리겠습니다." }, { "title": "leetcode(리트코드)5월24일 challenge709-To Lower Case(python)", "url": "/posts/leetcode_To_Lower_Case/", "categories": "leetcode, Eazy", "tags": "leetcode, AlgorithmStudy", "date": "2021-05-23 06:01:56 +0900", "snippet": "leetcode May 24일 - To Lower Case 문제입니다.1. 문제https://leetcode.com/problems/to-lower-case/2. Input , Output3. 분류 및 난이도Eazy 난이도입니다.5월 24일자 챌린지 문제입니다.4. 문제 해석 너무나도 쉬운 문제입니다.. 그래서 bad수가 압도적으로 많습니다.5. codepythonclass Solution: def toLowerCase(self, s: str) -&amp;gt; str: return s.lower()6. 결과 및 후기, 개선점필요시 c++로 풀어드립니다." }, { "title": "leetcode(리트코드)-1624 Largest Substring Between Two Equal Character(python)", "url": "/posts/leetcode_Largest_Substring_Between_Two_Equal_Characters/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-05-23 05:34:50 +0900", "snippet": "leetcode 1624 - Largest Substring Between Two Equal Character 문제입니다.1. 문제https://leetcode.com/problems/largest-substring-between-two-equal-characters/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 직관적인 문제입니다. 문자가 중복되었을 때 그 사이에있는 문자열의 크기가 제일 큰 값을 리턴합니다.5. code코드설명dictionary 자료형에 값이 이미 들어와있으면 중복된 것이므로 현재 인덱스에서 dic에 저장된 최초의 인덱스를 빼서 큰 값을 갱신해줍니다.pythonclass Solution: def maxLengthBetweenEqualCharacters(self, s: str) -&amp;gt; int: dic = {} ans = -1 for i in range(len(s)): if s[i] not in dic: dic[s[i]] = i else : ans = max(ans,i - dic[s[i]] - 1) return ans6. 결과 및 후기, 개선점필요시 c++로 짜드리겠습니다." }, { "title": "Programmers_Summer/Winter Coding(~2018) 점프와 순간이동(python)", "url": "/posts/Programmers_Jump_Teleport/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-05-23 02:34:40 +0900", "snippet": "프로그래머스 -점프와 순간이동 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/129802. 분류 및 난이도Programmers 문제입니다.Summer/Winter Coding(~2018) 문제입니다.Level 2난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 역으로 생각하면 어렵지 않습니다. N에서 0으로 만들어야하는데, 홀수인경우는 순간이동으로 온 것이 아니므로 -1을 해주면서 자원소모를 해줍니다.4. 접근 방법을 적용한 코드def solution(n): ans = 0 while(n!=0) : if n%2 ==1 : ans+=1 n-=1 else : n = n//2 return ans5. 결과필요시. c++ 짜드리겠습니다." }, { "title": "Programmers_2020 카카오 인턴십 수식 최대화(python)", "url": "/posts/Programmers_Expression_Max/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-05-23 01:34:40 +0900", "snippet": "프로그래머스 -수식 최대화 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/67257#2. 분류 및 난이도Programmers 문제입니다.2020 카카오 인턴십 문제입니다.Level 2난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) brute하게 풀었습니다. oper라는 list에는 숫자를 담고, op라는 list에는 연산자를 담았습니다. 변수가 많아서 오타 등으로 인해 테스트케이스가 많이 실패했습니다.. for문도 깔끔하게 작성하지 못하여 보기 불편하실 수 있습니다.4. 접근 방법을 적용한 코드import copydef solution(expression): answer = 0 oper = [] op = [] i = 0 #temp는 string으로 들어온 expression의 숫자들을 임시로 저장하여 나중에 stoi를 해줍니다. temp = &quot;&quot; # expression을 돌면서 숫자면 temp에 저장하고 아니면 operlist에 temp를 넣고 초기화해줍니다. while i &amp;lt; len(expression): if(expression[i].isdigit()) : temp+=expression[i] else: oper.append(int(temp)) temp=&quot;&quot; op.append(expression[i]) i+=1 # 마지막에 while문을 저장하지 않고 빠져나오므로 따로 또 저장해줍니다. oper.append(int(temp)) def calcu(oper,op,idx): #idx : 0 -&amp;gt; +, 1 -&amp;gt; -, 2 -&amp;gt; * k = 0 if idx ==0 : while k &amp;lt;len(op): if op[k] ==&quot;+&quot;: first,second = oper[k], oper[k+1] sum = first+second oper[k] = sum del oper[k+1] del op[k] else: k+=1 elif idx==1 : while k &amp;lt; len(op) : if op[k] ==&quot;-&quot;: first,second = oper[k], oper[k+1] sum = first-second oper[k] = sum del oper[k+1] del op[k] else: k+=1 else : while k &amp;lt;len(op): if op[k] ==&quot;*&quot;: first,second = oper[k], oper[k+1] sum = first*second oper[k] = sum del oper[k+1] del op[k] else : k+=1 # 여기서부터는 더 이쁘게 쓸 수 있을 것 같은데 아직 python문법에 미숙하여 직관적으로 썼습니다. # 0 1 2 # 1 2 0 # 2 0 1 for idx1 in range(3): idx2 = (idx1+1) % 3 idx3 = (idx1+2) % 3 copyoper = copy.deepcopy(oper) copyop = copy.deepcopy(op) calcu(copyoper,copyop,idx1) calcu(copyoper,copyop,idx2) calcu(copyoper,copyop,idx3) answer = max(answer,abs(copyoper[0])) # 이것도 마찬가지.. # 2 1 0 # 1 0 2 # 0 2 1 for idx1 in range(2,-1,-1): idx2 = (idx1-1) if idx2 &amp;lt; 0 : idx2 = 2 idx3 = (idx1-2) if idx2 ==0 : idx3 = 2 elif idx3 &amp;lt;0 : idx3 = 1 copyoper = copy.deepcopy(oper) copyop = copy.deepcopy(op) calcu(copyoper,copyop,idx1) calcu(copyoper,copyop,idx2) calcu(copyoper,copyop,idx3) answer = max(answer,abs(copyoper[0])) return answer5. 결과필요시. c++ 짜드리겠습니다." }, { "title": "leetcode(리트코드)5월21일 challenge890-Find and Replace Pattern", "url": "/posts/leetcode_Find_and_Replace_Pattern/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-05-21 06:01:56 +0900", "snippet": "leetcode May 21일 - Find and Replace Pattern 문제입니다.1. 문제https://leetcode.com/problems/find-and-replace-pattern/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.5월 21일자 챌린지 문제입니다.4. 문제 해석 pattern이 주어지고, words가 주어집니다. pattern과 동일하게 반복되는 문자열들을 찾아 결과로 리턴합니다. python은 ASCII로 변환하기 까다롭기에, dictionary 자료형을 사용해야한다는 것을 알았습니다. discuss를 보던 중 zip()함수에 대해 알게 되었습니다. “abc”, “add” 라는 문자열이 zip의 인자로 들어오면 [“a,a”],[“b,d”],[“c,d”]로 묶어줍니다. 5. codepythonclass Solution: def findAndReplacePattern(self, words: List[str], pattern: str) -&amp;gt; List[str]: res =[] def match(word,pattern): if len(word) != len(pattern): return False dir ={} for w,p in zip(word,pattern) : # 만약 dir에 처음 들어온 값인데 if w not in dir : # 이미 p는 어디간에 존재하면 if p in dir.values(): return False dir[w]= p else : # 만약 먼저 들어온 값과 p가 다르면 if dir[w] != p : return False return True for w in words : if match(w,pattern) : res.append(w) return res 6. 결과 및 후기, 개선점필요시 c++로 풀어드립니다.zip()에 대해 알게되었다." }, { "title": "leetcode(리트코드)-67 Add Binary(python)", "url": "/posts/leetcode_Add_Binary/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-05-21 05:34:50 +0900", "snippet": "leetcode 67 - Add Binary 문제입니다.1. 문제https://leetcode.com/problems/add-binary/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.Top Interview 문제입니다.4. 문제 해석 문자열로 들어온 숫자를 binary로 표현되었다고 생각하고 두 숫자를 더한 binary string을 리턴합니다.5. code코드설명pythonclass Solution: def addBinary(self, a: str, b: str) -&amp;gt; str: i = len(a)-1 j = len(b)-1 carry = 0 num = 0 res = &quot;&quot; while i &amp;gt;=0 and j &amp;gt;=0 : sum = int(a[i]) + int(b[j]) + carry carry = int(sum) //2 num = int(sum)%2 res +=str(num) i-=1 j-=1 while i&amp;gt;=0 : sum = int(a[i]) + carry carry = int(sum) //2 num = int(sum)%2 res +=str(num) i-=1 while j&amp;gt;=0: sum = int(b[j]) + carry carry = int(sum) //2 num = int(sum)%2 res +=str(num) j-=1 if carry ==1: res+=&quot;1&quot; return res[::-1]6. 결과 및 후기, 개선점필요시 c++로 짜드리겠습니다." }, { "title": "leetcode(리트코드)-116 Populating Next Right Pointers in Each Node(python)", "url": "/posts/leetcode_Populating_Next_Right_Pointers_in_Each_Node/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Interview", "date": "2021-05-21 04:34:50 +0900", "snippet": "leetcode 116 - Populating Next Right Pointers in Each Node 문제입니다.1. 문제https://leetcode.com/problems/populating-next-right-pointers-in-each-node/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.Top Interview 문제입니다.4. 문제 해석 Node라는 자료형을 가진 트리의 root가 들어옵니다. 해당 트리는 완벽한 이진트리로 주어지며, level이 끝날 때마다 해당 노드의 next값에 ‘#’를 부여하며 level을 돌면 됩니다.5. code코드설명python&quot;&quot;&quot;# Definition for a Node.class Node: def __init__(self, val: int = 0, left: &#39;Node&#39; = None, right: &#39;Node&#39; = None, next: &#39;Node&#39; = None): self.val = val self.left = left self.right = right self.next = next&quot;&quot;&quot;class Solution: def connect(self, root: &#39;Node&#39;) -&amp;gt; &#39;Node&#39;: # 빈 root가 들어올 경우 if not root : return None # BFS를 통해 해결할 것이므로 dq = deque() #res는 더미노드입니다. res = Node() res2 =res dq.append(root) while dq : size = len(dq) #dq의 사이즈만큼 돕니다. for i in range (size) : node = dq.popleft() #자식들을 dq에 넣어줍니다. if node.left : dq.append(node.left) if node.right : dq.append(node.right) res.next = Node(node.val) res = res.next # 마지막의 노드인 경우 이미 &#39;#&#39;으로 이미 지정되어 있으므로 하나의 예외처리를 해줬습니다. if len(dq)!= 0: res.next= Node(&quot;#&quot;) res = res.next return res2.next 6. 결과 및 후기, 개선점필요시 c++로 짜드리겠습니다." }, { "title": "Programmers_월간 코드 챌린지 시즌1 삼격 달팽이(python)", "url": "/posts/Programmers_trangle_snail/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-05-21 02:34:40 +0900", "snippet": "프로그래머스 -삼각 달팽이 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/686452. 분류 및 난이도Programmers 문제입니다.월간 코드 챌린지 시즌1 문제입니다.Level 2난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 2차원 list를 만들어 map을 구현하였습니다. 첫 번째로 row의 좌표를 내리면서 값을 저장하였습니다. 두 번째로 col을 좌표를 올려가면서 값을 저장하였습니다. 세 번째로 row와 col을 1씩 줄이면서 값을 저장하였습니다. 위 세 방법을 max값인 n(n+1)/2 까지 반복하면 됩니다.4. 접근 방법을 적용한 코드def solution(n): answer = [] map = [] for i in range(n) : map.append([]) map[i] = [0] * (i+1) nowx = -1 nowy = 0 max = (n *(n+1))//2 idx = 1 while idx &amp;lt;= max : while nowx+1 &amp;lt; n and map[nowx+1][nowy] ==0 : map[nowx+1][nowy] = idx nowx+=1 idx+=1 while nowy+1 &amp;lt;n and map[nowx][nowy+1]==0: map[nowx][nowy+1] = idx nowy+=1 idx+=1 while nowx-1 &amp;gt;0 and nowy-1 &amp;gt;0 and map[nowx-1][nowy-1] == 0: map[nowx-1][nowy-1] = idx nowx-=1 nowy-=1 idx+=1 for i in range(n): for j in range(len(map[i])): answer.append(map[i][j]) return answer5. 결과필요시. c++ 짜드리겠습니다." }, { "title": "Programmers_월간 코드 챌린지 시즌2 괄호 회전하기(python)", "url": "/posts/Programmers_parentheses_rotate/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-05-21 01:34:40 +0900", "snippet": "프로그래머스 -괄호 회전하기 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/765022. 분류 및 난이도Programmers 문제입니다.월간 코드 챌린지 시즌2 문제입니다.Level 2난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) brute하게 풀었지만, brute하게 접근을 안하는 방법이 있습니다. 올바른 괄호를 찾고 그 괄호에서의 올바른 괄호쌍들의 갯수를 찾아주면 되겠지만, brute하게 풀어도 시간초과가 나지 않으므로 brute하게 해결했습니다.4. 접근 방법을 적용한 코드from collections import dequedef solution(s): answer = 0 for i in range(len(s)): temp = s[i:]+ s[:i] ls = deque() check = True for j in range(len(temp)): ct = temp[j] if ct ==&quot;(&quot; or ct ==&quot;[&quot; or ct ==&quot;{&quot; : ls.append(ct) else : if len(ls) == 0 : check = False break popct = ls.pop() if popct == &quot;(&quot; and ct != &quot;)&quot; : check = False break elif popct ==&quot;{&quot; and ct != &quot;}&quot;: check = False break elif popct ==&quot;[&quot; and ct !=&quot;]&quot;: check = False break if check and len(ls)==0: answer+=1 return answer5. 결과필요시. c++ 짜드리겠습니다." }, { "title": "leetcode(리트코드)5월22일 challenge51-N Queens", "url": "/posts/leetcode_N_queens/", "categories": "leetcode, Hard", "tags": "leetcode, AlgorithmStudy", "date": "2021-05-21 01:01:56 +0900", "snippet": "leetcode May 22일 - N Queens 문제입니다.1. 문제https://leetcode.com/problems/n-queens/2. Input , Output3. 분류 및 난이도Hard 난이도입니다.5월 21일자 챌린지 문제입니다.4. 문제 해석 유명한 N Queens 문제입니다. 대각선으로 겹치지 않게 병사들을 놓을 때 놓을 수 있는 경우의 수를 리턴합니다. 대학교 수업에서 배운 것이 있어서 코드를 가져다 썼습니다.(이해는 잘 못함.)5. codepythonclass Solution: def solveNQueens(self, n: int) -&amp;gt; List[List[str]]: # 너무 깊게 재귀를 하지 않도록 제한을 걸어둡니다. def promising(i,col): k = 0 switch = True while k &amp;lt; i and switch == True : if col[i] == col[k] or abs(col[i] - col[k]) == i -k : switch = False k+=1 return switch def queens(n,i,col,res): if promising(i,col) : if i == n-1 : size = len(res) res.append([]) for j in range(len(col)): resstr = &quot;&quot; find = col[j] for k in range(len(col)): if k ==find : resstr+=&quot;Q&quot; else : resstr+=&quot;.&quot; res[size].append(resstr) else: for j in range(0,n): col[i+1] = j queens(n,i+1,col,res) col = n *[0] res = [] queens(n,-1,col,res) return res 6. 결과 및 후기, 개선점필요시 c++로 풀어드립니다." }, { "title": "leetcode(리트코드)-384 Shuffle an Array(python)", "url": "/posts/leetcode_Shuffle_an_Array/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Interview", "date": "2021-05-20 04:34:50 +0900", "snippet": "leetcode 384 - Shuffle an Array 문제입니다.1. 문제https://leetcode.com/problems/shuffle-an-array/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.Top Interview 문제입니다.4. 문제 해석 배열에 들어오는데, reset()함수는 처음 들어온 배열을 / shuffle()함수는 기존 배열의 요소값들을 랜덤으로 바꿔서 리턴하는 함수를 작성합니다.5. code코드설명pythonclass Solution: def __init__(self, nums: List[int]): self.nums = nums def reset(self) -&amp;gt; List[int]: return self.nums &quot;&quot;&quot; Resets the array to its original configuration and return it. &quot;&quot;&quot; def shuffle(self) -&amp;gt; List[int]: ans = self.nums[:] # copy list for i in range(len(ans)-1, 0, -1): # start from end # i+1 까지의 인덱스 중 하나를 골라 j에 넣습니다. j = random.randrange(0, i+1) # generate random index ans[i], ans[j] = ans[j], ans[i] # swap return ans &quot;&quot;&quot; Returns a random shuffling of the array. &quot;&quot;&quot; # Your Solution object will be instantiated and called as such:# obj = Solution(nums)# param_1 = obj.reset()# param_2 = obj.shuffle()6. 결과 및 후기, 개선점필요시 c++로 짜드리겠습니다." }, { "title": "Programmers_2021 Dev Mathcing 행렬 테두리 회전하기 (python)", "url": "/posts/Programmers_change_border_line/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-05-20 02:34:40 +0900", "snippet": "프로그래머스 -행렬 테두리 회전하기 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/77485#2. 분류 및 난이도Programmers 문제입니다.2021 Dev mathcing 웹 백엔드 개발 문제입니다.Level 2난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 최악의 경우 1,1,100,100 이 만 번의 쿼리가 반복된다면 brute한 접근으로는 터질거라 생각했습니다. 풀고나니 다행스럽게도(?) 이러한 입력은 없는 것 같습니다. 이러한 문제를 해결하기 위해 1가지 방법을 생각해냈습니다. 총 2가지 방법을 생각했습니다. 처음은 메모리를 아끼기 위해 주어진 map에서 모든 것을 처리하여 query에 대한 정보값도 저장하여 효율성을 극대화하려고 했습니다. 이러한 방식은 코드가 너무 복잡할 것 같고, 문제를 해결하기엔 시간을 너무 많이 투자할 것 같았습니다. 2번째 방법은 기존 map에 대한 정보를 담고 있는 copymap을 선언하여, 회전이 끝날 때마다 copymap에 map정보를 갱신해주는 방식입니다. copymap에 회전하지 않은 구간까지 다시 복사하는 것은 시간초과가 나서 회전한 구간만 갱신해주는 코드를 작성하였습니다. 4. 접근 방법을 적용한 코드import copydef solution(rows, columns, queries): answer = [] #map map = [0] * rows idx = 1 for i in range(rows) : map[i] = [0] * columns for j in range(columns) : map[i][j] =idx idx+=1 #python에서 깊은 복사를 하기 위해서는 밑처럼 써야합니다. copymap = copy.deepcopy(map) for i in range(len(queries)): # 문제에서의 좌표는 1,1로 시작하므로 1씩 빼줍니다. x1 = queries[i][0]-1 y1 = queries[i][1]-1 x2 = queries[i][2]-1 y2 = queries[i][3]-1 #print(x1,y1,x2,y2) #step 1 minN = map[x1][y1] for j in range(y1+1,y2+1) : map[x1][j] = copymap[x1][j-1] minN = min(minN,map[x1][j]) #step 2 for j in range(x1+1,x2+1) : map[j][y2] = copymap[j-1][y2] minN = min(minN,map[j][y2]) #step 3 for j in range(y2-1,y1-1,-1): map[x2][j] = copymap[x2][j+1] minN = min(minN,map[x2][j]) #step 4 for j in range(x2-1,x1-1,-1): map[j][y1] = copymap[j+1][y1] minN = min(minN,map[j][y1]) answer.append(minN) #copymap 수정 for j in range(y1,y2+1): copymap[x1][j] = map[x1][j] copymap[x2][j] = map[x2][j] for j in range(x1,x2+1) : copymap[j][y2] = map[j][y2] copymap[j][y1] = map[j][y1] #print(map,copymap) return answer5. 결과필요시. c++ 짜드리겠습니다." }, { "title": "Programmers_2020 카카오 기출 괄호 변환(python)", "url": "/posts/Programmers_trans_parentheses/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-05-20 01:34:40 +0900", "snippet": "프로그래머스 -괄호 변환 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/600582. 분류 및 난이도Programmers 문제입니다.2020 KaKao BLIND RECRUITMENT 문제입니다.Level 2난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 재귀함수를 잘 구현할 수 있는 지 묻는 문제입니다. 과정을 잘 따라가면 어렵지 않습니다. checkstr() 함수는 ‘올바른 괄호인지 확인하는 함수입니다.’ makestr() 함수는 ‘균형잡힌 괄호 2개로 나눠주는 함수입니다.’ reversestr()함수는 ‘괄호들의 방향을 바꿔주는 함수입니다.’ solv()함수는 기본적인 재귀함수입니다.4. 접근 방법을 적용한 코드def checkstr(p): li = [] # stack을 통해 p를 돌면서 괄호의 짝을 확인합니다. for i in range(len(p)): if p[i] == &quot;(&quot;: li.append(&quot;(&quot;) else : if len(li) == 0 : return False li.pop() return Truedef makestr(p): idx = 0 left = 0 right = 0 # p를 돌면서 &#39;(&#39; 갯수와 &#39;)&#39; 갯수가 맞는 최소 구간을 확인합니다. while idx &amp;lt;len(p): if p[idx] == &quot;(&quot; : left += 1 else : right += 1 if left == right : break idx+=1 return p[:left+right] , p[left+right : ]def reversestr(p) : temp = &quot;&quot; for i in range(len(p)): if p[i] ==&quot;(&quot;: temp+=&quot;)&quot; else : temp+=&quot;(&quot; return temp def solv(p): if p ==&quot;&quot;: return &quot;&quot; if checkstr(p): return p u,v = makestr(p) #print(&quot;u : &quot;, u,&quot;v : &quot;,v) if checkstr(u) : resv = u + solv(v) return resv else : temp = &quot;(&quot; temp += solv(v) temp += &quot;)&quot; u = u[1:-1] u = reversestr(u) temp+= u return temp def solution(p): p = solv(p) return p5. 결과필요시. c++ 짜드리겠습니다." }, { "title": "leetcode(리트코드)-189 Rotate Array(python)", "url": "/posts/leetcode_Rotate_Array/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Interview", "date": "2021-05-19 03:34:50 +0900", "snippet": "leetcode 189 - Rotate Array 문제입니다.1. 문제https://leetcode.com/problems/rotate-array/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.Top Interview 문제입니다.4. 문제 해석 k로 들어온 숫자만큼 오른쪽으로 회전(?) 각 요소들을 옮깁니다. discuss에서 나온 방식이 가장 먼저 떠올랐지만, 해당 구문이 python에서 어떤 우선순위를 가지고 처리할 지 몰라서 하나하나 옮기는 식으로 작성하였습니다.5. code코드설명pythonclass Solution: def rotate(self, nums: List[int], k: int) -&amp;gt; None: size = len(nums) k = k%size tempres = copy.deepcopy(nums) print(tempres) for i in range(size): rotate = (i+k) %size nums[rotate] = tempres[i] # dicuss 코드 def rotate2(self, nums, k): n = len(nums) k = k % n nums[:] = nums[n-k:] + nums[:n-k] 6. 결과 및 후기, 개선점동작방식 참고" }, { "title": "leetcode(리트코드)5월19일 challenge462-Minimum Moves to Equal Array Elements II", "url": "/posts/leetcode_Minimum_Moves_to_Equal_Array_Elements_II/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-05-19 01:01:56 +0900", "snippet": "leetcode May 19일 - Minimum Moves to Equal Array Elements II 문제입니다.1. 문제https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.5월 19일자 챌린지 문제입니다.4. 문제 해석 nums가 들어옵니다. 하나의 요소를 잡아 다른 요소들을 해당 요소로 바꾸는데 드는 최소 비용을 리턴하세요. 한 요소를 1을 더하거나 뺄 수 있습니다.5. codepythonclass Solution: def minMoves2(self, nums: List[int]) -&amp;gt; int: nums.sort() size = len(nums) pick = nums[size//2] res = 0 for i in range(size) : res += abs(nums[i] - pick) return res6. 결과 및 후기, 개선점필요시 c++로 풀어드립니다." }, { "title": "leetcode(리트코드)5월18일 challenge609-Find Duplicate File in System", "url": "/posts/leetcode_Find_Duplicate_File_in_System/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-05-18 04:01:56 +0900", "snippet": "leetcode May 18일 - Find Duplicate File in System 문제입니다.1. 문제https://leetcode.com/problems/find-duplicate-file-in-system/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.5월 18일자 챌린지 문제입니다.4. 문제 해석 paths가 주어집니다. “()” 안에 있는 것을 기준으로 주어진 값들을 나눠 리턴해야 합니다. 예를 들어서 “~1.txt(abcd), ~3.txt(abcd)”인 경우 같은 abcd이므로 묶고, 마찬가지로 예제의 (efgh)도 위와같은 방식으로 해결하면 됩니다. 단, 단 하나로 묶어질 경우 결과값에 포함하지 않습니다. dictionary 자료형을 이용하여, 묶고 풀었습니다.5. codepythonclass Solution: def findDuplicate(self, paths: List[str]) -&amp;gt; List[List[str]]: dic = {} res = [] for i in range(len(paths)): direction = paths[i].split() #root directory root = direction[0] for j in range(1,len(direction)) : temp = direction[j] name = root +&quot;/&quot; + temp[:temp.find(&quot;(&quot;)] content = temp[temp.find(&quot;(&quot;)+1 : temp.find(&quot;)&quot;)] if content not in dic : tlist = [] tlist.append(name) dic[content] = tlist else : dic[content].append(name) for i in dic : if len(dic[i])&amp;gt;=2 : res.append(dic[i]) return res6. 결과 및 후기, 개선점필요시 c++로 풀어드립니다." }, { "title": "Programmers_2개 이하로 다른 비트(python)", "url": "/posts/Programmers_diff_two_bit/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-05-18 02:34:40 +0900", "snippet": "프로그래머스 -2개 이하로 다른 비트 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/77885#2. 분류 및 난이도Programmers 문제입니다.월간 코드 챌린지 시즌2 문제입니다.Level 2난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 규칙을 찾아야하는 문제입니다. 질문하기에서 힌트를 얻어 작성하였습니다. ‘11011’ 이라는 숫자가 있으면 0이 처음으로 나오는 곳을 찾아 2진수로 만듭니다. -&amp;gt; ‘00100’ 그리고 그 보다 하나 오른쪽으로 쉬프트한 값 ‘00010’의 차이만큼 더해주면 값이 나옵니다.4. 접근 방법을 적용한 코드def solution(numbers): answer = [] for i in range(len(numbers)): num = numbers[i] cnt = 0 while 1: if (num &amp;amp; 1 &amp;lt;&amp;lt;cnt) ==0 : break cnt+=1 if cnt != 0 : num = num + ((1&amp;lt;&amp;lt;cnt)) - (1&amp;lt;&amp;lt;(cnt-1)) #끝자리가 0인 경우 1만 더하면 된다. else : num += 1 answer.append(num) return answer5. 결과필요시. c++ 짜드리겠습니다." }, { "title": "Programmers_프렌즈 4블록(python)", "url": "/posts/Programmers_friend_fourblock/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-05-18 01:34:40 +0900", "snippet": "프로그래머스 -프렌즈 4블록 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/176792. 분류 및 난이도Programmers 문제입니다.2019 KaKao BLIND RECRUITMENT 문제입니다.Level 2난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 구현 문제입니다. 문제를 읽어보면 2*2인 경우에만 지워줘야합니다.(4개 이상의 인접한 모든 것이 아님.) set을 이용하여 중복 좌표값을 제거하기로 했습니다. python에 익숙하지 않아 코드가 많이 더럽습니다. 특히.. 문자열 지우기.4. 접근 방법을 적용한 코드from collections import dequedef solution(m, n, board): answer = 0 row = len(board) col = len(board[0]) #dx,dy는 대각선, 오른쪽, 아래를 검사하기 위한 좌표값입니다. dx = [0,1,1] dy = [1,0,1] st = set() # check 변수는 단 한번이라도 지워지는 블록이 있는 지 검사하는 변수입니다. check =0 while check == 0 : check = 1 for i in range(row) : for j in range(col): # 공백인 경우 무시 if board[i][j] != &quot; &quot;: counting = 1 tempst = set() tempst.add((i,j)) for k in range(3): newx = i + dx[k] newy = j + dy[k] if 0&amp;lt;= newx and newx &amp;lt; row and 0&amp;lt;=newy and newy &amp;lt; col and board[i][j] == board[newx][newy]: tempst.add((newx,newy)) counting +=1 # 하나라도 조건에 만족하지 않으면 빠져 나옵니다. else : break # for문을 완벽하게 돌았으면 set에 좌표값을 저장합니다. if counting == 4: templist = list(tempst) for k in range(len(templist)): x,y = templist[k] st.add((x,y)) # 저장된 좌표 값이 있으면 하나씩 빼면서 해당 좌표를 공백으로 만듭니다. while st : check = 0 x,y = st.pop() board[x] = board[x][:y] + &quot; &quot; + board[x][y+1:] answer += 1 # board 초기화 for i in range(row-1,-1,-1) : for j in range(col-1,-1,-1) : if board[i][j] == &quot; &quot;: tempx = i-1 #print(i,j,tempx) while tempx &amp;gt;=0 and board[tempx][j] == &#39; &#39;: tempx-=1 if tempx &amp;gt;=0 : ct = board[tempx][j] board[i] = board[i][:j] + ct + board[i][j+1:] board[tempx] = board[tempx][:j] + &quot; &quot; + board[tempx][j+1:] return answer5. 결과필요시. c++ 짜드리겠습니다." }, { "title": "Programmers_2019 카카오 인턴십 튜플", "url": "/posts/Programmers_Tuple/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-05-17 02:34:40 +0900", "snippet": "프로그래머스 -튜플 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/640652. 분류 및 난이도Programmers 문제입니다.2019 KaKao 개발자 겨울 인턴십 문제입니다.Level 2난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 문자열로 들어오고, 입력이 백만자까지, 튜플의 크기는 최대 10만, 튜플 속의 원소의 크기는 최대 500 이기에, 하나의 for문으로 해결해야 한다고 생각했습니다. 문자열을 돌면서 정수값을 기준으로 dictionary에 값을 넣으면서 카운트를 세주고, 가장 많이 세진 정수값을 기준으로 정렬을 해줍니다. 정렬된 값을 순서대로 answer 리스트에 넣어주면 해결할 수 있습니다.4. 접근 방법을 적용한 코드def solution(s): answer = [] dic ={} # 문자열을 돌기위한 index(idx) idx = 0 while idx &amp;lt; len(s) : # temp에 숫자들을 저장해줍니다. temp = &#39;&#39; while s[idx].isdigit(): temp += s[idx] idx +=1 # 만약 temp에 숫자가 들어갔으면 숫자로 바꿔주고 dictionary에 넣어줍니다. if temp!=&#39;&#39; : temp = int(temp) if temp not in dic : dic[temp] = 1 else: dic[temp] +=1 # 숫자가 들어가지 않았으면, else: idx+=1 # 역순으로 정렬해줍니다. res = sorted(dic.items(),key = (lambda x:x[1]),reverse = True) for i in range(len(res)): answer.append(res[i][0]) return answer5. 결과필요시. c++ 짜드리겠습니다." }, { "title": "Programmers_2019 카카오 오픈 채팅방", "url": "/posts/Programmers_OpenChat/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-05-17 01:34:40 +0900", "snippet": "프로그래머스 -오픈 채팅방 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/42888#2. 분류 및 난이도Programmers 문제입니다.2019 KaKao Blind Recuritment 문제입니다.Level 2난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 채팅방의 로그를 찍어서 나중에 뿌려줍니다. Enter, Leave, Change 3가지 상태가 주어지는데, Enter와 Leave의 경우 로그에 찍으면 되고, Change인 경우 채팅방의 닉네임을 바꿔줘야합니다. 마지막의 로그들이 중요하기에(마지막에 이름을 바꾸는 게 중요하므로) record의 맨 끝에서 처음으로 접근하는 방식으로 코드를 작성하였으나, Runtime Error가 떠서 처음부터 접근하는 for문을 2번 작성하였습니다.4. 접근 방법을 적용한 코드def solution(record): # 정답 answer = [] dic = {} # 로그 log =[] for i in range(len(record)): # &quot; &quot;를 기준으로 분리합니다. query = record[i].split(&quot; &quot;) # Leave가 아닌경우, dic에 중복값을 없애주기 위해 저장해줍니다. if(query[0] != &quot;Leave&quot;) : dic[query[1]] = query[2] # Enter나 Leave인 경우 log list에 id와 심볼을 저장합니다. if(query[0] == &quot;Enter&quot;) : log.append((query[1],&quot;E&quot;)) elif(query[0] ==&quot;Leave&quot;) : log.append((query[1],&quot;L&quot;)) # log를 돌면서 answer에 맞는 답안으로 바꿔줍니다. for i in range(len(log)): if log[i][1]==&quot;E&quot;: answer.append(dic[log[i][0]] + &quot;님이 들어왔습니다.&quot;) else: answer.append(dic[log[i][0]] + &quot;님이 나갔습니다.&quot;) return answer5. 결과필요시. c++ 짜드리겠습니다." }, { "title": "Programmers_2020카카오 문자열 압축 Python", "url": "/posts/Programmers_String_Compression/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-05-16 04:34:40 +0900", "snippet": "프로그래머스 -문자열 압축 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/60057?language=python3#2. 분류 및 난이도Programmers 문제입니다.2020 KaKao Blind Recuritment 문제입니다.Level 2난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 문제 내용 자체는 어렵지 않습니다. 연속된 경계를 검사해줘야합니다. 저는 list에 자른 값들을 저장해 놓고 하나씩 꺼내어 비교해가는 방법을 사용했습니다. 비교를 편하게 하기 위해 마지막에 더미 값을 하나 집어넣었습니다.4. 접근 방법을 적용한 코드def solution(s): answer = len(s) #반 이상 넘어갈 일이 없습니다. for i in range(1,len(s)//2+1): list = [] # 1개 ~ 문자열의 길이 반 만큼 자르고 list에 넣습니다. for j in range(i,len(s)+1,i): list.append(s[j-i:j]) # 만약 다음 값이 범위를 벗어난 경우 마지막 값을 추가해줍니다. if j+i &amp;gt; len(s) : list.append(s[j:]) # 더미 노드를 넣습니다. if(list[:-1] != &#39;&#39;) : list.append(&#39;&#39;) #print(list) #반복되는 값을 저장하기 위한 변수입니다. countnum = 1 #자릿수마다 나오는 값을 임시로 저장하기 위한 변수입니다. tempres = 0 # list를 돕니다. for j in range(1,len(list)): # 만약 반복되는 값이라면 count값을 늘려줍니다. if list[j] == list[j-1] : countnum+=1 else: #print(&quot;else&quot;,j,list[j-1]) # 1인 경우는 생략해야하므로 자릿수를 더하지 않습니다. if countnum == 1: tempres += len(list[j-1]) else: #자릿수를 계산하기 위해 string으로 바꿔줍니다. temp = str(countnum) # 자릿수와 자른 문자열의 크기를 더해갑니다. tempres += (len(temp) +len(list[j-1])) # 초기화 해줍니다. countnum=1 #print(i, tempres) # 값을 갱신해줍니다. answer = min(tempres,answer) return answer5. 결과필요시. c++ 짜드리겠습니다." }, { "title": "Programmers_멀쩡한 사각형", "url": "/posts/Programmers_complete_rect/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-05-16 03:34:40 +0900", "snippet": "프로그래머스 -멀쩡한 사각형 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/620482. 분류 및 난이도Programmers 문제입니다.Summer / Winter Coding(2019) 문제입니다.Level 2난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 문제는 직관적으로 어렵지 않습니다. 입력이 최대 1억씩 들어오므로 DP로 푸는 것은 불가능 하다고 생각했습니다. 따라서 정해진 공식이 있을 것인데, 문제를 보면 2,3를 기준으로 꼭지점을 지납니다. 따라서 2와 3의 배수인 8,12 는 완벽하게 꼭지점을 통과하게됩니다.(4,6) , (6,9) 를 거쳐서 2,3를 기준으로 4개의 블럭을 못 쓰는데, 이는 w + h - 1 공식에 따라 4개로 지정됩니다. 이에 대한 설명은 https://velog.io/@ajufresh/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%A9%80%EC%A9%A1%ED%95%9C-%EC%82%AC%EA%B0%81%ED%98%95-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4-Java 이 블로그를 참고하였습니다. 따라서 2,3 를 기준으로 최대공약수를 구해 그만큼 또 곱해주면 사용할 수 없는 블럭의 갯수를 구할 수 있습니다.4. 접근 방법을 적용한 코드# 유클리드 호제법def gcd(m,n): while n != 0: t = m%n (m,n) = (n,t) return abs(m)def solution(w,h): gcdnum =gcd(w,h) answer = w * h - ((w //gcdnum + h//gcdnum - 1) * gcdnum) return answer5. 결과필요시. c++ 짜드리겠습니다." }, { "title": "Programmers_약수의 개수와 덧셈 python", "url": "/posts/Programmers_sosucount_add/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-05-16 02:34:40 +0900", "snippet": "프로그래머스 -약수의 개수와 덧셈 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/77884#2. 분류 및 난이도Programmers 문제입니다.월간 코드 챌린지 시즌 2 문제입니다.Level 1난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 문제는 직관적으로 어렵지 않습니다. 에라토스테네스의 체를 변형하여 코드를 작성하였습니다.4. 접근 방법을 적용한 코드import mathdef solution(left, right): #에라토스테네스의 체 변형 maxnum = right+1 tenes = [1] * maxnum res = 0 for i in range(2,maxnum): tenes[i] +=1 for i in range(2,maxnum//2+1) : for j in range(2*i,maxnum,i): tenes[j] += 1 for i in range (left,maxnum) : if tenes[i] %2 == 1 : res -= i else : res += i return res5. 결과필요시. c++ 짜드리겠습니다." }, { "title": "leetcode(리트코드)5월15일 challenge65-Valid Number", "url": "/posts/leetcode_Valid_Number/", "categories": "leetcode, Hard", "tags": "leetcode, AlgorithmStudy", "date": "2021-05-15 11:01:56 +0900", "snippet": "leetcode May 15일 - Valid Number 문제입니다.1. 문제https://leetcode.com/problems/valid-number/2. Input , Output3. 분류 및 난이도Hard 난이도입니다.5월 15일자 챌린지 문제입니다.4. 문제 해석 들어온 string이 숫자로 표현될 수 있는 지 확인합니다. 모든 경우의 수를 따져야해서 bad가 많은 문제 입니다.(창의성이 없어서 그런 듯.)5. codepythonclass Solution: def isNumber(self, s: str) -&amp;gt; bool: s = s.strip() numberS = False eS = False pointS = False numberAE = True for i in range(len(s)): if s[i]&amp;gt;=&quot;0&quot; and s[i] &amp;lt;=&quot;9&quot; : numberS = True numberAE = True elif s[i] == &quot;.&quot;: if eS or pointS : return False pointS = True elif s[i] == &quot;e&quot; or s[i] == &quot;E&quot;: if eS or not numberS : return False numberAE = False eS = True elif s[i] ==&quot;-&quot; or s[i] ==&quot;+&quot; : if i != 0 and s[i-1] !=&quot;e&quot; : return False else: return False return numberS and numberAE6. 결과 및 후기, 개선점나중에 다시 풀 것." }, { "title": "leetcode(리트코드)-130 Surrounded Regions(python)", "url": "/posts/leetcode_Surrounded_Regions/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Interview", "date": "2021-05-15 10:34:50 +0900", "snippet": "leetcode 130 - Surrounded Regions 문제입니다.1. 문제https://leetcode.com/problems/surrounded-regions/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.Top Interview 문제입니다.4. 문제 해석 board가 주어집니다. 해당 board에서 ‘X’로 둘러쌓인 ‘O’를 전부 ‘X’로 바꿔서 리턴합니다.5. code코드설명 경계선과 이어진 ‘O’를 찾아서 체크해줍니다. 맵 안에서 서로 이어진 ‘O’들은 어차피 ‘X’로 바꿔지기 때문입니다. 체크된 값은 ‘O’로 아닌 값은 ‘X’로 바꿔 정답을 리턴합니다.pythonfrom collections import dequeclass Solution: def solve(self, board: List[List[str]]) -&amp;gt; None: res = board row = len(board) col = len(board[0]) v = [0] * row for i in range(row): v[i] = [0] * col queue = deque() dx = [-1,0,1,0] dy = [0,-1,0,1] for i in range (col) : if board[0][i] == &#39;O&#39;: queue.append([0,i]) if board[row-1][i] ==&#39;O&#39;: queue.append([row-1,i]) for i in range (row): if board[i][0] == &#39;O&#39; : queue.append([i,0]) if board[i][col-1] ==&#39;O&#39;: queue.append([i,col-1]) while queue : x,y = queue.popleft() v[x][y] = 1 for i in range(4) : newX,newY = x + dx[i], y+dy[i] if 0&amp;lt;=newX and newX &amp;lt;row and 0&amp;lt;=newY and newY&amp;lt;col and v[newX][newY] == 0 and board[newX][newY] ==&#39;O&#39;: v[newX][newY] = 1 queue.append([newX,newY]) for i in range(row) : for j in range(col): if v[i][j] == 0 : res[i][j] = &#39;X&#39; else : res[i][j] = &#39;O&#39; return res &quot;&quot;&quot; Do not return anything, modify board in-place instead. &quot;&quot;&quot; 6. 결과 및 후기, 개선점python 45% 140ms" }, { "title": "leetcode(리트코드)5월12일 challenge304-Range Sum Query 2D Immutable", "url": "/posts/leetcode_Range_Sum_Query_2D_-_Immutable/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-05-12 11:01:56 +0900", "snippet": "leetcode May 12일 - Range Sun Query 2D Immutable 문제입니다.1. 문제https://leetcode.com/problems/range-sum-query-2d-immutable/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.5월 12일자 챌린지 문제입니다.4. 문제 해석 주어진 matrix에서 row1 ~ row2, col1 ~ col2 까지의 합을 구하는 것입니다. brute하게 풀면 시간초과가 떠서 다른 방법으로 풀어야합니다. Discuss에서 잘 정리된 설명이 있습니다.https://leetcode.com/problems/range-sum-query-2d-immutable/discuss/75350/Clean-C%2B%2B-Solution-and-Explaination-O(mn)-space-with-O(1)-time5. codec++class NumMatrix {public: int row,col; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; sums; NumMatrix(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix) { row = matrix.size(); col = matrix[0].size(); sums = vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;(row+1,vector&amp;lt;int&amp;gt;(col+1,0)); for(int i =1 ; i &amp;lt;=row;++i){ for(int j =1 ; j&amp;lt;=col;++j){ sums[i][j] = matrix[i-1][j-1] + sums[i-1][j] + sums[i][j-1] - sums[i-1][j-1]; } } } int sumRegion(int row1, int col1, int row2, int col2) { return sums[row2+1][col2+1] - sums[row2+1][col1] - sums[row1][col2+1] + sums[row1][col1]; }};/** * Your NumMatrix object will be instantiated and called as such: * NumMatrix* obj = new NumMatrix(matrix); * int param_1 = obj-&amp;gt;sumRegion(row1,col1,row2,col2); */6. 결과 및 후기, 개선점나중에 다시 풀 것." }, { "title": "leetcode(리트코드)-454 4Sum II", "url": "/posts/leetcode_4Sum_II/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Interview", "date": "2021-05-12 10:34:50 +0900", "snippet": "leetcode 454 - 4Sum II 문제입니다.1. 문제https://leetcode.com/problems/4sum-ii/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.Top Interview 문제입니다.4. 문제 해석 벡터 4개가 들어옵니다. 4개의 벡터에서 요소를 하나씩 골라, 더한 값이 0이되는 경우의 수를 구해 리턴합니다.5. code코드설명 O(n^4)로 풀면 효율성 문제가 나므로, O(2*n^2)의 시간복잡도로 해결합니다.c++class Solution {public: int fourSumCount(vector&amp;lt;int&amp;gt;&amp;amp; nums1, vector&amp;lt;int&amp;gt;&amp;amp; nums2, vector&amp;lt;int&amp;gt;&amp;amp; nums3, vector&amp;lt;int&amp;gt;&amp;amp; nums4) { unordered_map&amp;lt;int,int&amp;gt; um; for(auto a : nums1){ for(auto b : nums2){ um[a+b]++; } } int res = 0 ; for(auto c : nums3){ for(auto d : nums4){ //만약에 반대쌍인 경우가 있으면, auto it = um.find(0 - c - d); if(it!=um.end()){ //중복을 고려 res += it-&amp;gt;second; } } } return res; }};6. 결과 및 후기, 개선점c++ 61% 4ms" }, { "title": "Programmers_예상 대진표", "url": "/posts/Programmers_Expected_Competition/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-05-10 02:34:40 +0900", "snippet": "프로그래머스 -예상 대진표 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/129852. 분류 및 난이도Programmers 문제입니다.2017 팁스타운 문제입니다.Level 2난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 문제는 직관적으로 어렵지 않습니다. A가 B보다 클 수 있다는 사실을 간과하여 시간이 좀 걸렸습니다.4. 접근 방법을 적용한 코드def solution(n,a,b): answer = 1 if a&amp;gt; b: a,b = b,a while 1 : print(a,b) if a%2 ==1 and b%2 ==0 and a+1 == b : return answer a = (a+1)//2 b = (b+1)//2 answer+=1 return answer5. 결과필요시. c++ 짜드리겠습니다." }, { "title": "leetcode(리트코드)5월10일 challenge204-Count Primes", "url": "/posts/leetcode_Count_Primes/", "categories": "leetcode, Eazy", "tags": "leetcode, AlgorithmStudy", "date": "2021-05-10 02:01:56 +0900", "snippet": "leetcode May 10일 - Count Primes 문제입니다.1. 문제https://leetcode.com/problems/count-primes/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.5월 10일자 챌린지 문제입니다.4. 문제 해석 n으로 들어온 자연수값의 약수 개수를 구해서 리턴합니다.5. code에라토스테네스의 체를 이용하면 쉽게 풀 수 있습니다.c++class Solution {public: int countPrimes(int n) { //에라토스테네스의 체 if(n==0 || n==1) return 0; int* dp = new int[n+1]; int res = 0; dp[0] = 0; dp[1] =0; for(int i = 2 ; i&amp;lt; n+1;++i) dp[i] = i; for(int i = 2; i&amp;lt;sqrt(n+1); ++i){ if(dp[i] == 0) continue; for(int j = i*2 ; j&amp;lt;n+1 ; j +=i) dp[j]=0; } for(int i = 2;i&amp;lt;n;++i) if(dp[i]!=0) ++res; return res; }};6. 결과 및 후기, 개선점" }, { "title": "Programmers_방문 길이", "url": "/posts/Programmers_LengthofDirection/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-05-07 13:34:40 +0900", "snippet": "프로그래머스 -방문 길이 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/499942. 분류 및 난이도Programmers 문제입니다.연습문제 입니다.Level 2난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) BFS로 풀면 간단하게 풀것이라 생각했지만, 위에서 들어오는 경우, 밑에서 들어오는 경우가 각각 다른경우로 계산해야하기 때문에 그 부분에서 애먹었습니다. 다른 사람들의 코드를 참고하여 4차원 배열을 썼는데 [fromx][fromy][tox][toy] 로 이해하시면 됩니다.4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;iostream&amp;gt;using namespace std;int findx(char dir){ if(dir ==&#39;U&#39;) return -1; else if(dir ==&#39;L&#39; || dir ==&#39;R&#39;) return 0; else return 1;}int findy(char dir){ if(dir ==&#39;U&#39; || dir ==&#39;D&#39;) return 0; else if(dir == &#39;L&#39;) return -1; else return 1;}int solution(string dirs) { bool map[11][11][11][11]={0,}; int startx = 5,starty = 5; int idx = 0 ; int answer = 0; queue&amp;lt;pair&amp;lt;int,int&amp;gt;&amp;gt; q; q.push(make_pair(startx,starty)); while(idx &amp;lt; dirs.size()){ int x = q.front().first; int y = q.front().second; q.pop(); int newX = x + findx(dirs[idx]); int newY = y + findy(dirs[idx]); if(0&amp;lt;=newX &amp;amp;&amp;amp; newX &amp;lt;11 &amp;amp;&amp;amp; 0&amp;lt;=newY &amp;amp;&amp;amp; newY&amp;lt;11 ){ if(!map[x][y][newX][newY]){ map[x][y][newX][newY] = true; map[newX][newY][x][y] = true; ++answer; } q.push(make_pair(newX,newY)); } else q.push(make_pair(x,y)); ++idx; } return answer;}5. 결과필요시. python로 짜드리겠습니다." }, { "title": "leetcode(리트코드)5월11일 challenge1423-Maximum Points You Can Obtain from Cards", "url": "/posts/leetcode_Maximum_Points_You_Can_Obtain_from_Cards/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-05-07 13:12:56 +0900", "snippet": "leetcode May 11일 - Maximum Points You Can Obtain from Cards 문제입니다.1. 문제https://leetcode.com/problems/maximum-points-you-can-obtain-from-cards/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.5월 11일자 챌린지 문제입니다.4. 문제 해석 cardPoints라는 벡터가 들어옵니다. 맨 뒤와 맨 앞 중 골라 k만큼 뽑았을 때 그 포인트의 합계가가 가장 클 때의 값을 리턴합니다.5. code1,2,3,4,5,6,1 기준으로 k가 3일때 맨앞에서 부터 더하면 1,2,3,x,x,x,x 입니다.3을 제외하고 뒤에있는 1을 뽑은 경우 1,2,x,x,x,x,1 인 경우가 됩니다.같은 방식으로 2를 제외하고 뒤에 있는 6을 뽑으면 1,x,x,x,x,6,1인 경우가 되고 마찬가지로x,x,x,x,5,6,1 을 뽑은 이 경우가 최선의 답이므로 리턴합니다.우선순위 큐를 이용해서 값이 큰 것을 자동으로 큐 앞에 넣어 해당 값을 리턴하도록 작성하였습니다.c++class Solution {public: int maxScore(vector&amp;lt;int&amp;gt;&amp;amp; cardPoints, int k) { int ans = 0 ; for(int i = 0 ; i &amp;lt; k; ++i){ ans += cardPoints[i]; } if(k == cardPoints.size()) return ans; int pick = 1; int right = cardPoints.size()-1; priority_queue&amp;lt;int&amp;gt; pq; pq.push(ans); while(pick &amp;lt;= k){ ans -= cardPoints[k - pick] ; ans += cardPoints[right--]; ++pick; pq.push(ans); } return pq.top(); }};6. 결과 및 후기, 개선점" }, { "title": "leetcode(리트코드)5월7일 challenge583-Delete Operation for Two Strings", "url": "/posts/leetcode_Delete_Operation_for_Two_Strings/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-05-07 13:12:56 +0900", "snippet": "leetcode May 7일 - Delete Operation for Two Strings 문제입니다.1. 문제https://leetcode.com/problems/delete-operation-for-two-strings/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.5월 7일자 챌린지 문제입니다.4. 문제 해석 두개의 string이 주어집니다. word1에서 word2로 넘어가기 위해 문자를 삭제, 삽입할 수 있는데 최소한의 연산을 사용해야합니다. 최소한의 연산을 사용했을 때 그 갯수를 리턴합니다.5. codeLCS를 통해 공통 부분 문자열을 찾아 해당 문자열로 만드는 과정 (word1 - DP[m][n]&amp;lt;- LCS) + word2 -DP[m][n] &amp;lt;-LCS LCS를 word2로 만드는 과정을 코드로 담았습니다.c++class Solution {public: int minDistance(string word1, string word2) { //LCS int size1 = word1.size(); int size2 = word2.size(); int** DP = new int*[size1+1]; for(int i = 0 ; i&amp;lt;=size1;++i) DP[i] = new int[size2+1]; for(int i = 0 ; i &amp;lt;=size1;++i) DP[i][0] = 0; for(int j = 0 ; j &amp;lt;=size2;++j) DP[0][j] = 0; for(int i = 1 ; i &amp;lt;=size1;++i){ for(int j = 1 ; j &amp;lt;=size2;++j){ if(word1[i-1] == word2[j-1]) DP[i][j] = DP[i-1][j-1] + 1; else DP[i][j] = max(DP[i-1][j],DP[i][j-1]); } } return size1 + size2 - (DP[size1][size2] *2); }};6. 결과 및 후기, 개선점" }, { "title": "Programmers_게임 맵 최단거리", "url": "/posts/Programmers_find_mindirections/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-05-07 06:05:40 +0900", "snippet": "프로그래머스 -게임 맵 최단거리 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/1844?language=cpp2. 분류 및 난이도Programmers 문제입니다.찾아라 프로그래밍 마에스터 문제입니다.Level 2난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) BFS나 DFS로 풀면 되는데, python으로는 해결이 안되어서.. 왜인지 모르게 그래서 c++로 풀었습니다.4. 접근 방법을 적용한 코드#include&amp;lt;vector&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;int dx[4] = {0,1,0,-1};int dy[4] = {1,0,-1,0};int solution(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; maps){ int answer = 1234567; int row = maps.size(); int col = maps[0].size(); bool v[101][101] = {false,}; queue&amp;lt;pair&amp;lt;pair&amp;lt;int,int&amp;gt;,int&amp;gt;&amp;gt; q; q.push(make_pair(make_pair(0,0),1)); v[0][0] = true; while(!q.empty()){ int x = q.front().first.first; int y = q.front().first.second; int count = q.front().second; if(x == row-1 &amp;amp;&amp;amp; y ==col-1) answer = min(answer,count); q.pop(); for(int k = 0 ; k &amp;lt;4;++k){ int newX = x + dx[k]; int newY = y + dy[k]; if(0&amp;lt;=newX &amp;amp;&amp;amp; newX &amp;lt;row &amp;amp;&amp;amp; 0&amp;lt;=newY &amp;amp;&amp;amp; newY&amp;lt;col &amp;amp;&amp;amp; !v[newX][newY] &amp;amp;&amp;amp; maps[newX][newY]==1){ v[newX][newY] =true; q.push(make_pair(make_pair(newX,newY),count+1)); } } } if(answer != 1234567) return answer; else return -1;}python(안되는 코드 로직은 같은데 why?..)from collections import dequedx = [0,1,0,-1];dy = [1,0,-1,0];def solution(maps): answer = 12345678 q = deque() q.appendleft([0,0,1]) row = len(maps) col = len(maps[0]) v = [0] * 101 for i in range(101): v[i] = [0]*101 v[0][0]=1 while q: x,y,count = q.popleft() if x == row-1 and y == col-1 : answer = min(answer,count) for i in range (len(dx)): newX = x + dx[i] newY = y +dy[i] if 0&amp;lt;= newX and newX&amp;lt;row and 0&amp;lt;= newY and newY &amp;lt; col and v[newX][newY] != 1 and maps[newX][newY] == 1 : v[newX][newY] = 1 count += 1 q.append([newX,newY,count]) if answer != 12345678 : return answer else : return -15. 결과python코드 왜 안되는 지 아시는 분?.." }, { "title": "Programmers_이진 변환 반복하기", "url": "/posts/Progammers_binaryconvert/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-05-07 04:34:40 +0900", "snippet": "프로그래머스 -이진 변환 반복하기 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/701292. 분류 및 난이도Programmers 문제입니다.월간 코드 챌린지 시즌 1 문제입니다.Level 2난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) Greedy하게 접근하면 어렵지 않은 문제입니다.4. 접근 방법을 적용한 코드# 2진수로 바꾸는 함수def makestr(onecount) -&amp;gt; str: str = &quot;&quot; while onecount != 0: if onecount%2 == 0 : str += &quot;0&quot; else: str += &quot;1&quot; onecount//=2 #역순으로 들어갔으므로 역순으로 다시 리턴 return str[::-1]def solution(s): answer = [] # 삭제된 0의 갯수 zerocount = 0 #삭제시킨 횟수 total = 0 while s != &quot;1&quot; : onecount = s.count(&#39;1&#39;) zerocount += (len(s) - onecount) s = makestr(onecount) total += 1 answer.append(total) answer.append(zerocount) return answer5. 결과필요시. c++ 짜드리겠습니다." }, { "title": "Programmers_쿼드압축 후 개수 세기", "url": "/posts/Programmers_Quad_zip/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-05-07 02:34:40 +0900", "snippet": "프로그래머스 -쿼드압축 후 개수 세기 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/689362. 분류 및 난이도Programmers 문제입니다.월간 코드 챌린지 시즌 1 문제입니다.Level 2난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 쿼드 압축은 대표적인 재귀문제 중 하나로 방식을 이해하고 있으면 어렵지 않게 해결할 수 있습니다. 저는 방식을 잘 몰라서 참고하였습니다.4. 접근 방법을 적용한 코드one = 0zero = 0def solve(curX, curY,length,arr): global zero,one check = True ch = arr[curX][curY] if length == 1 : check = True else : for i in range(length): for j in range(length): if ch != arr[curX+i][curY+j] : check = False break if not check : break if check : if ch == 0 : zero += 1 else : one +=1 else : templ = int(length/2) solve(curX,curY,templ,arr) solve(curX,curY + templ,templ, arr) solve(curX + templ, curY ,templ,arr) solve(curX + templ, curY + templ ,templ,arr)def solution(arr): answer = [] solve(0,0,len(arr),arr) answer.append(zero) answer.append(one) return answer5. 결과필요시. python로 짜드리겠습니다." }, { "title": "Programmers_올바른 괄호", "url": "/posts/Programmers_Correct_parentheses/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-05-06 13:32:40 +0900", "snippet": "프로그래머스 -올바른 괄호 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/129092. 분류 및 난이도Programmers 문제입니다.연습문제 입니다.Level 2난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 스택을 이용하면 간단하게 풀 수 있습니다.4. 접근 방법을 적용한 코드from collections import dequedef solution(s): stack = deque() for i in range (len(s)): if s[i] ==&#39;(&#39;: stack.append(&#39;(&#39;) else : if len(stack) == 0 : return False stack.popleft() if stack : return False return True5. 결과필요시. c++로 짜드리겠습니다." }, { "title": "leetcode(리트코드)5월6일 challenge109-Convert Sorted List to Binary Search Tree", "url": "/posts/leetcode_Convert_Sorted_List_to_Binary_Search_Tree/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-05-06 12:17:56 +0900", "snippet": "leetcode May 6일 - Convert Sorted List to Binary Search Tree 문제입니다.1. 문제https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.5월 6일자 챌린지 문제입니다.4. 문제 해석 오름차순으로 정렬된 List가 들어옵니다. 해당 리스트를 통해 높이가 균등한 Binary Tree를 제작합니다. Discuss를 참조하였습니다.5. code핵심 코드는 List의 중간 노드를 찾아서 root노드로 만들어 left와 right에 붙여주는 것을 반복하는 것입니다.c++/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; *//** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: TreeNode* BST(ListNode* head, ListNode* tail){ ListNode* fast = head; ListNode* slow = head; if(head == tail) return nullptr; while(fast != tail &amp;amp;&amp;amp; fast-&amp;gt;next !=tail){ fast = fast-&amp;gt;next-&amp;gt;next; slow = slow-&amp;gt;next; } TreeNode* root = new TreeNode(slow-&amp;gt;val); root-&amp;gt;left = BST(head,slow); root-&amp;gt;right = BST(slow-&amp;gt;next,tail); return root; } TreeNode* sortedListToBST(ListNode* head) { if(head==nullptr) return nullptr; return BST(head,nullptr); }};//retry plz6. 결과 및 후기, 개선점discuss" }, { "title": "Programmers_땅따먹기", "url": "/posts/Programmers_land_attack/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-05-06 06:34:40 +0900", "snippet": "프로그래머스 -땅따먹기 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/129132. 분류 및 난이도Programmers 문제입니다.연습문제 입니다.Level 2난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) DP로 풀 수 있나 생각하다가, Greedy로도 풀 수 있을 것 같아서 Greedy로 시도했습니다. 효율성 부분에서 매우 안좋은 평가(?)가 나온 것 같지만, 풀었으니 제출하겠습니다.4. 접근 방법을 적용한 코드def solution(land): answer = 0 for i in range(1,len(land)): for j in range(4): maxidx = 0 for k in range(4): if k==j : continue maxidx = max(maxidx,land[i-1][k]) land[i][j] = land[i][j] + maxidx answer = max(answer,land[i][j]) return answer5. 결과필요시. c++로 짜드리겠습니다." }, { "title": "Programmers_N개의 최소공배수", "url": "/posts/Programmers_N_LCM/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-05-05 14:34:40 +0900", "snippet": "프로그래머스 - N개의 최소공배수 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/129532. 분류 및 난이도Programmers 문제입니다.연습문제 입니다.Level 2난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 직관적이고 어렵지 않습니다. 데이터도 크게 들어오지 않습니다. 유클리드 호제법을 사용해서 문제를 해결했습니다. 4. 접근 방법을 적용한 코드def GCM(a,b): while b != 0: r = a % b a = b b = r return adef solution(arr): # 최소공배수 공식 lcm = 0 gcm = 0 # 길이가 1인 배열이 들어올 경우. if len(arr)==1: return arr[0] for i in range(1,len(arr)): gcm = GCM(arr[i-1],arr[i]) lcm = arr[i-1] * arr[i] / gcm arr[i] = lcm return lcm5. 결과필요시. c++로 짜드리겠습니다." }, { "title": "Programmers_행렬의 곱셈", "url": "/posts/Programmers_Matrix_Multi/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-05-05 12:34:40 +0900", "snippet": "프로그래머스 -행렬의 곱셈 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/129492. 분류 및 난이도Programmers 문제입니다.연습문제 입니다.Level 2난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 직관적이고 어렵지 않습니다. 데이터도 크게 들어오지 않습니다. greedy하게 풀었는데, 시간을 더 줄일 수 있는 방법이 있습니다.4. 접근 방법을 적용한 코드def solution(arr1, arr2): answer = [] m = len(arr1) n = len(arr2[0]) max = len(arr1[0]) print(m,n) for i in range (0,m): answer.append([]) for j in range(0,n): answer[i].append(0) for k in range(0,max): answer[i][j] += (arr1[i][k] * arr2[k][j]) return answer5. 결과필요시. c++로 짜드리겠습니다." }, { "title": "Programmers_JadenCase 문자열 만들기", "url": "/posts/Programmers_JadenCase/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-05-05 12:34:40 +0900", "snippet": "프로그래머스 -JadenCase 문자열 만들기 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/129512. 분류 및 난이도Programmers 문제입니다.연습문제 입니다.Level 2난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 직관적이고 어렵지 않습니다. 데이터도 크게 들어오지 않습니다. python의 capitalize()함수를 활용했습니다.4. 접근 방법을 적용한 코드def solution(s): answer = s.split(&#39; &#39;) res = &#39;&#39; for i in range (len(answer)): answer[i] = answer[i].capitalize() res += answer[i]+ &#39; &#39; #마지막에 공백이 추가되어있으므로 return res[:-1]5. 결과필요시. c++로 짜드리겠습니다." }, { "title": "leetcode(리트코드)5월4일 challenge665-Non decreasing Array", "url": "/posts/leetcode_Non_decreasing_Array/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-05-05 11:17:56 +0900", "snippet": "leetcode May 4일 - Non decreasing Array 문제입니다.1. 문제https://leetcode.com/problems/non-decreasing-array/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.5월 4일자 챌린지 문제입니다.4. 문제 해석 nums라는 벡터가 들어옵니다. 하나의 값만 수정해서 오름차순으로 만들 수 있으면 true를 만들 수 없으면 false를 리턴합니다.5. codec++class Solution {public: bool checkPossibility(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int res = 0 ; for(int i = 1 ; i &amp;lt;nums.size() &amp;amp;&amp;amp; res&amp;lt;=1 ; ++i){ if(nums[i]&amp;lt;nums[i-1]){ res++; if(i-2&amp;lt;0 || nums[i-2] &amp;lt;= nums[i]) nums[i-1]= nums[i]; else nums[i] = nums[i-1]; } } return res&amp;lt;=1; }};6. 결과 및 후기, 개선점" }, { "title": "Programmers_최댓값과 최솟값", "url": "/posts/Programmers_maxandmin/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-05-05 06:34:40 +0900", "snippet": "프로그래머스 -최댓값과 최솟값 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/129392. 분류 및 난이도Programmers 문제입니다.연습문제 입니다.Level 2난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 직관적이고 어렵지 않습니다. 데이터도 크게 들어오지 않습니다. 문자열을 정수로 바꾸고 값을 찾은 다음 다시 정수를 문자열로 바꿨습니다.4. 접근 방법을 적용한 코드def solution(s): answer = &#39;&#39; temp = s.split(&#39; &#39;) min = int(temp[0]) max = int(temp[0]) for i in range(len(temp)): ele = int(temp[i]) if min &amp;gt; ele: min = ele if max &amp;lt; ele: max = ele answer += str(min) answer += &#39; &#39; answer += str(max) return answer5. 결과필요시. c++로 짜드리겠습니다." }, { "title": "Programmers_피보나치 수", "url": "/posts/Programmers_fibo/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-05-05 03:34:40 +0900", "snippet": "프로그래머스 - 피보나치 수 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/129452. 분류 및 난이도Programmers 문제입니다.연습문제 입니다.Level 2난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 유명한 피보나치 수 문제입니다. 데이터가 크므로 DP로 풀어줘야합니다.4. 접근 방법을 적용한 코드#재귀가 많이 호출되므로 최대 재귀 깊이를 늘려줌.import syssys.setrecursionlimit(10**7)def fibo(n,DP): if DP[n]: return DP[n] if n == 0 or n==1 : return 1 DP[n] = (fibo(n-1,DP) + fibo(n-2,DP)) %1234567 return DP[n]def solution(n): answer = 0 DP = [0] * (n + 1) fibo(n,DP) return DP[n-1] %12345675. 결과필요시. c++로 짜드리겠습니다." }, { "title": "Programmers_최솟값 만들기", "url": "/posts/Programmers_makeMin/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-05-05 01:34:40 +0900", "snippet": "프로그래머스 -최솟값 만들기 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/129412. 분류 및 난이도Programmers 문제입니다.연습문제 입니다.Level 2난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 직관적이고 어렵지 않습니다. 데이터도 크게 들어오지 않습니다. 최소값을 만들려면 하나는 가장 작은 갑을 뽑고 다른 하나에서 가장 큰 값을 뽑아 곱해버리면 된다고 생각했습니다.4. 접근 방법을 적용한 코드def solution(A,B): answer = 0 A.sort() B.sort() size = len(A)-1 for i in range (size+1): answer += (A[i] * B[size-i]) return answer5. 결과필요시. c++로 짜드리겠습니다." }, { "title": "Programmers_숫자의 표현", "url": "/posts/Programemrs_ExpressionDigit/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-05-05 01:34:40 +0900", "snippet": "프로그래머스 -숫자의 표현 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/12924#2. 분류 및 난이도Programmers 문제입니다.연습문제 입니다.Level 2난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 생각할 것이 좀 있습니다. 홀수인 경우에는 무조건 어떤수 + 어떤수로 나타낼 수 있으며, 나누어떨어지는 수를 중간으로 기준으로 일렬로 세우는 방법의 갯수를 세면 됩니다. 짝수인 경우에는 어떤수 + 어떤수로 나타낼 수 없습니다. 약수가 홀수인 경우에만 n으로 나타낼 수 있다는 것을 깨달아서 코드를 작성하였습니다.4. 접근 방법을 적용한 코드def solution(n): answer = 0 if(n%2 == 1): for i in range (1,n+1): if(n%i ==0): answer+=1 else: for i in range(1,n+1) : if(n%i==0 and i%2==1): answer+=1 return answer5. 결과필요시. c++로 짜드리겠습니다." }, { "title": "leetcode(리트코드)5월3일 challenge1480-Running Sum of 1d Array", "url": "/posts/leetcode_Running_Sum_of_1d_Array/", "categories": "leetcode, Eazy", "tags": "leetcode, AlgorithmStudy", "date": "2021-05-03 11:17:56 +0900", "snippet": "leetcode May 3일 - Running Sum of 1d Array 문제입니다.1. 문제https://leetcode.com/problems/running-sum-of-1d-array/2. Input , Output3. 분류 및 난이도Eazy 난이도입니다.5월 3일자 챌린지 문제입니다.4. 문제 해석 nums라는 벡터가 들어옵니다. 이전값들을 누적으로 더한 벡터를 리턴합니다.5. codec++class Solution {public: vector&amp;lt;int&amp;gt; runningSum(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;int&amp;gt; DP(nums.size(),0); DP[0] = nums[0]; for(int i = 1 ; i &amp;lt; nums.size();++i) DP[i] =DP[i-1] + nums[i]; return DP; }};6. 결과 및 후기, 개선점" }, { "title": "leetcode(리트코드)-103 Binary Tree Zigzag Level Order Traversal", "url": "/posts/leetcode_Binary_Tree_Zigzag_Level_Order_Traversal/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Interview", "date": "2021-05-03 10:34:50 +0900", "snippet": "leetcode 103 - Binary Tree Zigzag Level order Traversal 문제입니다.1. 문제https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.Top Interview 문제입니다.4. 문제 해석 트리를 level에따라 벡터에 집어넣는데, left-&amp;gt;right, right-&amp;gt;left 순으로 집어넣습니다.5. code코드설명 일단 level에 따라 벡터에 넣고 level이 홀수인 경우에 reverse를 해줍니다.c++/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: void DFS(TreeNode* root, int depth, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; res){ if(root){ if(res.size() &amp;lt; depth){ vector&amp;lt;int&amp;gt; temp; temp.push_back(root-&amp;gt;val); res.push_back(temp); } else res[depth-1].push_back(root-&amp;gt;val); DFS(root-&amp;gt;left,depth+1,res); DFS(root-&amp;gt;right,depth+1,res); } } vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; zigzagLevelOrder(TreeNode* root) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; DFS(root,1,res); for(int i = 0 ; i &amp;lt;res.size();++i){ if(i%2==1) reverse(res[i].begin(),res[i].end()); } return res; }};6. 결과 및 후기, 개선점c++ 61% 4ms" }, { "title": "leetcode(리트코드)58-Length of Last Word", "url": "/posts/leetcode_Length_of_Last_Word/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-05-03 08:34:50 +0900", "snippet": "leetcode 58 - Length of Last Word 문제입니다.1. 문제https://leetcode.com/problems/length-of-last-word/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.Random으로 뽑아서 푼 문제입니다.좋은 문제는 아닙니다.4. 문제 해석 문자열에서 마지막의 부분문자열의 길이를 리턴합니다.5. code코드설명 ’ ‘ 이 들어올 경우 count값을 0으로 만들어줍니다.c++class Solution {public: int lengthOfLastWord(string s) { int count = 0; int res = 0 ; for(int i = 0 ; i&amp;lt;s.size();++i){ if(s[i] ==&#39; &#39;){ count=0; continue; } ++count; res =count; } return res; }};6. 결과 및 후기, 개선점c++ 60% 4ms" }, { "title": "Programmers_124 나라의 숫자", "url": "/posts/Programmers_onetwothree/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-05-02 14:34:40 +0900", "snippet": "프로그래머스 - 124 나라의 숫자 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/12899#2. 분류 및 난이도Programmers 문제입니다.연습문제 입니다.Level 2난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 직관적이고 어렵지 않지만 나누기 처리를 잘 해줘야합니다. 나누어 떨어지는 경우의 처리가 중요합니다.4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;string solution(int n) { string answer = &quot;&quot;; char arr[2] = {&#39;1&#39;,&#39;2&#39;}; while(n){ //나누어 떨어지는 경우 --n을 해줘야합니다. if(n%3 ==0){ answer.push_back(&#39;4&#39;); --n; } else{ answer.push_back(arr[n%3-1]); } n/=3; } //뒤부터 집어넣었으므로 마지막에 뒤집어 줘야합니다. reverse(answer.begin(),answer.end()); return answer;}5. 결과필요시." }, { "title": "Programmers_폰켓몬", "url": "/posts/Programmers_PhoneKetmon/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-05-02 12:34:40 +0900", "snippet": "프로그래머스 - 폰켓몬 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/18452. 분류 및 난이도Programmers 문제입니다.찾아라 프로그래밍 마에스터 문제입니다.Level 1난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 직관적이고 어렵지 않은 문제입니다.4. 접근 방법을 적용한 코드#include &amp;lt;vector&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int solution(vector&amp;lt;int&amp;gt; nums){ set&amp;lt;int&amp;gt; st; for(int i = 0 ; i &amp;lt;nums.size();++i){ st.insert(nums[i]); } return min((int)st.size(),(int)(nums.size()/2));}5. 결과필요시." }, { "title": "leetcode(리트코드)35-Search Insert Position", "url": "/posts/leetcode_Search_Insert_Position/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-05-02 08:34:50 +0900", "snippet": "leetcode 35 - Serach Insert Position 문제입니다.1. 문제https://leetcode.com/problems/search-insert-position/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.Random으로 뽑아서 푼 문제입니다.4. 문제 해석 정렬된 벡터가 들어옵니다. 타겟이 있으면 해당 인덱스를 리턴하고, 없으면 정렬 시 들어갈 인덱스를 찾아 리턴합니다.5. code코드설명 target이 이미 정렬된 벡터의 끝요소보다 클 경우를 먼저 리턴하는게 좀 더 빠릅니다.c++class Solution {public: int searchInsert(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { if(target &amp;gt; nums[nums.size()-1]) return nums.size(); for(int i = 0 ; i &amp;lt;nums.size();++i){ if(nums[i] &amp;gt;= target) return i; } return nums.size(); }};6. 결과 및 후기, 개선점c++ 100% 0ms" }, { "title": "leetcode(리트코드)763-Partition Labels", "url": "/posts/leetcode_Partition_Labels/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Like", "date": "2021-05-02 06:34:50 +0900", "snippet": "leetcode 763 - Partition Labels 문제입니다.1. 문제https://leetcode.com/problems/partition-labels/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked 문제입니다.4. 문제 해석 문자열이 들어옵니다. 문자가 최대 한 부분에 나타나게 하여 그 부분 문자열의 길이들을 벡터에 넣고 리턴합니다.5. code코드설명 어디까지 나타나는 지에 대한 정보를 입력해야 합니다.c++class Solution {public: vector&amp;lt;int&amp;gt; partitionLabels(string S) { vector&amp;lt;int&amp;gt; charIdx(26,0); for(int i = 0 ; i&amp;lt;S.size();++i){ charIdx[S[i]-&#39;a&#39;] = i; } int maxIdx = -1, lastIdx = 0 ; vector&amp;lt;int&amp;gt; res; for(int i = 0 ; i &amp;lt;S.size();++i){ maxIdx = max(maxIdx,charIdx[S[i]-&#39;a&#39;]); if(maxIdx == i ){ res.push_back(maxIdx - lastIdx+1); lastIdx = i +1; } } return res; }};6. 결과 및 후기, 개선점c++ 81% 4ms" }, { "title": "Programmers_음양 더하기", "url": "/posts/Programmers_sums_abs/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-05-01 15:34:40 +0900", "snippet": "프로그래머스 - 음양 더하기 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/765012. 분류 및 난이도Programmers 문제입니다.월간 코드 챌린지 시즌 2문제입니다.Level 1난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 직관적이고 어렵지 않은 문제입니다.4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;int solution(vector&amp;lt;int&amp;gt; absolutes, vector&amp;lt;bool&amp;gt; signs) { int answer = 0; for(int i = 0 ; i &amp;lt;absolutes.size();++i){ //음수인 경우 빼줍니다. if(!signs[i]){ answer -= absolutes[i]; } //양수인 경우 더해줍니다. else answer += absolutes[i]; } return answer;}5. 결과필요시." }, { "title": "Programmers_로또의 최고 순위와 최저 순위", "url": "/posts/Programmers_max_min_lotto/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-05-01 14:34:40 +0900", "snippet": "프로그래머스 - 로또의 최고 순위와 최저 순위 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/774842. 분류 및 난이도Programmers 문제입니다.Dev-Matching 백엔드 코테 문제입니다.Level 1난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 직관적이고 어렵지 않은 문제입니다.4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;iostream&amp;gt;using namespace std;vector&amp;lt;int&amp;gt; solution(vector&amp;lt;int&amp;gt; lottos, vector&amp;lt;int&amp;gt; win_nums) { vector&amp;lt;int&amp;gt; answer; //set에 넣어서 접근할 수 있게 만듭니다. set&amp;lt;int&amp;gt; ans(win_nums.begin(),win_nums.end()); int max = 1 ; int min = 1; for(int i = 0; i&amp;lt;lottos.size();++i){ //0인 경우에는 최저 순위만 올라갑니다(틀렸다고 가정) if(lottos[i] ==0 ){ ++min; } else{ //만약 찾을 수 없다면 둘 다 순위가 올라갑니다. if(!ans.count(lottos[i])){ ++max; ++min; } } } //만약 다 없거나 다 맞춘 경우 min값이나 max값이 6을 초과하므로 다시 맞춰줍니다. min = min &amp;gt;6 ? 6 : min; max = max &amp;gt; 6 ? 6 :max; answer.push_back(max); answer.push_back(min); return answer;}5. 결과필요시." }, { "title": "leetcode(리트코드)1408-String Matching in an Array", "url": "/posts/leetcode_String_Matching_in_an_Array/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-04-27 06:34:50 +0900", "snippet": "leetcode 1408 - String Matching in an Array 문제입니다.1. 문제https://leetcode.com/problems/string-matching-in-an-array/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 words라는 string 벡터가 들어옵니다. 벡터들의 요소를 비교했을 때 해당 요소가 다른 요소의 substring일 경우 그 요소를 결과 벡터에 넣어 반환하세요.5. code코드설명 for문 2개를 써서 brute하게 접근합니다. 이유는 최대 100개의 길이를 가진 vector가 들어오므로 O(n^2)이여도 많은 시간이 걸리지 않기 때문입니다. 만약 같은 요소를 가리키고 있으면 continue로 스킵해주고 다른 요소에서 substring을 찾았으면 결과벡터에 넣어주고 break합니다.c++class Solution {public: vector&amp;lt;string&amp;gt; stringMatching(vector&amp;lt;string&amp;gt;&amp;amp; words) { set&amp;lt;string&amp;gt; st; for(int i = 0 ; i &amp;lt;words.size() ; ++i){ for(int j = 0 ; j &amp;lt; words.size();++j){ if(i==j) continue; if( words[j].find(words[i]) != -1){ st.insert(words[i]); break; } } } vector&amp;lt;string&amp;gt; res(st.begin(),st.end()); return res; }};6. 결과 및 후기, 개선점c++ 87% 4ms" }, { "title": "leetcode(리트코드)4월23일 challenge696-Count Binray Substrings", "url": "/posts/leetcode_Count_Binary_Substrings/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-04-23 11:17:56 +0900", "snippet": "leetcode April 23일 - Count Binary Substrings 문제입니다.1. 문제https://leetcode.com/problems/count-binary-substrings/2. Input , Output3. 분류 및 난이도Eazy 난이도입니다.4월 23일자 챌린지 문제입니다.4. 문제 해석 0과 1로 구성된 string이 들어옵니다. 연속된 부분 스트링에서 0과 1의 갯수가 같은 부분 스트링의 갯수를 반환하세요.5. code이전 값을 저장하고 배열의 인덱스가 달라지는 순간 이전값과 현재 값의 카운트 중 작은 값을 찾아 res에 더합니다.c++class Solution {public: int countBinarySubstrings(string s) { int cur = 1, pre = 0, res = 0; for(int i = 1 ; i &amp;lt;s.size(); ++i){ if(s[i] != s[i-1]){ res += min(cur,pre); pre = cur; cur = 1; } else cur++; } return res += min(pre,cur); }};6. 결과 및 후기, 개선점" }, { "title": "leetcode(리트코드)36-Valid Sudoku", "url": "/posts/leetcode_Valid_Sudoku/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Interview", "date": "2021-04-22 12:01:00 +0900", "snippet": "leetcode 36 - Valid Sudoku 문제입니다.1. 문제https://leetcode.com/problems/valid-sudoku/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.Top 100 Interview 문제입니다.4. 문제 해석 스도쿠 문제입니다. 채울 필요는 없고 스도쿠의 규칙에 맞는 지 확인만 하면 됩니다.5. codec++class Solution {public: bool findrow(vector&amp;lt;char&amp;gt; board){ bool checknum[10]={0,}; for(int i = 0 ; i &amp;lt; 9;++i){ if(board[i] ==&#39;.&#39;)continue; if(checknum[board[i]-&#39;0&#39;]) return false; checknum[board[i]-&#39;0&#39;]= true; } return true; } bool findcol(int j,vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt; b){ bool checknum[10]={0,}; for(int i = 0 ; i &amp;lt; 9;++i){ if(b[i][j] ==&#39;.&#39;)continue; if(checknum[b[i][j]-&#39;0&#39;]) return false; checknum[b[i][j]-&#39;0&#39;] = true; } return true; } bool subboxc(int i ,int j , vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt; b){ bool checknum[10]={false,}; for(int row = i ; row&amp;lt; i+3; ++row){ for(int col = j ; col &amp;lt; j+3 ; ++col){ if(b[row][col] == &#39;.&#39;) continue; if(checknum[b[row][col] -&#39;0&#39;]) return false; checknum[b[row][col] -&#39;0&#39;] =true; } } return true; } bool isValidSudoku(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; board) { //row 검사 int row = board.size(); int col = board[0].size(); for(int i = 0 ; i &amp;lt;row;++i){ if(!findrow(board[i])) return false; } //col 검사 for(int j = 0 ; j &amp;lt;col;++j){ if(!findcol(j,board)) return false; } //sub box for(int i = 0 ; i &amp;lt; 9; i += 3){ for(int j = 0 ; j &amp;lt;9; j+=3){ if(!subboxc(i,j,board)) return false; } } return true; }};6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!c++ 47% python ??% " }, { "title": "leetcode(리트코드)4월22일 challenge554-Brick Wall", "url": "/posts/leetcode_Brick_Wall/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-04-22 11:17:56 +0900", "snippet": "leetcode April 22일 - Brick Wall 문제입니다.1. 문제https://leetcode.com/problems/brick-wall/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.4월 22일자 챌린지 문제입니다.4. 문제 해석 Brick이라는 2차원 벡터가 주어집니다. 각 배열의 요소는 Brick의 넓이로 수직선을 그었을 때 최소한의 Brick을 지나는 경우의 Brick수를 리턴합니다. Brick의 넓이는 최대 INT_MAX까지 들어옵니다. 또한, 각 지점의 끝을 수직으로 긋는 것은 안됩니다. 그럴 수 밖에 없는 경우 높이를 리턴하면됩니다.5. code 핵심기능핵심적인 코드 및 생각해야할 것은 Brick의 폭을 더해 놓으면 경계선이 저장되므로 그 값을 이용해서 문제를 해결해나가면 됩니다.c++class Solution {public: int leastBricks(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; wall) { unordered_map&amp;lt;int,int&amp;gt; um; int maxcol = 0; int res = wall.size(); int height = res; for(int i = 0 ;i&amp;lt;height; ++ i){ int sum = 0; for(int j = 0 ; j &amp;lt;wall[i].size();++j){ //경계선을 계산. sum += wall[i][j]; um[sum]++; } maxcol = sum; } for(auto it = um.begin(); it!=um.end();++it){ //끝인 경우는 continue if(it-&amp;gt;first == maxcol) continue; // 높이에서 경계선을 가진 row의 개수를 빼줍니다. res = min(res, height- it-&amp;gt;second); } return res; }};6. 결과 및 후기, 개선점" }, { "title": "leetcode(리트코드)560-Subarray Sum Equals K", "url": "/posts/leetcode_Subarray_Sum_Equals_K/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Like", "date": "2021-04-22 06:34:50 +0900", "snippet": "leetcode 560 - Subarray Sum Equals K 문제입니다.1. 문제https://leetcode.com/problems/subarray-sum-equals-k/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked 문제입니다.4. 문제 해석 nums라는 벡터가 들어옵니다. 연속된 부분배열을 이용해 k를 만들 수 있는 경우의 수를 구해 리턴하세요.5. code코드설명 맵에 연속된 배열의 합을 저장해놓는 것이 중요합니다.c++class Solution {public: int subarraySum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) { unordered_map&amp;lt;int,int&amp;gt; um; um[0] ++; int res = 0 ; int sum = 0; for(int i = 0 ; i &amp;lt; nums.size();++i){ sum += nums[i]; res += um[sum-k]; um[sum] ++; } return res; }};6. 결과 및 후기, 개선점c++ 44% 84ms" }, { "title": "leetcode(리트코드)4월21일 challenge120-Triangle", "url": "/posts/leetcode_Triangle/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-04-21 11:17:56 +0900", "snippet": "leetcode April 21일 - Triangle 문제입니다.1. 문제https://leetcode.com/problems/triangle/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.4월 21일자 챌린지 문제입니다.4. 문제 해석 삼각형이 주어집니다. 삼각형의 길을 하나 따라서 밑으로 내려가는데, 그 값들의 합이 최소가 되는 값을 찾아 리턴하세요.5. codeDP문제이고, 길을 따라 내려가면서 위쪽의 최솟값만 찾아주면되므로 어려운 문제는 아닙니다.c++class Solution {public: int minimumTotal(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; triangle) { if(triangle.size() == 1) return triangle[0][0]; int res = INT_MAX; int DP[201][201]={0,}; DP[0][0] = triangle[0][0]; for(int i = 1 ;i&amp;lt;triangle.size();++i){ for(int j = 0; j&amp;lt;= i;++j){ if(j ==0){ DP[i][j] = DP[i-1][j] + triangle[i][j]; } else if(j==i){ DP[i][j] = DP[i-1][j-1] + triangle[i][j]; } else{ DP[i][j] = min(DP[i-1][j-1],DP[i-1][j]) + triangle[i][j]; } if(i == triangle.size()-1){ res = min(res,DP[i][j]); } } } return res; }};6. 결과 및 후기, 개선점" }, { "title": "leetcode(리트코드)438-Find All Anagrams in a String", "url": "/posts/leetcode_Find_All_Anagrams_in_a_String/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Like", "date": "2021-04-21 06:34:50 +0900", "snippet": "leetcode 438 - Find All Anagrams in a String 문제입니다.1. 문제https://leetcode.com/problems/find-all-anagrams-in-a-string/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked 문제입니다.4. 문제 해석 s라는 문자열과 p라는 문자열이 주어집니다. p에 있는 문자열이 순서와 상관없이 전부 들어있는 부분문자열의 첫 인덱스 위치를 vector에 넣어 리턴합니다.5. code 핵심 아이디어는 문자열의 위치를 1만큼 뒤로가면서 새로 추가된 문자에 대한 카운트를 증가시켜주고 맨앞의 문자에대한 카운트를 지워줍니다. 그리고 비교를 합니다.c++class Solution {public: vector&amp;lt;int&amp;gt; findAnagrams(string s, string p) { vector&amp;lt;int&amp;gt; res; if(p.size() &amp;gt; s.size()) return res; vector&amp;lt;int&amp;gt; pv(26,0),sv(26,0); for(int i = 0; i&amp;lt;p.size(); ++i){ pv[p[i]-&#39;a&#39;]++; sv[s[i]-&#39;a&#39;]++; } if(pv==sv) res.push_back(0); for(int i = p.size() ; i&amp;lt;s.size();++i){ sv[s[i]-&#39;a&#39;]++; sv[s[i-p.size()]- &#39;a&#39;]--; if(sv==pv)res.push_back(i-p.size()+1); } return res; }};6. 결과 및 후기, 개선점c++ 73% 12ms" }, { "title": "leetcode(리트코드)412-Fizz Buzz", "url": "/posts/leetcode_Fizz_Buzz/", "categories": "leetcode, Eazy", "tags": "leetcode, Top100Interview", "date": "2021-04-20 12:01:00 +0900", "snippet": "leetcode 412 - Fizz Buzz 문제입니다.1. 문제https://leetcode.com/problems/fizz-buzz/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.Top 100 Interview 문제입니다.4. 문제 해석인덱스가 5와 3으로 나눠지면 FizzBuzz 3으로 나눠지면 Fizz 5로 나눠지면 Buzz 나머지는 인덱스 숫자를 넣어 리턴합니다.5. codec++class Solution {public: vector&amp;lt;string&amp;gt; fizzBuzz(int n) { vector&amp;lt;string&amp;gt; res; for(int i = 1 ; i &amp;lt;= n ;++i){ if(i%15 ==0) res.push_back(&quot;FizzBuzz&quot;); else if(i%3==0) res.push_back(&quot;Fizz&quot;); else if(i%5==0) res.push_back(&quot;Buzz&quot;); else res.push_back(to_string(i)); } return res; }};6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!c++ 75% python ??% " }, { "title": "leetcode(리트코드)4월20일 challenge589-N-ary Tree Preorder Traversal", "url": "/posts/leetcode_N-ary_Tree_Preorder_Traversal/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-04-20 11:17:56 +0900", "snippet": "leetcode April 20일 - N-ary Tree Preorder Traversal 문제입니다.1. 문제https://leetcode.com/problems/n-ary-tree-preorder-traversal/2. Input , Output3. 분류 및 난이도Eazy 난이도입니다.4월 20일자 챌린지 문제입니다.4. 문제 해석 이진트리가 아닌 일반 트리가 들어옵니다. 트리를 preorder한 값을 vector에 넣어 반환합니다.5. code코드의 핵심은 자식들을 반대로 덱에 넣어줘서 자식이 있는 것을 우선순위로 꺼내는 것입니다.c++/*// Definition for a Node.class Node {public: int val; vector&amp;lt;Node*&amp;gt; children; Node() {} Node(int _val) { val = _val; } Node(int _val, vector&amp;lt;Node*&amp;gt; _children) { val = _val; children = _children; }};*/class Solution {public: vector&amp;lt;int&amp;gt; preorder(Node* root) { deque&amp;lt;Node*&amp;gt; q; vector&amp;lt;int&amp;gt; res; if(!root) return res; q.push_front(root); while(!q.empty()){ Node* frontnode = q.front(); q.pop_front(); res.push_back(frontnode-&amp;gt;val); for(int i = frontnode-&amp;gt;children.size()-1 ; i &amp;gt;=0; --i){ q.push_front(frontnode-&amp;gt;children[i]); } } return res; }};6. 결과 및 후기, 개선점" }, { "title": "leetcode(리트코드)387-First Unique Character in a String", "url": "/posts/leetcode_First_Unique_Character_in_a_String/", "categories": "leetcode, Eazy", "tags": "leetcode, Top100Interview", "date": "2021-04-19 12:01:00 +0900", "snippet": "leetcode 387 - First Unique Character in a String 문제입니다.1. 문제https://leetcode.com/problems/first-unique-character-in-a-string/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.Top 100 Interview 문제입니다.4. 문제 해석 문자열에서 한 번만 반복되는 문자를 찾아 index를 리턴합니다. 한 번만 반복되는 문자가 없으면 -1을 리턴합니다.5. codec++class Solution {public: int firstUniqChar(string s) { unordered_map&amp;lt;char,int&amp;gt; um; for(int i = 0 ; i &amp;lt;s.size();++i){ um[s[i]]++; } for(int i = 0;i&amp;lt;s.size();++i){ if(um[s[i]] == 1) return i; } return -1; }};6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!c++ 44% python ??% " }, { "title": "leetcode(리트코드)621-Task Scheduler", "url": "/posts/leetcode_Task_Scheduler/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Like", "date": "2021-04-19 06:34:50 +0900", "snippet": "leetcode 621 - Task Scheduler 문제입니다.1. 문제https://leetcode.com/problems/task-scheduler/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked 문제입니다.4. 문제 해석 tasks가 주어집니다. n은각 tasks를 처리하는 시간이라고 생각하면 됩니다. 이미 같은 문자의tasks가 이미 처리중일 때 idle을 통해 해당 tasks가 끝날 때까지 기다려야합니다. 최소한의 시간으로 tasks들을 수행할 때 그 시간을 리턴하세요.5. code코드설명 갯수를 세주는데 가장 많이 들어온 값을 count 변수에 넣어줍니다. 어차피 가장 많이 들어온 값의 task가 끝나지 않으면 문제는 안풀리기에 가장 많이 들어온 값을 기준으로 task를 진행합니다. 마지막 task를 수행하기 전에 count값이 같은 알파벳의 갯수를 세주고 그 알파벳을 세워주면 되므로 result값이 1씩 더해줍니다. 예를 들어 마지막 예제인 A가 6개, B,C,D,E,F,G가 들어오면 가장 많이 들어온 값인 A의 count(6개) - 1인 5개가 끝나기 전에는 해당 문제는 풀리지 않으므로 5개를 세워주고 count가 같은 다른 알파벳이 있는 지 찾습니다. 찾은 알파벳만큼 뒤에 세워주면 결과값이 나오는 겁니다. 즉 A (3개 아무거나 때움), A,A,A,A~~,AB 이런식으로 진행됩니다.c++class Solution {public: int leastInterval(vector&amp;lt;char&amp;gt;&amp;amp; tasks, int n) { unordered_map&amp;lt;char,int&amp;gt; um; int count = 0 ; for(size_t i =0 ; i &amp;lt;tasks.size();++i){ um[tasks[i]] ++; count = max(um[tasks[i]],count); } int res = (count -1) * (n+1); for(auto e : um){ if(e.second == count) ++res; } if(tasks.size() &amp;gt;= res) res = tasks.size(); return res; }};6. 결과 및 후기, 개선점c++ 20% 116ms" }, { "title": "leetcode(리트코드)494-Target Sum", "url": "/posts/leetcode_Target_Sum/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Like", "date": "2021-04-17 06:34:50 +0900", "snippet": "leetcode 494 - Target Sum 문제입니다.1. 문제https://leetcode.com/problems/target-sum/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked 문제입니다.4. 문제 해석 일반 벡터와 target이 주어집니다. 벡터의 요소들을 덧셈과 뺄셈을이용하여 target을 만들 수 있는 경우의 수를 리턴합니다.5. codec++class Solution {public: void DFS(vector&amp;lt;int&amp;gt;&amp;amp; nums,int target,int curr,int index,int&amp;amp; result){ if(index == nums.size()){ if(curr == target) ++result; return ; } DFS(nums,target,curr-nums[index],index+1,result); DFS(nums,target,curr + nums[index],index+1,result); } int findTargetSumWays(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { //DFS int result = 0 ; DFS(nums,target,0,0,result); return result; }};6. 결과 및 후기, 개선점c++ 17% 1144ms개선한 코드 4ms c++class Solution {public: typedef long long ll; int findTargetSumWays(vector&amp;lt;int&amp;gt;&amp;amp; a, int target) { ll i,j,sum=0,n=a.size(); for(i=0;i&amp;lt;n;i++){ //요소를 일단 다 더한다. sum+=a[i]; } //target을 만들 수 없는 경우 if(target&amp;gt;sum) return 0; //왠지 모르게 안되는 겅우? sum = (sum+target); if(sum%2!=0) return 0; //knap dp방법. ll k = (sum)/2; ll dp[n+1][k+1]; memset(dp, 0, sizeof(dp)); for(i=0;i&amp;lt;=n;i++){ dp[i][0]=1; } for(i=1;i&amp;lt;=n;i++){ for(j=0;j&amp;lt;=k;j++){ if(a[i-1]&amp;lt;=j){ dp[i][j]=dp[i-1][j] + dp[i-1][j-a[i-1]]; }else{ dp[i][j]=dp[i-1][j]; } } } return dp[n][k]; }};" }, { "title": "leetcode(리트코드)16-3Sum Closest", "url": "/posts/leetcode_3Sum_Closest/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Like", "date": "2021-04-15 13:34:50 +0900", "snippet": "leetcode 16 - 3Sum Closest 문제입니다.1. 문제https://leetcode.com/problems/3sum-closest/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked 문제입니다.4. 문제 해석 들어온 벡터에서 3개의 요소를 더한 값이 최대한 target과 비슷한 것을 찾아 리턴합니다.5. codec++class Solution {public: int threeSumClosest(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { //tiem out int res = 0; int min = INT_MAX; for(int i = 0 ; i&amp;lt;nums.size()-2;++i){ int sum = nums[i]; for(int j = i+1; j&amp;lt; nums.size()-1; ++j){ sum += nums[j]; for(int k = j+1; k&amp;lt; nums.size();++k){ sum+=nums[k]; int temp = target-sum; if(abs(min) &amp;gt; abs(temp)) { min = temp; res = sum; } sum-=nums[k]; } sum-=nums[j]; } } return res; }};6. 결과 및 후기, 개선점c++ 5%개선한 0ms code 100%class Solution { public: int threeSumClosest(vector&amp;lt;int&amp;gt;&amp;amp; v, int target) { sort(v.begin(), v.end()); int res = v[0] + v[1] + v[2]; int n = v.size(); for (int i = 0; i &amp;lt; n - 2; i++) { //k는 끝에서부터 검사 for (int j = i + 1, k = n - 1; j &amp;lt; k;) { int curr = v[i] + v[j] + v[k]; if (abs(curr - target) &amp;lt; abs(res - target)) res = curr; if (curr - target == 0) return curr; else if (curr - target &amp;gt; 0) k--; else j++; } } return res; }};저의 코드인 for문을 3개쓴 O(n^3)에 비해 for문을 2개 쓰고 그 하나도 투 포인트탐색을 하므로 O(n^2)의 시간복잡도를 갖습니다." }, { "title": "leetcode(리트코드)350-Intersection of Two Arrays II", "url": "/posts/leetcode_Intersection_of_Two_Arrays_II/", "categories": "leetcode, Eazy", "tags": "leetcode, Top100Interview", "date": "2021-04-15 12:01:00 +0900", "snippet": "leetcode 350 - Intersection of Two Arrays II 문제입니다.1. 문제https://leetcode.com/problems/intersection-of-two-arrays-ii/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.Top 100 Interview 문제입니다.4. 문제 해석 두 개의 집합에서의 교집합을 리턴합니다.5. codec++class Solution {public: vector&amp;lt;int&amp;gt; intersect(vector&amp;lt;int&amp;gt;&amp;amp; nums1, vector&amp;lt;int&amp;gt;&amp;amp; nums2) { //첫 벡터를 담을 맵 unordered_map&amp;lt;int,int&amp;gt; um1; //두 번째 벡터를 담을 맵 unordered_map&amp;lt;int,int&amp;gt; um2; //결과 벡터 vector&amp;lt;int&amp;gt; res; //값들을 맵에 넣습니다. for(size_t i = 0 ; i&amp;lt; nums1.size();++i) um1[nums1[i]]++; for(size_t i = 0 ; i &amp;lt;nums2.size();++i) um2[nums2[i]]++; //교집합이므로 um1으로 돌든 um2로 돌든 상관은 없습니다. for(auto it = um1.begin(); it!=um1.end(); ++it){ //두 맵에 값이 존재하면 if(um1.count(it-&amp;gt;first) &amp;amp;&amp;amp; um2.count(it-&amp;gt;first)){ //더 작은 값을 기준으로 카운트해주고 벡터에 넣어줍니다. int count = min(um1[it-&amp;gt;first] , um2[it-&amp;gt;first]); for(int i = 0; i &amp;lt;count;++i) res.push_back(it-&amp;gt;first); } } return res; }};6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!c++ 40% python ??% " }, { "title": "leetcode(리트코드)4월15일 challenge509-Fibonacii Number", "url": "/posts/leetcode_Fibonacci_Number/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-04-15 11:17:56 +0900", "snippet": "leetcode April 15일 - Fibonacii Number 문제입니다.1. 문제https://leetcode.com/problems/fibonacci-number/2. Input , Output3. 분류 및 난이도Eazy 난이도입니다.4월 15일자 챌린지 문제입니다.4. 문제 해석 피보나치 수열 DP사용5. codec++class Solution {public: int DP[31] = {}; int fib(int n) { if(n==0) return 0; if(n==1) return 1; if(DP[n]!=0) return DP[n]; return DP[n] = fib(n-1) + fib(n-2); }};6. 결과 및 후기, 개선점" }, { "title": "leetcode(리트코드)739-Daily Temperatures", "url": "/posts/leetcode_Daily_Temperatures/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Like", "date": "2021-04-15 06:34:50 +0900", "snippet": "leetcode 739 - Daily Temperatures 문제입니다.1. 문제https://leetcode.com/problems/decode-string/https://leetcode.com/problems/daily-temperatures/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked 문제입니다.4. 문제 해석 온도 벡터가 들어옵니다. 각 인덱스를 기준으로 따뜻해지는 순간이 언제인지 벡터에 넣어 반환합니다.5. codec++class Solution {public: vector&amp;lt;int&amp;gt; dailyTemperatures(vector&amp;lt;int&amp;gt;&amp;amp; T) { vector&amp;lt;int&amp;gt; res(T.size(),0); stack&amp;lt;pair&amp;lt;int,int&amp;gt;&amp;gt; st; for(size_t i = 0 ; i &amp;lt;T.size();++i){ if(st.empty())st.push(make_pair(T[i],i)); else{ while(!st.empty() &amp;amp;&amp;amp; st.top().first &amp;lt; T[i]){ int index = st.top().second; res[index] = i - index; st.pop(); } st.push(make_pair(T[i],i)); } } return res; }};6. 결과 및 후기, 개선점c++ 95%" }, { "title": "leetcode(리트코드)54-Spiral Matrix", "url": "/posts/leetcode_Spiral_Matrix/", "categories": "leetcode, Medium", "tags": "leetcode, Facebook", "date": "2021-04-15 03:45:20 +0900", "snippet": "leetcode 54 - Spiral Matrix 문제입니다.1. 문제https://leetcode.com/problems/spiral-matrix/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.https://www.teamblind.com/post/New-Year-Gift---Curated-List-of-Top-75-LeetCode-Questions-to-Save-Your-Time-OaM1orEU에서 추천한 문제입니다.4. 문제 해석 달팽이모양으로 방문처리를 합니다.5. codec++//좌표 이동을 위한int dx[4] = {0,1,0,-1};int dy[4] = {1,0,-1,0};class Solution {public: vector&amp;lt;int&amp;gt; spiralOrder(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix) { //row, col은 나중에도 쓰이므로 미리 변수에 넣어둡니다. int row = matrix.size(); int col = matrix[0].size(); //방문처리용 벡터 vector&amp;lt;bool&amp;gt; v(col,false); vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; vc; //결과값을 담을 벡터 vector&amp;lt;int&amp;gt; res; //방문처리 벡터 초기화 for(int i = 0 ; i&amp;lt;row;++i) vc.push_back(v); //BFS를 이용할 것입니다. queue&amp;lt;pair&amp;lt;int,int&amp;gt;&amp;gt; q; q.push(make_pair(0,0)); vc[0][0] = true; //dis는 방향전환이 필요할 때 사용하는 변수입니다. int dis = 0; //row * col만큼 돌면 빠져나오기 위한 변수 int count = 0; while(!q.empty()){ int x = q.front().first; int y = q.front().second; q.pop(); res.push_back(matrix[x][y]); ++count; if(count== row * col) break; int newX = x + dx[dis]; int newY = y + dy[dis]; //만약 새 좌표 값이 범위를 벗어나거나 이미 방문한 좌표를 지나려 한다면 좌표를 다시 갱신해줍니다. if(newX &amp;lt;0 || newX &amp;gt;= matrix.size() || newY &amp;lt;0 || newY &amp;gt;= matrix[0].size() ||vc[newX][newY]){ dis = (dis+1)%4; newX = x + dx[dis]; newY = y +dy[dis]; } if(!vc[newX][newY]){ q.push(make_pair(newX,newY)); vc[newX][newY] = true; } } return res; }};6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!c++ 0ms 100%" }, { "title": "leetcode(리트코드)344-Reverse String", "url": "/posts/leetcode_Reverse_String/", "categories": "leetcode, Eazy", "tags": "leetcode, Top100Interview", "date": "2021-04-14 12:01:00 +0900", "snippet": "leetcode 344 - Reverse String 문제입니다.1. 문제https://leetcode.com/problems/reverse-string/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.Top 100 Interview 문제입니다.4. 문제 해석 문자 벡터가 있습니다. 뒤집으면 됩니다.5. codec++class Solution {public: void reverseString(vector&amp;lt;char&amp;gt;&amp;amp; s) { reverse(s.begin(),s.end()); }};6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!c++ 72% python ??% " }, { "title": "leetcode(리트코드)4월14일 challenge86-Partition List", "url": "/posts/leetcode_Partition_List/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-04-14 11:00:56 +0900", "snippet": "leetcode April 14일 - Partition List 문제입니다.1. 문제https://leetcode.com/problems/partition-list/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.4월 14일자 챌린지 문제입니다.4. 문제 해석 리스트와 x가 주어집니다. 리스트를 x보다 작은 것은 앞으로 크거나 같은것은 뒤로 보냅니다. 큰 것을 정렬할 때 상대적 위치는 같아야합니다.5. codec++/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: void setless(ListNode*&amp;amp; less,ListNode* originless,int x){ if(originless){ if(originless-&amp;gt;val &amp;lt;x ){ ListNode* newNode = new ListNode(originless-&amp;gt;val); less-&amp;gt;next = newNode; less = less-&amp;gt;next; } setless(less,originless-&amp;gt;next,x); } return; } void setmore(ListNode* more,ListNode* originmore,int x){ if(originmore){ if(originmore-&amp;gt;val &amp;gt;= x){ ListNode* newNode = new ListNode(originmore-&amp;gt;val); more-&amp;gt;next = newNode; more = more-&amp;gt;next; } setmore(more,originmore-&amp;gt;next,x); } return ; } ListNode* partition(ListNode* head, int x) { ListNode* more = head; ListNode* less = head; ListNode* res = new ListNode(); ListNode* temp = res; setless(temp,less,x); setmore(temp,more,x); return res-&amp;gt;next; }};6. 결과 및 후기, 개선점" }, { "title": "leetcode(리트코드)416-Partition Equal Subset Sum", "url": "/posts/leetcode_Partition_Equal_Subset_Sum/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Like", "date": "2021-04-14 06:34:50 +0900", "snippet": "leetcode 416 - Partition Equal Subset Sum 문제입니다.1. 문제https://leetcode.com/problems/decode-string/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked 문제입니다.4. 문제 해석 string이 들어옵니다. 숫자만큼 ‘[]’ 에 있는 것들을 반복해야합니다. 결과를 리턴합니다. discuss 참조했습니다.5. codec++class Solution {public: string decodeString(string s) { stack&amp;lt;string&amp;gt; chars; stack&amp;lt;int&amp;gt; nums; int num = 0; string res = &quot;&quot;; for(char c : s){ if(isdigit(c)){ num = num * 10 + (c-&#39;0&#39;); } else if(isalpha(c)){ res.push_back(c); } else if(c ==&#39;[&#39;){ chars.push(res); nums.push(num); num = 0; res = &quot;&quot;; } else if(c==&#39;]&#39;){ string tmp = res; for(int i =0;i&amp;lt;nums.top()-1; ++i) res += tmp; res = chars.top() + res; chars.pop(), nums.pop(); } } return res; }};6. 결과 및 후기, 개선점c++ 100%" }, { "title": "leetcode(리트코드)406-Queue Reconstruction by Height", "url": "/posts/leetcode_Queue-Reconstruction_by_Height/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Like", "date": "2021-04-12 14:34:50 +0900", "snippet": "leetcode 406 - Queue Reconstruction by Height 문제입니다.1. 문제https://leetcode.com/problems/queue-reconstruction-by-height/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked 문제입니다.4. 문제 해석 people이 들어옵니다. people[n][0]는 키이고 people[n][1]은 자신보다 같거나 큰 키를 가진 사람이 앞에 있어야하는 명 수 입니다. 위의 조건으로 재배열해야합니다.5. codec++bool cmp(vector&amp;lt;int&amp;gt;&amp;amp; a,vector&amp;lt;int&amp;gt;&amp;amp; b){ if(a[0] == b[0]) return a[1] &amp;lt; b[1]; return a[0] &amp;gt; b[0];}class Solution {public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; reconstructQueue(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; people) { sort(people.begin(),people.end(),cmp); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; for(int i = 0 ; i&amp;lt;people.size();++i) { res.insert(res.begin() + people[i][1] ,people[i]); } return res; }};6. 결과 및 후기, 개선점c++ 33%" }, { "title": "leetcode(리트코드)326-Power of Three", "url": "/posts/leetcode_Power_of_Three/", "categories": "leetcode, Eazy", "tags": "leetcode, Top100Interview", "date": "2021-04-12 12:01:00 +0900", "snippet": "leetcode 326 - Power of Three 문제입니다.1. 문제https://leetcode.com/problems/power-of-three/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.Top 100 Interview 문제입니다.4. 문제 해석 들어온 n값이 3의 거듭제곱으로 나타낼 수 있으면 true 없으면 false를 리턴합니다.5. codec++class Solution {public: bool isPowerOfThree(int n) { if(n&amp;lt;=0) return false; while(n!=1){ if(n%3 !=0) return false; n/=3; } return true; }};6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!c++ 86% python ??% " }, { "title": "leetcode(리트코드)4월12일 challenge667-Beautiful ArrangeMent II", "url": "/posts/leetcode_Beautiful_Arrangement_II/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-04-12 11:00:56 +0900", "snippet": "leetcode April 12일 - Beautiful ArrangeMent II 문제입니다.1. 문제https://leetcode.com/problems/beautiful-arrangement-ii/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.4월 12일자 챌린지 문제입니다.4. 문제 해석 1 ~ n의 숫자를 가지는 배열이 있습니다. 각 배열의 인덱스의 차이의 절대값이 k만큼 다른 배열을 리턴합니다.5. codec++class Solution {public: vector&amp;lt;int&amp;gt; constructArray(int n, int k) { vector&amp;lt;int&amp;gt; res(n,0); for(int i = 1 ; i&amp;lt; n+1;++i) res[i-1] = i; for(int i = 1 ; i &amp;lt; k ;++i){ int left = i; int right= n-1; while(left&amp;lt;right){ swap(res[left++],res[right--]); } } return res; }};6. 결과 및 후기, 개선점" }, { "title": "leetcode(리트코드)4월11일 challenge1302-Deepest Leaves Sum", "url": "/posts/leetcode_Deepest_Leaves_Sum/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-04-11 10:00:56 +0900", "snippet": "leetcode April 11일 - Deepest Leaves Sum 문제입니다.1. 문제https://leetcode.com/problems/deepest-leaves-sum/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.4월 11일자 챌린지 문제입니다.4. 문제 해석 트리의 가장 깊은 자식의 노드값들을 더해 리턴하면됩니다.5. codec++/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: int deepestLeavesSum(TreeNode* root) { int res = 0 ,i; queue&amp;lt;TreeNode*&amp;gt; q; q.push(root); while(!q.empty()){ for(res = 0, i = q.size()-1; i&amp;gt;=0; --i){ TreeNode* nd = q.front(); q.pop(); res += nd-&amp;gt;val; if(nd-&amp;gt;left) q.push(nd-&amp;gt;left); if(nd-&amp;gt;right) q.push(nd-&amp;gt;right); } } return res; }};6. 결과 및 후기, 개선점discuss 봄." }, { "title": "leetcode(리트코드)73-Set Matrix Zeroes", "url": "/posts/leetcode_Set_Matrix_Zeroes/", "categories": "leetcode, Medium", "tags": "leetcode, Facebook", "date": "2021-04-08 16:45:20 +0900", "snippet": "leetcode 73 - Set Matrix Zeroes 문제입니다.1. 문제https://leetcode.com/problems/set-matrix-zeroes/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.https://www.teamblind.com/post/New-Year-Gift---Curated-List-of-Top-75-LeetCode-Questions-to-Save-Your-Time-OaM1orEU에서 추천한 문제입니다.4. 문제 해석 0으로 들어온 값의 행과 열을 모두 0으로 바꿔버립니다.5. codec++class Solution {public: void fillrow(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix,int row,int col){ for(int i =0;i&amp;lt;col;++i){ matrix[row][i] =0; } } void fillcol(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix,int row,int col){ for(int i = 0;i&amp;lt;row;++i) matrix[i][col]=0; } void setZeroes(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix) { int rowsize = matrix.size(); int colsize = matrix[0].size(); bool row[201]; bool col[201]; queue&amp;lt;pair&amp;lt;int,int&amp;gt;&amp;gt; q; memset(row,false,sizeof(row)); memset(col,false,sizeof(col)); //돌면서 0인 값은 queue에 넣음. for(int i = 0 ;i&amp;lt;rowsize;++i){ for(int j = 0; j&amp;lt;colsize; ++j){ if(matrix[i][j]==0 ){ q.push(make_pair(i,j)); } } } while(!q.empty()){ int x = q.front().first; int y = q.front().second; q.pop(); if(row[x]==false){ fillrow(matrix,x,colsize); row[x]=true; } if(col[y] == false){ fillcol(matrix,rowsize,y); col[y] =true; } } }};6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!c++ 16ms 40%" }, { "title": "leetcode(리트코드)394-Decode String", "url": "/posts/leetcode_Decode_String/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Like", "date": "2021-04-08 06:34:50 +0900", "snippet": "leetcode 394 - Decode String 문제입니다.1. 문제https://leetcode.com/problems/decode-string/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked 문제입니다.4. 문제 해석 string이 들어옵니다. 숫자만큼 ‘[]’ 에 있는 것들을 반복해야합니다. 결과를 리턴합니다. discuss 참조했습니다.5. codec++class Solution {public: string decodeString(string s) { stack&amp;lt;string&amp;gt; chars; stack&amp;lt;int&amp;gt; nums; int num = 0; string res = &quot;&quot;; for(char c : s){ if(isdigit(c)){ num = num * 10 + (c-&#39;0&#39;); } else if(isalpha(c)){ res.push_back(c); } else if(c ==&#39;[&#39;){ chars.push(res); nums.push(num); num = 0; res = &quot;&quot;; } else if(c==&#39;]&#39;){ string tmp = res; for(int i =0;i&amp;lt;nums.top()-1; ++i) res += tmp; res = chars.top() + res; chars.pop(), nums.pop(); } } return res; }};6. 결과 및 후기, 개선점c++ 100%" }, { "title": "leetcode(리트코드)237-Delete Node in a Linked List", "url": "/posts/leetcode_Delete_Node_in_a_Linked_List/", "categories": "leetcode, Eazy", "tags": "leetcode, Top100Interview", "date": "2021-04-08 01:01:00 +0900", "snippet": "leetcode 237 - Delete Node in a Linked List 문제입니다.1. 문제https://leetcode.com/problems/delete-node-in-a-linked-list/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.Top 100 Interview 문제입니다.4. 문제 해석 들어온 노드 값을 제거합니다. 완벽하게 제거하지 않아도 accept가 되기에 좋은 문제는 아닙니다.5. codec++/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: void deleteNode(ListNode* node) { node-&amp;gt;val = node-&amp;gt;next-&amp;gt;val; node-&amp;gt;next = node-&amp;gt;next-&amp;gt;next; }};6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!c++ 80% python 57% " }, { "title": "leetcode(리트코드)4월07일 challenge1704-Determine if String Halves Are Alike", "url": "/posts/leetcode_Determine_if_String_Halves_Are_Alike/", "categories": "leetcode, Eazy", "tags": "leetcode, AlgorithmStudy", "date": "2021-04-07 08:00:56 +0900", "snippet": "leetcode April 07일 - Determine if String Halves Are Alike 문제입니다.1. 문제https://leetcode.com/problems/determine-if-string-halves-are-alike/2. Input , Output3. 분류 및 난이도Eazy 난이도입니다.4월 07일자 챌린지 문제입니다.4. 문제 해석 문자열이 들어옵니다. 반 반으로 나눈 문자열의 모음 갯수가 같으면 true 다르면 false를 리턴합니다.5. codec++class Solution {public: bool halvesAreAlike(string s) { string a,b; set&amp;lt;char&amp;gt; st; st.insert(&#39;a&#39;); st.insert(&#39;e&#39;); st.insert(&#39;i&#39;); st.insert(&#39;o&#39;); st.insert(&#39;u&#39;); a = s.substr(0,s.size()/2); b = s.substr(s.size()/2); int aj = 0; int bj = 0; for(size_t i = 0 ;i&amp;lt;a.size();++i){ if(st.count(tolower(a[i])))++aj; if(st.count(tolower(b[i])))++bj; } return aj==bj; }};6. 결과 및 후기, 개선점c++ 100%" }, { "title": "leetcode(리트코드)347-Top K Frequent Elements", "url": "/posts/leetcode_Top_K_Frequent_Elements/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Like", "date": "2021-04-07 01:34:50 +0900", "snippet": "leetcode 347 - Top K Frequent Elements 문제입니다.1. 문제https://leetcode.com/problems/top-k-frequent-elements/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked 문제입니다.4. 문제 해석 배열이 들어오고 k가 들어옵니다. k는 저장공간의 크기이고, 가장 많이 반복된 숫자들을 k만큼의 저장공간에 넣어 리턴합니다. map과 pq를 써야한다는 것은 알았지만 코드에 담아내지 못해 discuss를 참조했습니다. (그냥 못했다는 소리)5. codec++class Solution {public: vector&amp;lt;int&amp;gt; topKFrequent(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) { unordered_map&amp;lt;int,int&amp;gt; um; for(size_t i = 0 ; i&amp;lt;nums.size();++i) um[nums[i]]++; vector&amp;lt;int&amp;gt; res; priority_queue&amp;lt;pair&amp;lt;int,int&amp;gt;&amp;gt; pq; for(auto it = um.begin(); it!=um.end(); ++it){ pq.push(make_pair(it-&amp;gt;second,it-&amp;gt;first)); if(pq.size() &amp;gt; (int)um.size() - k){ res.push_back(pq.top().second); pq.pop(); } } return res; }};6. 결과 및 후기, 개선점c++ 90%" }, { "title": "Programmers_카카오2020 인턴십 - 키패드 누르기", "url": "/posts/Programmers_kakao_Intership_keypad/", "categories": "Algorithm, Programmers", "tags": "Programmers, kakao2020ship", "date": "2021-04-06 16:30:40 +0900", "snippet": "프로그래머스 - 키패드 누르기 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/672562. 분류 및 난이도Programmers 문제입니다.2020년도 kakao 인턴십 문제이고, 난이도는 가장 쉬운 난이도입니다.3. 생각한 것들(문제 접근 방법) 두 점 사이의 거리를 구해서 푸는 문제가 아닙니다.4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;utility&amp;gt;#include &amp;lt;cmath&amp;gt;using namespace std;string solution(vector&amp;lt;int&amp;gt; numbers, string hand) { string answer = &quot;&quot;; //왼손 * pair&amp;lt;int,int&amp;gt; left = make_pair(3,0); //오른손 # pair&amp;lt;int,int&amp;gt; right = make_pair(3,2); for(size_t i = 0 ;i&amp;lt;numbers.size();++i){ //0일 때는 넘겨줍니다. //왼손 담당 if( numbers[i]!=0 &amp;amp;&amp;amp; numbers[i]%3 == 1){ answer+=&quot;L&quot;; left.first = numbers[i]/3; left.second = 0; } //오른손 담당 else if( numbers[i]!=0 &amp;amp;&amp;amp; numbers[i]%3==0){ answer+=&quot;R&quot;; right.first = numbers[i]/4; right.second = 2; } //중간 담당 else { //거리 계산 int x; int y; if(numbers[i] ==0) x =3,y=1; else x = numbers[i]/3,y = numbers[i]%3 -1; int leftdis = abs(left.first-x) + abs(left.second-y); int rightdis = abs(right.first-x) + abs(right.second-y); if(leftdis == rightdis){ if(hand == &quot;right&quot;) { answer += &quot;R&quot;; right.first = x; right.second =y; } else { left.first = x; left.second = y; answer += &quot;L&quot;; } } else{ if(leftdis &amp;lt; rightdis){ answer+=&quot;L&quot;; left.first = x; left.second = y; } else { answer +=&quot;R&quot;; right.first = x; right.second =y; } } } } return answer;}5. 결과필요시." }, { "title": "Programmers_월간 코드 챌린지 시즌1 - 3진법 뒤집기", "url": "/posts/Programmers_codeChallenge_reverse_three/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-04-06 16:30:40 +0900", "snippet": "프로그래머스 - 3진법 뒤집기 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/689352. 분류 및 난이도Programmers 문제입니다.월간 코드 챌린지 시즌1 문제입니다. 가장 쉬운 난이도 입니다.3. 생각한 것들(문제 접근 방법) string을 써서 쉽게 풀었습니다.4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;cmath&amp;gt;using namespace std;int solution(int n) { int answer = 0; string str = &quot;&quot;; while(n!=0){ str += (n%3) + 48; n/=3; } int exp = 0; for(int i = str.size()-1; i&amp;gt;=0;--i){ answer += pow(3,exp++) * (str[i]-48); } return answer;}5. 결과필요시." }, { "title": "Programmers_이상한 문자 만들기", "url": "/posts/Programmers_make_strange_str/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-04-06 14:34:40 +0900", "snippet": "프로그래머스 - 이상한 문자 만들기 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/129302. 분류 및 난이도Programmers 문제입니다.Level 1난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 직관적이고 어렵지 않은 문제입니다.4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;string solution(string s) { int count = 0 ; for(size_t i = 0 ;i&amp;lt;s.size();++i){ if(s[i] == &#39; &#39;){ count=0; continue; } if(count==0 || count%2==0) s[i] = toupper(s[i]); else if(count%2==1) s[i] = tolower(s[i]); ++count; } return s;}5. 결과필요시." }, { "title": "leetcode(리트코드)4월06일 challenge1551-Minimum Operations to Make Array Equal", "url": "/posts/leetcode_Minimum_Operations_to_Make_Array_Equal/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-04-06 14:00:56 +0900", "snippet": "leetcode April 06일 - Minimum Operations to Make Array Equal 문제입니다.1. 문제https://leetcode.com/problems/minimum-operations-to-make-array-equal/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.4월 06일자 챌린지 문제입니다.4. 문제 해석 배열의 요소는 [인덱스 * 2 + 1]입니다. 한 가지 요소를 선택하여 1을 올리고 한 가지 요소를 선택하여 1을 내릴 수 있습니다. 최소한으로 올리고 내려서 모든 배열의 수를 맞출 때 올리고 내린 횟수를 리턴해야합니다.5. codec++class Solution {public: int minOperations(int n) { int* DP = new int[n+1]; DP[0] =0; DP[1] = 0; for(int i =2;i&amp;lt;=n;++i) DP[i] = DP[i-2] + i-1; return DP[n]; }};6. 결과 및 후기, 개선점c++ 100%" }, { "title": "Programmers_문자열 내 마음대로 정렬하기", "url": "/posts/Programmers_level1_sortstr/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-04-06 13:34:40 +0900", "snippet": "프로그래머스 - 문자열 내 마음대로 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/129152. 분류 및 난이도Programmers 문제입니다.Level 1난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 직관적이고 어렵지 않은 문제입니다.4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;using namespace std;vector&amp;lt;string&amp;gt; solution(vector&amp;lt;string&amp;gt; strings, int n) { if(strings.size()==1) return strings; for(size_t i = 0 ; i&amp;lt;strings.size()-1; ++i){ for(size_t j = i+1;j&amp;lt;strings.size();++j){ if(strings[i][n] &amp;gt; strings[j][n]) swap(strings[i],strings[j]); else if(strings[i][n]==strings[j][n]){ if(strings[i]&amp;gt;strings[j]) swap(strings[i],strings[j]); } } } return strings;}5. 결과필요시." }, { "title": "leetcode(리트코드)202-Happy Number", "url": "/posts/leetcode_Happy_Number/", "categories": "leetcode, Eazy", "tags": "leetcode, Top100Interview", "date": "2021-04-06 11:01:00 +0900", "snippet": "leetcode 202 - Happy Number 문제입니다.1. 문제https://leetcode.com/problems/happy-number/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.Top 100 Interview 문제입니다.4. 문제 해석 1이될 때까지 자릿수에 제곱한 수를 더해 봅니다. 만약 1이 될 수 없다면 false를 리턴합니다. 평점이 좋지는 않은데 종료조건이 너무 명확하지 않아서 그런 것 같습니다.5. codec++class Solution {public: long long cal(long long happy){ long long res=0; while(happy!=0){ res += pow(happy%10,2); happy/=10; } return res; } bool isHappy(int n) { long long happy = n; long long fasthappy = n; do{ happy = cal(happy); fasthappy = cal(fasthappy); fasthappy = cal(fasthappy); }while(happy != fasthappy); return happy == 1 ? true : false; }};6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!c++ 100% python ??% " }, { "title": "Programmers_카카오2021blind - 신규 아이디 추천", "url": "/posts/Programmers_kakao2021_blind_id/", "categories": "Algorithm, Programmers", "tags": "Programmers, kakaoblind2021", "date": "2021-04-06 10:30:40 +0900", "snippet": "프로그래머스 - 신규 아이디 추천 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/724102. 분류 및 난이도Programmers 문제입니다.2021년도 kakao Blind 문제이고, 난이도는 가장 쉬운 난이도입니다.3. 생각한 것들(문제 접근 방법) 그리디하게 풀면 됩니다.4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;iostream&amp;gt;using namespace std;void one(string&amp;amp; str){ for(int i = 0 ; i&amp;lt;str.size();++i){ if(isalpha(str[i])) str[i] = tolower(str[i]); //2 if(!isalpha(str[i]) &amp;amp;&amp;amp; !isdigit(str[i]) &amp;amp;&amp;amp; str[i] != &#39;-&#39; &amp;amp;&amp;amp; str[i] !=&#39;_&#39; &amp;amp;&amp;amp; str[i] !=&#39;.&#39;) { str.erase(i,1); --i; } //3 if(i+1&amp;lt;str.size() &amp;amp;&amp;amp; str[i] == &#39;.&#39; &amp;amp;&amp;amp; str[i+1]==&#39;.&#39;) { str.erase(i,1); --i; } }}void eraselast(string&amp;amp; str){ if(str[str.size()-1] ==&#39;.&#39;) str.erase(str.size()-1,1);}string solution(string new_id) { string answer = &quot;&quot;; //1,2,3 one(new_id); //4 if(new_id[0] ==&#39;.&#39;) new_id.erase(0,1); eraselast(new_id); //5 if(new_id.empty()) new_id += &#39;a&#39;; //6 if(new_id.size()&amp;gt;=16){ new_id = new_id.substr(0,15); eraselast(new_id); } else if(new_id.size()&amp;lt;=2){ while(new_id.size()!=3) new_id += new_id[new_id.size()-1]; } return answer = new_id;}5. 결과필요시." }, { "title": "Programmers_나누어 떨어지는 숫자 배열", "url": "/posts/Programmers_Divisor_abcd/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-04-06 06:34:40 +0900", "snippet": "프로그래머스 - 나누어 떨어지는 숫자 배열 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/129102. 분류 및 난이도Programmers 문제입니다.Level 1난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 직관적이고 어렵지 않은 문제입니다.4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;vector&amp;lt;int&amp;gt; solution(vector&amp;lt;int&amp;gt; arr, int divisor) { vector&amp;lt;int&amp;gt; answer; for(size_t i = 0 ; i&amp;lt;arr.size();++i){ if(arr[i]%divisor == 0 ) answer.push_back(arr[i]); } if(answer.empty()) answer.push_back(-1); sort(answer.begin(),answer.end()); return answer;}5. 결과필요시." }, { "title": "leetcode(리트코드)718-Maximum Length of Repeated", "url": "/posts/leetcode_Maximum-Length_of_Repeated_Subarray/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-04-06 02:45:20 +0900", "snippet": "leetcode 718 - Maximum Length of Repeated 문제입니다.1. 문제https://leetcode.com/problems/maximum-length-of-repeated-subarray/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.문제가 안풀려서 random으로 뽑아 푼 문제입니다.4. 문제 해석 LCS와 비슷하게 부분 숫자에서 공통된 연속된 숫자의 길이 중 큰 값을 리턴합니다.5. codec++class Solution {public: int findLength(vector&amp;lt;int&amp;gt;&amp;amp; A, vector&amp;lt;int&amp;gt;&amp;amp; B) { int** DP = new int*[A.size()+1]; for(int i = 0 ; i &amp;lt;A.size()+1;++i) DP[i] = new int[B.size()+1]; int res = 0; for(int i = 0 ; i &amp;lt;A.size()+1;++i) { for(int j = 0 ; j &amp;lt;B.size()+1;++j) { if(i ==0 || j ==0) DP[i][j] =0; else { if(A[i-1] == B[j-1]) DP[i][j] = DP[i-1][j-1] + 1; else DP[i][j] =0; res = max(res,DP[i][j]); } } } return res; }};6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!c++ 232ms 55%" }, { "title": "leetcode(리트코드)57-Insert Interval", "url": "/posts/leetcode_Insert_Interval/", "categories": "leetcode, Medium", "tags": "leetcode, Facebook", "date": "2021-04-06 02:45:20 +0900", "snippet": "leetcode 57 - Insert Interval 문제입니다.1. 문제https://leetcode.com/problems/insert-interval/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.https://www.teamblind.com/post/New-Year-Gift---Curated-List-of-Top-75-LeetCode-Questions-to-Save-Your-Time-OaM1orEU에서 추천한 문제입니다.4. 문제 해석 문제가 직관적입니다.5. codec++class Solution {public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; insert(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; intervals, vector&amp;lt;int&amp;gt;&amp;amp; newInterval) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; int index = 0 ; while(index &amp;lt; intervals.size() &amp;amp;&amp;amp; intervals[index][1] &amp;lt; newInterval[0]){ res.push_back(intervals[index++]); } while(index &amp;lt; intervals.size() &amp;amp;&amp;amp; intervals[index][0] &amp;lt;= newInterval[1]){ newInterval[0] = min(newInterval[0],intervals[index][0]); newInterval[1] = max(newInterval[1],intervals[index][1]); ++index; } res.push_back(newInterval); while(index &amp;lt; intervals.size()){ res.push_back(intervals[index++]); } return res; }};6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!c++ 16ms 60%" }, { "title": "leetcode(리트코드)287-Find the Duplicate Number", "url": "/posts/leetcode_Find_the_Duplicate_Number/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Like", "date": "2021-04-05 13:34:50 +0900", "snippet": "leetcode 287 - Find the Duplicate Number 문제입니다.1. 문제https://leetcode.com/problems/find-the-duplicate-number/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked 문제입니다.4. 문제 해석 배열이 들어옵니다. 반복되는 요소가 있는데, 그 요소를 찾아 값을 리턴합니다.5. codec++class Solution {public: int findDuplicate(vector&amp;lt;int&amp;gt;&amp;amp; nums) { sort(nums.begin(),nums.end()); for(size_t i = 0 ; i&amp;lt;nums.size();++i){ if(nums[i]==nums[i+1]) return nums[i]; } return 0; }};6. 결과 및 후기, 개선점c++ 73%" }, { "title": "leetcode(리트코드)172-Factorial Trailing Zeroes", "url": "/posts/leetcode_Factorial_Trailing_Zeroes/", "categories": "leetcode, Eazy", "tags": "leetcode, Top100Interview", "date": "2021-04-05 08:01:00 +0900", "snippet": "leetcode 172 - Factorial Trailing Zeroes 문제입니다.1. 문제https://leetcode.com/problems/factorial-trailing-zeroes/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.Top 100 Interview 문제입니다.4. 문제 해석 int 형 정수로 들어온 값의 팩토리얼을 구해서 0의 개수를 리턴합니다. 이건 그냥 공식이 따로 있을 것 같아서 discuss를 봤습니다. 때문인지 평점이 좋지는 않습니다.5. codec++class Solution {public: int trailingZeroes(int n) { long long i = 5; int result = 0; for(i; n/i&amp;gt;0; i*=5) result += n/i; return result; }};6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!c++ 100% python ??% " }, { "title": "leetcode(리트코드)4월05일 challenge775-Global and Local Inversions", "url": "/posts/leetcode_Global_and_Local_Inversions/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-04-05 06:00:56 +0900", "snippet": "leetcode April 05일 - Global and Local Inversions 문제입니다.1. 문제https://leetcode.com/problems/global-and-local-inversions/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.4월 05일자 챌린지 문제입니다.4. 문제 해석 배열의 크기-1만큼의 요소값을 갖는 배열이 들어옵니다. Global과 local의 갯수가 다르면 false를 리턴합니다. A[i]가 i번째 인덱스와 1이상 차이나는 경우에 local과 global의 갯수가 달라집니다. A[i]가 i번째 인덱스와 같거나 1만큼 크면 갯수가 유지가 됩니다.(경우의 수로 안치므로)5. codec++class Solution {public: bool isIdealPermutation(vector&amp;lt;int&amp;gt;&amp;amp; A) { for(int i =0;i&amp;lt;A.size();++i){ if(A[i] == i || A[i] ==i+1 || A[i]==i-1) continue; else return false; } return true; }};6. 결과 및 후기, 개선점c++ 81%" }, { "title": "leetcode(리트코드)4월04일 challenge622-Design Circular Queue", "url": "/posts/leetcode_Design_Circular_Queue/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-04-04 02:00:56 +0900", "snippet": "leetcode April 04일 - Design Circular Queue 문제입니다.1. 문제https://leetcode.com/problems/design-circular-queue/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.4월 04일자 챌린지 문제입니다.4. 문제 해석 원형 큐를 만듭니다.5. code내가 푼 c++c++class MyCircularQueue {public: list&amp;lt;int&amp;gt; li; list&amp;lt;int&amp;gt;::iterator head; list&amp;lt;int&amp;gt;::iterator rear; int lisize; MyCircularQueue(int k) { lisize = k; } bool enQueue(int value) { if(li.size()==lisize){ return false; } else{ li.push_back(value); if(li.size()==1){ head = li.begin(); } rear = li.end(); } return true; } bool deQueue() { if(li.empty())return false; li.erase(head); if(!li.empty()) head = li.begin(); return true; } int Front() { return li.empty() ? -1 : li.front(); } int Rear() { return li.empty() ? -1 : li.back(); } bool isEmpty() { return li.size() == 0 ? true : false; } bool isFull() { return li.size() == lisize ? true : false; }};/** * Your MyCircularQueue object will be instantiated and called as such: * MyCircularQueue* obj = new MyCircularQueue(k); * bool param_1 = obj-&amp;gt;enQueue(value); * bool param_2 = obj-&amp;gt;deQueue(); * int param_3 = obj-&amp;gt;Front(); * int param_4 = obj-&amp;gt;Rear(); * bool param_5 = obj-&amp;gt;isEmpty(); * bool param_6 = obj-&amp;gt;isFull(); */6. 결과 및 후기, 개선점c++ 64%" }, { "title": "Programmers_자릿수 더하기", "url": "/posts/Programmers_add_to_index/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-04-03 16:15:15 +0900", "snippet": "프로그래머스 - 자릿수 더하기 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/129312. 분류 및 난이도Programmers 문제입니다.Level 1난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 직관적이고 어렵지 않은 문제입니다.4. 접근 방법을 적용한 코드#include &amp;lt;iostream&amp;gt;using namespace std;int solution(int n){ int answer = 0; while(n!=0) answer += n%10, n/=10; return answer;}5. 결과필요시." }, { "title": "Programmers_제일 작은 수 제거하기", "url": "/posts/Programmers_findMin_Erase/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-04-03 13:34:13 +0900", "snippet": "프로그래머스 - 제일 작은 수 제거하기 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/129352. 분류 및 난이도Programmers 문제입니다.Level 1난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 직관적이고 어렵지 않은 문제입니다. O(n)으로 빠르게 제거하는 코드입니다.4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;vector&amp;lt;int&amp;gt; solution(vector&amp;lt;int&amp;gt; arr) { auto min = arr.begin(); for(auto it = arr.begin(); it!=arr.end(); ++it){ if(*min &amp;gt; *it) min = it; } arr.erase(min); if(arr.size()==0){ arr.push_back(-1); } return arr;}5. 결과필요시." }, { "title": "Programmers_평균 구하기", "url": "/posts/Programmers_avg/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-04-03 13:33:40 +0900", "snippet": "프로그래머스 - 평균 구하기 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/129442. 분류 및 난이도Programmers 문제입니다.Level 1난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 직관적이고 어렵지 않은 문제입니다.4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;double solution(vector&amp;lt;int&amp;gt; arr) { if(arr.size()==1)return arr[0]; double answer = 0; for(size_t i = 1 ;i&amp;lt;arr.size();++i) arr[i] +=arr[i-1]; answer = arr[arr.size()-1] / double(arr.size()); return answer;}5. 결과필요시." }, { "title": "Programmers_두 정수 사이의 합", "url": "/posts/Programmers_two_sum/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-04-03 13:12:12 +0900", "snippet": "프로그래머스 - 두 정수 사이의 합 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/129122. 분류 및 난이도Programmers 문제입니다.Level 1난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 직관적이고 어렵지 않습니다.4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;long long solution(int a, int b) { long long answer = 0; for(int i = min(a,b); i&amp;lt;=max(a,b);++i) answer += i; return answer;}5. 결과필요시." }, { "title": "Programmers_휴대폰 번호 가리기", "url": "/posts/Programmers_Close_Phone_number/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-04-03 12:30:40 +0900", "snippet": "프로그래머스 - 휴대폰 번호 가리기 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/129482. 분류 및 난이도Programmers 문제입니다.Level 1난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 직관적이고 어렵지 않은 문제입니다.4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;string solution(string phone_number) { string answer = &quot;&quot;; for(int i = phone_number.size()-5; i&amp;gt;=0;--i) phone_number[i]=&#39;*&#39;; answer=phone_number; return answer;}5. 결과필요시." }, { "title": "Programmers_하샤드 수", "url": "/posts/Programmers_hashad/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-04-03 12:12:40 +0900", "snippet": "프로그래머스 - 하샤드 수 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/129472. 분류 및 난이도Programmers 문제입니다.Level 1난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 직관적이고 어렵지 않은 문제입니다.4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;bool solution(int x) { int tempx = x; int sum = 0 ; while(tempx!=0){ sum+=tempx%10; tempx/=10; } return x%sum ==0 ? true : false;}5. 결과필요시." }, { "title": "Programmers_최대 공약수와 최소 공배수", "url": "/posts/Programmers_gcd_ggcd/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-04-03 12:11:10 +0900", "snippet": "프로그래머스 - 최대 공약수와 최소 공배수 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/129402. 분류 및 난이도Programmers 문제입니다.Level 1난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 직관적이고 어렵지 않은 문제입니다. 유클리드 호제법을 사용하였습니다.4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;int gcd(int a, int b) { int r; while (b != 0) { r = a % b; a = b; b = r; } return a; }vector&amp;lt;int&amp;gt; solution(int n, int m) { vector&amp;lt;int&amp;gt; answer; answer.push_back(gcd(n,m)); answer.push_back((n*m) / gcd(n,m)); return answer;}5. 결과필요시." }, { "title": "Programmers_정수 내림차순으로 배치하기", "url": "/posts/Programmers_sort_up_bottom/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-04-03 11:33:40 +0900", "snippet": "프로그래머스 - 정수 내림차순으로 배치하기 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/129332. 분류 및 난이도Programmers 문제입니다.Level 1난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 직관적이고 어렵지 않습니다.4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;long long solution(long long n) { long long answer = 0; string temp = to_string(n); sort(temp.begin(),temp.end(),greater&amp;lt;char&amp;gt;()); return answer = stol(temp);}5. 결과필요시." }, { "title": "Programmers_짝수와 홀수", "url": "/posts/Programmers_even_odd/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-04-03 11:12:40 +0900", "snippet": "프로그래머스 - 짝수와 홀수 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/129372. 분류 및 난이도Programmers 문제입니다.Level 1난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 직관적이고 어렵지 않은 문제입니다.4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;string solution(int num) { string answer = &quot;&quot;; return answer = num%2 == 0 ? &quot;Even&quot; : &quot;Odd&quot;;}5. 결과필요시." }, { "title": "Programmers_정수 제곱근 판별", "url": "/posts/Programmers_Judge_sqrt/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-04-03 08:12:40 +0900", "snippet": "프로그래머스 - 정수 제곱근 판별 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/129342. 분류 및 난이도Programmers 문제입니다.Level 1난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 직관적이고 어렵지 않은 문제입니다. 계산이 부정확해서 틀렸다고 생각했는데 잘 넘어갔습니다.4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;cmath&amp;gt;using namespace std;long long solution(long long n) { long long answer = 0; int find = (sqrt(n) - (int)sqrt(n)) &amp;gt;0 ? -1 : sqrt(n); return find == -1 ? -1 : pow(find+1,2);}5. 결과필요시." }, { "title": "Programmers_콜라츠 추측", "url": "/posts/Programmers_judge_colaz/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-04-03 06:12:40 +0900", "snippet": "프로그래머스 - 콜라츠 추측 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/12943#qna2. 분류 및 난이도Programmers 문제입니다.Level 1난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 직관적이고 어렵지 않은 문제입니다. 받아온 int를 그대로 쓸 경우 오버플로가 날 수 있습니다.4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;int solution(int num) { long long tempn = num; int answer = 0; while(answer&amp;lt;=500 &amp;amp;&amp;amp; tempn!=1){ if(tempn%2 ==0)tempn/=2,answer++; else tempn=(tempn * 3 + 1),answer++; } return answer == 501 ? -1 : answer;}-----5. 결과필요시." }, { "title": "Programmers_Summer/Winter Coding(~2018) - 소수 만들기", "url": "/posts/Programmers_make_sosu/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-04-03 02:30:40 +0900", "snippet": "프로그래머스 - 소수만들기 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/129772. 분류 및 난이도Programmers 문제입니다.Level 1난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 주어진 벡터에서 요소를 3개 뽑아 소수를 만들 수 있는지 확인합니다. 1000이하의 자연수가 50 최대 50번 나올 수 있으므로(중복 없다고 했지만 그냥 넉넉하게) 1000 * 50의 사이즈를 가진 벡터를 만들었습니다. 에라토스테네스의 체를 이용하였습니다.4. 접근 방법을 적용한 코드#include &amp;lt;vector&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;cmath&amp;gt;using namespace std;int solution(vector&amp;lt;int&amp;gt; nums) { int answer = 0; //소수 벡터 const int size = 50000; vector&amp;lt;int&amp;gt; sosu(size,0); for(int i = 2; i &amp;lt; size ; ++i) sosu[i] = i; for(int i = 2 ; i&amp;lt;=sqrt(size);++i){ if(sosu[i]==0) continue; for(int j = 2*i; j&amp;lt;=size;j+=i){ sosu[j] = 0; } } for(int i = 0;i&amp;lt;nums.size()-2;++i){ for(int j = i+1; j &amp;lt;nums.size()-1;++j){ for(int k = j+1; k &amp;lt;nums.size();++k) if(sosu[nums[i] + nums[j] + nums[k]] !=0) ++answer; } } return answer;}5. 결과필요시." }, { "title": "Programmers_x만큼 간격이 있는 n개의 숫자", "url": "/posts/Programmers_x_n/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-04-03 02:30:30 +0900", "snippet": "프로그래머스 - x만큼 간격이 있는 n개의 숫자 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/129542. 분류 및 난이도Programmers 문제입니다.Level 1난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 직관적이고 쉬운 문제입니다.4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;vector&amp;lt;long long&amp;gt; solution(int x, int n) { vector&amp;lt;long long&amp;gt; answer; for(int i = 1 ; i&amp;lt;=n;++i) answer.push_back(x * i); return answer;}5. 결과필요시." }, { "title": "Programmers_Summer/Winter Coding(~2018) - 예산", "url": "/posts/Programmers_Budget/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-04-03 01:30:40 +0900", "snippet": "프로그래머스 - 예산 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/129822. 분류 및 난이도Programmers 문제입니다.Level 1난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) 예산이 주어지고 요청 예산벡터가 주어집니다. 최대한 많은 예산을 줄 수 있는 경우의 갯수를 리턴합니다. 작은 값을 순서대로 넣으면 되므로 어렵지 않습니다.4. 접근 방법을 적용한 코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int solution(vector&amp;lt;int&amp;gt; d, int budget) { int answer = 0; sort(d.begin(),d.end()); for(auto it = d.begin(); it!=d.end(); ++it){ if(budget&amp;gt;= *it) ++answer,budget -= *it; else break; } return answer;}5. 결과필요시." }, { "title": "Programmers_자연수 뒤집어서 배열로 만들기", "url": "/posts/Programmers_reverse_int/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-04-03 01:01:01 +0900", "snippet": "프로그래머스 - 자연수 뒤집어서 배열로 만들기 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/129322. 분류 및 난이도Programmers 문제입니다.Level 1난이도의 문제입니다.3. 생각한 것들(문제 접근 방법) no hard so eazy4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;vector&amp;lt;int&amp;gt; solution(long long n) { vector&amp;lt;int&amp;gt; answer; while(n!=0){ answer.push_back(n%10); n/=10; } return answer;}5. 결과필요시." }, { "title": "leetcode(리트코드)128-Longest Consecutive Sequence", "url": "/posts/leetcode_Longest_Consecutive_Sequence/", "categories": "leetcode, Hard", "tags": "leetcode, Facebook", "date": "2021-04-02 04:45:20 +0900", "snippet": "leetcode 128 - Longest Consecutive Sequence 문제입니다.1. 문제https://leetcode.com/problems/longest-consecutive-sequence/2. Input , Output3. 분류 및 난이도Hard 난이도 문제입니다.https://www.teamblind.com/post/New-Year-Gift---Curated-List-of-Top-75-LeetCode-Questions-to-Save-Your-Time-OaM1orEU에서 추천한 문제입니다.4. 문제 해석 그래프로 분류되어 있는데 그래프로 안 풀었습니다. 그리디로 품. set으로 중복을 제거하고 순차적으로 접근하여 확인하였습니다.5. codec++class Solution {public: int longestConsecutive(vector&amp;lt;int&amp;gt;&amp;amp; nums) { if(nums.size()==0) return 0; set&amp;lt;int&amp;gt; st; int count =1; for(size_t i = 0;i&amp;lt;nums.size();++i){ st.insert(nums[i]); } if(st.size()==1) return 1; int num = INT_MAX; int temp = 0; int answer = 1; for(auto it = st.begin(); it!=st.end();++it) { if(num==INT_MAX){num = *it; continue;} else{ temp = num; num = *it; if(temp+1 != num) { count=1; continue; } ++count; answer = max(answer, count); } } return answer; }};6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!c++ 4ms 98%" }, { "title": "leetcode(리트코드)279-Perfect Squares", "url": "/posts/leetcode_Perfect_Squares/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Like", "date": "2021-04-02 03:04:50 +0900", "snippet": "leetcode 279 - Perfect Squares 문제입니다.1. 문제https://leetcode.com/problems/perfect-squares/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked 문제입니다.4. 문제 해석 최소한의 거듭제곱을 사용하여 n을 만들어야 합니다. 최소한의 경우의 수를 리턴합니다.5. codec++class Solution {public: int exp(int n){ int i = 2; while(!(pow(i,2)&amp;lt;= n &amp;amp;&amp;amp; pow(i+1,2)&amp;gt;n)){ ++i; } return i; } int numSquares(int n) { vector&amp;lt;int&amp;gt; DP(n+4,987); DP[1]=1; DP[2]=2; DP[3]=3; if(n&amp;lt;=3)return DP[n]; for(int i = 4 ;i&amp;lt;=n;++i){ //거듭제곱 지수 찾기 int findexp = exp(i); if(pow(findexp,2)==i) DP[i] = 1; else{ while(findexp&amp;gt;1) { int expr = pow(findexp,2); DP[i] = min(DP[expr] + DP[i - expr], DP[i]); --findexp; } } } return DP[n]; }};6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!실행속도가 빠른 코드는 수학적으로 풀었는데 제가 해석을 못하여 첨부하지는 않겠습니다." }, { "title": "Programmers_카카오2018Blind[1차] - 뉴스 클러스터링", "url": "/posts/Programmers_Kakao2018_Blind_New_Clustering/", "categories": "Algorithm, Programmers", "tags": "Programmers, kakaoblind2018", "date": "2021-04-02 02:23:40 +0900", "snippet": "프로그래머스 - 뉴스 클러스터링 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/176772. 분류 및 난이도Programmers 문제입니다.2018년도 kakao Blind 1차 문제이고, 난이도는 level2 난이도입니다.3. 생각한 것들(문제 접근 방법) 문제에서 합집합을 구할 때 max 어쩌구해서 복잡하게 구하는데 수학시간에 합집합은 A 집합의 크기 + B 집합의 크기 - 교집합의 크기로 구한다고 배웠습니다. 이렇게 구하는게 더 쉬웠습니다. 접근하기 쉬운 map에 각각 원소를 넣으면서 이미 존재하면 count값을 올려주고 없으면 1로 초기화 해줍니다. 넣으면서 집합의 크기를 count해줘야합니다. isalpha()함수를 통해 영어인지 확인해주었고 tolower()함수를 통해 소문자로 일관성을 주었습니다.4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;unordered_map&amp;gt;#include &amp;lt;cctype&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;cmath&amp;gt;using namespace std;int solution(string str1, string str2) { int answer = 0; unordered_map&amp;lt;string,int&amp;gt; mtm1; unordered_map&amp;lt;string,int&amp;gt; mtm2; //합집합 크기 int sum = 0; //교집합 크기 int intersection = 0; //str1부터 for(size_t i = 0;i&amp;lt;str1.size()-1;++i){ // 영어이면 map에 넣습니다. if(isalpha(str1[i]) &amp;amp;&amp;amp; isalpha(str1[i+1])){ string tempstr = &quot;&quot;; tempstr+=tolower(str1[i]); tempstr += tolower(str1[i+1]); if(mtm1.count(tempstr)) mtm1[tempstr]++; else mtm1[tempstr] = 1; ++sum; } } //str2 for(size_t i = 0;i&amp;lt;str2.size()-1;++i){ if(isalpha(str2[i]) &amp;amp;&amp;amp; isalpha(str2[i+1])){ string tempstr = &quot;&quot;; tempstr+=tolower(str2[i]); tempstr += tolower(str2[i+1]); if(mtm2.count(tempstr)) mtm2[tempstr]++; else mtm2[tempstr] = 1; ++sum; } } //map에 한 개도 안들어와있으면 65536을 리턴 if(mtm1.empty() &amp;amp;&amp;amp; mtm2.empty()) return 65536; // map1을 돌면서 map2에 똑같은게 있으면 더 작은값(교집합)을 intersection에 더해줍니다. for(auto it = mtm1.begin(); it!=mtm1.end();++it){ string str = it-&amp;gt;first; if(mtm2.find(str) != mtm2.end()){ intersection += min(mtm1[str],mtm2[str]); } } //합집합 구하기 sum -=intersection; //연산을 위해 형 변환 double gob = intersection / (double)sum * 65536; //소수점 버림. gob = trunc(gob); answer=gob; return answer;}5. 결과필요시." }, { "title": "leetcode(리트코드)171-Excel Sheet Column Number", "url": "/posts/leetcode_Excel_Sheet_Column_Number/", "categories": "leetcode, Eazy", "tags": "leetcode, Top100Interview", "date": "2021-04-02 01:01:00 +0900", "snippet": "leetcode 171 - Excel Sheet Column Number 문제입니다.1. 문제https://leetcode.com/problems/excel-sheet-column-number/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.Top 100 Interview 문제입니다.4. 문제 해석 A = 1, B = 2, … , Z = 26 값을 가집니다. 문자열이 들어왔을 때 엑셀처럼 값을 반환해야합니다. AA는 27 AB는 28….5. codec++class Solution {public: int titleToNumber(string columnTitle) { int result = 0 ; int pownum = 0; for(int i = columnTitle.size()-1;i&amp;gt;=0;--i){ result+= (pow(26,pownum++) * (columnTitle[i]-64) ); } return result; }};6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!c++ 100% python ??% " }, { "title": "Programmers_월간 코드 챌린지 - 두 개 뽑아서 더하기", "url": "/posts/Programmers_code_Callenge_sum_twoint/", "categories": "Algorithm, Programmers", "tags": "Programmers, codechallenge", "date": "2021-04-01 16:30:40 +0900", "snippet": "프로그래머스 - 두 개 뽑아서 더하기 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/686442. 분류 및 난이도Programmers 문제입니다.월간 코드 챌린지 문제입니다.3. 생각한 것들(문제 접근 방법) 배열 안에 있는 요소를 2개 뽑아서 만들 수 있는 모든 경우의 수의 값을 구해 리턴합니다. 중복은 제외해야합니다 -&amp;gt; set을 쓴 이유4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;unordered_set&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;vector&amp;lt;int&amp;gt; solution(vector&amp;lt;int&amp;gt; numbers) { vector&amp;lt;int&amp;gt; answer; unordered_set&amp;lt;int&amp;gt; s; for(size_t i = 0;i&amp;lt;numbers.size();++i){ for(size_t j = i+1;j&amp;lt;numbers.size();++j) { int sum = numbers[i] + numbers[j]; if(s.count(sum)) continue; s.insert(sum); answer.push_back(sum); } } sort(answer.begin(),answer.end()); return answer;}5. 결과필요시." }, { "title": "Programmers_카카오2019겨울 인턴십 - 크레인 인형 뽑기", "url": "/posts/Programmers_kakao2019_doll_game/", "categories": "Algorithm, Programmers", "tags": "Programmers, kakao2019ship", "date": "2021-04-01 14:30:40 +0900", "snippet": "프로그래머스 - 크레인 인형 뽑기 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/640612. 분류 및 난이도Programmers 문제입니다.2019년도 kakao 겨울 인턴십 문제이고, 난이도는 가장 쉬운 난이도입니다.3. 생각한 것들(문제 접근 방법) 인형뽑기를 하여 바구니에 넣는데 바구니 맨 위의 값과 같으면 인형을 집은 인형과 바구니의 인형을 뺍니다. 뺀 인형의 개수를 구합니다. stack을 이용하라고 문제에서 대놓고 알려줘서 어렵지 않습니다.4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;iostream&amp;gt;using namespace std;int solution(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; board, vector&amp;lt;int&amp;gt; moves) { int answer = 0; stack&amp;lt;int&amp;gt; st; int row = board.size(); for(int i = 0;i&amp;lt;moves.size();++i){ int index = moves[i]-1; int count = 0; while(count &amp;lt; row &amp;amp;&amp;amp; board[count][index]==0){ ++count; } if(count==row) continue; int find = board[count][index]; board[count][index]=0; if(st.empty()) st.push(find); else{ if(st.top() == find) answer+=2,st.pop(); else st.push(find); } } return answer;}5. 결과필요시." }, { "title": "Programmers_카카오2018blind - 캐시", "url": "/posts/Programmers_cache/", "categories": "Algorithm, Programmers", "tags": "Programmers, kakaoblind2018", "date": "2021-04-01 13:30:40 +0900", "snippet": "프로그래머스 - 캐시 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/176802. 분류 및 난이도Programmers 문제입니다.2018년도 kakao Blind 문제이고, 난이도는 가장 쉬운 난이도입니다.3. 생각한 것들(문제 접근 방법) LRU 알고리즘을 사용했을 때 걸리는 시간을 리턴하는 간단한 문제입니다.4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include&amp;lt;unordered_map&amp;gt;#include&amp;lt;list&amp;gt;#include&amp;lt;cctype&amp;gt;using namespace std;//대소문자 구분을 안하므로 모든 영어를 소문자로 바꿔줍니다.string changelower(string str){ for(size_t i =0;i&amp;lt;str.size();++i) str[i] = tolower(str[i]); return str;}int solution(int cacheSize, vector&amp;lt;string&amp;gt; cities) { //LRU 구현 int answer = 0; list&amp;lt;string&amp;gt; dq; unordered_map&amp;lt;string,list&amp;lt;string&amp;gt;::iterator&amp;gt; um; for(size_t i =0;i&amp;lt;cities.size();++i){ string putstr = changelower(cities[i]); if(cacheSize==0){ answer+=5; continue; } if(um.find(putstr) == um.end()){ answer+=5; if(dq.size() == cacheSize){ string last = dq.back(); dq.pop_back(); um.erase(last); } } else{ answer+=1; dq.erase(um[putstr]); } dq.push_front(putstr); um[putstr] = dq.begin(); } return answer;}5. 결과필요시." }, { "title": "Programmers_2016", "url": "/posts/Programmers_2016/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-04-01 12:31:40 +0900", "snippet": "프로그래머스 - 2016 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/129012. 분류 및 난이도Programmers 문제입니다.level 1 ~ 2의 문제입니다.3. 생각한 것들(문제 접근 방법) 월, 일이 주어졌을 때 요일을 예측합니다. 조심해야할 점은 7,8월이 31일까지라는 점 윤년이라는 점이 있습니다.4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;iostream&amp;gt;using namespace std;string solution(int a, int b) { int month[12] = {31,29,31,30,31,30,31,31,30,31,30,31}; string day[7] = {&quot;FRI&quot;,&quot;SAT&quot;,&quot;SUN&quot;,&quot;MON&quot;,&quot;TUE&quot;,&quot;WED&quot;,&quot;THU&quot;}; int totalday = 0; for(int i = 0; i&amp;lt;(a-1);++i) totalday+=month[i]; totalday+=b; return day[(totalday-1)%7];}5. 결과필요시." }, { "title": "leetcode(리트코드)133-Clone Graph", "url": "/posts/leetcode_Clone_Graph/", "categories": "leetcode, Medium", "tags": "leetcode, Facebook", "date": "2021-04-01 04:45:20 +0900", "snippet": "leetcode 133 - Clone Graph 문제입니다.1. 문제https://leetcode.com/problems/clone-graph/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.https://www.teamblind.com/post/New-Year-Gift---Curated-List-of-Top-75-LeetCode-Questions-to-Save-Your-Time-OaM1orEU에서 추천한 문제입니다.4. 문제 해석 그래프문제입니다. 들어온 그래프를 깊은 복사를 해서 리턴합니다. discuss를 보고 이해했습니다.5. codec++/*// Definition for a Node.class Node {public: int val; vector&amp;lt;Node*&amp;gt; neighbors; Node() { val = 0; neighbors = vector&amp;lt;Node*&amp;gt;(); } Node(int _val) { val = _val; neighbors = vector&amp;lt;Node*&amp;gt;(); } Node(int _val, vector&amp;lt;Node*&amp;gt; _neighbors) { val = _val; neighbors = _neighbors; }};*/class Solution { //map을 사용하는 이유는 모든 경로를 조사해서 값을 넣는다해도 중복값이 저장되지 않기 때문입니다. private: unordered_map&amp;lt;Node*,Node*&amp;gt; um;public: Node* cloneGraph(Node* node) { if(!node)return NULL; Node* cpnode = new Node(node-&amp;gt;val); um[node] = cpnode; queue&amp;lt;Node*&amp;gt; nq; nq.push(node); while(!nq.empty()){ Node* origin = nq.front(); nq.pop(); for(int i = 0;i&amp;lt;origin-&amp;gt;neighbors.size();++i){ Node* neighbor = origin-&amp;gt;neighbors[i]; if(um.find(neighbor) ==um.end()){ um[neighbor] = new Node(neighbor-&amp;gt;val); nq.push(neighbor); } um[origin]-&amp;gt;neighbors.push_back(um[neighbor]); } } return cpnode; }};6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!" }, { "title": "leetcode(리트코드)236-Lowest Common Ancestor of a Binary Tree", "url": "/posts/leetcode_Lowest_Common_Ancestor_of_a_Binary_Tree/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Like", "date": "2021-04-01 03:04:50 +0900", "snippet": "leetcode 236 - Lowest Common Ancestor of a Binary Tree 문제입니다.1. 문제https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked 문제입니다.4. 문제 해석 P와 Q를 자식으로 갖는 가장 레벨이 큰 부모노드를 찾습니다. discuss를 봤습니다.5. codec++/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { //만약 찾거나 끝의 노드에 접근하면 반환합니다. if(!root || root ==q || root==p) return root; TreeNode* l = lowestCommonAncestor(root-&amp;gt;left,p,q); TreeNode* r = lowestCommonAncestor(root-&amp;gt;right,p,q); //부모 노드 안에서 l과 r이 있으면 root노드를 반환, 하나만 찾았으면 하나의 노드를 쭉 가지고 올라갑니다. return !l ? r : !r? l : root; }};6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!discuss 코드를 보고 재귀의 힘을 느끼면서 공부를 더 많이 해야겠다는 생각을 했습니다.." }, { "title": "leetcode(리트코드)125-Valid Palindrome", "url": "/posts/leetcode_Valid_Palindrome/", "categories": "leetcode, Eazy", "tags": "leetcode, Top100Interview", "date": "2021-04-01 01:01:00 +0900", "snippet": "leetcode 125 - Valid Palindrome 문제입니다.1. 문제https://leetcode.com/problems/valid-palindrome/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.Top 100 Interview 문제입니다.4. 문제 해석 문자열이 들어오는데, 영문과 숫자만 검사했을 때 회문이 되는 지 검사합니다. 특수문자, 공백은 제외합니다.5. codec++class Solution {public: bool isPalindrome(string s) { int left = 0; int right = s.size()-1; //양방향으로 검사합니다. while(left&amp;lt;=right){ //영문, 숫자가아니면 건너뜁니다. while(left&amp;lt; s.size() &amp;amp;&amp;amp; !isd(s[left]) &amp;amp;&amp;amp; !ise(s[left])){ ++left; } //마찬가지로 건너뜁니다. while(right&amp;gt; 0 &amp;amp;&amp;amp; !isd(s[right]) &amp;amp;&amp;amp; !ise(s[right])){ --right; } //만약 영문숫자가 하나도 안들어온 경우 true if(left&amp;gt;right) return true; //영문자라면 소문자로 바꿔서 비교 if(ise(s[left]) &amp;amp;&amp;amp; ise(s[right]) ){ s[left] = tolower(s[left]); s[right] = tolower(s[right]); } if(s[left] != s[right]) return false; //cout&amp;lt;&amp;lt;s[left]&amp;lt;&amp;lt;&quot; &quot;&amp;lt;&amp;lt;s[right]&amp;lt;&amp;lt;&#39;\\n&#39;; ++left; --right; } return true; } bool isd(char c){ return isdigit(c); } bool ise(char c){ return isalpha(c); }};6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!c++ 52% python ??% " }, { "title": "Programmers_카카오blind2018 - 비밀지도", "url": "/posts/Programmers_Secret_Map/", "categories": "Algorithm, Programmers", "tags": "Programmers, kakaoblind2018", "date": "2021-03-31 15:30:40 +0900", "snippet": "프로그래머스 - 비밀지도 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/176812. 분류 및 난이도Programmers 문제입니다.2018년도 kakao Blind 문제이고, 난이도는 가장 쉬운 난이도입니다.3. 생각한 것들(문제 접근 방법) 문제 난이도자체는 어렵지 않습니다. 효율성이 관건이라 생각하여 어떻게 하면 빨리 풀 지 생각했습니다. 하나의 for문에서 최대한 문제를 해결하려고 했습니다.4. 접근 방법을 적용한 코드```c++#include #include #include#includeusing namespace std;//2진수로 바꿔버리는 함수. 자릿수가 최대 16자리가 되므로 int로 바꾸는게 아닌 string으로 바꿔야함.string maketwo(int num){ if(num==0) return “0”; string making = “”; while(num!=1){ making+=(num%2) +48; num/=2; } making+=’1’; return making;}vector solution(int n, vector arr1, vector arr2) { vector answer; for(size_t i =0;i&amp;lt;n;++i){ //이진수로 바꿈 string first = maketwo(arr1[i]); //만약 이진수로 바꿨는데 자릿수가 안맞으면 0을 추가 while(first.size()!=n) first+=&#39;0&#39;; //이진수로 바꿈 string two = maketwo(arr2[i]); while(two.size()!=n) two+=&#39;0&#39;; //만약n이 5이고 1의 경우 위의코드까지만 했을 땐 10000이므로 reverse인 00001로 바꿔줌. reverse(first.begin(),first.end()); reverse(two.begin(),two.end()); string indexanswer= &quot;&quot;; //바꾼 문자열의 인덱스에서 1이 하나라도 있으면 #을 넣어줍니다. for(size_t j =0;j&amp;lt;n;++j){ if(first[j]== &#39;1&#39; || two[j] == &#39;1&#39;){ indexanswer += &quot;#&quot;; } else indexanswer += &quot; &quot;; } answer.push_back(indexanswer);}return answer; } -----5. 결과필요시." }, { "title": "Programmers_카카오blind2019 - 실패율", "url": "/posts/Programmers_fail/", "categories": "Algorithm, Programmers", "tags": "Programmers, kakaoblind2019", "date": "2021-03-31 14:30:40 +0900", "snippet": "프로그래머스 - 실패율 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/42889#2. 분류 및 난이도Programmers 문제입니다.2019년도 kakao Blind 문제이고, 난이도는 가장 쉬운 난이도입니다.3. 생각한 것들(문제 접근 방법) 정렬된 상태로 푸는게 쉽다고 생각했습니다. 이유는 스테이지를 점차적으로 증가시키고 나중에 실패율로 기준으로 정렬을 다시하려고 했기 때문입니다. 테케의 4,4,4,4,4 같은 경우 때문에 순차적으로 인덱스를 접근하는 방식은 무리가 있다고 생각하여 multiset 자료구조를 사용하였습니다. 0으로 나눠주는 경우를 조심하면 됩니다.4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include&amp;lt;algorithm&amp;gt;#include&amp;lt;iostream&amp;gt;#include&amp;lt;set&amp;gt;using namespace std;//실패율을 기준으로 정렬해주기 위한,bool pred(pair&amp;lt;int, double&amp;gt;&amp;amp; a, pair&amp;lt;int, double&amp;gt;&amp;amp; b) { // 실패율이 같으면 인덱스가 작은 순으로. if (a.second == b.second) return a.first &amp;lt; b.first; return a.second &amp;gt; b.second;}vector&amp;lt;int&amp;gt; solution(int N, vector&amp;lt;int&amp;gt; stages) { vector&amp;lt;int&amp;gt; answer; //인덱스와 실패율 값을 저장할 자료구조 vector &amp;lt; pair&amp;lt;int, double&amp;gt;&amp;gt; DP; //알아서 정렬되도록, count()함수를 이용하여 갯수를 구함. multiset&amp;lt;int&amp;gt; st; for (size_t i = 0; i &amp;lt; stages.size(); ++i) { st.insert(stages[i]); } int stage = 1; int stagesize = stages.size(); while (stage&amp;lt;=N) { double count = st.count(stage); double result; //0으로 나눠주는 경우를 방지 if(stagesize==0) result = 0; else result = count/stagesize; DP.push_back(make_pair(stage, result)); stagesize -= count; ++stage; } //재 정렬 sort(DP.begin(), DP.end(), pred); for (int i = 0; i &amp;lt; DP.size(); ++i) { //cout&amp;lt;&amp;lt;DP[i].first&amp;lt;&amp;lt;&quot; &quot;&amp;lt;&amp;lt;DP[i].second&amp;lt;&amp;lt;&#39;\\n&#39;; answer.push_back(DP[i].first); } return answer;}5. 결과필요시." }, { "title": "Programmers_카카오2018blind - 다트게임", "url": "/posts/Programmers_DartGame/", "categories": "Algorithm, Programmers", "tags": "Programmers, kakaoblind2018", "date": "2021-03-31 13:30:40 +0900", "snippet": "프로그래머스 - 다트게임 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/176822. 분류 및 난이도Programmers 문제입니다.2018년도 kakao Blind 문제이고, 난이도는 가장 쉬운 난이도입니다.3. 생각한 것들(문제 접근 방법) 이전 점수에 대한 정보가 필요하므로 벡터나 배열에 값을 저장해야한다고 생각했습니다. 어차피 숫자 뒤에는 문자가 한 개는 꼭 와야하므로 숫자에 대한 정보를 확인한 뒤 배열범위 검사는 해주지 않았습니다.4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include&amp;lt;vector&amp;gt;#include&amp;lt;iostream&amp;gt;using namespace std;int solution(string dartResult) { int answer = 0; vector&amp;lt;int&amp;gt; score(3, 0); int vin = 0; int i = 0; for (size_t i = 0; i &amp;lt; dartResult.size();) { if (dartResult[i] &amp;gt;= 48 &amp;amp;&amp;amp; dartResult[i] &amp;lt;= 57) { string temp = &quot;&quot;; temp += dartResult[i]; if (dartResult[i + 1] == &#39;0&#39;) { temp += &#39;0&#39;; ++i; } score[vin++] = stoi(temp); ++i; } if (dartResult[i] == &#39;D&#39;) { score[vin-1] = score[vin-1] * score[vin-1]; } else if (dartResult[i] == &#39;T&#39;) { score[vin-1] = score[vin-1] * score[vin-1] * score[vin-1]; } if (dartResult[i] == &#39;*&#39;) { score[vin-1] *= 2; if (vin-1 != 0) score[vin - 2] *= 2; } else if (dartResult[i] == &#39;#&#39;) { score[vin-1] *= (- .1); } ++i; } for(int i = 0;i&amp;lt;3;++i){ answer += score[i]; } return answer;}5. 결과필요시." }, { "title": "leetcode(리트코드)230-Kth Smallest Element in a BST", "url": "/posts/leetcode_Kth_Smallest_Element_in_a_BST/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Like", "date": "2021-03-31 03:04:50 +0900", "snippet": "leetcode 230 - Kth Smallest Element in a BST 문제입니다.1. 문제https://leetcode.com/problems/kth-smallest-element-in-a-bst/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked 문제입니다.4. 문제 해석 이진트리에서 k번째로 작은 값을 리턴하세요. set으로 풀었지만 재귀로 풀어야할 것 같아서 밑에 코드를 첨부하겠습니다.5. codec++/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: void findst(set&amp;lt;int&amp;gt;&amp;amp; st, TreeNode* root){ if(root!=nullptr){ st.insert(root-&amp;gt;val); findst(st,root-&amp;gt;left); findst(st,root-&amp;gt;right); } } int kthSmallest(TreeNode* root, int k) { set&amp;lt;int&amp;gt; st; findst(st,root); int count = 1; for(auto it = st.begin();it!=st.end(); ++it,++count) if(count==k){ return *it; } return 1; }};6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!c++ 50% python ??% 재귀 코드c++class Solution {public: void inorder(TreeNode* root, vector&amp;lt;int&amp;gt; &amp;amp;res){ if(!root) return; inorder(root-&amp;gt;left, res); res.push_back(root-&amp;gt;val); inorder(root-&amp;gt;right,res); } int kthSmallest(TreeNode* root, int k) { if(!root) return -1; vector&amp;lt;int&amp;gt; arr; inorder(root, arr); return arr[k-1]; }};" }, { "title": "leetcode(리트코드)100-Same Tree", "url": "/posts/leetcode_Same_Tree/", "categories": "leetcode, Eazy", "tags": "leetcode, Facebook", "date": "2021-03-31 01:00:20 +0900", "snippet": "leetcode 100 - Same Tree 문제입니다.1. 문제https://leetcode.com/problems/same-tree/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.https://www.teamblind.com/post/New-Year-Gift---Curated-List-of-Top-75-LeetCode-Questions-to-Save-Your-Time-OaM1orEU에서 추천한 문제입니다.4. 문제 해석 p로 들어온 트리와 q로 들어온 트리가 같은지 확인합니다. 모양과 값이 같아야 같은 트리입니다.5. codec++/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: bool isSameTree(TreeNode* p, TreeNode* q) { if(p==nullptr &amp;amp;&amp;amp; q==nullptr) return true; else if(p==nullptr || q==nullptr) return false; else{ if(p-&amp;gt;val != q-&amp;gt;val) return false; return isSameTree(p-&amp;gt;left,q-&amp;gt;left) &amp;amp;&amp;amp; isSameTree(p-&amp;gt;right,q-&amp;gt;right); } }};6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!c++ 100% python ??% " }, { "title": "leetcode(리트코드)3월30일 challenge354-Russian Doll Envelopes", "url": "/posts/leetcode_Russian_Doll_Envelopes/", "categories": "leetcode, Hard", "tags": "leetcode, AlgorithmStudy", "date": "2021-03-30 16:00:56 +0900", "snippet": "leetcode March 30일 - Russian Doll Envelopes 문제입니다.1. 문제https://leetcode.com/problems/russian-doll-envelopes/2. Input , Output3. 분류 및 난이도Hard 난이도입니다.3월 30일자 챌린지 문제입니다.4. 문제 해석 벡터안에 봉투의 width와 height가 주어집니다. 작은 봉투에서 넓은 봉투로 담을 때 가장 큰 담는 횟수를 구하세요. DP로 풀었지만, O(n^2)이기에효율이 좋지는 않습니다.5. codec++bool pred(vector&amp;lt;int&amp;gt;&amp;amp; a,vector&amp;lt;int&amp;gt;&amp;amp; b){ if(a[0] ==b[0]) return a[1]&amp;lt;b[1]; return a[0]&amp;lt;b[0];}class Solution {public: int maxEnvelopes(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; envelopes) { if(envelopes.size()==0) return 0; int* DP = new int[envelopes.size()]; int h = envelopes.size(); int w = envelopes[0].size(); int result =0; sort(envelopes.begin(),envelopes.end(),pred); for(int i = 0;i&amp;lt;h;++i){ DP[i] = 1; for(int j = 0;j&amp;lt;i;++j){ if(envelopes[i][0] &amp;gt; envelopes[j][0] &amp;amp;&amp;amp; envelopes[i][1] &amp;gt; envelopes[j][1]){ DP[i] = max(DP[i], 1+DP[j]); } } result= max(result,DP[i]); } return result; }};6. 결과 및 후기, 개선점c++ 46%" }, { "title": "leetcode(리트코드)91-Decode Ways", "url": "/posts/leetcode_Decode_Ways/", "categories": "leetcode, Medium", "tags": "leetcode, Facebook", "date": "2021-03-30 13:34:20 +0900", "snippet": "leetcode 91 - Decode Ways 문제입니다.1. 문제https://leetcode.com/problems/decode-ways/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.https://www.teamblind.com/post/New-Year-Gift---Curated-List-of-Top-75-LeetCode-Questions-to-Save-Your-Time-OaM1orEU에서 추천한 문제입니다.4. 문제 해석 DP문제입니다. 프로그래머스에 비슷한 문제가 있었던 것 같은데.. ‘0’에 대한 처리를 잘 해주면 특이하게 어려울 건 없는 문제입니다.5. codec++class Solution {public: int numDecodings(string s) { if(s[0]==&#39;0&#39;) return 0; if(s.size()==1) { return 1; } int* DP= new int[s.size()+1]; DP[0]=1; DP[1]=1; for(size_t i =2;i&amp;lt;=s.size();++i){ if(s[i-1]!=&#39;0&#39;) DP[i] = DP[i-1]; else DP[i]=0; string temp =&quot;&quot;; temp+=s[i-2]; temp+=s[i-1]; int con = stoi(temp); if(con&amp;lt;=26 &amp;amp;&amp;amp; con&amp;gt;=10) DP[i] += DP[i-2]; } return DP[s.size()]; }};6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!c++ 100% python ??% " }, { "title": "leetcode(리트코드)3월29일 challenge971-Flip Binary Tree To Match Preorder Traversal", "url": "/posts/leetcode_Flip_Binary_Tree_To_Match_Preorder_Traversal/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-03-30 13:00:56 +0900", "snippet": "leetcode March 29일 - Flip Binary Tree To Match Preorder Traversal 문제입니다.1. 문제https://leetcode.com/problems/flip-binary-tree-to-match-preorder-traversal/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.3월 28일자 챌린지 문제입니다.4. 문제 해석 주어진 트리속에서 자식을 swap하여 preorder했을 때 voyage에 들어온 값과 맞으면 swap한 자식들을 모은 벡터를 리턴합니다.5. codec++/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: bool check(TreeNode* root,vector&amp;lt;int&amp;gt;&amp;amp; voyage, int&amp;amp; count,vector&amp;lt;int&amp;gt;&amp;amp; result){ if(root==nullptr) return true; if(root-&amp;gt;val != voyage[count++]) return false; auto left = root-&amp;gt;left; auto right = root-&amp;gt;right; if(left!=nullptr &amp;amp;&amp;amp; left-&amp;gt;val != voyage[count]){ result.push_back(root-&amp;gt;val); swap(left,right); } return check(left,voyage,count,result) &amp;amp;&amp;amp; check(right,voyage,count,result); } vector&amp;lt;int&amp;gt; flipMatchVoyage(TreeNode* root, vector&amp;lt;int&amp;gt;&amp;amp; voyage) { int count = 0; vector&amp;lt;int&amp;gt; result; if(check(root,voyage,count,result)){ return result; } return vector&amp;lt;int&amp;gt;() = {-1}; }};6. 결과 및 후기, 개선점c++ 74%" }, { "title": "leetcode(리트코드)221-Maximal Square", "url": "/posts/leetcode_Maximal_Square/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Like", "date": "2021-03-30 02:01:10 +0900", "snippet": "leetcode 221 - Maximal Square 문제입니다.1. 문제https://leetcode.com/problems/maximal-square/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked 문제입니다.4. 문제 해석 1로 이루어진 정사각의 넓이가 가장 큰 것의 넓이를 리턴하세요.5. codec++class Solution {public: int maximalSquare(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; matrix) { int DP[301][301]={0,}; int h = matrix.size(); int w = matrix[0].size(); int result= 0; for(int i =0;i&amp;lt;h;++i){ for(int j =0;j&amp;lt;w;++j){ if(i==0 || j==0 || matrix[i][j]==&#39;0&#39;) DP[i][j] = matrix[i][j]-48; else { DP[i][j] = min(DP[i-1][j-1],min(DP[i-1][j],DP[i][j-1])) +1; } result= max(result,DP[i][j]); } } return result*result; }};6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!c++ 60% python ??% " }, { "title": "leetcode(리트코드)122-Best Time to Buy and Sell Stock II", "url": "/posts/leetcode_Best_Time_to_Buy_and_Sell_Stock_II/", "categories": "leetcode, Eazy", "tags": "leetcode, Top100Interview", "date": "2021-03-30 02:01:00 +0900", "snippet": "leetcode 122 - Best Time to Buy and Sell 문제입니다.1. 문제https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.Top 100 Interview 문제입니다.4. 문제 해석 DP문제이고, 비슷한 문제가 너무 많습니다. 다른 포스팅에도 해당 문제가 있으니 참고해주시길 바랍니다.5. codec++class Solution {public: int maxProfit(vector&amp;lt;int&amp;gt;&amp;amp; prices) { int* buy = new int[prices.size()]; int* sell = new int[prices.size()]; buy[0] = -prices[0]; sell[0] = 0; int result = 0; for(int i =1;i&amp;lt;prices.size();++i){ buy[i] = max(buy[i-1],sell[i-1] - prices[i]); sell[i] = max(sell[i-1],buy[i-1] + prices[i]); result = max(result,sell[i]); } return result; }};6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!c++ 42% python ??% " }, { "title": "leetcode(리트코드)3월28일 challenge423-Reconstruct Original Digits from English", "url": "/posts/leetcode_Reconstruct_Original_Digits_from_English/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-03-30 01:01:56 +0900", "snippet": "leetcode March 28일 - Reconstruct Original Digits from English 문제입니다.1. 문제https://leetcode.com/problems/reconstruct-original-digits-from-english/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.3월 28일자 챌린지 문제입니다.4. 문제 해석 문자열에 있는 흩어진 문자열을 모아 오름차순으로 정렬된 숫자를 리턴합니다. 좋은 문제는 아닌게 one,two,three … 하드코딩을 해야합니다.5. codec++class Solution {public: string originalDigits(string s) { int count[10] = {0,}; for(size_t i =0;i&amp;lt;s.size();++i) { char stri = s[i]; if(stri == &#39;z&#39;) count[0]++; if (stri == &#39;w&#39;) count[2]++; if (stri == &#39;x&#39;) count[6]++; if (stri == &#39;s&#39;) count[7]++; //7-6 if (stri == &#39;g&#39;) count[8]++; if (stri == &#39;u&#39;) count[4]++; if (stri == &#39;f&#39;) count[5]++; //5-4 if (stri == &#39;h&#39;) count[3]++; //3-8 if (stri == &#39;i&#39;) count[9]++; //9-8-5-6 if (stri == &#39;o&#39;) count[1]++; //1-0-2-4 } count[7]-=count[6]; count[5] -= count[4]; count[3] -=count[8]; count[9] = count[9] - count[8] - count[5]- count[6]; count[1] = count[1] -count[0] - count[2]-count[4]; string result = &quot;&quot;; for(int i = 0;i&amp;lt;10;++i){ for(int j =0;j&amp;lt;count[i];++j) result+=i+48; } return result; } };6. 결과 및 후기, 개선점c++ 68%편법으로 푼 문제이지만 모두 편법으로 풀었습니다." }, { "title": "leetcode(리트코드)3월27일 challenge647-Palindromic Substrings", "url": "/posts/leetcode_Palindromic_Substrings/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-03-30 01:00:56 +0900", "snippet": "leetcode March 27일 - Palindromic Substrings 문제입니다.1. 문제https://leetcode.com/problems/palindromic-substrings/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.3월 27일자 챌린지 문제입니다.4. 문제 해석 문자열 속에 있는 모든 문자열에 대해 Palindromic이 되는 지 확인하고 개수를 구합니다. 저는 brute하게 풀어서 좋은 코드는 아닙니다. 밑에 좋은 코드를 따로 첨부하겠습니다.5. code내가 푼 c++class Solution {public: bool check(string s,int left,int right){ while(left&amp;lt;=right){ if(s[left]!=s[right]) return false; ++left; --right; } return true; } int countSubstrings(string s) { int result = 0; for(size_t i =0;i&amp;lt;s.size();++i){ for(size_t j = i ;j&amp;lt;s.size();++j){ if(check(s,i,j)){ ++result; } } return result; }};6. 결과 및 후기, 개선점c++ 5%개선한 코드 4ms 87%class Solution {public: int countSubstrings(string s) { int leng = s.size(); int count = 0; for(int i =0;i&amp;lt;leng;++i){ //홀수길이의 s palindromic(s,i,i,count); //짝수길이의 s palindromic(s,i,i+1,count); } return count; } void palindromic(string s,int left,int right,int&amp;amp; count){ while(0&amp;lt;=left &amp;amp;&amp;amp; right&amp;lt;s.size() &amp;amp;&amp;amp; s[left] == s[right]){ ++count; --left; ++right; } }};값을 기준으로 양쪽으로 뻗어나가 계산하는 코드입니다." }, { "title": "leetcode(리트코드)118-Pascal&#39;s Triangle", "url": "/posts/leetcode_Pascal's_Triangle/", "categories": "leetcode, Eazy", "tags": "leetcode, Top100Interview", "date": "2021-03-28 03:12:00 +0900", "snippet": "leetcode 118 - Pascal’s Triangle 문제입니다.1. 문제https://leetcode.com/problems/pascals-triangle/2. Input , OutputInput: numRows = 5Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]3. 분류 및 난이도Eazy 난이도 문제입니다.Top 100 Interview 문제입니다.4. 문제 해석 들어온 numRows값의 row를 가진 파스칼 삼각형을 구현합니다.5. codec++class Solution {public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; generate(int numRows) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result; for(int i =0;i&amp;lt;numRows;++i) { vector&amp;lt;int&amp;gt; jvec; jvec.push_back(1); for(int j =1;j&amp;lt;i;++j) { jvec.push_back(result[i-1][j-1] + result[i-1][j]); } if(i!=0) jvec.push_back(1); result.push_back(jvec); } return result; }};6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!c++ 100% python ??% " }, { "title": "Programmers_짝지어제거하기", "url": "/posts/Programmerspair/", "categories": "Algorithm, Programmers", "tags": "Programmers", "date": "2021-03-28 01:00:00 +0900", "snippet": "프로그래머스 - 짝지어 제거하기 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/lessons/129732. 분류 및 난이도Programmers 문제입니다.지인들이 풀어보라해서 풀어봤습니다.3. 생각한 것들(문제 접근 방법) 문자열의 길이가 백만으로 O(n)으로 풀어야한다는 사실을 알았습니다. 매 번 문자열을 자르기보다 도미노처럼 쌓은걸 부셔버린다? 라는 생각으로 스택으로 풀었습니다.4. 접근 방법을 적용한 코드#include &amp;lt;iostream&amp;gt;#include&amp;lt;string&amp;gt;#include&amp;lt;stack&amp;gt;using namespace std;int solution(string s){ stack&amp;lt;char&amp;gt; st; for(size_t i =0;i&amp;lt;s.size();++i) { if(st.size()==0) st.push(s[i]); else if(st.top() == s[i]) st.pop(); else st.push(s[i]); } return st.empty();}5. 결과" }, { "title": "leetcode(리트코드)108-Convert Sorted Array to Binary Search Tree", "url": "/posts/leetcode_Convert_Sorted_Array_to_Binary_Search_Tree/", "categories": "leetcode, Eazy", "tags": "leetcode, Top100Interview", "date": "2021-03-27 14:12:00 +0900", "snippet": "leetcode 108 - Convert Sorted Array to Binary Search Tree 문제입니다.1. 문제https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.Top 100 Interview 문제입니다.4. 문제 해석 모든 자식 노드에 대해서 높이가 1이상 차이나지 않는 트리를 만듭니다.5. codec++/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: TreeNode* makeTree(vector&amp;lt;int&amp;gt;&amp;amp; nums,int left,int right){ if(left&amp;gt;right) return nullptr; int mid = (left + right) / 2; TreeNode* newNode = new TreeNode(nums[mid]); newNode-&amp;gt;left = makeTree(nums,left,mid-1); newNode-&amp;gt;right = makeTree(nums,mid+1,right); return newNode; } TreeNode* sortedArrayToBST(vector&amp;lt;int&amp;gt;&amp;amp; nums) { return makeTree(nums,0,nums.size()-1); }};6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!c++ 61% python ??% " }, { "title": "leetcode(리트코드)213-House Robber II", "url": "/posts/leetcode_House_Robber_II/", "categories": "leetcode, Medium", "tags": "leetcode, Facebook", "date": "2021-03-27 13:00:00 +0900", "snippet": "leetcode 213 - House Robber II 문제입니다.1. 문제https://leetcode.com/problems/house-robber-ii/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.https://www.teamblind.com/post/New-Year-Gift---Curated-List-of-Top-75-LeetCode-Questions-to-Save-Your-Time-OaM1orEU에서 추천한 문제입니다.4. 문제 해석 DP문제입니다. 프로그래머스에 똑같은 문제가 있습니다. ‘도둑질’5. codec++class Solution {public: int rob(vector&amp;lt;int&amp;gt;&amp;amp; nums) { if(nums.size()==1) return nums[0]; //DP를 2개만듦 //DP는 첫 번째 집을 들르는 경우 //DP2는 두 번째 집을 들르는 경우 int* DP = new int[nums.size()]; int* DP2 = new int[nums.size()]; DP[0] = nums[0]; DP[1] = nums[0]; DP2[0] = 0; DP2[1]=nums[1]; for(size_t i =2;i&amp;lt;nums.size();++i) { if(i !=nums.size()-1) { DP[i] = max(DP[i-2] + nums[i], DP[i-1]); } DP2[i] = max(DP2[i-2]+nums[i],DP2[i-1]); } int result = max(DP[nums.size()-2],DP2[nums.size()-1]); return result; }};6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!c++ 100% python ??% " }, { "title": "leetcode(리트코드)215-Kth Largest Element in an Array", "url": "/posts/leetcode_Kth_Largest_Element_in_an_Array/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Like", "date": "2021-03-27 01:01:00 +0900", "snippet": "leetcode 215 - Kth Largest Element in an Array 문제입니다.1. 문제https://leetcode.com/problems/kth-largest-element-in-an-array/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked 문제입니다.4. 문제 해석 간단한 문제입니다. k번째로 큰 수를 배열에서 찾아 리턴합니다.5. codec++class Solution {public: int findKthLargest(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) { sort(nums.begin(),nums.end()); return nums[nums.size()-k]; }};6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!c++ 97% python ??% " }, { "title": "leetcode(리트코드)207-Course Schedule", "url": "/posts/leetcode_Course_Schedule/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Like", "date": "2021-03-26 14:01:00 +0900", "snippet": "leetcode 207 - Course Schedule 문제입니다.1. 문제https://leetcode.com/problems/course-schedule/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked 문제입니다.4. 문제 해석 prerequisites에 있는 값의 첫번째 값은 강의 번호이고, 두번째 값은 먼저 들어야할 강의 입니다. 병목현상이 일어나면 false를 병목현상이 일어나지 않고 강의를 들을 수 있으면 true를 리턴합니다. 방문처리를 좀 더 잘해주면 빠른 코드가 나왔을텐데 아쉽습니다.5. codec++class Solution {public: bool canFinish(int numCourses, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; prerequisites) { vector&amp;lt;int&amp;gt;* graph = new vector&amp;lt;int&amp;gt;[numCourses+1]; bool* check = new bool[sizeof(bool) * numCourses+1]; for(size_t i =0;i&amp;lt;prerequisites.size();++i) { graph[prerequisites[i][0]].push_back(prerequisites[i][1]); } //BFS for(int i = 0;i&amp;lt;numCourses;++i) { if(graph[i].size()==0) continue; else { fill(check,check+numCourses+1,false); queue&amp;lt;int&amp;gt; q; q.push(i); check[i]=true; while(!q.empty()) { int x = q.front(); //cout&amp;lt;&amp;lt;x&amp;lt;&amp;lt;&#39;\\n&#39;; q.pop(); for(int k =0;k&amp;lt;graph[x].size();++k) { int temp = graph[x][k]; if(graph[temp].size()==0) continue; if(!check[graph[x][k]]) { q.push(graph[x][k]); check[graph[x][k]]=true; } if(graph[x][k]==i) { return false; } } } } } return true; }};6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!c++ ..% python ??% 빠른코드 c++public: bool canFinish(int numCourses, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;prerequisites) { m_graph = vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;(numCourses); for (const auto &amp;amp;p : prerequisites) m_graph[p[0]].push_back(p[1]); // states: 0 = unkonwn, 1 == visiting, 2 = visited vector&amp;lt;int&amp;gt; v(numCourses, 0); for (int i = 0; i &amp;lt; numCourses; ++i) if (dfs(i, v)) return false; return true; }private: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; m_graph; bool dfs(int cur, vector&amp;lt;int&amp;gt; &amp;amp;v) { if (v[cur] == 1) return true; if (v[cur] == 2) return false; v[cur] = 1; for (const int t : m_graph[cur]) if (dfs(t, v)) return true; v[cur] = 2; return false; }};DFS를 돌면서 1과 2로 방문처리를 해주는 코드입니다." }, { "title": "leetcode(리트코드)3월26일 challenge916-Word Subsets", "url": "/posts/leetcode_Word_Subsets/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-03-26 13:34:56 +0900", "snippet": "leetcode March 26일 - Word Subsets 문제입니다.1. 문제https://leetcode.com/problems/word-subsets/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.3월 26일자 챌린지 문제입니다.4. 문제 해석 B로 들어온 문자열을 모두 가지고 있는 A의 문자열을 찾아 vector에 넣고 반환합니다.5. codec++class Solution {public: vector&amp;lt;string&amp;gt; wordSubsets(vector&amp;lt;string&amp;gt;&amp;amp; A, vector&amp;lt;string&amp;gt;&amp;amp; B) { //B로들어온 문자열들을 합칠 것입니다. string temp = &quot;&quot;; //합치기 위한 사전 작업. &#39;oo&#39;와 같이 2개의 하나의 문자열 안에 동일한 문자가 2개 이상 포함될 경우 처리해주어야 합니다. int chrcount[26]={0,}; for(size_t i =0;i&amp;lt;B.size();++i) { int subcount[26]={0,}; for(size_t j =0;j&amp;lt;B[i].size();++j) { subcount[B[i][j]-97]++; chrcount[B[i][j]-97] = max(subcount[B[i][j]-97], chrcount[B[i][j]-97]); } } //저장된 값들을 이용해서 새로운 문자열을 만듭니다. for(int i =0;i&amp;lt;26;++i) { while(chrcount[i]!=0) { temp+=(i+97); chrcount[i]--; } } //결과 벡터 vector&amp;lt;string&amp;gt; result; //한번에 비교하기 위해 비교할 두 문자열 모두 정렬합니다. sort(temp.begin(),temp.end()); for(size_t i =0;i&amp;lt;A.size();++i) { bool check=true; string Atemp = A[i]; sort(Atemp.begin(),Atemp.end()); //subindex는 Atemp를 돌 문자열 j는 temp문자열을 돌 인덱스입니다. int subindex = 0; int j = 0; for(;j&amp;lt;temp.size() &amp;amp;&amp;amp; subindex&amp;lt;Atemp.size();) { if(Atemp[subindex] == temp[j]) { ++subindex; ++j; } else subindex++; } //j가 temp.size() 라는 것은 temp를 다 돌았다는 것이므로 A[i]안에 B가 포함되어 있다는 뜻입니다. if(j==temp.size()) result.push_back(A[i]); } return result; } };6. 결과 및 후기, 개선점c++ 86%" }, { "title": "leetcode(리트코드)377-Combination Sum IV", "url": "/posts/leetcode_Combination_Sum_IV/", "categories": "leetcode, Medium", "tags": "leetcode, Facebook", "date": "2021-03-26 13:00:00 +0900", "snippet": "leetcode 377 - Combination Sum IV 문제입니다.1. 문제https://leetcode.com/problems/combination-sum-iv/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.https://www.teamblind.com/post/New-Year-Gift---Curated-List-of-Top-75-LeetCode-Questions-to-Save-Your-Time-OaM1orEU에서 추천한 문제입니다.4. 문제 해석 DP문제입니다. 주어진 nums를 가지고 target을 만들 수 있는 경우의 수를 리턴합니다. 점화식은 DP[i] += DP[i-nums[i]]인데, 1부터 시작해서 nums를 조사해, 만들 수 있는 경우의 수를 전부 더해주는 식입니다.5. codec++class Solution {public: int combinationSum4(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { unsigned int* DP = new unsigned int[sizeof(int) * (target+1)]; memset(DP,false,sizeof(int) * (target+1)); DP[0]= 1; for(int i =1;i&amp;lt;=target; ++i) { for(int j =0;j&amp;lt;nums.size();++j) { if(i &amp;gt;= nums[j]) { DP[i] += DP[i-nums[j]]; } } } return DP[target]; }};/* int combinationSum4(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { vector&amp;lt;unsigned int&amp;gt; result(target + 1); result[0] = 1; for (int i = 1; i &amp;lt;= target; ++i) { for (int x : nums) { if (i &amp;gt;= x) result[i] += result[i - x]; } } return result[target]; }*/6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!c++ 100% python ??% " }, { "title": "leetcode(리트코드)208-Implement Trie (Prefix Tree)", "url": "/posts/leetcode_Implement_Trie_(Prefix-Tree)/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Like", "date": "2021-03-26 05:00:00 +0900", "snippet": "leetcode 208 - Implement Trie (Prefix Tree) 문제입니다.1. 문제https://leetcode.com/problems/implement-trie-prefix-tree/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked 문제입니다.4. 문제 해석 자신만의 자료구조를 만들어야합니다. serach()함수는 해당 자료구조에 있는 지 결과값을 리턴합니다. startWith() 함수는 들어온 문자열이 본문에 접두사로 존재하는 지 확인합니다. startWtih() 함수를 작성하기 위해 들어온 문자열에 각각의 접두사를 전부 map에다 넣어줬습니다. 그래서 느린 코드가 완성된 것 같습니다.5. codec++class Trie {public: /** Initialize your data structure here. */ unordered_map&amp;lt;string,int&amp;gt; um; unordered_map&amp;lt;string,int&amp;gt; preum; Trie() { } /** Inserts a word into the trie. */ void insert(string word) { um[word]= 1; string temp = &quot;&quot;; for(size_t i = 0;i&amp;lt;word.size();++i) { temp += word[i]; preum[temp] = 1; } } /** Returns if the word is in the trie. */ bool search(string word) { auto it = um.find(word); if(it==um.end()) return false; return true; } /** Returns if there is any word in the trie that starts with the given prefix. */ bool startsWith(string prefix) { auto it = preum.find(prefix); if(it==um.end()) return false; return true; }};/** * Your Trie object will be instantiated and called as such: * Trie* obj = new Trie(); * obj-&amp;gt;insert(word); * bool param_2 = obj-&amp;gt;search(word); * bool param_3 = obj-&amp;gt;startsWith(prefix); */6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!c++ 21% python ??% c++28ms 100% code#define MAX_NODES 10000class Trie { struct Trienode { char val; int count; int endsHere; Trienode *child[26]; }; Trienode *root; Trienode *getNode(int index) { Trienode *newnode = new Trienode; newnode-&amp;gt;val = &#39;a&#39;+index; newnode-&amp;gt;count = newnode-&amp;gt;endsHere = 0; for(int i=0;i&amp;lt;26;++i) newnode-&amp;gt;child[i] = NULL; return newnode; }public: /** Initialize your data structure here. */ Trie() { ios_base::sync_with_stdio(false); cin.tie(NULL); root = getNode(&#39;/&#39;-&#39;a&#39;); } /** Inserts a word into the trie. */ void insert(string word) { Trienode *curr = root; int index; for(int i=0;i&amp;lt;word.length();i++) { index = word[i]-&#39;a&#39;; if(curr-&amp;gt;child[index]==NULL) curr-&amp;gt;child[index] = getNode(index); curr-&amp;gt;child[index]-&amp;gt;count +=1; curr = curr-&amp;gt;child[index]; } curr-&amp;gt;endsHere +=1; } /** Returns if the word is in the trie. */ bool search(string word) { Trienode *curr = root; int index; for(int i=0;i&amp;lt;word.length();i++) { index = word[i]-&#39;a&#39;; if(curr-&amp;gt;child[index]==NULL) return false; curr = curr-&amp;gt;child[index]; } if((curr-&amp;gt;endsHere)&amp;gt;0) return true; return false; } /** Returns if there is any word in the trie that starts with the given prefix. */ bool startsWith(string prefix) { Trienode *curr = root; int index; for(int i=0;i&amp;lt;prefix.length();i++) { index = prefix[i]-&#39;a&#39;; if(curr-&amp;gt;child[index]==NULL) return false; curr = curr-&amp;gt;child[index]; } if((curr-&amp;gt;count)&amp;gt;0) return true; return false; }};/** * Your Trie object will be instantiated and called as such: * Trie* obj = new Trie(); * obj-&amp;gt;insert(word); * bool param_2 = obj-&amp;gt;search(word); * bool param_3 = obj-&amp;gt;startsWith(prefix); */" }, { "title": "leetcode(리트코드)3월25일 challenge417-Pacific Atlantic Water Flow", "url": "/posts/leeetcode_Pacific_Atlantic_Water_Flow/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-03-26 01:00:20 +0900", "snippet": "leetcode March 25일 - Pacific Atlantic Water Flow 문제입니다.1. 문제https://leetcode.com/problems/pacific-atlantic-water-flow/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.3월 25일자 챌린지 문제입니다.4. 문제 해석 Pacific(~) 와 Atlantic(*)로 둘다 갈 수 있는 물결이면 해당 좌표를 리턴합니다. 좌표에 써있는 값은 높이로, 작거나 같은 물결로 이동할 수 있습니다. ~나 *에 닿으면 이동한것으로 칩니다. 저는 해석을 처음에 잘 못해서 좋은 코드가 나오지 못했습니다. Pacific와 Atlantic을 가는 경우를 한 번에 찾아줬는데, 하나만 찾고 찾지 못했으면 그냥 제외시키는 등 로직을 구성하면 훨씬 빠른 코드가 될 것입니다.5. codec++int dx[4] = {0,1,0,-1};int dy[4] = {1,0,-1,0};bool v[151][151]={false,};class Solution {public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; pacificAtlantic(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix) { //BFS if(matrix.size()==0) return matrix; int row = matrix.size(); int col = matrix[0].size(); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result; for(int i =0 ; i &amp;lt; row;++i) { for(int j = 0;j&amp;lt;col;++j) { bool pc = false; bool ac = false; //BFS memset(v,false,sizeof(v)); //Pacific queue&amp;lt;pair&amp;lt;int,int&amp;gt;&amp;gt; pacific; pacific.push(make_pair(i,j)); while(!pacific.empty()) { int x = pacific.front().first; int y = pacific.front().second; //cout&amp;lt;&amp;lt;&quot;x&quot;&amp;lt;&amp;lt;x&amp;lt;&amp;lt;&quot;y&quot;&amp;lt;&amp;lt;y&amp;lt;&amp;lt;&#39;\\n&#39;; if(x==0||y==0) { pc=true; } if(x==row-1 || y==col-1) { ac=true; } if(pc &amp;amp;&amp;amp; ac) { //cout&amp;lt;&amp;lt;&quot;pc ac\\n&quot;; vector&amp;lt;int&amp;gt; temp; temp.push_back(i); temp.push_back(j); result.push_back(temp); break; } pacific.pop(); for(int k = 0;k&amp;lt;4;++k) { int newX = x + dx[k]; int newY = y + dy[k]; if(0&amp;lt;=newX &amp;amp;&amp;amp; newX&amp;lt;row &amp;amp;&amp;amp; 0&amp;lt;=newY &amp;amp;&amp;amp; newY&amp;lt;col &amp;amp;&amp;amp; matrix[newX][newY]&amp;lt;=matrix[x][y] &amp;amp;&amp;amp; !v[newX][newY]) { v[newX][newY]=true; pacific.push(make_pair(newX,newY)); } } } } } return result; }};6. 결과 및 후기, 개선점c++ 5%" }, { "title": "leetcode(리트코드)1143-Common Subsequence", "url": "/posts/leetcode_Common_Subsequence/", "categories": "leetcode, Medium", "tags": "leetcode, Facebook", "date": "2021-03-25 08:00:00 +0900", "snippet": "leetcode 1143 - Common Subsequence 문제입니다.1. 문제https://leetcode.com/problems/longest-common-subsequence/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.https://www.teamblind.com/post/New-Year-Gift---Curated-List-of-Top-75-LeetCode-Questions-to-Save-Your-Time-OaM1orEU에서 추천한 문제입니다.4. 문제 해석 DP문제입니다. 문자열 2개에서 가장 긴 공통된 문자열을 찾아 그 길이를 리턴합니다.5. codec++class Solution {public: int longestCommonSubsequence(string text1, string text2) { //DP테이블 int** check; // row는 text1의 길이보다 1만큼 증가 int row = text1.size()+1; // col도 마찬가지. 이유는 초기값을 0으로 셋팅하기 위해서 int col = text2.size()+1; check=new int*[row * sizeof(int)]; for(int i =0;i&amp;lt;row;++i) check[i] = new int[col * sizeof(int)]; for(int i = 0;i&amp;lt;row;++i) { for(int j = 0 ;j&amp;lt;col;++j) { //초기값 세팅 if(i==0 || j==0 ) { check[i][j] = 0; continue; } //점화식 부분. if(text1[i-1] ==text2[j-1]) { check[i][j]= check[i-1][j-1]+1; } else check[i][j] = max(check[i-1][j],check[i][j-1]); } } return check[row-1][col-1]; }};6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!c++ 74% python ??% " }, { "title": "leetcode(리트코드)66-Plus One", "url": "/posts/leetcode_Plus_One/", "categories": "leetcode, Eazy", "tags": "leetcode, Top100Interview", "date": "2021-03-25 03:00:00 +0900", "snippet": "leetcode 66 - Plus One 문제입니다.1. 문제https://leetcode.com/problems/plus-one/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.Top 100 Interview 문제입니다.4. 문제 해석 벡터로 들어온 값을 하나의 정수로 봅니다. [1,2,3]은 123처럼 봅니다. 바뀐 정수에 +1을 한 값을 리턴합니다. 999,9999인 경우만 조심하면 어려울 게 없는 문제입니다.5. codec++class Solution {public: vector&amp;lt;int&amp;gt; plusOne(vector&amp;lt;int&amp;gt;&amp;amp; digits) { int carry= 0; int size = digits.size()-1; while(size&amp;gt;=0 &amp;amp;&amp;amp; digits[size]==9) { digits[size]=0; --size; } //만약 999,9999처럼 끝까지 9만 반복된 경우 뒤에 1을 넣고 반전시켜버립니다. 00001-&amp;gt;10000처럼 if(size==-1) { digits.push_back(1); reverse(digits.begin(),digits.end()); } else digits[size]++; return digits; }};6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!c++ 100% python ??% " }, { "title": "leetcode(리트코드)3월24일 challenge870-Advantage Shuffle", "url": "/posts/leetcode_Advantage_Shuffle/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-03-25 01:03:20 +0900", "snippet": "leetcode March 24일 - Advantage Shuffle 문제입니다.1. 문제https://leetcode.com/problems/advantage-shuffle/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.3월 24일자 챌린지 문제입니다.4. 문제 해석 A[i] &amp;gt; B[i]로 만들 수 있게 A의 값들을 바꿔야합니다. A[i] &amp;gt; B[i] 인 갯수가 최대가 되도록 바꿔야합니다.5. codec++bool pred(pair&amp;lt;int,int&amp;gt;&amp;amp; a,pair&amp;lt;int,int&amp;gt;&amp;amp; b){ if(a.first==b.first) return a.second&amp;lt;b.second; return a.first&amp;lt;b.first;}class Solution {public: vector&amp;lt;int&amp;gt; advantageCount(vector&amp;lt;int&amp;gt;&amp;amp; A, vector&amp;lt;int&amp;gt;&amp;amp; B) { //tempB는 B의 값과 인덱스를 저장합니다. 정렬을 해줄 것이므로. vector&amp;lt;pair&amp;lt;int,int&amp;gt;&amp;gt; tempB; //배열의 끝을 돌 때까지 정렬하지 못한 것은 queue에 넣습니다. queue&amp;lt;int&amp;gt; q; //결과 벡터입니다. vector&amp;lt;int&amp;gt; result(A.size()); for(size_t i =0;i&amp;lt;B.size();++i) tempB.push_back(make_pair(B[i],i)); //B의 인덱스와 값을 넣은 tempB를 정렬합니다. sort(tempB.begin(),tempB.end(),pred); sort(A.begin(),A.end()); //j는 tempB를 도는 인덱스 값입니다. int j = 0; for(size_t i = 0;i&amp;lt;A.size();++i) { int value = tempB[j].first; int index = tempB[j].second; //만약 A[i]가 조건에 맞지 않으면 큐에 넣습니다. if(A[i]&amp;lt;=value) { q.push(A[i]); continue; } //조건에 맞으므로 result벡터에 값을 넣어줍니다. result[index] = A[i]; ++j; } //q가 빌 때까지 접근하지 않은 인덱스에 값들을 넣어줍니다. while(!q.empty()) { for(size_t i =0;i&amp;lt;result.size();++i) { if(result[i]==0) { result[i] =q.front(); q.pop(); } } } return result; }};6. 결과 및 후기, 개선점c++ 92%" }, { "title": "leetcode(리트코드)300-Longest Increasing Subsequence", "url": "/posts/leetcode_Longest_Increasing_Subsequence/", "categories": "leetcode, Medium", "tags": "leetcode, Facebook", "date": "2021-03-23 13:00:00 +0900", "snippet": "leetcode 300 - Longest Increasing 문제입니다.1. 문제https://leetcode.com/problems/longest-increasing-subsequence/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.https://www.teamblind.com/post/New-Year-Gift---Curated-List-of-Top-75-LeetCode-Questions-to-Save-Your-Time-OaM1orEU에서 추천한 문제입니다.4. 문제 해석 DP문제입니다. 부분수열중에서 가장 긴 증가수열의 길이를 찾아 리턴합니다.5. codec++class Solution {public: int lengthOfLIS(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int* DP =new int[nums.size()]; for(int i =0 ;i&amp;lt;nums.size();++i) DP[i] = 1; int result = 1; for(int i = 1; i&amp;lt;nums.size();++i) { for(int j =0;j&amp;lt;i;++j) { if(nums[i]&amp;gt; nums[j]) DP[i] = max(DP[i],DP[j]+1); result = max(result,DP[i]); } } return result; }};6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!c++ 56% python ??% O(nlogn)으로 푼 코드 0ms 100%class Solution {public: int lengthOfLIS(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int ans = 0; int n = nums.size(); vector&amp;lt;int&amp;gt; lis(n, 0); for(int i=0; i&amp;lt;n; i++) { int lo=0, hi=ans; while(lo&amp;lt;hi) { int mid = lo + (hi-lo)/2; if(lis[mid]&amp;lt;nums[i]) lo = mid+1; else hi = mid; } lis[lo] = nums[i]; if(lo==ans) ans++; } return ans; }};이분 검색으로 값을 찾아서 갱신하는 코드입니다." }, { "title": "leetcode(리트코드)200-Number of Islands", "url": "/posts/leetcode_Number_of_Islands/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Like", "date": "2021-03-23 06:00:00 +0900", "snippet": "leetcode 200 - Number of Islands 문제입니다.1. 문제https://leetcode.com/problems/number-of-islands/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked 문제입니다.4. 문제 해석 어려울게 없는 BFS,DFS문제입니다. 1로 이루어진 섬의 개수를 셉니다.5. codec++class Solution { bool v[301][301]={false,}; int dx[4] ={0,-1,1,0}; int dy[4] = {1,0,0,-1};public: int BFS(int i,int j,int row,int col,vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; grid) { queue&amp;lt;pair&amp;lt;int,int&amp;gt;&amp;gt; q; q.push(make_pair(i,j)); v[i][j]=true; while(!q.empty()) { int x = q.front().first; int y = q.front().second; q.pop(); for(int k =0;k&amp;lt;4;++k) { int newX = x+dx[k]; int newY = y+dy[k]; if(0&amp;lt;=newX &amp;amp;&amp;amp; newX&amp;lt;row &amp;amp;&amp;amp; 0&amp;lt;=newY &amp;amp;&amp;amp; newY&amp;lt;col &amp;amp;&amp;amp; !v[newX][newY] &amp;amp;&amp;amp; grid[newX][newY]==&#39;1&#39;) { v[newX][newY] = true; q.push(make_pair(newX,newY)); } } } return 1; } int numIslands(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; grid) { int result = 0; memset(v,false,sizeof(v)); int row = grid.size(); int col = grid[0].size(); for(size_t i =0;i&amp;lt;row;++i) { for(size_t j = 0 ;j&amp;lt;col;++j) if(grid[i][j] == &#39;1&#39;&amp;amp;&amp;amp;!v[i][j]) result += BFS(i,j,row,col,grid); } return result; }};6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!c++ 80% python ??% " }, { "title": "leetcode(리트코드)28-Implement strStr()", "url": "/posts/leetcode_Implement-strStr()/", "categories": "leetcode, Eazy", "tags": "leetcode, Top100Interview", "date": "2021-03-23 03:00:00 +0900", "snippet": "leetcode 28 - Implement strStr() 문제입니다.1. 문제https://leetcode.com/problems/implement-strstr/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.Top 100 Interview 문제입니다.4. 문제 해석 동일한 문자열을 찾습니다. 예외처리가 중요한 문제라고 적혀있습니다. 연습할 겸 KMP알고리즘을 이용해서 풀었습니다.5. codec++class Solution {public: int strStr(string haystack, string needle) { if(haystack.empty()&amp;amp;&amp;amp; needle.empty())return 0; else if(!haystack.empty() &amp;amp;&amp;amp; needle.empty())return 0; return KMP(haystack,needle); } vector&amp;lt;int&amp;gt; maketable( string pattern) { int parttsize = pattern.size(); vector&amp;lt;int&amp;gt; table(parttsize,0); int j =0; for(int i =1;i&amp;lt;pattern.size();++i) { while(j&amp;gt;0 &amp;amp;&amp;amp; pattern[i] != pattern[j]) { j = table[j-1]; } if(pattern[i] == pattern[j]) table[i] = ++j; } return table; } int KMP(string origin, string pattern) { vector&amp;lt;int&amp;gt; table = maketable(pattern); int originsize = origin.size(); int pattsize= pattern.size(); int j =0; for(int i =0;i&amp;lt;origin.size();++i) { while(j&amp;gt; 0 &amp;amp;&amp;amp; origin[i] != pattern[j]) j = table[j-1]; if(origin[i] == pattern[j]) { if(j==pattsize-1) return i - pattsize + 1; else ++j; } } return -1; }};6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!c++ 73% python ??% " }, { "title": "leetcode(리트코드)3월22일 challenge966-Vowel Spellchecker", "url": "/posts/leetcode_Vowel_Spellchecker/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-03-23 01:03:20 +0900", "snippet": "leetcode March 22일 - Vowel Spellchecker 문제입니다.1. 문제https://leetcode.com/problems/vowel-spellchecker/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.3월 22일자 챌린지 문제입니다.4. 문제 해석 wordlist가 들어오고 queries가 들어옵니다. queries안에 있는 문자열이 wordlist에 있으면 냅두고, 대소문자만 다르면 wordlist의 앞에서부터 가깝게 위치한 문자열을 리턴, ‘a’, ‘e’, ‘o’, ‘u’, ‘i’로 치환이 가능하면 해당 문자열을 리턴 없으면 ““를 리턴합니다. discuss로 보고 아이디어를 얻어서 풀었습니다.5. codec++class Solution {public: vector&amp;lt;string&amp;gt; spellchecker(vector&amp;lt;string&amp;gt;&amp;amp; wordlist, vector&amp;lt;string&amp;gt;&amp;amp; queries) { //중복처리를 위한. unordered_set&amp;lt;string&amp;gt; words(wordlist.begin(),wordlist.end()); //lowlist는 key값으로 문자열을 소문자로 치환한 값, value값으로 원본 문자열이 들어갑니다. //vowlist는 key값으로 &#39;a&#39;,&#39;e&#39;,&#39;o&#39;,&#39;u&#39;,&#39;i&#39;를 &#39;#&#39;로 치환한 값, value는 원본 문자열이 들어갑니다. unordered_map&amp;lt;string,string&amp;gt; lowerlist,vowlist; for(string w : wordlist){ string lowword = makelow(w), vowword = makevow(w); lowerlist.insert({lowword,w}); vowlist.insert({vowword,w}); } for(size_t i =0;i&amp;lt;queries.size();++i) { if(words.count(queries[i]))continue; string lowq = makelow(queries[i]), vowq = makevow(queries[i]); if(lowerlist.count(lowq)) queries[i] = lowerlist[lowq]; else if(vowlist.count(vowq)) queries[i] = vowlist[vowq]; else queries[i] = &quot;&quot;; } return queries; } string makelow(string w){ for(auto&amp;amp; c : w){ c = tolower(c); } return w; } string makevow(string w){ w= makelow(w); for(auto&amp;amp;c : w){ if(c ==&#39;a&#39;||c==&#39;e&#39;||c==&#39;i&#39;||c==&#39;o&#39;||c==&#39;u&#39;) c=&#39;#&#39;; } return w; }};6. 결과 및 후기, 개선점c++ 83%" }, { "title": "leetcode(리트코드)3월23일 challenge923-3Sum With Multiplicity", "url": "/posts/leetcode_3Sum_With_Multiplicity/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-03-23 01:03:20 +0900", "snippet": "leetcode March 23일 - 3Sum With Multiplicity 문제입니다.1. 문제https://leetcode.com/problems/3sum-with-multiplicity/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.3월 23일자 챌린지 문제입니다.4. 문제 해석 숫자 세개를 더해서 target을 만들 수 있는 경우의 수를 모두 찾아 10^+7로 나눈 나머지를 리턴합니다.5. codec++class Solution {public: int threeSumMulti(vector&amp;lt;int&amp;gt;&amp;amp; arr, int target) { unordered_map&amp;lt;int,long long&amp;gt; um; for(size_t i = 0;i&amp;lt;arr.size();++i) um[arr[i]]++; long long result=0; for(auto it : um) { for(auto it2: um) { int first =it.first; int second = it2.first; int third = target-first-second; if(!um.count(third))continue; if(first == second &amp;amp;&amp;amp; second== third) result += um[first]* (um[first]-1) * (um[first]-2) / 6; else if(first==second &amp;amp;&amp;amp; second!=third) result += (um[first] * (um[first]-1))/2 * um[third]; else if(first&amp;lt;second &amp;amp;&amp;amp; second&amp;lt;third) result += um[first] * um[second] * um[third]; } } return (result %(int)(1e9+7)); }};6. 결과 및 후기, 개선점c++ 84%" }, { "title": "leetcode(리트코드)198-House Robber", "url": "/posts/leetcode_House_Robber/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Interview", "date": "2021-03-22 06:00:00 +0900", "snippet": "leetcode 198 - House Robber 문제입니다.1. 문제https://leetcode.com/problems/house-robber/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked 문제입니다.4. 문제 해석 인접한 배열을 접근하지 않고 배열 안에 있는 값들을 더할 때 최대값을 구하세요. 점화식은 DP[i] = max(DP[i-2],DP[i-3]) + nums[i]로 바로 접근할 때와 하나 건너뛰고 접근하는 경우의 수가 있습니다.5. codec++class Solution {public: int rob(vector&amp;lt;int&amp;gt;&amp;amp; nums) { if(nums.size()==1) return nums[0]; if(nums.size()==2) return max(nums[0],nums[1]); int* DP = new int[nums.size()]; DP[0] = nums[0]; DP[1] = nums[1]; DP[2] = nums[2] + DP[0]; int result = max(DP[2],DP[1]); for(size_t i = 3; i&amp;lt;nums.size();++i) { DP[i] = max(DP[i-2],DP[i-3]) + nums[i]; result = max(result,DP[i]); } return result; }};6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!c++ 100% python ??% " }, { "title": "leetcode(리트코드)14-Longest Common Prefix", "url": "/posts/leetcode_Longest_Common_Prefix/", "categories": "leetcode, Eazy", "tags": "leetcode, Top100Interview", "date": "2021-03-22 02:00:00 +0900", "snippet": "leetcode 14 - LongestCommon Prefix 문제입니다.1. 문제https://leetcode.com/problems/longest-common-prefix/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.Top 100 Interview 문제입니다.4. 문제 해석 input으로 여러 문자열이 들어옵니다. 들어온 문자열에서 가장 긴 공통 접두사를 찾아 리턴합니다.5. codec++class Solution {public: string longestCommonPrefix(vector&amp;lt;string&amp;gt;&amp;amp; strs) { if(strs.size()==0) return &quot;&quot;; string result=&quot;&quot;; bool ok = false; //인덱스를 접근하는 변수입니다. int count = 0; //어느 문자열의 끝을 돌았거나, 문자열의 인덱스가 다른 것을 찾습니다. while(!ok) { //기준이 되는 문자로 가장 첫번째 문자열을 기준으로합니다. char standard; //count가 문자열의 범위를 벗어나지 않게 조정합니다. if(count &amp;lt; strs[0].size()) standard = strs[0][count]; for(size_t i =0;i&amp;lt;strs.size();++i) { //ok를 관리하기 위한 구문입니다. if(strs[i][count]!=standard || count&amp;gt;= strs[i].size()) { ok=true; break; } } if(!ok) { ++count; result+=standard; } } return result; }};6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!c++ 100% python ??% " }, { "title": "leetcode(리트코드)190-Reverse Bits", "url": "/posts/leetcode_Reverse_Bits/", "categories": "leetcode, Eazy", "tags": "leetcode, Facebook", "date": "2021-03-22 01:00:00 +0900", "snippet": "leetcode 190 - Reverse Bits 문제입니다.1. 문제https://leetcode.com/problems/reverse-bits/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.https://www.teamblind.com/post/New-Year-Gift---Curated-List-of-Top-75-LeetCode-Questions-to-Save-Your-Time-OaM1orEU에서 추천한 문제입니다.4. 문제 해석 문제로 들어온 값을 2진수로 바꾸고 역순으로 바꾼 숫자를 리턴합니다.5. codec++class Solution {public: uint32_t reverseBits(uint32_t n) { //bitset bitset&amp;lt;32&amp;gt; bs; int count = 0 ; //들어온 값을 2진수로 바꾸는 과정 while(n!=0) { bs.set(count,n%2); n/=2; ++count; } //bitset을 다시 문자열로 바꾸고 string result = bs.to_string(); //역순으로 바꿔버립니다. reverse(result.begin(),result.end()); //2진수를 다시 숫자로 바꾸기 위해서 bitset에 다시 넣고 bitset&amp;lt;32&amp;gt; resultbs(result); //숫자로 바꿔버립니다. uint32_t find = resultbs.to_ulong(); return find; }};6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!c++ 56% python ??% " }, { "title": "leetcode(리트코드)3월21일 challenge869-Reordered Power of 2", "url": "/posts/leetcode_Reordered_Power_of_2/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-03-21 13:03:20 +0900", "snippet": "leetcode March 20일 - Reordered Power of 2 문제입니다.1. 문제https://leetcode.com/problems/reordered-power-of-2/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.3월 20일자 챌린지 문제입니다.4. 문제 해석 정수 N이 들어옵니다. 정수 N을 2진법으로 나타내어 재배열 했을 때 그 수가 2의 거듭제곱 수로 나타낼 수 있으면 true 나타낼 수 없으면 false를 리턴합니다.5. codec++class Solution {public: bool reorderedPowerOf2(int N) { long long result = change(N); for(int i = 0;i&amp;lt;=31;++i) { if(result == change(1&amp;lt;&amp;lt;i)) return true; } return false; } long long change(int n){ //2진수로 바꿔버림. long long result = 0; for(;n;n/=10) result += pow(10,n%10); return result; }};6. 결과 및 후기, 개선점c++ 99%" }, { "title": "Spring_JPA - Spring boot를 이용한 메모리로 DB돌리기.", "url": "/posts/Spring_JPA03/", "categories": "Java, 5_김영한_실전! 스프링 부트와 JPA 활용 1", "tags": "Spring", "date": "2021-03-21 12:12:00 +0900", "snippet": "강의를 듣다가 좋은 내용이 있어서 가져왔습니다.Test코드 작성 시에 인메모리디비를 쓰고 싶은 경우가 있을텐데 그 경우 설정하는 방법을 알려줍니다.(h2 DB를 씁니다.)먼저 h2 DB를 다운받지 않고 사용하는 방법입니다.1. 홈페이지 접속https://www.h2database.com/html/main.htmlh2홈페이지에 들어가, 왼쪽 메뉴에 Cheat Sheet를 누릅니다.다음과 같이 뜹니다.In-Memory에 적혀있는 경로를 복사해서프로젝트의 yml 파일에 경로에 붙여넣어줍니다.Spring boot에서 제공하는 메모리로 돌리는 법.위의 경우를 더 간편하게 하는 방법을 Spring boot가 제공합니다.간단하게, 자신의 의존성 파일에서runtimeOnly &#39;com.h2database:h2&#39;란 문구가 있는 지 확인하고, 있으면 test/resources/application.yml을 생성하고 아무것도 안쓰면 Springboot가 알아서 돌립니다.자신이 테스트돌릴 파일에는 다음과 같은 애노테이션이 붙어있어야 합니다.@RunWith(SpringRunner.class)@SpringBootTest" }, { "title": "leetcode(리트코드)146-LRU Cache", "url": "/posts/leetcode_LRU_Cache/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Like", "date": "2021-03-21 06:00:00 +0900", "snippet": "leetcode 146 - LRU Cache 문제입니다.1. 문제https://leetcode.com/problems/lru-cache/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked 문제입니다.4. 문제 해석 문제 내용은 어렵지 않습니다. LRU를 기준으로put, get함수를 구현하는 것입니다. put과 get이 호출될 때마다 ‘최근’ 사용된 것으로 봅니다. 같은 키값이 들온 경우 해당 키값의 value를 수정해줘야합니다. 개인적으로 굉장히 좋은 문제라고 생각합니다.!! Discuss를 봤지만, 해당 코드를 이해하기 위해 공책으로 리스트와 맵의 구조를 몇 번 그렸는 지 모르겠습니다.5. codec++class LRUCache { typedef unordered_map&amp;lt;int,pair&amp;lt;int,list&amp;lt;int&amp;gt;::iterator&amp;gt;&amp;gt; UMIL; UMIL cache; list&amp;lt;int&amp;gt; result; int _size;public: LRUCache(int capacity) { _size = capacity; } int get(int key) { auto it = cache.find(key); if(it!=cache.end()) { move(it); return it-&amp;gt;second.first; } else return -1; } void put(int key, int value) { auto it = cache.find(key); if(it!=cache.end()) { //수정 move(it); } else { if(_size == cache.size()) { cache.erase(result.back()); result.pop_back(); } result.push_front(key); } cache[key] = {value, result.begin()}; } void move(UMIL::iterator it) { int key = it-&amp;gt;first; result.push_front(key); result.erase(it-&amp;gt;second.second); it-&amp;gt;second.second = result.begin(); }};/** * Your LRUCache object will be instantiated and called as such: * LRUCache* obj = new LRUCache(capacity); * int param_1 = obj-&amp;gt;get(key); * obj-&amp;gt;put(key,value); */6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!c++ 56% python ??% " }, { "title": "leetcode(리트코드)338-Counting Bits", "url": "/posts/leetcode_Counting_Bits/", "categories": "leetcode, Medium", "tags": "leetcode, Facebook", "date": "2021-03-21 04:00:00 +0900", "snippet": "leetcode 338 - Counting Bits 문제입니다.1. 문제https://leetcode.com/problems/counting-bits/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.https://www.teamblind.com/post/New-Year-Gift---Curated-List-of-Top-75-LeetCode-Questions-to-Save-Your-Time-OaM1orEU에서 추천한 문제입니다.4. 문제 해석 주어진 트리에서 가장 긴 경로를 가진 길이를 구하세요. 트리의 root를 지날 수도 안지날 수도 있습니다. 왼쪽자식 + 오른쪽 자식의 합을 매 트리의 노드마다 구해줘서 갱신했습니다.5. codec++class Solution {public: vector&amp;lt;int&amp;gt; countBits(int num) { vector&amp;lt;int&amp;gt; DP(num+1); DP[0] = 0 ; if(num ==0) return DP; DP[1] = 1; int Two_exp = 1; for(int i = 1;i&amp;lt;=num;++i) { if(i == pow(2,Two_exp)) { DP[i] = 1; ++Two_exp; } else { int pownum = pow(2,Two_exp-1); DP[i] = DP[pownum] + DP[i-pownum]; } } return DP; }};6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!c++ 94% python ??% c++ 0ms 100% codeclass Solution {public: int ans = 0; int util(TreeNode *root){ if(!root) return 0; int left = util(root-&amp;gt;left); int right = util(root-&amp;gt;right); ans = max(left + right, ans); return max(left, right) + 1; } int diameterOfBinaryTree(TreeNode* root) { util(root); return ans; }};제 로직에서 쓸데없는 재귀를 없애버린 코드입니다." }, { "title": "leetcode(리트코드)3월20일 challenge1396-Design Underground System", "url": "/posts/leetcode_Design_Underground_System/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-03-20 10:00:20 +0900", "snippet": "leetcode March 20일 - Design Underground System 문제입니다.1. 문제https://leetcode.com/problems/design-underground-system/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.3월 20일자 챌린지 문제입니다.4. 문제 해석 checkIn으로 고유한 ID, 시작 장소, 도착한 시간이 들어옵니다. checkout으로 고유한 ID, 끝나는 장소, 나간시간이 들어옵니다. getAverageTime으로 시작한 장소와 끝나는 장소가 들어오고 그 장소에서 사람들이 평균적으로 머무른 시간 (나간시간 - 도착한시간) / 사람수 를 리턴합니다. map2개와 pair 2개를 써서 관리하였습니다.5. codec++class UndergroundSystem { //stationName, id, time unordered_map&amp;lt;int,pair&amp;lt;string,int&amp;gt;&amp;gt; inmm; unordered_map&amp;lt;string,pair&amp;lt;int,int&amp;gt;&amp;gt; outmm;public: UndergroundSystem() { } void checkIn(int id, string stationName, int t) { inmm[id]= {stationName , t}; } void checkOut(int id, string stationName, int t) { auto&amp;amp; it = inmm[id]; string end = it.first + &quot;-&quot; + stationName; outmm[end].first += t - it.second; outmm[end].second +=1; } double getAverageTime(string startStation, string endStation) { string find = startStation + &quot;-&quot; + endStation; double result = double(outmm[find].first) / double(outmm[find].second); return result; }};/** * Your UndergroundSystem object will be instantiated and called as such: * UndergroundSystem* obj = new UndergroundSystem(); * obj-&amp;gt;checkIn(id,stationName,t); * obj-&amp;gt;checkOut(id,stationName,t); * double param_3 = obj-&amp;gt;getAverageTime(startStation,endStation); */6. 결과 및 후기, 개선점c++ 78%" }, { "title": "leetcode(리트코드)543-Diameter of Binary Tree", "url": "/posts/leetcode_Diameter_of_Binary_Tree/", "categories": "leetcode, Eazy", "tags": "leetcode, Top100Like", "date": "2021-03-20 02:00:00 +0900", "snippet": "leetcode 543 - Diameter of Binary Tree 문제입니다.1. 문제https://leetcode.com/problems/diameter-of-binary-tree/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.leetcode Top 100 Liked 문제입니다.4. 문제 해석 주어진 트리에서 가장 긴 경로를 가진 길이를 구하세요. 트리의 root를 지날 수도 안지날 수도 있습니다. 왼쪽자식 + 오른쪽 자식의 합을 매 트리의 노드마다 구해줘서 갱신했습니다.5. codec++/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: int result = 0; int order(TreeNode* node) { if(node!=nullptr) return max(order(node-&amp;gt;left),order(node-&amp;gt;right) )+1; return 0; } int diameterOfBinaryTree(TreeNode* root) { if(root!=nullptr) { int leftdepth = order(root-&amp;gt;left); int rightdepth = order(root-&amp;gt;right); result = max(result,leftdepth+rightdepth); diameterOfBinaryTree(root-&amp;gt;left); diameterOfBinaryTree(root-&amp;gt;right); } return result; }};6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!c++ 50% python ??% c++ 0ms 100% codeclass Solution {public: int ans = 0; int util(TreeNode *root){ if(!root) return 0; int left = util(root-&amp;gt;left); int right = util(root-&amp;gt;right); ans = max(left + right, ans); return max(left, right) + 1; } int diameterOfBinaryTree(TreeNode* root) { util(root); return ans; }};제 로직에서 쓸데없는 재귀를 없애버린 코드입니다." }, { "title": "leetcode(리트코드)3월19일 challenge841-Keys and Rooms", "url": "/posts/leetcode_Keys_and_Rooms/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-03-19 13:03:20 +0900", "snippet": "leetcode March 19일 - Key and Rooms 문제입니다.1. 문제https://leetcode.com/problems/keys-and-rooms/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.3월 19일자 챌린지 문제입니다.4. 문제 해석 2차원 벡터 rooms이 주어집니다. rooms[i][j]에 rooms[i]를 열 수 있는 key가 있습니다. 모든 문을 열 수 있으면 true 없으면 false를 리턴합니다. BFS나 DFS로 풀면 됩니다.5. codec++class Solution {public: bool canVisitAllRooms(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; rooms) { bool check[3001]={false,}; check[0]=true; //bfs queue&amp;lt;int&amp;gt; q; q.push(0); while(!q.empty()) { int x = q.front(); q.pop(); for(int k = 0;k&amp;lt;rooms[x].size();++k) { if(!check[rooms[x][k]]) { check[rooms[x][k]]=true; q.push(rooms[x][k]); } } } for(size_t i =0;i&amp;lt;rooms.size();++i) { if(!check[i]) return false; } return true; }};6. 결과 및 후기, 개선점c++ 99%" }, { "title": "leetcode(리트코드)148-Sort List", "url": "/posts/leetcode_Sort_List/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Like", "date": "2021-03-19 06:00:00 +0900", "snippet": "leetcode 148 - Sort List 문제입니다.1. 문제https://leetcode.com/problems/sort-list/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked 문제입니다.4. 문제 해석 LinkedList가 주어집니다. 정렬하세요.5. codec++/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* sortList(ListNode* head) { vector&amp;lt;int&amp;gt; temp; ListNode* result = head; while(result!=nullptr) { temp.push_back(result-&amp;gt;val); result=result-&amp;gt;next; } sort(temp.begin(),temp.end()); result = head; for(size_t i =0;i&amp;lt;temp.size();++i) { result-&amp;gt;val = temp[i]; result = result-&amp;gt;next; } return head; }};6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!c++ 95% python ??% 문제에서는 nlogn 으로 정렬하라 했기에 해당 코드를 가져왔습니다.class Solution {public: ListNode *sortList(ListNode *head) { if(!head || !(head-&amp;gt;next)) return head; //linked list의 길이를 구합니다. ListNode* cur = head; int length = 0; while(cur){ length++; cur = cur-&amp;gt;next; } //더미노드 ListNode dummy(0); dummy.next = head; ListNode *left, *right, *tail; for(int step = 1; step &amp;lt; length; step &amp;lt;&amp;lt;= 1){ cur = dummy.next; tail = &amp;amp;dummy; while(cur){ left = cur; right = split(left, step); cur = split(right,step); tail = merge(left, right, tail); } } return dummy.next; }private: /** 처음 들어온 head 노드를 기준으로 n만큼 이동해서 잘라버립니다. 잘라버린 노드는 second이고 그것을 반환하여 main method의 right,cur이 됩니다. */ ListNode* split(ListNode *head, int n){ //if(!head) return NULL; for(int i = 1; head &amp;amp;&amp;amp; i &amp;lt; n; i++) head = head-&amp;gt;next; if(!head) return NULL; ListNode *second = head-&amp;gt;next; head-&amp;gt;next = NULL; return second; } /** * merge the two sorted linked list l1 and l2, * then append the merged sorted linked list to the node head * return the tail of the merged sorted linked list */ ListNode* merge(ListNode* l1, ListNode* l2, ListNode* head){ ListNode *cur = head; while(l1 &amp;amp;&amp;amp; l2){ if(l1-&amp;gt;val &amp;gt; l2-&amp;gt;val){ cur-&amp;gt;next = l2; cur = l2; l2 = l2-&amp;gt;next; } else{ cur-&amp;gt;next = l1; cur = l1; l1 = l1-&amp;gt;next; } } cur-&amp;gt;next = (l1 ? l1 : l2); while(cur-&amp;gt;next) cur = cur-&amp;gt;next; return cur; }};" }, { "title": "leetcode(리트코드)234-Palindrome Linked List", "url": "/posts/leetcode_Palindrome_Linked_List/", "categories": "leetcode, Eazy", "tags": "leetcode, Top100Like", "date": "2021-03-19 04:00:00 +0900", "snippet": "leetcode 234 - Palindrome Linked List 문제입니다.1. 문제https://leetcode.com/problems/palindrome-linked-list/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.leetcode Top 100 Liked 문제입니다.4. 문제 해석 Linked List가 주어집니다. 꼬리에서 출발해도 같은 값(palindrome)을 갖는 지 확인해주세요.5. codec++/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: string str = &quot;&quot;; void check(ListNode* head) { if(head==nullptr) return ; str += std::to_string(head-&amp;gt;val); check(head-&amp;gt;next); } bool isPalindrome(ListNode* head) { check(head); string temp = str; reverse(str.begin(),str.end()); if(temp==str) return true; return false; }};python은 discuss에서 긁어온 것def isPalindrome(self, head): vals = [] #head가 None이 아닐 때 값을 다 리스트에 넣는다. while head: vals += head.val, head = head.next #리스트의 끝부터 검사. return vals == vals[::-1]6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!c++ 5% python ??% c++ 8ms 96% codeclass Solution {public: bool isPalindrome(ListNode* head) { ListNode* slow = head; ListNode* fast = head; ListNode* nxt = NULL; while(fast &amp;amp;&amp;amp; fast-&amp;gt;next){ fast = fast-&amp;gt;next-&amp;gt;next; ListNode* tmp = slow-&amp;gt;next; slow-&amp;gt;next = nxt; nxt = slow; slow = tmp; } if(fast) slow = slow-&amp;gt;next; while(slow &amp;amp;&amp;amp; nxt){ if(slow-&amp;gt;val != nxt-&amp;gt;val) return false; slow = slow-&amp;gt;next; nxt = nxt-&amp;gt;next; } return true; }};nxt라는 새로운 노드를 만들어서 반대로 가는 리스트를 만듭니다.fast가 끝까지 도달하면 slow는 반쯤 온것 이므로 위치를 조정해주고 nxt와 slow를 비교합니다." }, { "title": "leetcode(리트코드)3월18일 challenge376-Wiggle Subsequence", "url": "/posts/leetcode_Wiggle_Subsequence/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-03-19 01:00:20 +0900", "snippet": "leetcode March 18일 - Wiggle Subsequence 문제입니다.1. 문제https://leetcode.com/problems/wiggle-subsequence/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.3월 18일자 챌린지 문제입니다.4. 문제 해석 wiggle이란 인접한 배열의 차이가 + - 가 반복되는 배열을 말합니다. [1, 7, 4, 9, 2, 5]의 각 인접한 배열의 차이는 [6,-3,5,-7,3]으로 이렇게 인접한 배열의 차이가 + - 가 반복되는 wiggle 부분배열의 최대길이를 반환합니다. DP로 풀었습니다.5. codec++class Solution {public: int wiggleMaxLength(vector&amp;lt;int&amp;gt;&amp;amp; nums) { if(nums.size()==1) return 1; int* DP = new int [nums.size()]; DP[0]=1; bool minusC = true; bool plusC = true; for(size_t i =1;i&amp;lt;nums.size();++i) { if(minusC &amp;amp;&amp;amp; nums[i-1] &amp;lt; nums[i]) { minusC= false; plusC= true; DP[i] = DP[i-1]+1; } else if(plusC &amp;amp;&amp;amp; nums[i-1]&amp;gt;nums[i]) { plusC = false; minusC = true; DP[i] = DP[i-1] + 1; } else DP[i] = DP[i-1]; } return DP[nums.size()-1]; }};pythonclass Solution: def wiggleMaxLength(self, nums: List[int]) -&amp;gt; int: if len(nums) == 1: return 1 DP = [0] * len(nums) DP[0]= 1 plusC = 1 minusC = 1 for i in range(1,len(nums)): if minusC==1 and nums[i] &amp;lt; nums[i-1] : minusC = 0 plusC = 1 DP[i] = DP[i-1] + 1 elif plusC==1 and nums[i] &amp;gt; nums[i-1] : minusC = 1 plusC = 0 DP[i] = DP[i-1] + 1 else : DP[i] =DP[i-1] return DP[len(nums)-1]6. 결과 및 후기, 개선점c++ 100% python 62%" }, { "title": "leetcode(리트코드)153-Find Minimum in Roated Sorted Array", "url": "/posts/leetcode_Find_Minimum_in_Rotated_Sorted_Array/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Like", "date": "2021-03-18 06:00:00 +0900", "snippet": "leetcode 153 - Find Minimum in Rotated Sorted Array 문제입니다.1. 문제https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked 문제입니다.4. 문제 해석 한칸씩 뒤로 밀려버린 vector가 인풋으로 들어옵니다. 원래 벡터로 만들었을 때 가장 작은 값을 리턴합니다. 너무 쉽게 푼것 같습니다. 이렇게 푸는게 아닌 것 같은데..5. codepythonclass Solution: def findMin(self, nums: List[int]) -&amp;gt; int: for i in range(len(nums)-1) : if nums[i] &amp;gt; nums[i+1] : return nums[i+1] return nums[0]c++class Solution {public: int findMin(vector&amp;lt;int&amp;gt;&amp;amp; nums) { for(size_t i= 0;i&amp;lt;nums.size()-1;++i) { if(nums[i] &amp;gt;nums[i+1]) return nums[i+1]; } return nums[0]; }};6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!c++ 50% python 71% binary search로 푼 code c++ int findMin(vector&amp;lt;int&amp;gt; &amp;amp;num) { int start=0,end=num.size()-1; while (start&amp;lt;end) { if (num[start]&amp;lt;num[end]) return num[start]; int mid = (start+end)/2; if (num[mid]&amp;gt;=num[start]) { start = mid+1; } else { end = mid; } } return num[start]; }" }, { "title": "leetcode(리트코드)142-Linked List Cycle II", "url": "/posts/leetcode_Linked_List_Cycle_II/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Like", "date": "2021-03-18 02:00:00 +0900", "snippet": "leetcode 142 - Linked List Cycle II 문제입니다.1. 문제https://leetcode.com/problems/linked-list-cycle-ii/2. Input , OutputConstraints: The number of the nodes in the list is in the range [0, 104]. -105 &amp;lt;= Node.val &amp;lt;= 105 pos is -1 or a valid index in the linked-list. Follow up: Can you solve it using O(1) (i.e. constant) memory?3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked 문제입니다.4. 문제 해석 Linked List가 사이클을 돌면 어디서 부터 시작인지 노드를 반환하고 사이클이 아니면 null을 반환합니다. Cycle 확인하는 법은 Linked List Cycle I을 통해 알 수 있지만 어디서부터 시작인지는 몰라 Discuss를 참고하였습니다..근데 왜 저 점화식이 성립하는 지는 공부를 더 해야 알 것 같습니다.5. codepython# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def detectCycle(self, head: ListNode) -&amp;gt; ListNode: if head ==None or head.next ==None : return None onext = head dnext = head cycle = 0 while onext != None and dnext!=None: if dnext.next == None : return None onext = onext.next dnext = dnext.next.next if onext == dnext: cycle = 1 break if not cycle : return None onext = head while onext != dnext : onext = onext.next dnext = dnext.next return onext c++/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode *detectCycle(ListNode *head) { if (head==nullptr || head-&amp;gt;next==nullptr) return nullptr; ListNode* onext = head; ListNode* dnext = head; bool cycle = false; while(onext!=nullptr &amp;amp;&amp;amp; dnext!=nullptr) { onext = onext-&amp;gt;next; if(dnext-&amp;gt;next ==nullptr) return nullptr; dnext = dnext-&amp;gt;next-&amp;gt;next; if(dnext == onext) { cycle = true; break; } } if(!cycle) return nullptr; onext = head; while(onext!=dnext) { onext = onext-&amp;gt;next; dnext = dnext-&amp;gt;next; } return onext; }};6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!" }, { "title": "leetcode(리트코드)226-Invert Binary Tree", "url": "/posts/leetcode_Invert_Binary_Tree/", "categories": "leetcode, Eazy", "tags": "leetcode, Top100Like", "date": "2021-03-18 01:00:00 +0900", "snippet": "leetcode 226 - Invert Binary Tree 문제입니다.1. 문제https://leetcode.com/problems/invert-binary-tree/2. Input , OutputConstraints: The number of nodes in the tree is in the range [0, 100]. -100 &amp;lt;= Node.val &amp;lt;= 1003. 분류 및 난이도Eazy 난이도 문제입니다.leetcode Top 100 Liked 문제입니다.4. 문제 해석 주어진 트리를 대칭으로 바꿔버립니다.5. codec++/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: TreeNode* invertTree(TreeNode* root) { if(root!=nullptr) { invertTree(root-&amp;gt;left); invertTree(root-&amp;gt;right); std::swap(root-&amp;gt;left,root-&amp;gt;right); } return root; }};python# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def invertTree(self, root: TreeNode) -&amp;gt; TreeNode: if root : self.invertTree(root.left) self.invertTree(root.right) root.left,root.right = root.right,root.left return root 6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!c++ 45% python 83% 결과는 4ms라 0ms랑 차이가 없으므로 개선사항은 없습니다." }, { "title": "leetcode(리트코드)3월17일 challenge478-Generate Random Point in a Circle", "url": "/posts/leetcode_Generate_Random_Point_in_a_Circle/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-03-17 06:03:20 +0900", "snippet": "leetcode March 17일 - Generate Random Point in a Circle 문제입니다.1. 문제https://leetcode.com/problems/generate-random-point-in-a-circle/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.3월 17일자 챌린지 문제입니다.4. 문제 해석 랜덤으로 원의 좌표를 찍는 것인데, 테스트 케이스와 값이 같아야합니다. 좋은 문제는 아닌듯 합니다.5. codec++ 삽질한 코드 테스트 케이스 답이 정해져있는 줄 몰랐다.class Solution {private: double cradius; double cx; double cy;public: Solution(double radius, double x_center, double y_center) { this-&amp;gt;cradius = radius; this-&amp;gt;cx = x_center; this-&amp;gt;cy = y_center; } vector&amp;lt;double&amp;gt; randPoint() { vector&amp;lt;double&amp;gt; result; // 시드값을 얻기 위한 random_device 생성. std::random_device rd; // random_device 를 통해 난수 생성 엔진을 초기화 한다. std::mt19937 gen(rd()); // 0 부터 99 까지 균등하게 나타나는 난수열을 생성하기 위해 균등 분포 정의. //x 먼저 std::uniform_real_distribution&amp;lt;&amp;gt; dis(cx-cradius,cx+cradius); double rx=dis(gen); //y의 범위 x^2 + y^2 &amp;lt;= r^2 이므로 double tempyf = sqrt(cradius * cradius - rx * rx); cout&amp;lt;&amp;lt;tempyf&amp;lt;&amp;lt;&quot;tempyf&quot;; std::uniform_real_distribution&amp;lt;&amp;gt; dis2(0.0,tempyf); double ry =dis2(gen); cout&amp;lt;&amp;lt;rx&amp;lt;&amp;lt;&quot; &quot;&amp;lt;&amp;lt;ry&amp;lt;&amp;lt;&#39;\\n&#39;; result.push_back(rx); result.push_back(ry); return result; }};/** * Your Solution object will be instantiated and called as such: * Solution* obj = new Solution(radius, x_center, y_center); * vector&amp;lt;double&amp;gt; param_1 = obj-&amp;gt;randPoint(); */정답인 c++코드class Solution {public: double radius; double x_center; double y_center; Solution(double radius, double x_center, double y_center) { this-&amp;gt;radius = radius; this-&amp;gt;x_center = x_center; this-&amp;gt;y_center = y_center; } vector&amp;lt;double&amp;gt; randPoint() { double x; double y; do { x = (2 * ((double)rand() / RAND_MAX) - 1.0) * radius; y = (2 * ((double)rand() / RAND_MAX) - 1.0) * radius; } while (x * x + y * y &amp;gt; radius * radius); return { x_center + x, y_center + y }; }};6. 결과 및 후기, 개선점skip" }, { "title": "leetcode(리트코드)152-Maximum Product Subarray", "url": "/posts/leetcode_Maximum_Product_Subarray/", "categories": "leetcode, Medium", "tags": "leetcode, Facebook", "date": "2021-03-17 05:00:00 +0900", "snippet": "leetcode 152 - Maximum Product Subarray 문제입니다.1. 문제https://leetcode.com/problems/maximum-product-subarray/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.https://www.teamblind.com/post/New-Year-Gift---Curated-List-of-Top-75-LeetCode-Questions-to-Save-Your-Time-OaM1orEU에서 추천한 문제입니다.4. 문제 해석 곱한 값이 가장 큰 부분배열을 찾아야합니다. ’-‘을 잘 처리해주어야합니다. 1시간정도 고민하다가 discuss로 힌트를 얻었습니다..5. codepythonclass Solution: def maxProduct(self, nums: List[int]) -&amp;gt; int: maxP = -11 minP = 11 result = -98765321 for i in range(len(nums)): if nums[i] &amp;lt; 0 : temp = maxP maxP = minP minP = temp maxP = max(nums[i],maxP * nums[i]) minP = min(nums[i],minP * nums[i]) result = max(maxP,result) return resultc++class Solution {public: int maxProduct(vector&amp;lt;int&amp;gt;&amp;amp; nums) { if(nums.size()==0) return 0; int maxP = 1; int minP = 1; int result = INT_MIN; for(auto i =0 ; i&amp;lt;nums.size();++i) { if(nums[i]&amp;lt;0) swap(maxP,minP); maxP = max(nums[i],nums[i] * maxP); minP = min(nums[i],nums[i] * minP); result = max(result,maxP); } return result; }};6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!Discuss를 봤으니 x" }, { "title": "leetcode(리트코드)139-Word Break", "url": "/posts/leetcode_Word_Break/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Like", "date": "2021-03-17 03:00:00 +0900", "snippet": "leetcode 139 - Word Break 문제입니다.1. 문제https://leetcode.com/problems/word-break/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked 문제입니다.4. 문제 해석 s의 문자열과 wordDict이라는 문자열이 들어옵니다. wordDict의 문자들을 사용 및 중복사용하여, s문자열을 만들 수 있으면 True, 만들 수 없으면 False를 리턴합니다. wordDict을 중복사용할 수 있어서 고민을 많이 했는데 c++은 map를 이용하고, python은 ‘in’ 구문을 사용하여 구별할 수 있었습니다. 시작 인덱스만 조회하여, 끝까지 닿을 수 있으면 True, 닿을 수 없으면 False를 리턴합니다. 5. codec++class Solution {public: bool wordBreak(string s, vector&amp;lt;string&amp;gt;&amp;amp; wordDict) { bool* v = new bool[s.size()+1]; memset(v,false,sizeof(bool) *(s.size()+1) ); v[0] = true; unordered_map&amp;lt;string,bool&amp;gt; map; for(size_t i =0;i&amp;lt;wordDict.size();++i) { map[wordDict[i]] = true; } for(int i =1;i&amp;lt;s.size()+1;++i) { for(int j =0;j&amp;lt;i;++j) { string temp(s,j,i-j); if(v[j] == true) { auto it = map.find(temp); if(it!=map.end()) { v[i]=true; break; } } } } return v[s.size()]; }};pythonclass Solution: def wordBreak(self, s: str, wordDict: List[str]) -&amp;gt; bool: v = [0] * (len(s)+1) v[0]=1 for i in range(1,len(s)+1): for j in range(i) : if v[j] ==1 and s[j:i] in wordDict: v[i] = 1 break if v[len(s)] == 1: return True return False 6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!c++ 45% python 83% c++ 0ms 100% code//dpclass Solution{ public: bool wordBreak(string s, vector&amp;lt;string&amp;gt;&amp;amp; wordDict) { if (wordDict.size() == 0) return false; unordered_set&amp;lt;string&amp;gt; d(wordDict.begin(), wordDict.end()); // dp[i] is true only if a valid word or sequence of words ends at i vector&amp;lt;bool&amp;gt; dp(s.size() + 1, false); dp[0] = true; for (int i = 1; i &amp;lt;= s.size(); ++i) { for (int j = i - 1; j &amp;gt;= 0; --j) { // check only if a valid sequence of words (or a word) ends at j if (dp[j]) { const string sub = s.substr(j, i - j); if (d.count(sub)) { // Ending at i is a valid word dp[i] = true; // Others j values might be false // We stop here since there is one valid sequence ending here break; } } } } return dp[s.size()]; }};로직은 동일한 것 같은데 시간차이가 많이 납니다." }, { "title": "leetcode(리트코드)206-Reverse Linked List", "url": "/posts/leetcode_Reverse_Linked_List/", "categories": "leetcode, Eazy", "tags": "leetcode, Top100Like", "date": "2021-03-17 02:00:00 +0900", "snippet": "leetcode 206 - Reverse Linked List 문제입니다.1. 문제https://leetcode.com/problems/reverse-linked-list/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.leetcode Top 100 Liked 문제입니다.4. 문제 해석 LinkedList가 주어집니다. 뒤집어야합니다.5. codec++/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: void save(ListNode* head,vector&amp;lt;int&amp;gt;&amp;amp; vec) { if(head!=nullptr) { vec.push_back(head-&amp;gt;val); save(head-&amp;gt;next,vec); } } //재귀 void put(ListNode* node,vector&amp;lt;int&amp;gt;&amp;amp; vec,int count) { if(node!=nullptr) { node-&amp;gt;val = vec[count--]; put(node-&amp;gt;next,vec,count); } } //for문 void put2(ListNode* node,vector&amp;lt;int&amp;gt;&amp;amp; vec,int count) { for(;count&amp;gt;=0;--count) { node-&amp;gt;val = vec[count]; node=node-&amp;gt;next; } } ListNode* reverseList(ListNode* head) { ListNode* savenode = head; vector&amp;lt;int&amp;gt; vec; save(savenode,vec); savenode= head; //put(head,vec,vec.size()-1); //put2(head,vec,vec.size()-1); //수정 구문 ListNode* prev= nullptr; ListNode* next; while(savenode!=nullptr) { next = savenode-&amp;gt;next; savenode-&amp;gt;next = prev; prev = savenode; savenode=next; } return prev; }};6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!c++ 72% 코드를 개선하였으나 시간차이가 별로 없었다..아이디어만 배워갔다." }, { "title": "leetcode(리트코드)3월16일 challenge714-Best Time to Buy and Sell Stock with Transaction", "url": "/posts/leetcode_Best_Time_to_Buy_and_Sell_Stock_with_Transaction_Fee/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-03-17 01:03:20 +0900", "snippet": "leetcode March 16일 - Best Time to Buy and Sell Stock with Transaction 문제입니다.1. 문제https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.3월 16일자 챌린지 문제입니다.4. 문제 해석 물건값들들과 세금이 주어집니다. 언제 사고 팔아야 가장 많은 이득을 취할 수 있을까요.? 이미 산 물품이 있는데 또 사는건 불가능합니다. 산 물건을 팔아야 다음날 또 살 수 있습니다. 비슷한 문제를 백준?에서 풀어봤습니다.5. codec++class Solution {public: int maxProfit(vector&amp;lt;int&amp;gt;&amp;amp; prices, int fee) { int* buy = new int[prices.size()]; int* sell = new int[prices.size()]; buy[0] = -prices[0]; sell[0] = 0; for(size_t i = 1;i&amp;lt;prices.size();++i) { buy[i] = max(buy[i-1],sell[i-1] - prices[i]); sell[i] = max(sell[i-1], buy[i-1] + prices[i]-fee); } return sell[prices.size()-1]; }};pythonclass Solution: def maxProfit(self, prices: List[int], fee: int) -&amp;gt; int: size = len(prices) buy = [0] * size sell = [0] * size buy[0] = -prices[0] sell[0] = 0 for i in range(1,size): buy[i] = max(buy[i-1], sell[i-1] - prices[i]) sell[i] = max(sell[i-1] , buy[i-1] + prices[i]-fee) return sell[size-1]6. 결과 및 후기, 개선점c++ 96% python 39%python 502ms 96%c codeclass Solution: def maxProfit(self, prices: List[int], fee: int) -&amp;gt; int: minimum = sys.maxsize profit = 0 for p in prices: if p &amp;lt; minimum: minimum = p elif p &amp;gt; minimum + fee: profit += p - minimum - fee minimum = p - fee return profit" }, { "title": "Spring_JPA2 - 도메인 분석 설계", "url": "/posts/Spring_JPA02/", "categories": "Java, 5_김영한_실전! 스프링 부트와 JPA 활용 1", "tags": "Spring", "date": "2021-03-16 03:12:00 +0900", "snippet": "해당 자료는 인프런 김영한 선생님의 실전! 스프링 부트와 JPA 활용 1 강의노트입니다.해당 챕터는 글로 적기 힘든 이해의 영역이므로 글을 많이 적지 않겠습니다.1. 요구사항 분석기능 목록을 작성하였습니다.2. 도메인 모델과 테이블 설계테이브를 설계하는 과정을 알려주시고, 다 대 다 관계를 만들 지 말 것. DB는 회사마다 다르지만 해당 예제에서는 소문자 + _(언더 스코어)스타일을 사용 외래 키가 있는 곳을 연관관계의 주인. 자동차와 바퀴에서 자동차가 주인이 아니고 바퀴가 주인이다. 이유는 바퀴 1개를 바꾼다하면 자동차 테이블의 바퀴 정보도 바꿔줘야하는데, 이러한 과정이 꽤나 복잡하기 때문이다. 3. 엔티티 클래스 개발 1코드를 공개할 순 없으므로..skip사용된 애노테이션을 메모하겠습니다.@Column(name = “지정할 컬럼 이름”)해당 애노테이션을 통해 컬럼에 이름을 부여할 수 있습니다.@Column(name = &quot;order_id&quot;) private Long id;다른 테이블에서도 위와같이 id로 선언할 수 있어서 구분하기 위해 넣는 애노테이션입니다.@InheritanceType, @DiscriminatorColumn@Inheritance(strategy = InheritanceType.SINGLE_TABLE)@DiscriminatorColumn(name = &quot;dtype&quot;)여러 옵션이 있고 만약 추상화 클래스를 통해 여러가지를 상속받았으면 하나의 테이블로 관리할 지 분리해서 관리할 지 전략을 정해주는 애노테이션입니다.위의 코드는 SINGLE_TABLE로 상속받은 클래스들에 대해 JPA가 테이블 하나로 관리해줍니다.@DiscriminatorColumn은 통합된 SINGLE_TABLE에 대해 상속받은 클래스들에 대해 구분을 해주기 위해 넣어주는 애노테이션입니다.@Mapped by, @Embedded다대다 관계 등에서 테이블에 같은 객체가 존재할 경우 하나의 객체만 관리해줘야하기에 다른 하나는 수정할 수 없게 읽기전용으로 바꾸어주는 애노테이션입니다.@Enumerated(EnumType.STRING)해당 애노테이션을 통해 Enum으로 생성된 자료형에 대해 구분을 해줍니다.EnumType.STRING은 실제 Enum에 등록된 값으로 구분을 해주며, 데이터를 잡아먹지만 새로운 상태가 추가되는 등에 대해 유연하게 작용합니다.4. 엔티티 클래스 개발2DB 설정을 마치고 잘 구동되었는 지 확인합니다.다행히 저는 한번에 성공하였습니다." }, { "title": "leetcode(리트코드)238-Product of Array Except Self", "url": "/posts/leetcode_Product_of_Array_Except_Self/", "categories": "leetcode, Medium", "tags": "leetcode, Facebook", "date": "2021-03-16 02:00:00 +0900", "snippet": "leetcode 238 - Product of Array Except Self 문제입니다.1. 문제https://leetcode.com/problems/product-of-array-except-self/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.https://www.teamblind.com/post/New-Year-Gift---Curated-List-of-Top-75-LeetCode-Questions-to-Save-Your-Time-OaM1orEU에서 추천한 문제입니다.4. 문제 해석 나눗셈을 사용하지 않고 인덱스의 곱들을 구합니다. 단, 선택된 인덱스를 제외한 모든 인덱스의 곱입니다.5. codepythonclass Solution: def productExceptSelf(self, nums: List[int]) -&amp;gt; List[int]: size = len(nums) result = [1] * size for i in range(1,size): result[i] = result[i-1] * nums[i-1] right = 1 for i in range(size-1,-1,-1): result[i] *= right right *= nums[i] return resultc++class Solution {public: vector&amp;lt;int&amp;gt; productExceptSelf(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int n = nums.size(); vector&amp;lt;int&amp;gt; result(n); result[0] = 1; for(size_t i =1;i&amp;lt;n;++i) { result[i] = result[i-1] * nums[i-1]; } int right = 1; for(int i = n-1; i&amp;gt;=0;--i) { result[i] *= right; right *= nums[i]; } return result; }};6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!c++ 93% python 72%" }, { "title": "leetcode(리트코드)169-Major Element", "url": "/posts/leetcode_Major_Element/", "categories": "leetcode, Eazy", "tags": "leetcode, Top100Like", "date": "2021-03-16 01:00:00 +0900", "snippet": "leetcode 169 - Major Element 문제입니다.1. 문제https://leetcode.com/problems/majority-element/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.leetcode Top 100 Liked 문제입니다.4. 문제 해석 Major한 원소를 찾아야합니다. 여기서 Major한 원소는 배열의 절반 이상 등장하는 요소로, 무조건 있다고 가정합니다. 절반 이상을 차지하고 있다고 보장하므로 배열의 각 요소에 대한갯수를 더하고 빼면 결국 남은 요소는 Major한 요소일 것입니다.5. codec++class Solution {public: int majorityElement(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int major = nums[0]; int count = 1; for(size_t i = 1;i&amp;lt;nums.size();++i) { if(count==0) { major = nums[i]; ++count; } else if(nums[i]==major) ++count; else --count; } return major; }};pythonclass Solution: def majorityElement(self, nums: List[int]) -&amp;gt; int: count = 1 major = nums[0] for i in range(1,len(nums)): if count == 0 : major = nums[i] count = 1 elif nums[i] == major : count += 1 else : count -= 1 return major6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!c++ 70% python 88%" }, { "title": "leetcode(리트코드)105-Construct Binary Tree from Preorder and Inorder Traversal", "url": "/posts/leetcode_Construct_Binary_Tree_from_Preorder_and_Inorder_Traversal/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Like", "date": "2021-03-15 13:34:00 +0900", "snippet": "leetcode 105 - Construct Binary Tree from Preorder and Inorder Traversal 문제입니다.1. 문제https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/2. Input , OutputConstraints: 1 &amp;lt;= preorder.length &amp;lt;= 3000 inorder.length == preorder.length -3000 &amp;lt;= preorder[i], inorder[i] &amp;lt;= 3000 preorder and inorder consist of unique values.Each value of inorder also appears in preorder. preorder is guaranteed to be the preorder traversal of the tree. inorder is guaranteed to be the inorder traversal of the tree.3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked 문제입니다.4. 문제 해석 Preorder와 Inorder를 가지고 맞게 트리를 구성해야합니다. 재귀라는 것은 알았으나 너무 어려웠습니다. Discuss를 봤습니다.5. codec++class Solution {public: TreeNode* buildTree(vector&amp;lt;int&amp;gt;&amp;amp; preorder, vector&amp;lt;int&amp;gt;&amp;amp; inorder) { int rootIdx = 0; return build(preorder, inorder, rootIdx, 0, inorder.size()-1); } TreeNode* build(vector&amp;lt;int&amp;gt;&amp;amp; preorder, vector&amp;lt;int&amp;gt;&amp;amp; inorder, int&amp;amp; rootIdx, int left, int right) { if (left &amp;gt; right) return NULL; int pivot = left; // find the root from inorder while(inorder[pivot] != preorder[rootIdx]) pivot++; rootIdx++; TreeNode* newNode = new TreeNode(inorder[pivot]); newNode-&amp;gt;left = build(preorder, inorder, rootIdx, left, pivot-1); newNode-&amp;gt;right = build(preorder, inorder, rootIdx, pivot+1, right); return newNode; }};python# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def buildTree(self, preorder, inorder): if inorder: ind = inorder.index(preorder.pop(0)) root = TreeNode(inorder[ind]) root.left = self.buildTree(preorder, inorder[0:ind]) root.right = self.buildTree(preorder, inorder[ind+1:]) return root 6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!Discuss를 봤으므로 올리지 않습니다." }, { "title": "leetcode(리트코드)3월15일 challenge535-Encode and Decode TinyURL", "url": "/posts/leetcode_Encode_and_Decode_TinyURL/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-03-15 13:03:20 +0900", "snippet": "leetcode March 15일 - Encode and Decode TinyURL 문제입니다.1. 문제https://leetcode.com/problems/encode-and-decode-tinyurl/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.3월 15일자 챌린지 문제입니다.4. 문제 해석 좋지 않은 문제입니다. 사실 해석도 못했습니다. 그래서 그런지 Bad수가 많습니다.5. codeclass Solution {public: // Encodes a URL to a shortened URL. string encode(string longUrl) { return longUrl; } // Decodes a shortened URL to its original URL. string decode(string shortUrl) { return shortUrl; }};// Your Solution object will be instantiated and called as such:// Solution solution;// solution.decode(solution.encode(url));6. 결과 및 후기, 개선점c++ 100%" }, { "title": "Spring_JPA1 - 프로젝트 환경설정", "url": "/posts/Spring_JPA01/", "categories": "Java, 5_김영한_실전! 스프링 부트와 JPA 활용 1", "tags": "Spring", "date": "2021-03-15 06:12:00 +0900", "snippet": "해당 자료는 인프런 김영한 선생님의 실전! 스프링 부트와 JPA 활용 1 강의노트입니다.Spring 환경설정 만드는 예제는 옛날에도 작성했으므로 환경설정에서 전에 작성한 내용은 글로 설명하겠습니다.1. 프로젝트 생성프로젝트 생성은https://start.spring.io/에서 할 수 있습니다.위와 같은 설정을 갖고,Dependencies는 web thymeleaf jpa h2 lombok validation을 검색하여 추가합니다.IntellJ에서 import를 해줘서 라이브러리를 다운받고, 해당 강의에서 JUnit4를 사용하므로(최신버전이 아님) ‘build.gradle’ 파일을 수정해줘야합니다.//JUnit4 추가 testImplementation(&quot;org.junit.vintage:junit-vintage-engine&quot;){ exclude group: &quot;org.hamcrest&quot;, module : &quot;hamcrest-core&quot; }//전체코드plugins { id &#39;org.springframework.boot&#39; version &#39;2.4.3&#39; id &#39;io.spring.dependency-management&#39; version &#39;1.0.11.RELEASE&#39; id &#39;java&#39;}group = &#39;jpabook&#39;version = &#39;0.0.1-SNAPSHOT&#39;sourceCompatibility = &#39;11&#39;configurations { compileOnly { extendsFrom annotationProcessor }}repositories { mavenCentral()}dependencies { implementation &#39;org.springframework.boot:spring-boot-starter-data-jpa&#39; implementation &#39;org.springframework.boot:spring-boot-starter-thymeleaf&#39; implementation &#39;org.springframework.boot:spring-boot-starter-validation&#39; implementation &#39;org.springframework.boot:spring-boot-starter-web&#39; compileOnly &#39;org.projectlombok:lombok&#39; runtimeOnly &#39;com.h2database:h2&#39; annotationProcessor &#39;org.projectlombok:lombok&#39; testImplementation &#39;org.springframework.boot:spring-boot-starter-test&#39; //JUnit4 추가 testImplementation(&quot;org.junit.vintage:junit-vintage-engine&quot;){ exclude group: &quot;org.hamcrest&quot;, module : &quot;hamcrest-core&quot; }}test { useJUnitPlatform()}main method()를 실행하고 http://localhost:8080에 접속하여 환경이 잘 적용되었는 지 확인합니다.Whitelabel Error PageThis application has no explicit mapping for /error, so you are seeing this as a fallback.Mon Mar 15 15:38:01 KST 2021There was an unexpected error (type=Not Found, status=404).와 비슷한 페이지가 뜨면 적용이 된것입니다.lombok 적용https://kkminseok.github.io/posts/SpringPoint09/에서 lombok환경세팅과 lombok이 뭔지에 대한 글을 썼으니 참고하여 셋팅합니다.간단한 클래스를 하나 만들어 다음과 같이 적어줍니다.mainclass로 가서 다음과 같이 코드를 작성하고 실행해서 ‘hi’가 뜨면 성공입니다.package jpabook.jpashop;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class JpashopApplication { public static void main(String[] args) { Hello hello = new Hello(); hello.setData(&quot;hi&quot;); String temp = hello.getData(); System.out.println(&quot;temp = &quot; + temp); SpringApplication.run(JpashopApplication.class, args); }}누락된 내용이 있을 수도 있으니https://kkminseok.github.io/posts/SpringPoint2/도 참고해서 셋팅해야합니다.2. 라이브러리 보는 법생략3. View 환경설정이 강의에서는 템플릿 엔진으로 thymeleaf를 사용합니다. thymeleaf 공식 사이트: https://www.thymeleaf.org/예제는 https://kkminseok.github.io/posts/Springnovice3/와 비슷 합니다.만약 html 파일을 수정한다면 서버를 재시작해서 확인해야합니다.불필요한 작업을 줄이기 위해‘build.gradle’ 파일에 다음 코드를 추가해줍니다. implementation &#39;org.springframework.boot:spring-boot-devtools&#39;devtools는 개발할 때 도움이 되는 도구들을 제공합니다.위와 같이 재실행 했을 때 [restartedMain]~이라고 뜨면 성공입니다.앞으로는 서버를 재실행하지 않고 위의 ‘build’ -&amp;gt; ‘Recompile’ 버튼을 눌러주면 변경사항이 적용됩니다.4. H2 DB 설정내용이 중복이므로 https://kkminseok.github.io/posts/Springnovice8/를 참고해서 설정하면 됩니다.5. JPA, DB 설정 확인강의에서는 ‘application.properties’가 아닌 ‘application.yml’파일을 사용하므로 application.properties를 삭제하고 apllication.yml 파일을 resources폴더 밑에 만들어줍니다.내용이 굉장히 중요한데, yml은 2칸씩 띄워줘야 계층을 만듭니다.때문에 띄어쓰기 + 오타 관리를 잘해야합니다.. 이걸로 나중에 테스트 코드에서 오류가 많이납니다.대표적인 오류는 ‘Failed to load ApplcationContext’입니다.yml 파일 내용입니다.spring: #띄어쓰기 없음 datasource: #띄어쓰기 2칸 url: jdbc:h2:tcp://localhost/~/jpashop #4칸 username: sa password: driver-class-name: org.h2.Driver jpa: #띄어쓰기 2칸 hibernate: #띄어쓰기 4칸 ddl-auto: create #띄어쓰기 6칸 properties: #띄어쓰기 4칸 hibernate: #띄어쓰기 6칸 # sout로 로그를 찍는데 권장하지 않습니다. # show_sql: true #띄어쓰기 8칸 format_sql: true #띄어쓰기 8칸logging.level: #띄어쓰기 없음 #hibernater를 이용해서 로그를 찍습니다. org.hibernate.SQL: debug #띄어쓰기 2칸# org.hibernate.type: trace #띄어쓰기 2칸다음 테스트를 위해 Member.java 파일을 만들어줍니다.//Member.java@Entity@Getter @Setterpublic class Member { @Id @GeneratedValue private Long id; private String username;}Member를 등록할 간단한 저장소를 만듭니다.//MemberRepository.java@Repositorypublic class MemberRepository { @PersistenceContext EntityManager em; public Long save(Member member){ em.persist(member); return member.getId(); } public Member find(Long id){ return em.find(Member.class,id); }}이후 window 기준 ctrl + shift + t 키를 이용해서 테스트파일을 만드는데, 강의에서 Junit4를 사용해서 Junit4버전으로 만들었습니다.//MemberTest.java 파일//스프링부트에게 알리는 방식이라고 합니다.@RunWith(SpringRunner.class)@SpringBootTestpublic class MemberRepositoryTest { //불러오기 @Autowired MemberRepository memberRepository; @Test //밑의 애노테이션이 없으면 오류가 납니다. @Transactional //false옵션 사용 시 실제 DB에 테스트한 값이 남습니다. Rollback 애노테이션을 지우면 테스트 이후 DB를 롤백해 DB에 자료가 남지 않습니다. @Rollback(value = false) public void testMember(){ //member 객체 생성 Member member = new Member(); member.setUsername(&quot;KMS&quot;); Long saveId = memberRepository.save(member); //DB에 저장완료 //DB에서 찾아봅니다. Member findMember = memberRepository.find(saveId); //DB에서 찾은 객체의 Id와 DB에 넣기로한 객체와 Id가 같은지 확인합니다. Assertions.assertThat(findMember.getId()).isEqualTo(member.getId()); //마찬가지 Assertions.assertThat(findMember.getUsername()).isEqualTo(member.getUsername()); //Ok가 뜹니다. Assertions.assertThat(findMember).isEqualTo(member); }}참고로 yml파일의 마지막줄에서 작성한 주석문을 제거하고,build.gradle 파일의 의존성에 다음 코드를 추가하면 로그에 어떤데이터가 들어갔는 지 확인할 수 있습니다. (추가하지 않으면 확인이 불가)#build.gradle 파일implementation &#39;com.github.gavlyukovskiy:p6spy-spring-boot-starter:1.5.6&#39;p6spy라고 불리는데, 다음과 같이 로그를 찍어줍니다.하지만 성능이 느려질 수 있으니 개발 단계에서 사용하고, 운영 단계에서는 성능 테스트를 거치라고 하셨습니다." }, { "title": "leetcode(리트코드)217-Contains Duplicate", "url": "/posts/leetcode_Contains_Duplicate/", "categories": "leetcode, Eazy", "tags": "leetcode, Facebook", "date": "2021-03-15 02:02:00 +0900", "snippet": "leetcode 217 - Contains Duplicate 문제입니다.1. 문제https://leetcode.com/problems/contains-duplicate/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.https://www.teamblind.com/post/New-Year-Gift---Curated-List-of-Top-75-LeetCode-Questions-to-Save-Your-Time-OaM1orEU에서 추천한 문제입니다.4. 문제 해석 배열이 주어집니다. 최소 2번 이상 반복되는 요소가 있으면 True 없으면 False를 리턴합니다.5. codepythonclass Solution: def containsDuplicate(self, nums: List[int]) -&amp;gt; bool: dic = {} for i in range(len(nums)) : temp = dic.get(nums[i],2) if temp != 2 : return True dic[nums[i]] = 1 return Falsec++class Solution {public: bool containsDuplicate(vector&amp;lt;int&amp;gt;&amp;amp; nums) { unordered_map&amp;lt;int,bool&amp;gt; map; for(size_t i = 0;i&amp;lt;nums.size();++i) { if(map[nums[i]]==true) return true; map[nums[i]]=true; } return false; }};6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!c++ 86% python 99%c++99% 8ms codeclass Solution {public: bool containsDuplicate(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int n = nums.size(); sort(nums.begin(), nums.end()); for (int i = 0; i &amp;lt; n - 1; i++) if (nums[i] == nums[i+1]) return true; return false; }};정렬하고 끝요소까지 같은 요소가 없으면 false를 리턴합니다." }, { "title": "leetcode(리트코드)155-Min Stack", "url": "/posts/leetcode_Min_Stack/", "categories": "leetcode, Eazy", "tags": "leetcode, Top100Like", "date": "2021-03-15 01:02:00 +0900", "snippet": "leetcode 155 - Min Stack 문제입니다.1. 문제https://leetcode.com/problems/min-stack/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.leetcode Top 100 Liked 문제입니다.4. 문제 해석 stack을 구현해야합니다. getMin()함수를 호출하면 요소중 가장 작은 값을 리턴해야합니다.5. codepythonclass MinStack: def __init__(self): self.st = [] &quot;&quot;&quot; initialize your data structure here. &quot;&quot;&quot; def push(self, x: int) -&amp;gt; None: currmin = self.getMin() if currmin == None or x &amp;lt; currmin : currmin = x self.st.append((x,currmin)) def pop(self) -&amp;gt; None: self.st.pop() def top(self) -&amp;gt; int: if len(self.st) == 0 : return None return self.st[len(self.st) -1][0] def getMin(self) -&amp;gt; int: if len(self.st) == 0 : return None return self.st[len(self.st)-1][1]# Your MinStack object will be instantiated and called as such:# obj = MinStack()# obj.push(x)# obj.pop()# param_3 = obj.top()# param_4 = obj.getMin()c++class MinStack {private: multiset&amp;lt;int&amp;gt; ms; stack&amp;lt;int&amp;gt; st;public: /** initialize your data structure here. */ MinStack() { } void push(int x) { st.push(x); ms.insert(x); } void pop() { int temp = st.top(); st.pop(); auto findindex = ms.find(temp); if(findindex!=ms.end()) { ms.erase(findindex); } } int top() { return st.top(); } int getMin() { multiset&amp;lt;int&amp;gt;::iterator iter = ms.begin(); return *iter; }};/** * Your MinStack object will be instantiated and called as such: * MinStack* obj = new MinStack(); * obj-&amp;gt;push(x); * obj-&amp;gt;pop(); * int param_3 = obj-&amp;gt;top(); * int param_4 = obj-&amp;gt;getMin(); */6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!c++ 70% python 70%python은 40ms 코드와 다를 게 없었고,c++99% codeclass MinStack {public: stack&amp;lt;int&amp;gt; s,mn; MinStack() { } void push(int x) { s.push(x); //단순한 구문이지만 핵심. if((mn.empty())||(x&amp;lt;=mn.top())) {mn.push(x);} } void pop() { int nn=s.top(); s.pop(); if(nn==mn.top()) {mn.pop();} } int top() { return s.top(); } int getMin() { return mn.top(); }};" }, { "title": "leetcode(리트코드)3월14일 challenge1721-Swapping Nodes in a Linked List", "url": "/posts/leetcode_Swapping_Nodes_in_a_Linked_List/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-03-14 18:00:00 +0900", "snippet": "leetcode March 14일 - Swapping Nodes in a Linked List 문제입니다.1. 문제https://leetcode.com/problems/swapping-nodes-in-a-linked-list/2. Input , OutputConstraints: The number of nodes in the list is n. 1 &amp;lt;= k &amp;lt;= n &amp;lt;= 105 0 &amp;lt;= Node.val &amp;lt;= 1003. 분류 및 난이도Medium 난이도입니다.3월 14일자 챌린지 문제입니다.4. 문제 해석 앞에서 k번째의 수와 뒤에서 k 번째의 수를 바꿔주면 됩니다.5. codec++/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: void calsize(ListNode* head, int&amp;amp; count) { if(head-&amp;gt;next==nullptr) return; calsize(head-&amp;gt;next,++count); } void swappointer(ListNode* head,int count, int k,ListNode*&amp;amp; first,ListNode*&amp;amp; second,int size) { if(head==nullptr) return ; if( k== count) { first = head; } if(size - k +1== count) { second = head; int temp = first-&amp;gt;val; first-&amp;gt;val = second-&amp;gt;val; second-&amp;gt;val= temp; } swappointer(head-&amp;gt;next,++count,k,first,second,size); } ListNode* swapNodes(ListNode* head, int k) { //첫 번째 돌 때 전체의 갯수를 알게하자. ListNode* tempsize = head; int size = 1; calsize(tempsize,size); cout&amp;lt;&amp;lt;size; ListNode* first; ListNode* second; //second부터 만나는 경우를 없애버림. if(size/2 &amp;lt; k) k = size-k+1; swappointer(tempsize,1,k,first,second,size); return head; }};6. 결과 및 후기, 개선점c++ 99%" }, { "title": "leetcode(리트코드)96-Unique Binary Search Trees", "url": "/posts/leetcode_Unique_Binary_Search_Trees/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Like", "date": "2021-03-14 01:02:00 +0900", "snippet": "leetcode 96 - Unique Binary Search Trees 문제입니다.1. 문제https://leetcode.com/problems/unique-binary-search-trees/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked 문제입니다.4. 문제 해석 DP문제입니다. 이런 경우의 수 문제는 규칙이 있을 수 밖에.. 없을 것입니다. 점화식을 해석, 생각하는 데 오래걸렸고 생각하기 힘듭니다. 만약 n=5라고 하면 {1,2,3,4,5}이렇게 트리의 루트가 될 수 있습니다. ‘1’를 루트노드라고 하면 왼쪽 자식에는 올 것이 없고 오른쪽 자식에는 {2,3,4,5}를 트리로 만들어야하는데 이 경우의 수는 n=4일 때의 경우의 수와 같습니다. ‘2’를 루트노드라고 하면 왼쪽 자식에는 {1}, 오른쪽 자식에는 {3,4,5}가 와야하는데 이는 왼쪽의 경우 n=1, 오른쪽 자식은 n=3인 경우의 수입니다. 이런식으로 진행하다보면따라서 밑과 같은 점화식이 성립하는 것입니다.5. codepythonclass Solution: def numTrees(self, n: int) -&amp;gt; int: dp =[0] * 20 dp[0] = 1 dp[1] = 1 for i in range(2,n+1): for j in range(1,i+1): dp[i] = dp[i] + dp[j-1] * dp[i-j] return dp[n]c++class Solution {public: int numTrees(int n) { int dp[20]={0,}; dp[0] = 1; dp[1] = 1; for(int i = 2; i &amp;lt;= n ;++i) for(int j = 1;j&amp;lt;=i;++j) dp[i] += (dp[j-1] * dp[i-j]); return dp[n]; }};6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!c++ 100% python 84%" }, { "title": "leetcode(리트코드)104-Maximum Depth of Binary Tree", "url": "/posts/leetcode_Maximum_Depth_of_Binary_Tree/", "categories": "leetcode, Eazy", "tags": "leetcode, Top100Like", "date": "2021-03-14 01:00:00 +0900", "snippet": "leetcode 104 - Maximum Depth of Binary Tree 문제입니다.1. 문제https://leetcode.com/problems/maximum-depth-of-binary-tree/2. Input , OutputConstraints: The number of nodes in the tree is in the range [0, 104]. -100 &amp;lt;= Node.val &amp;lt;= 1003. 분류 및 난이도Eazy 난이도 문제입니다.leetcode Top 100 Liked 문제입니다.4. 문제 해석 트리의 깊이를 찾아 리턴합니다.5. codepython# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def maxDepth(self, root: TreeNode) -&amp;gt; int: if root == None : return 0 return max(self.maxDepth(root.left),self.maxDepth(root.right))+1c++/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: int cal(TreeNode* root) { if(root!=nullptr) { return max(cal(root-&amp;gt;left),cal(root-&amp;gt;right))+1; } return 0; } int maxDepth(TreeNode* root) { return cal(root); }};6. 결과 및 후기, 개선점코드에 대한 설명이 필요하신 분은 댓글을 달아주세요.!!c++ 100% python 98%" }, { "title": "leetcode(리트코드)3월13일 challenge823-Binary Trees With Factors", "url": "/posts/leetcode_Binary_Trees_With_Factors/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-03-13 13:00:00 +0900", "snippet": "leetcode March 13일 - Binary Trees With Factors 문제입니다.1. 문제https://leetcode.com/problems/binary-trees-with-factors/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.3월 13일자 챌린지 문제입니다.4. 문제 해석 arr에 들어있는 숫자로 만들 수 있는 트리의 개수를 셉니다. 트리의 조건은 양쪽의 자식 노드를 곱해서 부모노드를 만들 수 있으면 됩니다. DP로 풀 수 있습니다. 왜냐하면 자식 노드를 곱해서 부모노드를 만들 수 있으므로 사실상 두 자식 노드를 만들 수 있는 경우의 수를 더하면 그 부모노드를 만들 수 있는 경우의 수가 되기 때문입니다.5. codec++class Solution {public: int numFactoredBinaryTrees(vector&amp;lt;int&amp;gt;&amp;amp; arr) { int mod = pow(10,9) + 7; sort(arr.begin(),arr.end()); unordered_map&amp;lt;int,long&amp;gt; dp; long result = 0; for(size_t i =0;i&amp;lt;arr.size();++i) { dp[arr[i]] = 1; for(int j = 0 ; j&amp;lt;i;++j) { if(arr[i] % arr[j] == 0) dp[arr[i]] = (dp[arr[i]] + dp[arr[j]] * dp[arr[i] /arr[j]]) %mod; } result = (result + dp[arr[i]])%mod; } return result; }};pythonclass Solution: def numFactoredBinaryTrees(self, arr: List[int]) -&amp;gt; int: dp ={} result = 0 mod = pow(10,9) + 7 arr.sort() for i in range(len(arr)): dp[arr[i]] = 1 for j in range(i): if arr[i] % arr[j] == 0: if(arr[i]//arr[j]) in dp : dp[arr[i]] = (dp[arr[i]] + dp[arr[j]] *(dp[arr[i] // arr[j]])) %mod else: dp[arr[i]//arr[j]] =0 result = (result+ dp[arr[i]]) %mod return result6. 결과 및 후기, 개선점c++ 40% python 50%" }, { "title": "leetcode(리트코드)3월12일 challenge1461-Check If a String Contains All Binary Codes of Size K", "url": "/posts/leetcode_Check_If_a_String_Contains_All_Binary_Codes_of_Size_K/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-03-12 17:00:00 +0900", "snippet": "leetcode March 12일 - Check If a String Contains All Binary Codes of Size K 문제입니다.1. 문제https://leetcode.com/problems/check-if-a-string-contains-all-binary-codes-of-size-k/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.3월 12일자 챌린지 문제입니다.4. 문제 해석 string 으로 들어온 s안에 k만큼의 크기를 가진 binary 숫자들이 전부 들어 있는 지 확인합니다. set은 중복 값이 들어오거나 값이 들어오지 않은 경우는 크기가 커지지 않고 모든 경우의 수는 2^k 이므로 두 값을 비교하였습니다.5. codepythonclass Solution: def hasAllCodes(self, s: str, k: int) -&amp;gt; bool: sh = set() if k&amp;gt; len(s): return False for i in range(len(s)-k+1): temp = str() for j in range(k): temp +=s[i+j] sh.add(temp) if len(sh) == pow(2,k): return True return False c++class Solution {public: bool hasAllCodes(string s, int k) { unordered_set&amp;lt;string&amp;gt; sh; if(k&amp;gt;s.size()) return false; for(int i=0;i&amp;lt;=s.size()-k;++i) { string temp = &quot;&quot;; for(int j =0;j&amp;lt;k;++j) { temp+=s[i+j]; } //cout&amp;lt;&amp;lt;temp&amp;lt;&amp;lt;&quot; &quot;&amp;lt;&amp;lt;sh.size()&amp;lt;&amp;lt;&#39;\\n&#39;; sh.insert(temp); } if(sh.size() == pow(2,k)) return true; return false; }};6. 결과 및 후기, 개선점c++ 40% python 14%c++ 100% 12ms codeclass Solution {public: bool hasAllCodes(string&amp;amp; s, int k) { if (k&amp;gt;15) return false; bool set[1&amp;lt;&amp;lt;k]; memset(set, 0, sizeof(set)); int n = stoi(s.substr(0,k), 0, 2); for (int i=k; i &amp;lt;= s.size(); i++) { // check prev window set[n] = true; if (i == s.size()) break; n = n &amp;amp; ~(1 &amp;lt;&amp;lt; (k-1)); // clear kth bit n = (n &amp;lt;&amp;lt; 1) | (s[i]-&#39;0&#39;); } for (int i=0; i &amp;lt; (1&amp;lt;&amp;lt;k); i++) if (set[i] == false) return false; return true; } };static auto _______ = [](){ std::ios::sync_with_stdio(false); std::cin.tie(NULL); std::cout.tie(NULL); return 0;}();python 224ms 96% codeclass Solution: def hasAllCodes(self, s: str, k: int) -&amp;gt; bool: count = 2 ** k seen = set() for i in range(k, len(s)+1): temp = s[i-k:i] if temp not in seen: seen.add(temp) count -= 1 if count == 0: return True return False제가 파이썬이 미성숙해 temp를 업데이트하는 for문을 돌지 않았다는 점에서 다릅니다." }, { "title": "HTTP - 8 HTTP 헤더 2", "url": "/posts/HTTP09/", "categories": "HTTP, 김영한_모든 개발자를 위한 HTTP 웹 기본 지식", "tags": "HTTP", "date": "2021-03-12 14:12:00 +0900", "snippet": "해당 자료는 인프런 김영한 선생님의 모든 개발자를 위한 HTTP 웹 기본 지식 강의노트입니다.1. 캐시 기본 동작클라이언트에서 ‘GET/star.JPG’ 라는 요청을 서버에 보내면 서버는 star.jpg를 찾아서 응답해줄 것입니다. HTTP 헤더(0.1M 가정) + HTTP 바디(1.0M) = 1.1M 정도의 크기를 포함해서 말이죠.하지만 캐시가 없는 상태에서 똑같은 요청을 또 한다면 또 1.1M크기의 데이터를 응답하는 것은 효율적인 상황은 아닙니다.그렇기에 캐시가 없는 상태에서의 이러한 요청은 사용자에게 느린 경험을 주고 브라우저 로딩 속도 저하로 이어집니다.만약 캐시가 있다면 첫 번째 요청에 서버는 cache 유효시간을 포함한 헤더를 함께 클라이언트에 응답하여 클라이언트는 유효시간동안 ‘브라우저 캐시’ 라는 곳에 응답 결과를 저장해 놓고 유효시간 동안 똑같은 요청이 오면 캐시에서 꺼내서 쓸 것입니다.정말 운이 나쁘게도 유효시간이 끝날 때 마다 요청을 보내면 결국 매 번 똑같은 응답을 다시 받아야하는데 어떻게 해결할까요.?2. 검증 헤더와 조건부 요청1캐시가 시간을 초과해서 서버에 다시 요청을 보내면 다음과 같은 두 가지 상황이 있습니다. 서버에서 기존 데이터를 변경하여 새로 받아야함. 서버에서 기존 데이터가 변경되지 않아서 새로 받을 필요가 없음. 2 번의 경우 클라이언트의 데이터와 서버의 데이터가 같다는 사실을 확인할 수 있는 방법이 필요합니다.그래서 헤더에 새로운 정보를 추가하게 됩니다.헤더HTTP/1.1 200 OKContent-Type: image/jpegcache-control: max-age=60Last-Modified: UTC 날짜 어쩌구 저쩌구 &amp;lt;- 이부분 이 중요합니다.Content-Length:77777sdkakldjlajdlkjfklajslkdjdkasjdlkajdskljdaslk위의 헤더를 처음 클라이언트가 서버에 요청을 보낼 때 받게 됩니다.이를 통해 클라이언트는 다음 요청에 캐시에 있는 Last-Modified를 꺼내 서버에 비교 요청을 합니다.만약 수정일이 같다면 서버는 304 Not Modified라는 응답을 보내며 캐시를 다시 업데이트 하고,HTTP 헤더만 보냅니다. 따라서 HTTP body는 보내지 않기에 클라이언트는 다운로드에 대한 부담이 적어지고 캐시에 있는 데이터를 재활용할 수 있게 됩니다.참고로 캐시의 만료 와 삭제는 다른 개념으로 캐시가 만료되었다고 해서 삭제되지는 않습니다. 브라우저마다 캐시 삭제 주기가 다르기도 하고 직접 삭제도 가능합니다.3. 검증 헤더와 조건부 요청2 검증 헤더위에서 설명한 Last-Modified 말고 ETag라는 것이 있습니다. 조건부 요청 헤더 검증 헤더로 조건에 따른 분기 If-Modified-Since : Last-Modified 사용 If-None-Match : ETag 사용. 조건이 만족하면 200 OK 조건이 만족하지 않으면 304 Not Modified 조건부 요청 헤더에서 주의할 점은 부정 구문이라 조건을 만족하면 304(실패)가 떠야한다는 것입니다.If-Modified-Since는 이후에 데이터가 수정되었으면? 이라는 구문인데 데이터가 수정이 되지 않았으면 200 OK가 아닌 304 Not Modified라는 페이지를 반환해야한다는 것이지요.Last-Modified와 이를 이용한 If-Modified-Since는 단점이 있습니다. 날짜 기반의 로직 사용이라는 점. 데이터를 수정해서 날짜가 다르지만 같은 데이터를 수정해서 데이터 결과가 같은 경우 위의 경우는 a 를 b로 수정했다가 다시 a로 수정하였는데도 데이터를 처음부터 받는 경우를 말합니다. 서버에서 별도의 캐시 로직을 관리하고 싶은 경우 스페이스바, 주석처럼 크게 영향이 없는 변경에서도 캐시를 유지하고 싶은 경우 위의 단점들을 보완하기 위해 ETag, If-None-Match가 탄생하였습니다. ETag(Entity Tag) 캐시용 데이터에 임의의 고유한 버전 이름을 달아둡니다. 예) ETag:”v1.1”, ETag:”kmsblog1” 데이터가 변경되면 이 이름을 바꾸어서 변경합니다. 예) ETag:”v1.1” -&amp;gt; ETag:”v1.2” 등 단순하게 클라이언트가 캐시에 저장된 ETag만 보내서 같으면 유지, 다르면 다시 받게 합니다.즉 클라이언트 첫 번째 요청에 서버가 ETag를 포함한 헤더를 응답하여 클라이언트 캐시에 저장시킨다음 클라이언트가 다음 요청 시 로컬에 저장된 캐시에서 ETag만 끄집어 내어 ‘If-None-Match’를 통해 같으면 304 Not Modified와 캐시 유효시간을 증가시키고 다르면 데이터를 다시 받습니다.이를 통해서 캐시 제어 로직을 서버에서 관리할 수 있습니다. 보통 배포 주기에 맞추어 ETag를 모두 갱신합니다.4. 캐시와 조건부 요청 헤더캐시 제어 헤더 Cache-Control : 캐시 제어 Pragma : 캐시 제어 (하위 호환) Expires : 캐시 유효 기간(하위 호환)Cache-Control Cache-Control : max-age 캐시 유효 시간, 초 단위 Cache-Control : no-cache 데이터는 캐시해도 되지만, 항상 origin 서버에서 검증하고 사용 Cache-Control : no-store 데이터에 민감한 정보가 있으므로 저장하면 안됨.(메모리에서 사용하고 최대한 빨리 삭제) Pragma no-cache HTTP 1.0 하위 호환Expires 캐시 만료일 지정 expires : Mon, 01 Jan 2020 00:00:00 GMT HTTP 1.0 부터 사용 했지만, Cache-Control: max-age를 권장.(더 유연) 따라서 같이 사용되면 Expires는 무시 됩니다.5. 프록시 캐시만약 한국에서 미국에 있는 원(origin)서버에 바로 접근한다고 하면 시간이 오래 걸릴 것입니다.그래서 한국 어딘가에 프록시 캐시 서버라는 서버를 두면 이 서버에 접근하여 상대적으로 시간을 줄일 수 있을 것입니다.위의 그림에서 private, public 캐시가 있습니다. Cache-Control : public 응답이 public 캐시에 저장되어도 됨 (방문 경로 등) Cache-Control : private 응답이 해당 사용자만을 위한 것임.(로그인 정보 등) prvate 캐시에 저장되어야함(기본 값) Cache-Control : s-maxage 프록시 캐시에만 적용되는 max-age Age : 60 (HTTP 헤더) 오리진 서버에서 응답 후 프록시 캐시 내에 머문 시간(초) 6. 캐시 무효화계좌 금액이나 민감한 정보에 대해 캐시가 들어오지 않게 지정해야 합니다.확실하게 캐시를 무효화 시키는 방법은 밑의 값들을 전부 넣어주는 것입니다. Cache-Control : no-cache, no-store, must-revalidate Pragma:no-cache (HTTP 1.0 하위 호환) Cache-Control : no-cache 데이터는 캐시해도 되지만, 항상 원 서버에 검증하고 사용. Cache-Control : no-store 데이터에 민감한 정보가 있으므로 저장하면 안됨. Cache-Control : must-revalidate 캐시 만료후 최초 조회시 원 서버에 검증해야함. 원 서버 접근 실패시 반드시 오류가 발생해야함. 504(Gateway Timeout) no-cahce와 must-revalidate는 비슷해보이지만 다음과 같은 상황에서 다르게 작용합니다.위의 상황인 프록시 캐시 서버와 원서버의 연결이 단절된 경우no-cache는 프록시 캐시에 있는 데이터를 보여주자고 200 OK를 응답으로 주지만must-revalidate는 504 Gateway Timeout을 응답으로 내어 오류를 뿜습니다." }, { "title": "leetcode(리트코드)9-Palindrome Number", "url": "/posts/leetcode_Palindrome_Number/", "categories": "leetcode, Eazy", "tags": "leetcode, Top100Like", "date": "2021-03-12 06:00:00 +0900", "snippet": "leetcode 9 - Palindrome Number 문제입니다.1. 문제https://leetcode.com/problems/palindrome-number/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.leetcode Top 100 Liked 문제입니다.4. 문제 해석 간단한 문제입니다. 정수로 들어온 값이 Palindrome인지 판단합니다. string으로 바꿔서 풀었습니다. 풀고나서는 음수 값이 들어오면 Palindrome이 성립할 수 없기에 그냥 Brute Force로 풀었어도 되었을 것 같습니다.5. codec++class Solution {public: bool isPalindrome(int x) { string temp = std::to_string(x); int left = 0; int right = temp.size()-1; while(left&amp;lt;=right) { if(temp[left++]!=temp[right--]) return false; } return true; }};pythonclass Solution: def isPalindrome(self, x: int) -&amp;gt; bool: temp = str(x) left = 0 right = len(temp)-1 while(left&amp;lt;=right): if temp[left]!=temp[right]: return False left+=1 right-=1 return True6. 결과 및 후기, 개선점c++ 54% python 98%c++ 100% 0ms code class Solution {public: bool isPalindrome(int x) { int temp = x; long rev, rem; rev = 0; if (x &amp;lt; 0) return false; while (temp != 0){ rem = temp % 10; rev = rev * 10 + rem; temp = temp/10; } if (x == rev) return true; else return false; }};string으로 바꾸지않고 맨 뒤의 값과 맨 앞의 값을 비교하면서 푼 코드입니다." }, { "title": "leetcode(리트코드)72-Edit Distance", "url": "/posts/leetcode_Edit_Distance/", "categories": "leetcode, Hard", "tags": "leetcode, Top100Like", "date": "2021-03-12 02:00:00 +0900", "snippet": "leetcode 72 - Edit Distance 문제입니다.1. 문제https://leetcode.com/problems/edit-distance/2. Input , Output3. 분류 및 난이도Hard 난이도 문제입니다.leetcode Top 100 Liked 문제입니다.4. 문제 해석 DP문제입니다. word1로 word2로 만드는데 삽입, 삭제, 대체 를 몇 번 이용하여 만들 수 있는지를 리턴합니다. DP 점화식이 이해가 안된다면 직접 그리면서 하면 이해가 잘 됩니다.5. codepythonclass Solution: def minDistance(self, word1: str, word2: str) -&amp;gt; int: dp=[] for i in range(len(word1)+1): dp.append([]) for j in range(len(word2)+1): dp[i].append([]) for i in range(len(word1)+1): dp[i][0] = i for j in range(len(word2)+1): dp[0][j] = j if i!= 0 and j!= 0 : if word1[i-1] == word2[j-1]: dp[i][j] = dp[i-1][j-1] else : dp[i][j] = min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1])+1 return dp[len(word1)][len(word2)] c++ class Solution {public: int minDistance(string word1, string word2) { int** dp = new int*[word1.size()+1]; for(int i = 0;i&amp;lt;=word1.size(); ++i) dp[i] = new int[word2.size()+1]; for(int i = 0;i&amp;lt;=word1.size();++i) { dp[i][0] = i; for(int j=0;j&amp;lt;=word2.size();++j) { dp[0][j]= j; if(i!=0 &amp;amp;&amp;amp; j!=0) { if(word1[i-1] == word2[j-1]) dp[i][j] = dp[i-1][j-1]; else dp[i][j] = min({dp[i-1][j-1], dp[i-1][j],dp[i][j-1]})+1; } } } return dp[word1.size()][word2.size()]; }};6. 결과 및 후기, 개선점c++ 68% python 12%c++ 100% 12ms code class Solution {public: int minDistance(string word1, string word2) { int m = word1.size(); int n = word2.size(); if(m * n == 0) return m + n; int DP[m + 1][n + 1]; for(int i = 0; i &amp;lt;= m; i++) DP[i][0] = i; for(int i = 0; i &amp;lt;= n; i++) DP[0][i] = i; for(int i = 1; i &amp;lt;= m; i++) for(int j = 1; j &amp;lt;= n; j++) { int top = DP[i - 1][j] + 1; int left = DP[i][j - 1] + 1; int top_left = DP[i-1][j-1]; if(word1[i-1] != word2[j-1]) top_left++; DP[i][j] = min(top,min(left,top_left)); } return DP[m][n]; }};필요한 값을 미리 꺼내놓고 작업을 하여 속도가 빨라진 것 같습니다.python 100% 44ms codeclass Solution: def minDistance(self, word1: str, word2: str) -&amp;gt; int: visit, q=set(), [(word1, word2, 0)] while True: w1, w2, d=q.pop(0) if (w1, w2) not in visit: if w1==w2: return d visit.add((w1, w2)) while w1 and w2 and w1[0]==w2[0]: w1, w2=w1[1:], w2[1:] d+=1 q.extend([(w1[1:], w2[1:], d), (w1, w2[1:], d), (w1[1:], w2, d)])" }, { "title": "leetcode(리트코드)78-Subsets", "url": "/posts/leetcode_Subsets/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Like", "date": "2021-03-12 01:00:00 +0900", "snippet": "leetcode 78 - Symmetric Tree 문제입니다.1. 문제https://leetcode.com/problems/subsets/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked 문제입니다.4. 문제 해석 중복되지 않게 수를 나열하고 그 수를 담은 벡터를 리턴합니다.5. codepythonclass Solution: def subsets(self, nums: List[int]) -&amp;gt; List[List[int]]: self.result = [] self.solution(0,nums,[]) return self.result def solution(self, depth : int, nums : List[int], temp : List[int]): if depth == len(nums): self.result.append(temp) return temp.append(nums[depth]) self.solution(depth+1,nums,temp[:]) temp.pop() self.solution(depth+1,nums,temp[:]) c++class Solution {public: void solution(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; vec,int depth,vector&amp;lt;int&amp;gt;&amp;amp; nums,vector&amp;lt;int&amp;gt; temp) { if(depth == nums.size()) { vec.push_back(temp); return; } temp.push_back(nums[depth]); solution(vec,depth+1,nums,temp); temp.pop_back(); solution(vec,depth+1,nums,temp); } vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; subsets(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result; vector&amp;lt;int&amp;gt; temp; solution(result,0,nums,temp); return result; }};6. 결과 및 후기, 개선점c++ 64% python 94%c++100% 코드는 for문 3개로 brute force하게 풀었는데.. 제가 더 느리다니..?" }, { "title": "HTTP - 7 HTTP 헤더 1(2)", "url": "/posts/HTTP08/", "categories": "HTTP, 김영한_모든 개발자를 위한 HTTP 웹 기본 지식", "tags": "HTTP", "date": "2021-03-11 13:12:00 +0900", "snippet": "해당 자료는 인프런 김영한 선생님의 모든 개발자를 위한 HTTP 웹 기본 지식 강의노트입니다.1. 헤더의 일반 정보헤더에 일반적으로 들어가는 정보는 다음과 같습니다. From : 유저 에이전트의 이메일 정보- Referer : 이전 웹페이지 주소 User-Agent : 유저 에이전트 애플리케이션 Server : 요청을 처리하는 오리진 서버의 소프트웨어 정보 Date : 메시지가 생성된 날짜이 모든 것은 간단한 예제를 통해 알 수 있습니다.From 일반적으로 잘 사용되지 않습니다. 검색 엔진 같은 곳에서 요청에서 주로 사용합니다. 크롤링에서 자기 홈페이지기를 긁지 말라는 용도로도 사용될 수 있다고 합니다.Referer 현재 요청된 페이지의 이전 웹페이지 주소 입니다. 요청에서 사용됩니다.만약 ‘구글’에서 ‘임창정’을 검색한다면 이전 웹페이지는 ‘구글’ 이므로 Referer는 구글이 나올 것입니다.Referer를 이용해서 유입 경로 분석이 가능합니다.User-Agent 클라이언트의 애플리케이션 정보 입니다. 위의 정보를 통해 어떤 브라우저, 어떤 환경에서 장애가 발생하는지 파악이 가능합니다. 제 컴퓨터 환경인 윈도우 10과 크롬 버전이 나옵니다.Sever요청을 처리하는 ORIGIN 서버의 소프트웨어 정보입니다.클라이언트가 요청을 할 때 많은 프록시 서버를 거쳐 ORIGIN 서버에 도달하게 되는데 그 ORIGIN 서버의 정보입니다.응답에서 사용되므로 Response Header에 있습니다. server:gwsDate메시지가 발생한 날짜와 시간으로 응답에서 사용합니다. Date: Tue, 20 Nov 2020 08:12:31 GMT2. 특별한 정보 Host : 요청한 호스트 정보(도메인) Location : 페이지 리다이렉션 Allow : 허용 가능한 HTTP 메서드 Retry-After : 유저 에이전트가 다음 요청을 하기까지 기다려야하는 시간HostHost는 헤더에 필수적으로 포함되어야 합니다.요청에서 사용하고 존재의 이유는 하나의 서버가 여러 도메인을 처리해야할 때입니다.서버에서는 가상호스팅을 통해 여러 도메인을 가질 수 있습니다. 111.111.111.1 이라는 서버에서 aaa.com, bbb.com, ccc.com 이라는 도메인을 가졌다고 가정합니다. Client에서 ‘GET /hello HTTP/1.1’ 이라는 요청을 보내면 서버에 도착했을 때 aaa.com인지 bbb.com 인지 ccc.com 인지 모르기 때문에 호스트정보를 통해 구분해야합니다. 때문에 요청정보는 다음과 같이 수정되어야 합니다. GET /hello HTTP/1.1Host:aaa.com Location저번 포스팅의 응답코드 3xx에서 설명한 내용들 입니다.3xx 응답의 결과에 Location 헤더가 있으면, Location 위치로 자동 이동(리다이렉트) 합니다.Allow405(Method Not Allowed)에서 응답에 포함해야합니다. Allow:GET,HEAD,PUT위와 같은 양식을 갖습니다. 즉 POST나 DELETE 요청이 들어오면 위와같은 헤더를 포함하며 405 페이지를 리턴합니다.Retry-After503(Service Unavailable) : 서비스가 언제까지 불능인지 알려줄 수 있음.에서 사용합니다. Retry-After:Fri, 31 Nov 2020 20:20:20 GMT처럼 날짜로 표기할 수도 있고 초 단위로 표기할 수도 있습니다.하지만 서비스가 언제까지 불능인지 예측하기 어려우므로 잘 사용되지 않습니다.3. 인증 Authorization : 클라이언트 인증 정보를 서버에 전달 WWW-Authenticate: 리소스 접근시 필요한 인증 방법 정의Authorization 의 경우는 oauth 등 인증방식에 따라 값이 다릅니다.WWW-Authenticate는 401 Unauthorized 응답과 함께 사용되어 사용자에게 인증방식을 알려줍니다. WWW-Authenticate : Newauth realm=”apps”, type =1, title = “Login to &quot;apps&quot;”, Basic realm=”simple”4. 쿠키 Set-Cookie : 서버에서 클라이언트로 쿠키 전달(응답) Cookie : 클라이언트가 서버에서 받은 쿠키를 저장하고, HTTP 요청 시 서버로 전달어떤 사이트에 ‘강민석’으로 로그인해서 ‘안녕하세요. 강민석님’ 이라는 응답을 받고 싶은 경우가 있다고 가정합니다.만약 쿠키를 사용하지 않는다면 어떤 사이트에 로그인 한 뒤, ‘GET /weclome HTTP 1.1’과 같은 요청을 보낸다면 사용자에 대한 정보가 없기 때문에 응답을 ‘안녕하세요. ???님’ 처럼 사용자를 모르는 어떠한 메시지가 응답으로 올 것입니다.왜냐하면 HTTP는 기본적으로 Stateless 프로토콜이기에 요청을 주고받으면 연결이 끊어져, 로그인 했을 때 연결이 끊어졌을테니까요.하지만, 이러한 점을 개선하기 위해 요청에 사용자 정보를 넣는 방법도 있습니다. GET /welcome?user=강민석 HTTP/1.1이러한 방식을 사용하면 원하는 응답을 받을 수 있지만, 모든 요청에 로그인 정보를 포함해야하고, 민감한 정보를 요청에 적어야하는 부담이 있습니다.위의 문제점을 고치기 위해 생겨난 것이 쿠키입니다.먼저 로그인을 하면 서버에서 ‘Set-Cookie’ 라는 곳에 user=강민석 과 같은 로그인 정보를 담아 클라이언트에 보냅니다.클라이언트는 응답받은 Set-Cookie를 통해 클라이언트에 있는 Cookie에 값을 저장하고 요청을 보낼 때 마다 Cookie에서 값을 찾아서 서버에 보냅니다.쿠키의 양식은 다음과 같습니다.set-cookie : sessionId=abcd123; expires = Sat,26-Nov-2021-00:00:00 GMT;path=/; domain=.google.com; Secure쿠키 - 생명주기Expires, max-ageSet-Cookie : expires = Sat ~ GMT 이부분입니다. 만료일이 되면 쿠키가 삭제가 됩니다.Set-Cookie : max-age=3600 (3600초) 0이나 음수를 지정하면 쿠키 삭제세션 쿠키 : 만료 날짜를 생략하면 브라우저 종료 시까지만 유지영속 쿠키 : 만료 날짜를 입력하면 해당 날짜까지 유지쿠키 - 도메인Domainex) domain=example.org위에서 명시한 문서 기준 도메인 + 서브 도메인을 포함합니다.즉 example.org, dev.example.org에서도 쿠키 접근이 가능합니다.위의 문구를 생략하면 기준 도메인만 적용됩니다. dev.example.org에서는 쿠키에 접근을 못합니다.쿠키 - 경로pathex) path = /home이 경로를 포함한 하위 경로 페이지만 쿠키 접근이 가능합니다.일반적으로 path=/ 로 루트를 지정합니다.쿠키 - 보안Secure, HttpOnly, SameSite Secure 쿠키는 http, https를 구분하지 않고 전송하지만 Secure를 적용하면 https인 경우에만 전송합니다. HttpOnly XSS 공격 방지, 자바스크립트를 통한 쿠키값 해킹 가능성을 막습니다. HTTTP 전송에만 사용이 가능합니다. SameSite XSRF 공격 방지, 요청 도메인과 쿠키에 설정된 도메인이 같은 경우에만 쿠키를 전송합니다. " }, { "title": "leetcode(리트코드)3월11일 challenge322-Coin Change", "url": "/posts/leetcode_Coin_Change/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-03-11 06:00:00 +0900", "snippet": "leetcode March 11일 - Coin Change 문제입니다.1. 문제https://leetcode.com/problems/coin-change/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.3월 11일자 챌린지 문제입니다.4. 문제 해석 대표적인 DP문제입니다. 주어진 coins을 최소한 사용하여 amount를 만들어야합니다. 만들 수 없으면 -1을 리턴합니다.5. codepythonclass Solution: def coinChange(self, coins: List[int], amount: int) -&amp;gt; int: coins.sort() dp = [987654] * (amount+1) dp[0] = 0 for i in range(1,amount+1): for j in range(len(coins)): if coins[j] &amp;lt;= i: dp[i] = min(dp[i],dp[i-coins[j]]+1) return -1 if dp[amount] == 987654 else dp[amount]c++class Solution {public: int coinChange(vector&amp;lt;int&amp;gt;&amp;amp; coins, int amount) { sort(coins.begin(),coins.end()); int* dp = new int[amount+1]; dp[0]=0; for(int i =1;i&amp;lt;amount+1;++i) dp[i]= 987654; for(int i =1;i&amp;lt;=amount; ++i) { for(int j = 0; j&amp;lt;coins.size();++j) { if(coins[j]&amp;lt;=i) dp[i] = min(dp[i], dp[i -coins[j]] +1 ); } } return dp[amount] == 987654 ? -1 : dp[amount]; }};6. 결과 및 후기, 개선점c++ 94% python 40%python 개선한 코드들이 너무 보기 어려워서 추가하지 않겠습니다." }, { "title": "leetcode(리트코드)79-Search Word", "url": "/posts/leetcode_Search_Word/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Like", "date": "2021-03-11 02:00:00 +0900", "snippet": "leetcode 79 - Search Word 문제입니다.1. 문제https://leetcode.com/problems/word-search/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked 문제입니다.4. 문제 해석 board에 있는 문자를 연결하여 주어진 문자열을 만들 수 있는지 확인합니다. string의 제한이 클 수도 있고 board의 크기도 거의 무제한일 수 있으므로 이 부분에 유의해야합니다. c++은 제가 작성한 코드지만, board의 크기를 지정해버려서 좋은 코드가 아닙니다. python으로 옮기기에 비효율적이라 python은 다른사람들의 코드를 긁어왔습니다.5. codepythonclass Solution: def exist(self, board, word): if not board: return False for i in xrange(len(board)): for j in xrange(len(board[0])): if self.dfs(board, i, j, word): return True return False# check whether can find word, start at (i,j) position def dfs(self, board, i, j, word): if len(word) == 0: # all the characters are checked return True if i&amp;lt;0 or i&amp;gt;=len(board) or j&amp;lt;0 or j&amp;gt;=len(board[0]) or word[0]!=board[i][j]: return False tmp = board[i][j] # first character is found, check the remaining part board[i][j] = &quot;#&quot; # avoid visit agian # check whether can find &quot;word&quot; along one direction res = self.dfs(board, i+1, j, word[1:]) or self.dfs(board, i-1, j, word[1:]) \\ or self.dfs(board, i, j+1, word[1:]) or self.dfs(board, i, j-1, word[1:]) board[i][j] = tmp return res c++int dx[4] = {-1,0,1,0};int dy[4] = {0,-1,0,1};bool v[200][200] ={0,};class Solution {public: bool DFS(int x,int y,vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; board,int m,int n,string word,int depth) { if(depth == word.size()-1 ) { if(board[x][y] == word[depth]) return true; else return false; } for(int k = 0;k&amp;lt;4;++k) { int newX = x + dx[k]; int newY = y + dy[k]; if(0&amp;lt;=newX &amp;amp;&amp;amp; newX&amp;lt;m &amp;amp;&amp;amp; 0&amp;lt;=newY &amp;amp;&amp;amp; newY&amp;lt;n &amp;amp;&amp;amp; board[newX][newY] == word[depth+1] &amp;amp;&amp;amp; !v[newX][newY]) { //cout&amp;lt;&amp;lt;newX&amp;lt;&amp;lt;newY&amp;lt;&amp;lt;board[newX][newY]&amp;lt;&amp;lt;&quot; &quot;&amp;lt;&amp;lt;depth&amp;lt;&amp;lt;&#39;\\n&#39;; v[newX][newY] = true; if(DFS(newX,newY,board,m,n,word,depth+1)) return true; v[newX][newY]=false; } } return false; } bool exist(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; board, string word) { //DFS int row = board.size(); int col = board[0].size(); if(row * col &amp;lt; word.size()) return false; for(size_t i = 0;i&amp;lt;row;++i) { for(size_t j = 0 ; j&amp;lt;col;++j) { memset(v,false,sizeof(v)); if(board[i][j] == word[0]) { v[i][j]=true; if(DFS(i,j,board,row,col,word,0)) return true; } } } return false; }};6. 결과 및 후기, 개선점c++ 40% python 5%..?c++ 100% 12ms codeclass Solution {public: bool exist(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; board, string word) { if(board.empty()) return false; h = board.size(); w = board[0].size(); for(int i = 0; i&amp;lt;h; ++i) { for(int j = 0; j&amp;lt;w; ++j) if(search(board, word, 0, i, j)) return true; } return false; }private: int w, h; bool search(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; board, string&amp;amp; word, int d, int i, int j) { if(i&amp;lt;0 || j&amp;lt;0 || i&amp;gt;=h || j&amp;gt;=w || board[i][j]!=word[d]) return false; if(d == word.size()-1) return true; char cur = board[i][j]; board[i][j] = &#39;0&#39;; bool found = search(board, word, d+1, i+1, j) || search(board, word, d+1, i-1, j) || search(board, word, d+1, i, j+1) || search(board, word, d+1, i, j-1); board[i][j] = cur; return found; }};방문처리를 임시 값인 ‘0’로 대체하여 풀었고 로직은 비슷합니다.." }, { "title": "leetcode(리트코드)101-Symmetric Tree", "url": "/posts/leetcode_Symmetric_Tree/", "categories": "leetcode, Eazy", "tags": "leetcode, Top100Like", "date": "2021-03-11 01:00:00 +0900", "snippet": "leetcode 101 - Symmetric Tree 문제입니다.1. 문제https://leetcode.com/problems/symmetric-tree/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.leetcode Top 100 Liked 문제입니다.4. 문제 해석 트리가 대칭인지를 판단합니다. 대칭(모양이 데칼코마니이고 값도 같아야합니다.)5. codepython# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def isSymmetric(self, root: TreeNode) -&amp;gt; bool: def test(leftP : TreeNode, rightP : TreeNode) -&amp;gt; bool: if leftP == None and rightP == None : return True elif leftP == None or rightP == None : return False return (leftP.val == rightP.val) and test(leftP.left,rightP.right) and test(leftP.right,rightP.left) return test(root.left,root.right)c++/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: bool test(TreeNode* leftP, TreeNode* rightP) { if(leftP==nullptr &amp;amp;&amp;amp; rightP==nullptr) return true; else if(leftP==nullptr || rightP==nullptr) return false; return (leftP-&amp;gt;val == rightP-&amp;gt;val) &amp;amp;&amp;amp;test(leftP-&amp;gt;left,rightP-&amp;gt;right) &amp;amp;&amp;amp; test(leftP-&amp;gt;right,rightP-&amp;gt;left); } bool isSymmetric(TreeNode* root) { return test(root-&amp;gt;left,root-&amp;gt;right); }};6. 결과 및 후기, 개선점c++ 84% python 58%python 12ms 100% code# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def isSymmetric(self, root: TreeNode) -&amp;gt; bool: def DFS(r1, r2): if not r1 and not r2: return True if bool(r1) != bool(r2): return False if r1.val != r2.val: return False left = DFS(r1.left, r2.right) right = DFS(r1.right, r2.left) return left and right return DFS(root, root)로직은 같은데 어디서 속도차이가 나는지 잘 모르겠습니다." }, { "title": "leetcode(리트코드)3월10일 challenge12-Integer to Roman", "url": "/posts/leetcode_Integer_to_Roman/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-03-10 09:00:00 +0900", "snippet": "leetcode March 10일 - Integer to Roman 문제입니다.1. 문제https://leetcode.com/problems/integer-to-roman/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.3월 10일자 챌린지 문제입니다.4. 문제 해석 Bad가 더 많은 좋지 않은 문제입니다. 이유는 하드코딩식으로 풀어야합니다. 심지어 시간이 빠른 코드도 하드코딩식으로 풀었습니다. 위의 이유에서 python으로는 풀지 않았습니다.5. codec++class Solution {public: string intToRoman(int num) { string temp =&quot;&quot;; while(num!=0) { if(num&amp;gt;=1000) { num-=1000; temp+=&#39;M&#39;; } else if(num&amp;gt;=900) { num-=900; temp+=&quot;CM&quot;; } else if(num&amp;gt;=500) { num-=500; temp+=&#39;D&#39;; } else if(num&amp;gt;=400) { num-=400; temp+=&quot;CD&quot;; } else if(num&amp;gt;=100) { num-=100; temp+=&#39;C&#39;; } else if(num&amp;gt;=90) { num-=90; temp+=&quot;XC&quot;; } else if(num&amp;gt;=50) { num-=50; temp+=&#39;L&#39;; } else if(num&amp;gt;=40) { num-=40; temp+=&quot;XL&quot;; } else if(num&amp;gt;=10) { num-=10; temp+=&#39;X&#39;; } else if(num&amp;gt;=9) { num-=9; temp+=&quot;IX&quot;; } else if(num&amp;gt;=5) { num-=5; temp+=&#39;V&#39;; } else if(num&amp;gt;=4) { num-=4; temp+=&quot;IV&quot;; } else if(num&amp;gt;0) { num-=1; temp+=&#39;I&#39;; } } return temp; }};6. 결과 및 후기, 개선점" }, { "title": "leetcode(리트코드)42-Trapping Rain Water", "url": "/posts/leetcode_Trapping_Rain_Water/", "categories": "leetcode, Hard", "tags": "leetcode, Top100Like", "date": "2021-03-10 05:00:00 +0900", "snippet": "leetcode 42 - Trapping Rain Water 문제입니다.1. 문제https://leetcode.com/problems/trapping-rain-water/2. Input , Output3. 분류 및 난이도Hard 난이도 문제입니다.leetcode Top 100 Liked 문제입니다.4. 문제 해석 black으로 되어진 막대기들이 있습니다. 물이채워질 때 넓이를 구하세요. 한 칸의 넓이는 1입니다. 1시간 정도 풀다가 Discuss를 봤습니다. left와 right를 관리하여 푸는 방식인데, 코드 자체는 어렵지 않으나 이해하면 놀라운?.. 코드입니다..5. codepythonclass Solution: def trap(self, height: List[int]) -&amp;gt; int: left = 0 right = len(height)-1 maxleft = 0 maxright = 0 result = 0 while left &amp;lt;= right: if height[left] &amp;lt;= height[right] : if maxleft &amp;lt;= height[left] : maxleft = height[left] else: result += maxleft - height[left] left+=1 else : if maxright &amp;lt;= height[right] : maxright = height[right] else: result += maxright - height[right] right-=1 return resultc++class Solution {public: int trap(vector&amp;lt;int&amp;gt;&amp;amp; height) { int left = 0; int right = height.size()-1; int result = 0; int maxleft = 0; int maxright = 0; while(left&amp;lt;=right) { if(height[left]&amp;lt;=height[right]) { if(height[left]&amp;gt;=maxleft) maxleft = height[left]; else result += maxleft - height[left]; ++left; } else { if(height[right]&amp;gt;=maxright) maxright = height[right]; else result += maxright - height[right]; --right; } } return result; }};6. 결과 및 후기, 개선점Discuss를 봤으므로 올리지 않습니다." }, { "title": "leetcode(리트코드)75-Sort Colors", "url": "/posts/leetcode_Sort_Colors/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Like", "date": "2021-03-10 03:00:00 +0900", "snippet": "leetcode 75 - Sort Colors 문제입니다.1. 문제https://leetcode.com/problems/sort-colors/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked 문제입니다.4. 문제 해석 라이브러리를 사용하지 않고 정렬합니다. 기수정렬 비슷하게 풀었습니다.5. codepythonclass Solution: def sortColors(self, nums: List[int]) -&amp;gt; None: ns = len(nums) countz = [0] * 3 for i in range(ns): countz[nums[i]]+=1 index = 0 for i in range(ns): while index &amp;lt; 3 and countz[index]==0: index+=1 nums[i] = index countz[index]-=1c++class Solution {public: void sortColors(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int ns = nums.size(); int countz[3] = {0,0,0}; for(size_t i =0;i&amp;lt;ns;++i) { countz[nums[i]]++; } int index =0; for(size_t i =0 ;i&amp;lt;ns;++i) { while(index&amp;lt;3 &amp;amp;&amp;amp; countz[index]==0) ++index; nums[i] = index; countz[index]--; } }};6. 결과 및 후기, 개선점python 77%, c++ 100%python 100% 12ms codeclass Solution: def sortColors(self, nums: List[int]) -&amp;gt; None: i=0 j=len(nums)-1 k=0 while k&amp;lt;=j: if nums[k]==2: t=nums[k] nums[k]=nums[j] nums[j]=t j-=1 elif k!=i and nums[k]==0: t=nums[k] nums[k]=nums[i] nums[i]=t i+=1 else: k+=1 i는 0을 관리하고 j 는 끝에서 2와 바꿔줄 인덱스값을 관리합니다.인덱스의 값이 1인 경우는 elif문에서 swap을 하면서 바꿔버립니다." }, { "title": "leetcode(리트코드)64-Minimum Path Sum", "url": "/posts/leetcode_Minimum_Path_Sum/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Like", "date": "2021-03-10 02:00:00 +0900", "snippet": "leetcode 64 - Minimum Path Sum 문제입니다.1. 문제https://leetcode.com/problems/minimum-path-sum/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked 문제입니다.4. 문제 해석 숫자가 들어있는 2차원 벡터가 들어옵니다. 왼쪽 맨 위에서 오른쪽 맨 아래에 도달할 때 숫자를 더합니다. 숫자가 최소가 되도록 경로를 짰을 때 숫자를 리턴하세요.5. codepythonclass Solution: def minPathSum(self, grid: List[List[int]]) -&amp;gt; int: row = len(grid) col = len(grid[0]) for i in range(1,row): grid[i][0] += grid[i-1][0] for j in range(1,col): grid[0][j] += grid[0][j-1] for i in range(1,row) : for j in range(1,col): grid[i][j] += min(grid[i-1][j],grid[i][j-1]) return grid[row-1][col-1]c++class Solution {public: int minPathSum(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid) { int row = grid.size(); int col = grid[0].size(); for(size_t i = 1;i&amp;lt;row; ++i) grid[i][0] += grid[i-1][0]; for(size_t j = 1; j&amp;lt;col; ++j) grid[0][j] += grid[0][j-1]; int i = 1; int j = 1; for(; i&amp;lt;row;++i) { for(j=1; j&amp;lt;col; ++j) grid[i][j] += (min(grid[i-1][j], grid[i][j-1])); } return grid[row-1][col-1]; }};6. 결과 및 후기, 개선점python 92%, c++ 96%" }, { "title": "leetcode(리트코드)45-Jump Game II", "url": "/posts/leetcode_Jump_Game_II/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Like", "date": "2021-03-10 01:00:00 +0900", "snippet": "leetcode 45 - Jump Game II 문제입니다.1. 문제https://leetcode.com/problems/jump-game-ii/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked 문제입니다.4. 문제 해석 배열에 들어있는 숫자만큼 최대로 점프할 수 있습니다. 점프를 많이하지 않고 끝에 도달하였을 때 점프한 횟수를 리턴하세요.5. codepythonclass Solution: def jump(self, nums: List[int]) -&amp;gt; int: counting = [0] * len(nums) for i in range(len(nums)): for j in range(1,nums[i]+1): if i + j &amp;gt;= len(nums): continue if counting[i+j] == 0 : counting[i+j] = counting[i]+1 return counting[len(nums)-1]c++class Solution {public: int jump(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;int&amp;gt; v(nums.size(),0); v[0] = 0; for(size_t i =0;i&amp;lt;nums.size()-1;++i) { for(int j = 1;j&amp;lt;=nums[i] ; ++j) { if(i+j &amp;gt;=nums.size()) continue; if(v[i+j]==0) v[i+j] = v[i]+1; } } return v[v.size()-1]; }};6. 결과 및 후기, 개선점python, c++ 100%" }, { "title": "leetcode(리트코드)3월09일 challenge623-Add One Row to Tree", "url": "/posts/leetcode_Add_One_Row_to_Tree/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-03-09 13:00:00 +0900", "snippet": "leetcode March 09일 - Add one Row to Tree문제입니다.1. 문제https://leetcode.com/problems/add-one-row-to-tree/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.3월 09일자 챌린지 문제입니다.4. 문제 해석 Tree와 v와 d가 인풋으로 들어옵니다. d의 깊이에서 v의 값을 가진 노드들을 집어 넣어야합니다. d깊이에 넣어줘야하므로 d-1를 감지해야합니다. d가 1로 들어올 경우도 생각해야합니다.5. codepython# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def addOneRow(self, root: TreeNode, v: int, d: int) -&amp;gt; TreeNode: def order(root : TreeNode, v : int , curr : int, d :int) : if root != None : if d-1 == curr: if root.left != None : newNode = TreeNode(v) newNode.left = root.left root.left = newNode else : newNode = TreeNode(v) root.left = newNode if root.right != None : newNode = TreeNode(v) newNode.right = root.right root.right = newNode else : newNode = TreeNode(v) root.right = newNode order(root.left,v,curr+1,d) order(root.right,v,curr+1,d) if d == 1: newNode = TreeNode(v) newNode.left = root return newNode else : order(root,v,1,d) return rootc++ /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: void order(TreeNode* root, int v,int cur,int d) { if(root!=nullptr) { if(d-1 ==cur) { if(root-&amp;gt;left!=nullptr) { TreeNode* newNode =new TreeNode(v); newNode-&amp;gt;left = root-&amp;gt;left; root-&amp;gt;left = newNode; } else { TreeNode* newNode= new TreeNode(v); root-&amp;gt;left = newNode; } if(root-&amp;gt;right!=nullptr) { TreeNode* newNode =new TreeNode(v); newNode-&amp;gt;right = root-&amp;gt;right; root-&amp;gt;right = newNode; } else { TreeNode* newNode = new TreeNode(v); root-&amp;gt;right = newNode; } } order(root-&amp;gt;left,v,cur+1,d); order(root-&amp;gt;right,v,cur+1,d); } } TreeNode* addOneRow(TreeNode* root, int v, int d) { if(d==1) { TreeNode* newNode = new TreeNode(v); newNode -&amp;gt;left = root; return newNode; } else order(root,v,1,d); return root; }};6. 결과 및 후기, 개선점c++ 90%8ms 100% code/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: TreeNode* addOneRow(TreeNode* root, int v, int d) { if (! root) return NULL; bool level_done = false; if (d == 1) { TreeNode *node = new TreeNode(v, root, NULL); return node; } int level = 1; queue &amp;lt;TreeNode *&amp;gt;q; q.push(root); while (!q.empty()) { int sz = q.size(); for (int i = 0; i &amp;lt; sz; i ++) { TreeNode *node = q.front(); q.pop(); if(level == d - 1) { TreeNode *node1 = new TreeNode(v, node-&amp;gt;left, NULL); TreeNode *node2 = new TreeNode(v, NULL, node-&amp;gt;right); node-&amp;gt;left = node1; node-&amp;gt;right = node2; level_done = true; //return root; } else { if (node-&amp;gt;left) q.push(node-&amp;gt;left); if (node-&amp;gt;right) q.push(node-&amp;gt;right); } } if (level_done) return root; level += 1; } return root; }};BFS를 이용해서 level를 찾고 level-1에서 새로운 노드들을 넣는 작업을 수행합니다." }, { "title": "leetcode(리트코드)62-Unique Paths", "url": "/posts/leetcode_Unique_Paths/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-03-09 07:00:00 +0900", "snippet": "leetcode 62 - Unique Paths 문제입니다.1. 문제https://leetcode.com/problems/unique-paths/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked 문제입니다.4. 문제 해석 MAP의 길이가 주어집니다. MAP의 끝에 도달하는 경우의 수를 리턴합니다. 옛날 수학시간에 배운 길찾기 (위에서 오는 경우의 수 + 왼쪽에서 오는 경우의 수)를 통해 풀었습니다.5. codepythonclass Solution: def uniquePaths(self, m: int, n: int) -&amp;gt; int: v = [] for i in range(m) : v.append([]) for j in range(n) : v[i].append([]) for i in range(m): for j in range(n): if i == 0 or j ==0 : v[i][j] = 1 else : v[i][j] = v[i-1][j] + v[i][j-1] return v[m-1][n-1]c++class Solution {public: void cal(int m,int n,int** map) { for(int x =1;x &amp;lt; m ;++x) { for(int y = 1; y&amp;lt;n;++y) { map[x][y] = map[x-1][y] + map[x][y-1]; } } } int uniquePaths(int m, int n) { int** map = new int*[m]; for(int i =0;i&amp;lt;m;++i) map[i] = new int[n]; for(int i=0;i&amp;lt;m;++i) { for(int j =0;j&amp;lt;n;++j) { map[i][j]=1; } } cal(m,n,map); int result = map[m-1][n-1]; for(int i =0;i&amp;lt;m;++i) { delete []map[i]; } delete[] map; return result; }};6. 결과 및 후기, 개선점c++ 100%python100% 12ms codeclass Solution: def __init__(self): self.dp = {} def uniquePaths(self, m: int, n: int) -&amp;gt; int: #이미 돌았으면 값을 리턴 if (m, n) in self.dp: return self.dp[(m, n)] if m == 1 or n == 1: return 1 #재귀문 ans = self.uniquePaths(m, n-1) + self.uniquePaths(m-1, n) self.dp[(m, n)] = ans return ans" }, { "title": "leetcode(리트코드)1779-Find Nearest Point That Has the Same X or Y Coordinate", "url": "/posts/leetcode_Find_Nearest_Point_That_Has_the_Same_X_or_Y_Coordinate/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-03-09 05:00:00 +0900", "snippet": "leetcode 1779 - Find Nearest Point That Has the Same X or Y Coordinate 문제입니다.1. 문제https://leetcode.com/problems/find-nearest-point-that-has-the-same-x-or-y-coordinate/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.leetcode 대회에서 나왔던 문제입니다.4. 문제 해석 대회에서 풀 당시에는 해석이 안되어서.. 특히 ‘smallest index’ 저 부분이 x좌표와 y좌표중 작은 값을 말하는 줄 알았는데 points의 인덱스를 말하는 것 이었습니다. 그래서 못품.. 하필 [2,4] 와 [4,4]에서 2라는 숫자때문에 더 헷갈렸습니다. 아무튼 의미를 깨닫고는 빠르게 풀 수 있었습니다. coordinate가 아닌것은 continue로 거르고 거리가 0인(동일한 점)을 찾으면 바로 리턴합니다.5. codepythonclass Solution: def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -&amp;gt; int: ans = -1 mind = 987654321 for i in range(len(points)) : if mind == 0 : break x_d = x - points[i][0] y_d = y - points[i][1] if x_d != 0 and y_d !=0: continue distance = abs(x_d) + abs(y_d) if distance &amp;lt; mind: ans = i mind = distance return ansc++class Solution {public: int nearestValidPoint(int x, int y, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; points) { int ans = -1; int mind = INT_MAX; for(size_t i =0;i&amp;lt;points.size() &amp;amp;&amp;amp; mind != 0;++i) { int x_d = x - points[i][0]; int y_d = y - points[i][1]; if(x_d != 0 &amp;amp;&amp;amp; y_d !=0) { continue; } int distance = abs(x_d) + abs(y_d); if(distance &amp;lt; mind) { ans = i; mind = distance; } } return ans; }};6. 결과 및 후기, 개선점" }, { "title": "leetcode(리트코드)56-Merge Intervals", "url": "/posts/leetcode_Merge_Intervals/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-03-09 03:00:00 +0900", "snippet": "leetcode 56 - Merge Intervals 문제입니다.1. 문제https://leetcode.com/problems/merge-intervals/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked 문제입니다.4. 문제 해석 구간의 시작과 끝이 주어집니다. 겹치는 구간은 합쳐버려서 구간을 다시 리턴합니다.5. codepythonclass Solution: def merge(self, intervals: List[List[int]]) -&amp;gt; List[List[int]]: result =[] intervals.sort() index = 0 while index &amp;lt; len(intervals): temp = [] start = intervals[index][0] end = intervals[index][1] j = index+1 while j &amp;lt; len(intervals) and end &amp;gt;= intervals[j][0] : end = max(intervals[j][1],end) index = j j += 1 temp.append(start) temp.append(end) result.append(temp) index+=1 return result c++class Solution {public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; merge(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; intervals) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result; sort(intervals.begin(),intervals.end()); for(int i = 0; i&amp;lt;intervals.size(); ++i) { vector&amp;lt;int&amp;gt; temp; int start = intervals[i][0]; int end = intervals[i][1]; int j = i+1; while(j&amp;lt;intervals.size() &amp;amp;&amp;amp; end &amp;gt;= intervals[j][0]) { end = max(intervals[j][1],end); i=j; ++j; } temp.push_back(start); temp.push_back(end); result.push_back(temp); } return result; }};6. 결과 및 후기, 개선점94%" }, { "title": "leetcode(리트코드)32-Longest Valid Parentheses", "url": "/posts/leetcode_Longest_Valid_Parentheses/", "categories": "leetcode, Hard", "tags": "leetcode", "date": "2021-03-09 02:00:00 +0900", "snippet": "leetcode 32 - Longest Valid Parentheses 문제입니다.1. 문제https://leetcode.com/problems/longest-valid-parentheses/2. Input , Output3. 분류 및 난이도Hard 난이도 문제입니다.leetcode Top 100 Liked 문제입니다.4. 문제 해석 ”()”짝을 가진 가장 긴 길이의 substring의 길이를 반환합니다. 2시간 정도 잡고 있다가 안 풀려서 Discuss를 참조하였습니다.5. codepythonclass Solution: def longestValidParentheses(self, s: str) -&amp;gt; int: stk = [] stk.append(-1) ans = 0 for i in range(len(s)): if s[i] == &#39;(&#39; : stk.append(i) else: stk.pop() if len(stk)==0 : stk.append(i) else: ans = max(ans,i - stk[-1]) return ansc++class Solution {public: int longestValidParentheses(string s) { stack&amp;lt;int&amp;gt; stk; stk.push(-1); int ans = 0; for (int i = 0; i &amp;lt; s.size(); i++) { if (s[i] == &#39;(&#39;) { stk.push(i); } else { stk.pop(); if (stk.empty()) { stk.push(i); } else { ans = max(ans, i - stk.top()); } } } return ans; }};6. 결과 및 후기, 개선점" }, { "title": "leetcode(리트코드)3월08일 challenge1332-Remove Palindromic Subsequences", "url": "/posts/leetcode_Remove_Palindromic_Subsequences/", "categories": "leetcode, Eazy", "tags": "leetcode, AlgorithmStudy", "date": "2021-03-09 01:00:00 +0900", "snippet": "leetcode March 08일 - Remove Palindromic Subsequences 문제입니다.1. 문제https://leetcode.com/problems/remove-palindromic-subsequences/2. Input , Output3. 분류 및 난이도Eazy 난이도입니다.3월 08일자 챌린지 문제입니다.4. 문제 해석 좋은 문제는 아닌 것 같습니다. Palindromic이면 1을 리턴 아니면 2를 리턴 문자열의 크기가 0인 경우 0을 리턴하는 문제입니다.5. codec++class Solution {public: int removePalindromeSub(string s) { if(s.size()==0) return 0; string reverseS = s; std::reverse(reverseS.begin(),reverseS.end()); if(s == reverseS) return 1; return 2; }};pythonclass Solution: def removePalindromeSub(self, s: str) -&amp;gt; int: if(len(s)==0): return 0 reverseS = s[::-1] if(reverseS == s): return 1 else : return 26. 결과 및 후기, 개선점" }, { "title": "leetcode(리트코드)3월07일 challenge706-Design HashMap", "url": "/posts/leetcode_Design_HashMap/", "categories": "leetcode, Eazy", "tags": "leetcode, AlgorithmStudy", "date": "2021-03-08 01:00:00 +0900", "snippet": "leetcode March 07일 - Design HashMap 문제입니다.1. 문제https://leetcode.com/problems/design-hashmap/2. Input , Output3. 분류 및 난이도Eazy 난이도입니다.3월 07일자 챌린지 문제입니다.4. 문제 해석 생각보다 어려웠습니다. Discuss를 참고하였습니다.5. codec++class MyHashMap { vector&amp;lt;list&amp;lt;pair&amp;lt;int,int&amp;gt;&amp;gt;&amp;gt; vec; size_t vecSize = 10000; public: /** Initialize your data structure here. */ MyHashMap() { vec.resize(vecSize); } /** value will always be non-negative. */ void put(int key, int value) { list&amp;lt;pair&amp;lt;int,int&amp;gt;&amp;gt; &amp;amp;list = vec[key % vecSize]; for (auto &amp;amp; val : list) { if (val.first == key) { val.second = value; return; } } list.emplace_back(key, value); } /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */ int get(int key) { const auto &amp;amp;list = vec[key % vecSize]; if (list.empty()) { return -1; } for (const auto &amp;amp; val : list) { if (val.first == key) { return val.second; } } return -1; } /** Removes the mapping of the specified value key if this map contains a mapping for the key */ void remove(int key) { list&amp;lt;pair&amp;lt;int,int&amp;gt;&amp;gt; &amp;amp;pairs = vec[key%vecSize]; for(auto i=pairs.begin(); i!= pairs.end(); i++) { if(i-&amp;gt;first==key) { pairs.erase(i); return; } } }};/** * Your MyHashMap object will be instantiated and called as such: * MyHashMap* obj = new MyHashMap(); * obj-&amp;gt;put(key,value); * int param_2 = obj-&amp;gt;get(key); * obj-&amp;gt;remove(key); */python# using just arrays, direct access table# using linked list for chainingclass ListNode: def __init__(self, key, val): self.pair = (key, val) self.next = Noneclass MyHashMap: def __init__(self): &quot;&quot;&quot; Initialize your data structure here. &quot;&quot;&quot; self.m = 1000; self.h = [None]*self.m def put(self, key, value): &quot;&quot;&quot; value will always be non-negative. :type key: int :type value: int :rtype: void &quot;&quot;&quot; index = key % self.m if self.h[index] == None: self.h[index] = ListNode(key, value) else: cur = self.h[index] while True: if cur.pair[0] == key: cur.pair = (key, value) #update return if cur.next == None: break cur = cur.next cur.next = ListNode(key, value) def get(self, key): &quot;&quot;&quot; Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key :type key: int :rtype: int &quot;&quot;&quot; index = key % self.m cur = self.h[index] while cur: if cur.pair[0] == key: return cur.pair[1] else: cur = cur.next return -1 def remove(self, key): &quot;&quot;&quot; Removes the mapping of the specified value key if this map contains a mapping for the key :type key: int :rtype: void &quot;&quot;&quot; index = key % self.m cur = prev = self.h[index] if not cur: return if cur.pair[0] == key: self.h[index] = cur.next else: cur = cur.next while cur: if cur.pair[0] == key: prev.next = cur.next break else: cur, prev = cur.next, prev.next # Your MyHashMap object will be instantiated and called as such:# obj = MyHashMap()# obj.put(key,value)# param_2 = obj.get(key)# obj.remove(key)6. 결과 및 후기, 개선점Discuss를 봤으므로 올리지 않습니다." }, { "title": "leetcode(리트코드)3월06일 challenge820-Short Encoding of Words", "url": "/posts/leetcode_Short_Encoding_of_Words/", "categories": "leetcode, Medium", "tags": "leetcode, AlgorithmStudy", "date": "2021-03-07 01:00:00 +0900", "snippet": "leetcode March 06일 - Short Encoding of Words 문제입니다.1. 문제https://leetcode.com/problems/short-encoding-of-words/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.3월 06일자 챌린지 문제입니다.4. 문제 해석 문제 해석을 못 했습니다..그래서 discuss를 봤습니다.5. codeclass Solution {public: int minimumLengthEncoding(vector&amp;lt;string&amp;gt;&amp;amp; words) { unordered_set&amp;lt;string&amp;gt; s(words.begin(), words.end()); for (string w : s) for (int i = 1; i &amp;lt; w.size(); ++i) s.erase(w.substr(i)); int res = 0; for (string w : s) res += w.size() + 1; return res; }};6. 결과 및 후기, 개선점Discuss를 봤으므로 올리지 않습니다." }, { "title": "leetcode(리트코드)3월05일 challenge637-Average of Levels in Binary Tree", "url": "/posts/leetcode_Average_of_Levels_in_Binary_Tree/", "categories": "leetcode, Eazy", "tags": "leetcode, AlgorithmStudy", "date": "2021-03-06 01:00:00 +0900", "snippet": "leetcode March 05일 - Average of Levels in Binary Tree 문제입니다.1. 문제https://leetcode.com/problems/average-of-levels-in-binary-tree/2. Input , Output3. 분류 및 난이도eazy 난이도입니다.3월 05일자 챌린지 문제입니다.4. 문제 해석 트리에서 같은 레벨에 있는 값들에 대해 평균값을 벡터에 넣어 리턴합니다.5. codepython# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def averageOfLevels(self, root: TreeNode) -&amp;gt; List[float]: result = [] queue = deque([root]) while queue: sumnum = 0.0 sizenum = len(queue) for i in range (0,sizenum) : numb = queue.popleft() sumnum +=numb.val if (numb.left !=None): queue.append(numb.left) if (numb.right !=None) : queue.append(numb.right) result.append(sumnum/sizenum) return resultc++/* * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: vector&amp;lt;double&amp;gt; averageOfLevels(TreeNode* root) { vector&amp;lt;double&amp;gt; result; queue&amp;lt;TreeNode*&amp;gt; q; q.push(root); while(!q.empty()) { int x = q.size(); double sum = 0.0; for(int i = 0; i&amp;lt;x;++i) { TreeNode* numb = q.front(); q.pop(); sum += (numb-&amp;gt;val); if(numb-&amp;gt;left!=nullptr) q.push(numb-&amp;gt;left); if(numb-&amp;gt;right!=nullptr) q.push(numb-&amp;gt;right); } result.push_back(sum/x); } return result; }};6. 결과 및 후기, 개선점" }, { "title": "leetcode(리트코드)10-Regular Expression Matching", "url": "/posts/leetcode_Regular_Expression_Matching/", "categories": "leetcode, Hard", "tags": "leetcode", "date": "2021-03-05 01:00:00 +0900", "snippet": "leetcode 10 - Regular Expression Matching 문제입니다.1. 문제https://leetcode.com/problems/regular-expression-matching/2. Input , OutputConstraints: 0 &amp;lt;= s.length &amp;lt;= 20 0 &amp;lt;= p.length &amp;lt;= 30 s contains only lowercase English letters. p contains only lowercase English letters, ‘.’, and ‘’.It is guaranteed for each appearance of the character ‘’, there will be a previous valid character to match.3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Interviewd 문제입니다.4. 문제 해석 stoi()를 해주는 문제이지만.. 예외처리할 게 많습니다.5. codeclass Solution {public: int myAtoi(string s) { if(s[0]&amp;gt;96 &amp;amp;&amp;amp; s[0]&amp;lt;123 || s[0]==&#39;.&#39;) return 0; //맨 처음이 공백인 경우 공백이 아닐때까지 점프합니다. if(s[0]==&#39; &#39;) { int i = 0; while(i&amp;lt;s.size() &amp;amp;&amp;amp; s[0]==&#39; &#39;) { s = s.substr(1); } } int result; try { result = std::stoi(s); } //문자가 들어온 경우 catch(invalid_argument&amp;amp; e) { return 0; } //오버플로우, 언더플로우인 경우 catch(std::out_of_range&amp;amp; e) { if(s[0]==&#39;-&#39;) result = -2147483648; else result = 2147483647; } return result; }};6. 결과 및 후기, 개선점" }, { "title": "leetcode(리트코드)3월04일 challenge160-Intersection of Two Linked Lists", "url": "/posts/leetcode_Intersection_of_Two_Linked_Lists/", "categories": "leetcode, Eazy", "tags": "leetcode, AlgorithmStudy", "date": "2021-03-04 02:00:00 +0900", "snippet": "leetcode March 04일 - Intersection of Two Linked Lists 문제입니다.1. 문제https://leetcode.com/problems/intersection-of-two-linked-lists/2. Input , OutputNotes: The number of nodes of listA is in the m. The number of nodes of listB is in the n. 1 &amp;lt;= m, n &amp;lt;= 3 * 104 1 &amp;lt;= Node.val &amp;lt;= 105 1 &amp;lt;= skipA &amp;lt;= m 1 &amp;lt;= skipB &amp;lt;= n intersectVal is 0 if listA and listB do not intersect. intersectVal == listA[skipA + 1] == listB[skipB + 1] if listA and listB intersect.3. 분류 및 난이도eazy 난이도입니다.3월 04일자 챌린지 문제입니다.4. 문제 해석 두 개의 링크드 리스트에서 이어진 부분을 찾아야합니다.5. codec++/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { if(headA == nullptr || headB == nullptr) return 0; ListNode* a = headA; ListNode* b = headB; while(a!=b) { a = a == nullptr ? headB : a-&amp;gt;next; b = b == nullptr ? headA : b-&amp;gt;next; } return a; }};python# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&amp;gt; ListNode: if headA == None or headB == None : return None a = headA b = headB while a != b: a = headB if a == None else a.next b = headA if b == None else b.next return a6. 결과 및 후기, 개선점84%24ms 99% 코드int speedup = []() {ios::sync_with_stdio(0); cin.tie(0); return 0;}();class Solution {public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { ListNode *pA = headA, *pB = headB; while (pA != pB) { pA = pA ? pA-&amp;gt;next : headB; pB = pB ? pB-&amp;gt;next : headA; } return pA; }};입출력 향상 부분 말고는 다른 점이 없습니다." }, { "title": "leetcode(리트코드)3월03일 challenge268-Missing Number", "url": "/posts/leetcode_Missing_Number/", "categories": "leetcode, Eazy", "tags": "leetcode, AlgorithmStudy", "date": "2021-03-04 01:00:00 +0900", "snippet": "leetcode March 03일 - Missing Number 문제입니다.1. 문제https://leetcode.com/problems/missing-number/2. Input , OutputConstraints: n == nums.length 1 &amp;lt;= n &amp;lt;= 104 0 &amp;lt;= nums[i] &amp;lt;= n All the numbers of nums are unique.3. 분류 및 난이도eazy 난이도입니다.3월 03일자 챌린지 문제입니다.4. 문제 해석 0 ~ n의 만큼의 배열이 들어와야합니다. 한 숫자가 누락되었는데 그 숫자를 찾아야합니다.5. codec++class Solution {public: int missingNumber(vector&amp;lt;int&amp;gt;&amp;amp; nums) { sort(nums.begin(),nums.end()); for(int i =0;i&amp;lt;nums.size();++i) if(nums[i] != i) return i; return nums[nums.size()-1]+1; }};pythonclass Solution: def missingNumber(self, nums: List[int]) -&amp;gt; int: nums.sort() for i in range (0,len(nums)): if nums[i] != i : return i return nums[len(nums)-1]+1;6. 결과 및 후기, 개선점24ms 100% 코드class Solution {public: int missingNumber(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int sum = 0; for(auto num : nums) { sum += num; } int numsLength = nums.size(); int total = numsLength*(numsLength+1)/2; return total-sum; }};정렬이 없이 벡터의 모든 합을 더하고, 정상합에서 빼서 수를 찾습니다." }, { "title": "Baekjoon11724-연결요소 개수", "url": "/posts/baekjoon11724/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, BFS, AlgorithmStudy", "date": "2021-03-03 01:02:00 +0900", "snippet": "백준 사이트 11724- 연결요소 개수 문제입니다.1. 문제https://www.acmicpc.net/problem/117242. Input , Output3. 분류 및 난이도기초 BFS문제에서 결과값을 보존해야하는 변형 문제입니다.4. 생각한 것들 python으로 고치기 그냥 고치니까 시간초과가 뜹니다.5. codec++#include&amp;lt;iostream&amp;gt;#include&amp;lt;vector&amp;gt;#include&amp;lt;queue&amp;gt;using namespace std;bool check[1001] = { false, };vector&amp;lt;int&amp;gt;* vec;int bfs(int start){ if (check[start] == true) return 0; queue&amp;lt;int&amp;gt; q; q.push(start); check[start] = true; while (!q.empty()) { int x = q.front(); q.pop(); for (int i = 0; i &amp;lt; vec[x].size(); ++i) { int y = vec[x][i]; if (!check[y]) { q.push(y); check[y] = true; } } } return 1;}int main(){ int n, m; cin &amp;gt;&amp;gt; n&amp;gt;&amp;gt;m; vec = new vector&amp;lt;int&amp;gt;[n + 1]; for (int i = 0; i &amp;lt; m; ++i) { int u, v; cin &amp;gt;&amp;gt; u &amp;gt;&amp;gt; v; vec[u].push_back(v); vec[v].push_back(u); } int result = 0; for (int i = 1; i &amp;lt;= n; ++i) { result +=bfs(i); } cout &amp;lt;&amp;lt; result; delete[]vec;}pythonimport sys#BFSfrom collections import dequedef BFS(graph, root,visited): if(visited[root]==1): return 0 queue = deque([root]) visited[root]=1 while queue: n = queue.popleft() for i in range (len(graph[n])): y = graph[n][i] if(y != 0 and visited[y]==0): queue.append(y) visited[y]=1 return 1n,m = map(int,input().split())graph = []for i in range(n+1): line = [] graph.append(line)visited = [0] * (n+1) for i in range (0,m): first,second = map(int,input().split()) graph[first].append(second) graph[second].append(first) result = 0for i in range (0,n+1): visited[i]=0for i in range(1,n+1): result= result + BFS(graph,i,visited)print(result)6. 후기python이랑 c++ 실행속도 차이 너무 체감이..pypy3으로 제출해야겠다." }, { "title": "leetcode(리트코드)3월02일 challenge645-Set Mismatch", "url": "/posts/leetcode_Set_MisMatch/", "categories": "leetcode, Eazy", "tags": "leetcode, AlgorithmStudy", "date": "2021-03-03 01:00:00 +0900", "snippet": "leetcode March 02일 - Set Mismatch 문제입니다.1. 문제https://leetcode.com/problems/set-mismatch/2. Input , Output3. 분류 및 난이도eazy 난이도입니다.3월 02일자 챌린지 문제입니다.4. 문제 해석 0 ~ n의 만큼의 배열이 들어와야합니다. 한 숫자가 누락되었는데 그 숫자를 찾아야합니다.5. codec++c++class Solution {public: vector&amp;lt;int&amp;gt; findErrorNums(vector&amp;lt;int&amp;gt;&amp;amp; nums) { bool* countnum = new bool[nums.size()+1]; memset(countnum,false,sizeof(bool) * (nums.size()+1)); vector&amp;lt;int&amp;gt; result; for(size_t i=0;i&amp;lt;nums.size();++i) { if(countnum[nums[i]]) result.push_back(nums[i]); countnum[nums[i]]=true; } bool check =false; for(size_t i=1;i&amp;lt;nums.size()+1;++i) { if(!countnum[i]) { result.push_back(i); break; } } return result; }};pythonclass Solution: def findErrorNums(self, nums: List[int]) -&amp;gt; List[int]: countnum = [0] * (len(nums)+1) result = [] for i in range(len(nums)): if(countnum[nums[i]]): result.append(nums[i]) countnum[nums[i]]=1 check = 0 for i in range(1,len(nums)+1): if countnum[i] == 0: result.append(i) break return result 6. 결과 및 후기, 개선점95%" }, { "title": "leetcode(리트코드)8-String to Integer (atoi)", "url": "/posts/leetcode_String_to_Integer_(atoi)/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-03-02 15:00:00 +0900", "snippet": "leetcode 8 - String to Integer 문제입니다.1. 문제https://leetcode.com/problems/string-to-integer-atoi/2. Input , OutputConstraints: 0 &amp;lt;= s.length &amp;lt;= 200 s consists of English letters (lower-case and upper-case), digits (0-9), ‘ ‘, ‘+’, ‘-‘, and ‘.’.3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Interviewd 문제입니다.4. 문제 해석 stoi()를 해주는 문제이지만.. 예외처리할 게 많습니다.5. codeclass Solution {public: int myAtoi(string s) { if(s[0]&amp;gt;96 &amp;amp;&amp;amp; s[0]&amp;lt;123 || s[0]==&#39;.&#39;) return 0; //맨 처음이 공백인 경우 공백이 아닐때까지 점프합니다. if(s[0]==&#39; &#39;) { int i = 0; while(i&amp;lt;s.size() &amp;amp;&amp;amp; s[0]==&#39; &#39;) { s = s.substr(1); } } int result; try { result = std::stoi(s); } //문자가 들어온 경우 catch(invalid_argument&amp;amp; e) { return 0; } //오버플로우, 언더플로우인 경우 catch(std::out_of_range&amp;amp; e) { if(s[0]==&#39;-&#39;) result = -2147483648; else result = 2147483647; } return result; }};6. 결과 및 후기, 개선점" }, { "title": "Baekjoon1260-DFS와 BFS", "url": "/posts/baekjoon1260/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, BFS, DFS, AlgorithmStudy", "date": "2021-03-02 13:02:00 +0900", "snippet": "백준 사이트 1260- DFS와 BFS 문제입니다.1. 문제https://www.acmicpc.net/problem/12602. Input , Output3. 분류 및 난이도기초 BFS, DFS 문제입니다.4. 생각한 것들 python으로 고치기5. codec++#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstdio&amp;gt;#include&amp;lt;vector&amp;gt;#include&amp;lt;algorithm&amp;gt;#include&amp;lt;queue&amp;gt;using namespace std;void dfs(int start, vector&amp;lt;int&amp;gt; graph[], bool check[]){ check[start] = true; printf(&quot;%d &quot;, start); for (int i = 0; i &amp;lt; graph[start].size(); ++i) { int next = graph[start][i]; if (check[next] == false) dfs(next, graph, check); }}void bfs(int start, vector&amp;lt;int&amp;gt; graph[], bool check[]){ queue&amp;lt;int&amp;gt;q; q.push(start); check[start] = true; while (!q.empty()) { int tmp = q.front(); q.pop(); printf(&quot;%d &quot;, tmp); for (int i = 0; i &amp;lt; graph[tmp].size(); ++i) { if (check[graph[tmp][i]] == false) { q.push(graph[tmp][i]); check[graph[tmp][i]] = true; } } }}int main(){ int n, m, start; cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; start; vector&amp;lt;int&amp;gt;* graph=new vector&amp;lt;int&amp;gt;[n+1]; bool* check = new bool[n + 1]; fill(check, check + n + 1, false); int u, v; for (int i = 0; i &amp;lt; m; ++i) { cin &amp;gt;&amp;gt; u &amp;gt;&amp;gt; v; graph[u].push_back(v); graph[v].push_back(u); } for (int i = 1; i &amp;lt;= n; ++i) sort(graph[i].begin(), graph[i].end()); dfs(start, graph, check); fill(check, check + n + 1, false); puts(&quot;&quot;); bfs(start, graph, check); for (int i = 0; i &amp;lt; graph[i].size(); ++i) graph[i].clear(); graph-&amp;gt;clear(); return 0;}pythonimport sys#BFSfrom collections import dequedef DFS(graph,root,visited): visited[root] = 1 print(root) for i in range(len(graph[root])): next = graph[root][i] if(graph[root][i]!= 0 and visited[next]==0): DFS(graph,next,visited)def BFS(graph, root,visited): queue = deque([root]) visited[root]=1 while queue: n = queue.popleft() print(n) for i in range (len(graph[n])): if(graph[n][i] != 0 and visited[graph[n][i]]==0): queue.append(graph[n][i]) visited[graph[n][i]]=1n,m,v = map(int,input().split())graph = [[0]* (n+1) for i in range(n+1)]visited = [0] * (n+1) for i in range (0,m): first,second = map(int,input().split()) graph[first][second] = second graph[second][first]= firstDFS(graph,v,visited)for i in range (0,n+1): visited[i]=0BFS(graph,v,visited)6. 후기python으로 처음바꿔봤는데메모리랑 시간 차이가 너무 많이 난다.. 왜일까.. 50b8024c45aaee6221eae1385dddd61fc2c7adea " }, { "title": "leetcode(리트코드)3월1일 challenge575-Distribute Candies", "url": "/posts/leetcode_Distribute_Candies/", "categories": "leetcode, Eazy", "tags": "leetcode, AlgorithmStudy", "date": "2021-03-01 02:00:00 +0900", "snippet": "leetcode March 01일 - Distribtue Candies 문제입니다.1. 문제https://leetcode.com/problems/distribute-candies/2. Input , Output3. 분류 및 난이도Eazy 난이도입니다.3월01일자 챌린지 문제입니다.4. 문제 해석 주어진 벡터 크기/2만큼 캔디를 먹을 수 있습니다. 하지만 그만큼 종류가 되지 않으면 캔디 종류를 리턴합니다. 오름차순이 아닐 수도 있다는 점을 고려하며 풀면 틀리지 않을 것 같습니다.5. codec++class Solution {public: int distributeCandies(vector&amp;lt;int&amp;gt;&amp;amp; candyType) { sort(candyType.begin(),candyType.end()); int num = candyType.size()/2; int count = 1; for(size_t i =0;i&amp;lt;candyType.size()-1;++i) { if(candyType[i] != candyType[i+1]) ++count; } return count &amp;gt; num ? num : count; }};pythonclass Solution: def distributeCandies(self, candyType: List[int]) -&amp;gt; int: candyType.sort() num = int(len(candyType)/2) count = 1 for i in range(len(candyType)-1): if candyType[i] != candyType[i+1]: count+=1 return num if count&amp;gt; num else count6. 결과 및 후기, 개선점104ms 100% 코드class Solution {public: int distributeCandies(vector&amp;lt;int&amp;gt;&amp;amp; candyType) { int possible = candyType.size() / 2; bitset&amp;lt;200001&amp;gt; types(0); for(auto type : candyType) { types.set(type + 100000); } int typesNumber = types.count(); return typesNumber &amp;lt; possible ? typesNumber : possible; }};bitset은 STL 입니다.음수가 들어올 수 있으므로 넉넉하게 200001만큼 bitset을 만들고 음수를 대비하여 100000을 더합니다.참고 출처 : https://www.crocus.co.kr/549" }, { "title": "leetcode(리트코드)2월28일 challenge895-Maximum Frequency Stack", "url": "/posts/leetcode_Maximum_Frequency_Stack/", "categories": "leetcode, Hard", "tags": "leetcode", "date": "2021-03-01 01:00:00 +0900", "snippet": "leetcode February 28일 - Maximum Frequency Stack 문제입니다.1. 문제https://leetcode.com/problems/maximum-frequency-stack/2. Input , OutputNote: Calls to FreqStack.push(int x) will be such that 0 &amp;lt;= x &amp;lt;= 10^9. It is guaranteed that FreqStack.pop() won’t be called if the stack has zero elements. The total number of FreqStack.push calls will not exceed 10000 in a single test case. The total number of FreqStack.pop calls will not exceed 10000 in a single test case. The total number of FreqStack.push and FreqStack.pop - calls will not exceed 150000 across all test cases.3. 분류 및 난이도Hard 난이도입니다.2월28일자 챌린지 문제입니다.4. 문제 해석 stack을 구현합니다. 다만 POP를 할 때 빈번한 순서대로 반환을 합니다. 만약 빈번한 정도가 같다면 stack의 top에 가까운 순서대로 반환합니다. 2월의 마지막 문제라 그런지 Hard문제를 줬습니다. 5. codeclass FreqStack {private: //map은 요소 찾기용입니다. 첫 번째 값은 요소, 두 번째 값은 빈번도 입니다. 4324 이 들어오면 map[4]는 2, map[3]은 1 map[2]는 1로 저장되어 있습니다. unordered_map&amp;lt;int,int&amp;gt; map; // st는 직접 관리할 스택입니다. 첫 번째 값은 push로 들어온 값. 두 번째 요소는 map에서 찾은 value값입니다. vector&amp;lt;pair&amp;lt;int,int&amp;gt;&amp;gt; st; //vec는 maxnum을 관리할 객체입니다. 54321로 들어오면 maxnum이 1이므로 vec[1]=5(개)입니다. 543215 로 5가 2개이므로 maxnum은 2가 되고, 들어오면 vec[1]= 5 vec[2] = 1 입니다. vector&amp;lt;int&amp;gt; vec; int maxnum=0; public: FreqStack() { //0번째 요소를 만듭니다. 더미값. vec.push_back(0); } void push(int x) { //만약 들어온 값이 처음들어온 값이면 if(map.find(x) == map.end()) { //처음 들어온 값이므로 1만큼 카운트값을 세주고 map[x]=1; //아예 처음들어온 값이면 if(maxnum==0) { maxnum=1; vec.push_back(1); } else { //아니면 이미 vec[1]은 존재하므로 vec[1]++; } } //이미 stack에 값이 존재하면 else { //카운트 값을 증가시킵니다. map[x]++; if(map[x]&amp;gt;maxnum) { maxnum=map[x]; //만약 vec요소에 접근할 수 없을만큼 큰 값이면 if(vec.size()&amp;lt;=maxnum) vec.push_back(1); else { vec[maxnum]++; } } //vec요소에 접근할 수 있습니다. else vec[map[x]]++; } st.push_back(make_pair(x,map[x])); } int pop() { int size = st.size()-1; int temp = st[size].first; if(map[temp] == maxnum) { map[temp]--; st.pop_back(); vec[maxnum]--; //최대값을 갱신합니다. if(vec[maxnum]==0) { --maxnum; } return temp; } else { for(;size&amp;gt;=0;--size) { //최대값이랑 같은 count면 지워버립니다. if(st[size].second == maxnum) { map[st[size].first]--; int returnnum = st[size].first; st.erase(st.begin() + size); vec[maxnum]--; if(vec[maxnum]==0) { --maxnum; } return returnnum; } } } return 1; }};/** * Your FreqStack object will be instantiated and called as such: * FreqStack* obj = new FreqStack(); * obj-&amp;gt;push(x); * int param_2 = obj-&amp;gt;pop(); */6. 결과 및 후기, 개선점2시간 걸렸습니다..그래도 공간 복잡도가 상위권으로 나왔군요..136ms 100% 코드//입출력을 빠르게 하는 코드인것 같습니다.#pragma GCC optimize(&quot;Ofast&quot;)static auto _ = [] () {ios_base::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();class FreqStack{public: unordered_map&amp;lt;int, int&amp;gt; freqMap; unordered_map&amp;lt;int, vector&amp;lt;int&amp;gt;&amp;gt; stackMap; int maxFreq = 0; FreqStack() {} void push(int x) { int freq = ++freqMap[x]; //이게 되네. stackMap[freq].push_back(x); maxFreq = max(maxFreq, freq); } int pop() { auto&amp;amp; stack = stackMap[maxFreq]; int x = stack.back(); stack.pop_back(); --freqMap[x]; if (stack.size() == 0) --maxFreq; return x; }};이해하기 간단한 코드입니다..map을 저렇게 활용할 수 있다는 건 몰랐습니다." }, { "title": "leetcode(리트코드)114-Flatten Binary Tree to Linked List", "url": "/posts/leetcode_Flatten_Binary_Tree_to_Linked_List/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Like", "date": "2021-02-27 17:30:00 +0900", "snippet": "leetcode 55 - Flatten Binary Tree to Linked List 문제입니다.1. 문제https://leetcode.com/problems/flatten-binary-tree-to-linked-list/2. Input , OutputConstraints: The number of nodes in the tree is in the range [0, 2000]. -100 &amp;lt;= Node.val &amp;lt;= 100 Follow up: Can you flatten the tree in-place (with O(1) extra space)?3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked 문제입니다.4. 문제 해석 주어진 트리를 오른쪽으로 펼쳐놓아야합니다.5. code/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: void Preorder(TreeNode* Node,TreeNode*&amp;amp; temp) { if(Node==nullptr) return ; Preorder(Node-&amp;gt;right,temp); Preorder(Node-&amp;gt;left,temp); Node-&amp;gt;right = temp; Node-&amp;gt;left=nullptr; temp = Node; } void flatten(TreeNode* root) { TreeNode* temp=nullptr; Preorder(root,temp); }};6. 결과 및 후기, 개선점Discuss를 참고했습니다.따라서 수행시간은 적지 않겠습니다.temp라는 변수를 통해 오른쪽부터 순회를 하면서 값들을 저장합니다. 결과적으로 오른쪽 자식부터 돌면서 중간에 값들을 끼워넣는 방식입니다." }, { "title": "leetcode(리트코드)136-Single Number", "url": "/posts/leetcode_Single_Number/", "categories": "leetcode, Eazy", "tags": "leetcode, Top100Like", "date": "2021-02-27 17:00:00 +0900", "snippet": "leetcode 136 - Single Number 문제입니다.1. 문제https://leetcode.com/problems/single-number/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.leetcode Top 100 Liked 문제입니다.4. 문제 해석 한 요소 빼고 다른 요소들은 2번씩 반복됩니다. 2번씩 반복되지 않은 요소를 찾아 리턴합니다.5. codeclass Solution {public: int singleNumber(vector&amp;lt;int&amp;gt;&amp;amp; nums) { sort(nums.begin(),nums.end()); int result = 0; for(size_t i = 0; i&amp;lt;nums.size();i+=2) { if(i ==nums.size()-1|| nums[i] != nums[i+1]) { result = nums[i]; break; } } return result; }};6. 결과 및 후기, 개선점4ms 100% 코드class Solution {public: int singleNumber(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int a =0; for (int n: nums) a^=n; return a; }};XOR 비트연산을 통해 값을 도출하는 코드입니다. 어차피 2번 반복되면 비트는 0으로 바뀔 것이므로 가능한 것입니다.배웠습니다." }, { "title": "leetcode(리트코드)2월27일 challenge29-Divide Two Integers", "url": "/posts/leetcode_Divide_Two_Integers/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-02-27 16:00:00 +0900", "snippet": "leetcode February 29 - Divide Two Integers 문제입니다.1. 문제https://leetcode.com/problems/divide-two-integers/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.2월27일자 챌린지 문제입니다.4. 문제 해석 버림을 사용해서 나눗셈을 하면 됩니다. challenge문제들은 보통 Liked 갯수가 많은 문제가 많았는데..반대의 경우는 처음 봤습니다. 이유인 즉슨, 오버플로 같은 처리에서 Wrong Answer 처리를 해서 그런것 같습니다. 창의성의 문제라기 보다는 정답에 끼워맞춰야하는 문제.. 예를 들어서 2^31-1 과 -1 이 들어오면 INT_MAX를 뱉어야합니다. 이유는 모르겠습니다.5. codeclass Solution {public: int divide(int dividend, int divisor) { if(dividend == INT_MIN &amp;amp;&amp;amp; divisor==-1) return INT_MAX; return trunc(dividend / divisor); }};6. 결과 및 후기, 개선점" }, { "title": "leetcode(리트코드)55-Jump Game", "url": "/posts/leetcode_Jump_Game/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Like", "date": "2021-02-27 14:00:00 +0900", "snippet": "leetcode 55 - Jump Game 문제입니다.1. 문제https://leetcode.com/problems/jump-game/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked 문제입니다.4. 문제 해석 벡터로 주어진 요소만큼 점프할 수 있습니다. 점프를 해서 맨 끝요소로 도달할 수 있는지 여부를 리턴합니다.5. codeclass Solution {public: bool canJump(vector&amp;lt;int&amp;gt;&amp;amp; nums) { bool* v = new bool[nums.size()]; memset(v,false,sizeof(bool) * nums.size()); v[0]=true; for(size_t i =0;i&amp;lt;nums.size()-1;++i) { if(v[i]==true) { for(int j =0;j&amp;lt;=nums[i]; ++j) { if(i+j&amp;gt;nums.size()-1) { break; } if(v[i+j]==true) continue; else v[i+j]=true; } } } return v[nums.size()-1]; }};6. 결과 및 후기, 개선점0ms 100% 코드class Solution {public: bool canJump(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int s=nums.size(); //벡터의 크기가 1개일 때 if(s==1){ return true; } int target=s-1; for(int i=s-2; i&amp;gt;=0; i--){ if(i+nums[i]&amp;gt;=target){ target=i; } } return target==0; } };백트래킹 방법입니다. 만약 더 많이 점프할 수 있으면 해당 인덱스로 옮겨버립니다." }, { "title": "leetcode(리트코드)33-Serach in Rotated Sorted Array", "url": "/posts/leetcode_Search_in_Rotated_Sorted_Array/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Like", "date": "2021-02-27 13:00:00 +0900", "snippet": "leetcode 33 - Search in Rotated Sorted Array 문제입니다.1. 문제https://leetcode.com/problems/search-in-rotated-sorted-array/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked 문제입니다.4. 문제 해석 문제 해석이 까다로웠습니다. 이미 정렬된 오름차순 벡터가 있다고 가정하고 어느 한 인덱스를 지점으로 뒤집어 버린것이 ‘nums’ 벡터입니다. 그렇기에 [4,5,6,7,0,1,2]는 인덱스 [0,1,2,4,5,6,7]에서 인덱스 3을 기준으로 뒤집은 벡테입니다. 해당 벡터에서 target으로 주어진 값을 찾습니다. 있으면 해당index를 반환하고 없으면 -1을 반환합니다. 풀이과정은 맨끝 의 인덱스는 앞으로 갈수록 작아질 일만 남았고, 0번째 인덱스에서 어느 지점까지는 증가할 일만 남았으니 들어온 값이 0번째 인덱스를 기준으로 작으면 뒤에서부터 검사하고 아니면 순차접근 합니다. 최악의경우 n이겠지만..5. codeclass Solution {public: int search(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { if(nums.size()==1) return nums[0]==target ? 0 : -1; int start =0; int end = nums.size()-1; int max = nums[end]; //끝에서부터 탐색(끝이 가까울 수록) if(target&amp;lt;=nums[end]) { while(end&amp;gt;start &amp;amp;&amp;amp; nums[end]&amp;gt;target) { cout&amp;lt;&amp;lt;end&amp;lt;&amp;lt;&#39;\\n&#39;; --end; } if(nums[end]==target) return end; else return -1; } else { while(start&amp;lt;end &amp;amp;&amp;amp;nums[start]&amp;lt;target) { ++start; } if(nums[start]==target) return start; else return -1; } return -1; }};pythonclass Solution: def search(self, nums: List[int], target: int) -&amp;gt; int: if len(nums) == 1 : return -1 if nums[0] != target else 0 #binary search left = 0 right = len(nums)-1 if nums[right] == target : return right if nums[right] &amp;gt; target : while right-1 &amp;gt;=0 and nums[right] &amp;gt;nums[right-1] : if nums[right-1] == target : return right-1 right-=1 else : if nums[left] == target : return left while left+1 &amp;lt; len(nums) and nums[left] &amp;lt; nums[left+1] : if nums[left+1] == target : return left+1 left+=1 return -16. 결과 및 후기, 개선점" }, { "title": "leetcode(리트코드)2월26일 challenge946-Validate Stack Sequences", "url": "/posts/leetcode_Validate_Stack_Sequences/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-02-26 15:00:00 +0900", "snippet": "leetcode February 946 - Validate Stack Sequences 문제입니다.1. 문제https://leetcode.com/problems/validate-stack-sequences/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.2월26일자 챌린지 문제입니다.4. 문제 해석 pushed로 된 벡터와 popped으로 된 벡터가 있습니다. 주어진 순서대로 push를 하고 임의의 pop을 통해 popped 벡터를 만들 수 있는 지 확인합니다.5. codeclass Solution {public: bool validateStackSequences(vector&amp;lt;int&amp;gt;&amp;amp; pushed, vector&amp;lt;int&amp;gt;&amp;amp; popped) { stack&amp;lt;int&amp;gt; st; int pi=0; int popi=0; for(;popi&amp;lt;popped.size();) { //처음 접근하면 밑의 st.top()연산을 할 수 없으모로 넣어줍ㄴ디ㅏ. if(st.empty()) st.push(pushed[pi++]); while(st.top()!=popped[popi] &amp;amp;&amp;amp; pi&amp;lt;pushed.size()) { st.push(pushed[pi++]); } //만약 push배열에 있는 모든 걸 넣었는데 다르다면 false를 리턴합니다. if(st.top()!=popped[popi]) return false; st.pop(); ++popi; } return true; }};6. 결과 및 후기, 개선점" }, { "title": "leetcode(리트코드)7-Reverse Integer", "url": "/posts/leetcode_Reverse_Integer/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-02-26 13:00:00 +0900", "snippet": "leetcode 7 - Reverse Integer 문제입니다.1. 문제https://leetcode.com/problems/reverse-integer/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.leetcode Top 100 Interview의 문제입니다.4. 문제 해석 숫자로 들어온 x 값을 뒤집어서 리턴합니다. ‘싫어요’ 갯수가 굉장히 많은데 제 추측으로는 input이 9876543210(2^32보다 큰 값)이 들어올 경우 뒤집으면 int형으로 담을 수 있는 예외처리 때문에 사람들이 문제의도와 안맞다고 생각하는 것 같습니다.5. codeclass Solution {public: int reverse(int x) { if(x==0 || x&amp;gt;2147483647 || x&amp;lt;-2147483647) return 0; string temp = &quot;&quot;; bool check = false; if(x&amp;lt;0) { x= -x; check = true; } temp = to_string(x); if(check) temp+=&quot;-&quot;; std::reverse(temp.begin(),temp.end()); long long result = stol(temp); if(result&amp;gt;INT_MAX || result&amp;lt;INT_MIN) return 0; return result; }};6. 결과 및 후기, 개선점" }, { "title": "leetcode(리트코드)2월25일 challenge581-Shortest Unsorted Continuous Subarray", "url": "/posts/leetcode_Shortest_Unsorted_Continuous_Subarray/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-02-25 17:00:00 +0900", "snippet": "leetcode February 581 - Shortest Unsorted Continuous Subarray 문제입니다.1. 문제https://leetcode.com/problems/shortest-unsorted-continuous-subarray/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.2월25일자 챌린지 문제입니다.4. 문제 해석 해당 배열을 오름차순으로 바꿀 때 어느 부분을 바꿔야하는지 알고 그 길이를 리턴합니다.5. codeclass Solution {public: int findUnsortedSubarray(vector&amp;lt;int&amp;gt;&amp;amp; nums) { //정렬을 미리해서 비교를합니다. vector&amp;lt;int&amp;gt; temp = nums; sort(temp.begin(),temp.end()); int left = 0; int right= nums.size()-1; //left먼저 돕니다. while(left&amp;lt;nums.size() &amp;amp;&amp;amp; nums[left]==temp[left]) ++left; //만약 끝까지 돌았으면 이미 정렬된 상태입니다. if(left==nums.size()) return 0; while(right&amp;gt;=0 &amp;amp;&amp;amp;nums[right]==temp[right]) --right; return right-left+1; }};6. 결과 및 후기, 개선점" }, { "title": "leetcode(리트코드)49-Group Anagrams", "url": "/posts/leetcode_Group_Anagrams/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Like", "date": "2021-02-25 15:00:00 +0900", "snippet": "leetcode 49 - Group Anagrams 문제입니다.1. 문제https://leetcode.com/problems/group-anagrams/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked의 문제입니다.4. 문제 해석 문자열로 들어온 것들을 순서를 바꾸어도 같은것 끼리 뭉쳐서 리턴합니다.5. codebool cmp(pair&amp;lt;string,int&amp;gt;&amp;amp; a,pair&amp;lt;string,int&amp;gt;&amp;amp; b){ return a.first&amp;lt;b.first;}class Solution {public: vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; groupAnagrams(vector&amp;lt;string&amp;gt;&amp;amp; strs) { //첫번째는 기존 str, 두번째는 인덱스 값을 저장 vector&amp;lt;pair&amp;lt;string,int&amp;gt;&amp;gt; vec; //결과 벡터 vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; result; //strs를 돌면서 strs[i]를 정렬해주고 인덱스와 함께 넣습니다. for(size_t i =0;i&amp;lt;strs.size();++i) { string temp = strs[i]; sort(temp.begin(),temp.end()); vec.push_back(make_pair(temp,i)); } // 첫번째 값을 기준으로 정렬합니다. sort(vec.begin(),vec.end(),cmp); for(size_t i = 0; i&amp;lt;vec.size();++i) { vector&amp;lt;string&amp;gt; tempvec; tempvec.push_back(strs[vec[i].second]); //다음 요소가 같으면 몰아서 push하빈다. while(i+1&amp;lt;vec.size() &amp;amp;&amp;amp; vec[i+1].first == vec[i].first) { ++i; tempvec.push_back(strs[vec[i].second]); } result.push_back(tempvec); } return result; }};6. 결과 및 후기, 개선점" }, { "title": "leetcode(리트코드)2월24일 challenge856-Score of Parentheses", "url": "/posts/leetcode_Score_of_Parentheses/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-02-24 13:00:00 +0900", "snippet": "leetcode February 856 - Scroe of Parentheses 문제입니다.1. 문제https://leetcode.com/problems/score-of-parentheses/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.2월24일자 챌린지 문제입니다.4. 문제 해석 input으로 “()”짝이 들어옵니다. 기본적으로 ()는 1로 치환됩니다. 괄호 안에 괄호가 들어 있으면 &amp;gt; “(())” 괄호안의 숫자의 2배를 해줍니다. ”()()” 이렇게 이어져 있으면 () + () 를 해야합니다.5. codeclass Solution {public: int scoreOfParentheses(string S) { int result = 0; int count = 0; bool check = false; for(size_t i = 0;i&amp;lt;S.size();++i) { if(S[i] == &#39;(&#39;) { ++count; check=true; } else if (S[i]==&#39;)&#39; &amp;amp;&amp;amp; check) { result += pow(2,count-1); --count; check=false; } else { --count; } } return result; }};6. 결과 및 후기, 개선점" }, { "title": "leetcode(리트코드)2월23일 challenge240-Search a 2D Matrix II", "url": "/posts/leetcode_Search_a_2D_Matrix_II/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-02-23 01:00:00 +0900", "snippet": "leetcode February 240 - Search a 2D Matrix II 문제입니다.1. 문제https://leetcode.com/problems/search-a-2d-matrix-ii/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.2월23일자 챌린지 문제입니다.4. 문제 해석 오름차순이 되어 있는 2차원 배열을 돌면서 target값을 효율성있게 찾아야합니다. STL 에서 find 함수를 지원하지만 find 함수는 순차접근으로 계산하기에 효율성이 좋은 코드는 아닙니다. BinarySearch를 이용해서 위의 코드를 개선하였습니다.5. codeclass Solution {public: bool searchMatrix(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix, int target) { for(size_t i =0;i&amp;lt;matrix.size();++i) { auto finditem = binary_search(matrix[i].begin(),matrix[i].end(),target); if(finditem) return true; } return false; }};6. 결과 및 후기, 개선점시간이 빠른 코드 12ms(100%)class Solution {public: bool searchMatrix(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; a, int target) { ios::sync_with_stdio(0); //h는 배열의 행 w는 열 int h = 0, w = a[0].size(), x; while(h &amp;lt; a.size() &amp;amp;&amp;amp; w &amp;amp;&amp;amp; (x = a[h][w-1]) != target) { if (x &amp;gt; target) w--; else h++; } //while문은 기존 코드에 있으나 지워도 상관없어서 지워버림. //while (a.size()) a.pop_back(); return x == target; }};일단 열의 끝 부터 검사하면서 그 다음 행을 검사합니다." }, { "title": "leetcode(리트코드)2월22일 challenge524-Longest Word in Dictionary through Deleting", "url": "/posts/leetcode_Longest_Word_in_Dictionary_through_Deleting/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-02-22 01:00:00 +0900", "snippet": "leetcode February 524 - Longest Word in Dictionary through Deleting 문제입니다.1. 문제https://leetcode.com/problems/longest-word-in-dictionary-through-deleting/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.2월22일자 챌린지 문제입니다.4. 문제 해석 s에 있는 문자를 빼서 dictionary에 있는 문자열을 만들 수 있으면 됩니다. 리턴할 문자열은 가장 길이가 길어야합니다. 리턴할 문자열의 길이가 같을 땐 사전순으로 빠른 것을 리턴합니다.5. codeclass Solution {public: string findLongestWord(string s, vector&amp;lt;string&amp;gt;&amp;amp; dictionary) { //결과 문자열 string result = &quot;&quot;; //길이가 큰 문자열을 담을 변수 int sz= 0; //길이가 같으면 사전 순으로 처리해야하므로 정렬을합니다. sort(dictionary.begin(),dictionary.end()); for(size_t i =0;i&amp;lt;dictionary.size();++i) { //index는 사전에 있는 문자열을 돌 것입니다. int index = 0; //예를 들어 apple를 돌고 plea를 돈다하면 plea는 apple보다 문자열의 크기가 작으므로 돌 필요가 없습니다. if(dictionary[i].size()&amp;gt;sz) { for(size_t j = 0; j&amp;lt;s.size();++j) { if(dictionary[i][index]==s[j]) { ++index; } if(index == dictionary[i].size()) { sz = index; result = dictionary[i]; } } } } return result; }};6. 결과 및 후기, 개선점시간이 빠른 코드 24ms(100%)class Solution {public: inline bool contains(string &amp;amp;s, string &amp;amp;t) { int n = s.length(), m = t.length(); int i = 0 , j = 0; while(i&amp;lt;n and j&amp;lt;m) if(s[i] == t[j]) i++ , j++; else i++; return j == m; } string findLongestWord(string s, vector&amp;lt;string&amp;gt;&amp;amp; d) { //입출력을 빠르게 ios_base::sync_with_stdio(0),cin.tie(0); //함수 포인터 d(dictionary)를 길이 순으로 정렬 //같은 길이면 사전순으로 정렬. //나머지 로직은 같다. auto cmp = [](string &amp;amp;a, string &amp;amp;b) { if(a.length() != b.length()) return a.length() &amp;gt; b.length(); return a&amp;lt;b; }; sort(d.begin() , d.end() , cmp); for(int i=0 ; i&amp;lt;d.size() ; i++) { if(contains(s,d[i])) return d[i]; } return &quot;&quot;; }};" }, { "title": "leetcode(리트코드)2월21일 challenge991-Broken Calculator", "url": "/posts/leetcode_Broken_Calculator/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-02-21 17:01:00 +0900", "snippet": "leetcode February challenge991 - Broken Calculator 문제입니다.1. 문제https://leetcode.com/problems/broken-calculator/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.2월21일자 챌린지 문제입니다.4. 문제 해석 X에서 2를 곱하거나 -1을 하여 Y로 만들어야합니다. 카운트를 리턴합니다. 백트래킹으로 Y를 X로 만드는 것에 신경을 썼습니다.5. codeclass Solution {public: int brokenCalc(int X, int Y) { queue&amp;lt;pair&amp;lt;int,int&amp;gt;&amp;gt; q; q.push(make_pair(Y,0)); if(Y&amp;lt;X) return X-Y; while(!q.empty()) { int now = q.front().first; int count = q.front().second; q.pop(); if(now&amp;lt;X) return count+X-now; if(now == X) return count; if(now%2==0) q.push(make_pair(now/2,count+1)); else q.push(make_pair(now+1,count+1)); } return 0; }};6. 결과 및 후기, 개선점더 간단한 코드class Solution {public: int brokenCalc(int x, int y) { if(x == y) { return 0; } if(x &amp;gt; y) { return x-y; } if(y %2 == 0) { return 1+brokenCalc(x , y/2); } else { return 1 + brokenCalc(x , y+1); } }};코드 본문의 내용이 쉬우므로 해설은 적지 않겠습니다." }, { "title": "leetcode(리트코드)48-Rotate Image", "url": "/posts/leetcode_Rotate_Image/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Like", "date": "2021-02-21 16:30:00 +0900", "snippet": "leetcode 48 - Rotate Image 문제입니다.1. 문제https://leetcode.com/problems/rotate-image/2. Input , OutputConstraints: matrix.length == n matrix[i].length == n 1 &amp;lt;= n &amp;lt;= 20 -1000 &amp;lt;= matrix[i][j] &amp;lt;= 10003. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked의 문제입니다.4. 문제 해석 새로운 2차원 벡터를 생성하지 않고 주어진 벡터를 90도 오른쪽으로 돌려야합니다.5. codeclass Solution {public: void rotate(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix) { int size = matrix.size(); for(size_t i =0;i&amp;lt;size;++i) { vector&amp;lt;int&amp;gt; temp; for(int j = size-1;j&amp;gt;-1;--j) { temp.push_back(matrix[j][0]); matrix[j].erase(matrix[j].begin()); } matrix.push_back(temp); } for(int i =0 ;i&amp;lt;size;++i) matrix.erase(matrix.begin()); }};6. 결과 및 후기, 개선점" }, { "title": "leetcode(리트코드)53-Maximum Subarray", "url": "/posts/leetcode_Maximum_Subarray/", "categories": "leetcode, Eazy", "tags": "leetcode, Top100Like", "date": "2021-02-21 16:10:00 +0900", "snippet": "leetcode 53 - Maximum Subarray 문제입니다.1. 문제https://leetcode.com/problems/maximum-subarray/2. Input , OutputConstraints: 1 &amp;lt;= nums.length &amp;lt;= 3 * 104 -105 &amp;lt;= nums[i] &amp;lt;= 1053. 분류 및 난이도Hard 난이도 문제입니다.leetcode Top 100 Liked의 문제입니다.4. 문제 해석 주어진 배열내에서 연속된 수를 더해 가장큰 값을 찾습니다. DP로 풀었습니다.5. codeclass Solution {public: int maxSubArray(vector&amp;lt;int&amp;gt;&amp;amp; nums) { if(nums.size()==1) return nums[0]; int* DP = new int[nums.size()+1]; DP[0] = nums[0]; int result = DP[0]; for(size_t i =1;i&amp;lt;nums.size();++i) { DP[i] = max(DP[i-1] + nums[i], nums[i]); result = max(result,DP[i]); } return result; }};6. 결과 및 후기, 개선점0ms 코드와 같습니다." }, { "title": "leetcode(리트코드)39-Combination Sum", "url": "/posts/leetcode_Combination_Sum/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Like", "date": "2021-02-21 15:10:00 +0900", "snippet": "leetcode 39 - Combination Sum 문제입니다.1. 문제https://leetcode.com/problems/combination-sum/2. Input , OutputConstraints: 1 &amp;lt;= candidates.length &amp;lt;= 30 1 &amp;lt;= candidates[i] &amp;lt;= 200 All elements of candidates are distinct. 1 &amp;lt;= target &amp;lt;= 5003. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked의 문제입니다.4. 문제 해석 후보자로 주어진 벡터에서 target을 만들 수 있는 경우의 수를 벡터에 넣어 리턴합니다.5. codeclass Solution {public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result; void practice(vector&amp;lt;int&amp;gt;&amp;amp; candidates, int target,vector&amp;lt;int&amp;gt; temp,int num) { if(target==0) { result.push_back(temp); } else if(target&amp;lt;0) { return; } else { for( ;num&amp;lt;candidates.size();++num) { temp.push_back(candidates[num]); practice(candidates,target-candidates[num],temp,num); temp.pop_back(); } } } vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; combinationSum(vector&amp;lt;int&amp;gt;&amp;amp; candidates, int target) { vector&amp;lt;int&amp;gt; temp; practice(candidates,target,temp,0); return result; }};6. 결과 및 후기, 개선점시간 40ms(30%)이해가 안되는 점은 4ms 97% 코드와 똑같은데 40ms 나온 것.. 트래픽이 몰렸나..?class Solution {public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; combinationSum(vector&amp;lt;int&amp;gt;&amp;amp; candidates, int target) { vector&amp;lt;int&amp;gt; temp; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result; solve(candidates, 0, target, temp, result); return result; } void solve(vector&amp;lt;int&amp;gt;&amp;amp; candidates, int start, int target, vector&amp;lt;int&amp;gt; &amp;amp;temp, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp;result) { if(target &amp;lt; 0) { return; } else if(target == 0) { result.push_back(temp); } for(int i=start ; i&amp;lt; candidates.size() ; i++) { temp.push_back(candidates[i]); solve(candidates, i, target-candidates[i], temp, result); temp.pop_back(); } }};" }, { "title": "leetcode(리트코드)46-Permutations", "url": "/posts/leetcode_Permutation/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Like", "date": "2021-02-21 15:00:00 +0900", "snippet": "leetcode 46 - Permutations 문제입니다.1. 문제https://leetcode.com/problems/permutations/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked의 문제입니다.4. 문제 해석 Permutation을 구합니다.5. codeclass Solution {public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; permute(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result; sort(nums.begin(),nums.end()); do{ vector&amp;lt;int&amp;gt; temp; for(int i =0;i&amp;lt;nums.size();++i) temp.push_back(nums[i]); result.push_back(temp); }while(next_permutation(nums.begin(),nums.end())); return result; }};6. 결과 및 후기, 개선점next_permutation 함수를 잊지말자. 정렬을 먼저 해줘야 올바르게 나옴." }, { "title": "leetcode(리트코드)34-Find First and Last Position of Element in Sorted Array", "url": "/posts/leetcode_Find_First_and_Last_Position_of_Element_in_Sorted_Array/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Like", "date": "2021-02-21 14:10:00 +0900", "snippet": "leetcode 34 - Find First and Last Position of Element in Sorted Array 문제입니다.1. 문제https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked의 문제입니다.4. 문제 해석 target으로 주어진 값을 찾아 반복되는 구간의 첫 부분과 끝 부분을 찾아 리턴합니다. 문제에서 시간복잡도 logN으로 해결하라고 하였으니, 이분탐색을 통해 문제를 해결하면 됩니다. 5. codeclass Solution {public: vector&amp;lt;int&amp;gt; searchRange(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { int start = 0; int end=nums.size()-1; vector&amp;lt;int&amp;gt; result; while(start&amp;lt;=end) { int mid = (start+end)/2; cout&amp;lt;&amp;lt;start&amp;lt;&amp;lt;&quot; &quot;&amp;lt;&amp;lt;mid&amp;lt;&amp;lt;&quot; &quot;&amp;lt;&amp;lt;end&amp;lt;&amp;lt;&#39;\\n&#39;; if(target==nums[mid]) { start = mid; end = mid; while(start-1 &amp;gt;=0 &amp;amp;&amp;amp; nums[start-1] ==target) start--; while(end+1 &amp;lt;nums.size() &amp;amp;&amp;amp; nums[end+1] == target) ++end; result.push_back(start); result.push_back(end); return result; } else if(target&amp;gt;nums[mid]) { start = mid+1; } else end=mid-1; } result.push_back(-1); result.push_back(-1); return result; }};6. 결과 및 후기, 개선점시간 4ms(97%)" }, { "title": "leetcode(리트코드)23-Merge K Sorted Lists", "url": "/posts/leetcode_Merge_K_Sorted_Lists/", "categories": "leetcode, Hard", "tags": "leetcode, Top100Like", "date": "2021-02-21 13:10:00 +0900", "snippet": "leetcode 23 - Merge K Sorted Lists 문제입니다.1. 문제https://leetcode.com/problems/merge-k-sorted-lists/2. Input , OutputConstraints: k == lists.length 0 &amp;lt;= k &amp;lt;= 10^4 0 &amp;lt;= lists[i].length &amp;lt;= 500 -10^4 &amp;lt;= lists[i][j] &amp;lt;= 10^4 lists[i] is sorted in ascending order. The sum of lists[i].length won’t exceed 10^4.3. 분류 및 난이도Hard 난이도 문제입니다.leetcode Top 100 Liked의 문제입니다.4. 문제 해석 K로 주어진 리스트들의 벡터를 정렬해야합니다.5. code/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* TwoListMerger(ListNode* list1,ListNode* list2) { if(list1 ==nullptr) return list2; else if(list2==nullptr) return list1; if(list1-&amp;gt;val &amp;lt;=list2-&amp;gt;val) { list1-&amp;gt;next = TwoListMerger(list1-&amp;gt;next,list2); return list1; } else { list2-&amp;gt;next=TwoListMerger(list1,list2-&amp;gt;next); return list2; } } ListNode* mergeKLists(vector&amp;lt;ListNode*&amp;gt;&amp;amp; lists) { if(lists.empty()) return nullptr; while(lists.size()&amp;gt;1) { lists.push_back(TwoListMerger(lists[0],lists[1])); lists.erase(lists.begin()); lists.erase(lists.begin()); } return lists.front(); }};6. 결과 및 후기, 개선점Discuss 참조.0ms 100% 코드/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* mergeKLists(vector&amp;lt;ListNode*&amp;gt;&amp;amp; lists) { map&amp;lt;int, int&amp;gt; counts; ListNode *head, *aux; //더미노드를 가리키는 헤드 head = new ListNode(); aux = head; //list를 돌면서 map에 벡터요소에 대한 카운트값을 증가시켜줍니다. for (int i = 0; i &amp;lt; lists.size(); i++) { ListNode *p = lists[i]; while (p != nullptr) { counts[p-&amp;gt;val]++; p = p-&amp;gt;next; } } //map을 돌면서 노드들을 연결합니다. for (auto it = counts.begin(); it != counts.end(); it++) { for (int i = 0; i &amp;lt; it-&amp;gt;second; i++) { aux-&amp;gt;next = new ListNode(it-&amp;gt;first); aux = aux-&amp;gt;next; } } aux = head; head = head-&amp;gt;next; delete aux; return head; }};" }, { "title": "leetcode(리트코드)2월20일 challenge13-Roman to Integer", "url": "/posts/leetcode_Roman_to_Integer/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-02-20 02:00:00 +0900", "snippet": "leetcode February challenge13 - Roman to Integer 문제입니다.1. 문제https://leetcode.com/problems/roman-to-integer/2. Input , OutputConstraints: 1 &amp;lt;= s.length &amp;lt;= 15 s contains only the characters (‘I’, ‘V’, ‘X’, ‘L’, ‘C’, ‘D’, ‘M’). It is guaranteed that s is a valid roman numeral in the range [1, 3999].3. 분류 및 난이도Eazy 난이도입니다.2월20일자 챌린지 문제입니다.4. 문제 해석 문자가 들어옵니다. 들어오는 문자가 단어가 되도록 만들어야합니다. 괄호의 짝이 맞아야합니다.5. codeclass Solution {public: string minRemoveToMakeValid(string s) { stack&amp;lt;int&amp;gt; st; for(size_t i=0;i&amp;lt;s.size();++i) { if(s[i]==&#39;(&#39;) { st.push(i); } else if(s[i]==&#39;)&#39;) { if(st.empty()) s[i]=&#39;*&#39;; else st.pop(); } } while(!st.empty()) { s[st.top()]=&#39;*&#39;; st.pop(); } s.erase(remove(s.begin(),s.end(),&#39;*&#39;),s.end()); return s; }};6. 결과 및 후기, 개선점시간(43%)0ms시간코드(100%)class Solution { int charToInt(char c) { if (c == &#39;I&#39;) return 1; else if (c == &#39;V&#39;) return 5; else if (c == &#39;X&#39;) return 10; else if (c == &#39;L&#39;) return 50; else if (c == &#39;C&#39;) return 100; else if (c == &#39;D&#39;) return 500; else return 1000; }public: int romanToInt(string s) { int n = s.length(); int ans = 0; for (int i = 0; i &amp;lt; n; i++) { int num1 = charToInt(s[i]), num2 = 0; if (i + 1 &amp;lt; n) num2 = charToInt(s[i + 1]); if (num1 &amp;lt; num2) { ans += (num2 - num1); i++; } else { ans += num1; } } return ans; }};코드 본문의 내용이 쉬우므로 해설은 적지 않겠습니다." }, { "title": "leetcode(리트코드)2월19일 challenge1249-Minimum Remove to Make Valid Parentheses", "url": "/posts/leetcode_Minimum_Remove_to_Make_Valid_Parentheses/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-02-20 01:00:00 +0900", "snippet": "leetcode February challenge19 - Minimum Remove to Make Valid Parentheses 문제입니다.1. 문제https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.2월19일자 챌린지 문제입니다.4. 문제 해석 문자가 들어옵니다. 들어오는 문자가 단어가 되도록 만들어야합니다. 괄호의 짝이 맞아야합니다.5. codeclass Solution {public: string minRemoveToMakeValid(string s) { stack&amp;lt;int&amp;gt; st; for(size_t i=0;i&amp;lt;s.size();++i) { if(s[i]==&#39;(&#39;) { st.push(i); } else if(s[i]==&#39;)&#39;) { if(st.empty()) s[i]=&#39;*&#39;; else st.pop(); } } while(!st.empty()) { s[st.top()]=&#39;*&#39;; st.pop(); } s.erase(remove(s.begin(),s.end(),&#39;*&#39;),s.end()); return s; }};6. 결과 및 후기, 개선점시간(95%)Discuss를 참조했습니다." }, { "title": "leetcode(리트코드)2월18일 challenge413-Arithmetic Slices", "url": "/posts/leetcode_Arithmetic_Slices/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-02-18 18:00:00 +0900", "snippet": "leetcode February challenge18 - Arithmetic Slices 문제입니다.1. 문제https://leetcode.com/problems/arithmetic-slices/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.2월18일자 챌린지 문제입니다.4. 문제 해석 연속된 배열에서 앞과 뒤의 차이는 같아야합니다. 그 길이가 2 이상이 되면 만들 수 있는 조합의 개수를 만들어야합니다.. 설명이 어려운데 1,2,3,4,5 들어오면 각각 1의 차이를 보이므로 나오는 값은 {1,2,3}, {2,3,4},{1,2,3,4,5},{1,2,3,4}… 이런 식으로 10개가됩니다. 저는 DP로 풀었습니다. 점화식은 DP[i] = 2 * DP[i-1] - (DP[i-2] + 1) 입니다. 설명하기 어려우므로 궁금하신 분은 물어보시면 알려드리겠습니다.5. codeclass Solution {public: int numberOfArithmeticSlices(vector&amp;lt;int&amp;gt;&amp;amp; A) { if(A.size()&amp;lt;3) return 0; int count=1; int temp = A[1]-A[0]; int result = 0; int* DP=new int[A.size()+1]; for(int i = 0;i&amp;lt;A.size()+1;++i) DP[i]=0; for(size_t i = 2;i&amp;lt;A.size();++i) { if(A[i]-A[i-1]==temp) { ++count; } else { count=1; temp = A[i]-A[i-1]; } if(count&amp;gt;=2) { DP[i] = DP[i-1] + (DP[i-1] -DP[i-2] + 1); } } for(size_t i=0;i&amp;lt;A.size();) { while(DP[i+1]!=0 &amp;amp;&amp;amp; i&amp;lt;A.size()) { ++i; } result+=DP[i]; ++i; } return result; }};6. 결과 및 후기, 개선점시간(64%)마지막에 DP를 도는 시간 때문에 오래걸린 것 같습니다.0ms(100%)코드class Solution {public: int numberOfArithmeticSlices(vector&amp;lt;int&amp;gt;&amp;amp; A) { int i,j,n=A.size(),c=0; if(n&amp;lt;3) return 0; for(i=0;i&amp;lt;n-2;i++) { for(j=i+2;j&amp;lt;n;j++) { if(A[j]-A[j-1]==A[j-1]-A[j-2]) c++; else break; } } return c; }};아예 다 검사하는 코드입니다. 이렇게 간단해도 0ms가 나오다니..브루트 포스로 풀어볼 걸 그랬습니다. 정해진 배열의 크기가 없어서 브루트 포스로 풀지 않았는데.." }, { "title": "leetcode(리트코드)22-Generate Parentheses", "url": "/posts/leetcode_Generate_Parentheses/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Like", "date": "2021-02-18 17:10:00 +0900", "snippet": "leetcode 22 - Generate Parentheses 문제입니다.1. 문제https://leetcode.com/problems/generate-parentheses/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked의 문제입니다.4. 문제 해석 n으로 들어온 값으로 만들 수 있는 “()”짝을 만들어 리턴합니다. 재귀로 푸는 방식은 알았으나 해결하지 못하여 Discuss를 봤습니다.5. codeclass Solution {public: vector&amp;lt;string&amp;gt; result; void solution(int head,int tail,int n,string temp) { if(temp.size()==n*2 ) { result.push_back(temp); } else { if(head&amp;lt;n) solution(head+1,tail,n,temp+&#39;(&#39;); if(tail&amp;lt;head) solution(head,tail+1,n,temp+&#39;)&#39;); } } vector&amp;lt;string&amp;gt; generateParenthesis(int n) {; solution(0,0,n,&quot;&quot;); return result; }};6. 결과 및 후기, 개선점Discuss를 봤으므로 올리지 않습니다." }, { "title": "leetcode(리트코드)21-Merge Two Sorted Lists", "url": "/posts/leetcode_Merge_Two_Sorted_Lists/", "categories": "leetcode, Eazy", "tags": "leetcode, Top100Like", "date": "2021-02-18 16:10:00 +0900", "snippet": "leetcode 21 - Merge Two Sorted Lists 문제입니다.1. 문제https://leetcode.com/problems/merge-two-sorted-lists/2. Input , OutputConstraints: The number of nodes in both lists is in the range [0, 50]. -100 &amp;lt;= Node.val &amp;lt;= 100 Both l1 and l2 are sorted in non-decreasing order.3. 분류 및 난이도Eazy 난이도 문제입니다.leetcode Top 100 Liked의 문제입니다.4. 문제 해석 두 리스트를 합병정렬 합니다.5. code/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode* result = new ListNode(); ListNode* head = result; while(l1!=nullptr &amp;amp;&amp;amp; l2!=nullptr) { if(l1-&amp;gt;val &amp;gt;= l2-&amp;gt;val) { result-&amp;gt;next = l2; l2=l2-&amp;gt;next; } else { result-&amp;gt;next=l1; l1=l1-&amp;gt;next; } result= result-&amp;gt;next; } while(l1!=nullptr) { result-&amp;gt;next=l1; result=result-&amp;gt;next; l1=l1-&amp;gt;next; } while(l2!=nullptr) { result-&amp;gt;next=l2; result=result-&amp;gt;next; l2=l2-&amp;gt;next; } return head-&amp;gt;next; }};6. 결과 및 후기, 개선점시간(81%)시간0ms(100%) 코드/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { //임시 노드 ListNode dummy(-3); //그것을 가리키는 꼬리노드 ListNode *tail = &amp;amp;dummy; //l1과 l2가 nullptr이 아니면 while (l1 and l2) { if (l1-&amp;gt;val &amp;lt; l2-&amp;gt;val) { tail-&amp;gt;next = l1; l1 = l1-&amp;gt;next; } else { tail-&amp;gt;next = l2; l2 = l2-&amp;gt;next; } tail = tail-&amp;gt;next; } //끝난 것을 기준으로 다른 노드를 아예 갖다 붙임. tail-&amp;gt;next = l1 ? l1 : l2; return dummy.next; }};기존 내 코드에서 개선한 코드 0ms 100%/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode* result = new ListNode(); ListNode* head = result; while(l1!=nullptr &amp;amp;&amp;amp; l2!=nullptr) { if(l1-&amp;gt;val &amp;gt;= l2-&amp;gt;val) { result-&amp;gt;next = l2; l2=l2-&amp;gt;next; } else { result-&amp;gt;next=l1; l1=l1-&amp;gt;next; } result= result-&amp;gt;next; } //이 부분 result-&amp;gt;next = l1 ? l1 : l2; return head-&amp;gt;next; }};" }, { "title": "leetcode(리트코드)20-Valid Parentheses", "url": "/posts/leetcode_Valid_Parentheses/", "categories": "leetcode, Eazy", "tags": "leetcode, Top100Like", "date": "2021-02-18 15:10:00 +0900", "snippet": "leetcode 20 - Valid Parentheses 문제입니다.1. 문제https://leetcode.com/problems/valid-parentheses/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.leetcode Top 100 Liked의 문제입니다.4. 문제 해석 스택으로 푸는 유명한 괄호문제입니다. 짝이 맞으면 true 틀리면 false를 리턴합니다.5. codeclass Solution {public: bool isValid(string s) { stack&amp;lt;char&amp;gt; st; for(size_t i =0;i&amp;lt;s.size();++i) { if(s[i]==&#39;(&#39; || s[i]==&#39;{&#39; || s[i]==&#39;[&#39;) { st.push(s[i]); } else { if(st.empty()) return false; else { char temp = st.top(); st.pop(); if(s[i]==&#39;)&#39; &amp;amp;&amp;amp; temp!=&#39;(&#39;) return false; else if(s[i]==&#39;]&#39; &amp;amp;&amp;amp; temp!=&#39;[&#39;) return false; else if(s[i]==&#39;}&#39; &amp;amp;&amp;amp; temp!=&#39;{&#39;) return false; } } } if(st.empty()) return true; else return false; }};6. 결과 및 후기, 개선점시간(100%)" }, { "title": "leetcode(리트코드)19-Remove Nth Node From End of List", "url": "/posts/leetcode_Remove_Nth_Node_From_End_of_List/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Like", "date": "2021-02-18 14:30:00 +0900", "snippet": "leetcode 19 - Remove Nth Node From End of List 문제입니다.1. 문제https://leetcode.com/problems/remove-nth-node-from-end-of-list/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked의 문제입니다.4. 문제 해석 n이 주어집니다. 끝에서 n번째에 있는 노드를 지워야합니다. 한 번에 처리할 수 있게 로직을 짜야합니다.5. code/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: void solution(ListNode*&amp;amp; first,ListNode*&amp;amp; tempnode,ListNode*&amp;amp; head,int count,int n) { if(first-&amp;gt;next!=nullptr) { //count가 n에 도달했으면 그때부터 tempnode를 움직여줍니다. if(count==n) { tempnode=tempnode-&amp;gt;next; } else ++count; solution(first-&amp;gt;next,tempnode,head,count,n); } else { //만약 다 돌았는데 count가 n만큼 채워지지 않았다면 head를 바꿔야합니다. if(count!=n) { head= head-&amp;gt;next; } else tempnode-&amp;gt;next=tempnode-&amp;gt;next-&amp;gt;next; } } ListNode* removeNthFromEnd(ListNode* head, int n) { //first는 리스트의 끝까지 돌 것입니다. ListNode* first = head; //tempnode는 first와 n만큼 뒤에있는 노드입니다. ListNode* tempnode = head; solution(first,tempnode,head,0,n); return head; }};6. 결과 및 후기, 개선점시간(83%)0ms코드(100%)/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* removeNthFromEnd(ListNode* head, int key) { ListNode *first = head; // Second pointer will point to the // Nth node from the beginning ListNode *second = head; for (int i = 0; i &amp;lt; key; i++) { // If count of nodes in the given // linked list is &amp;lt;= N //리스트의 크기보다 1만큼 작은 n이 들어왔을 때 if (second-&amp;gt;next == NULL) { // If count = N i.e. // delete the head node if (i == key - 1) head = head-&amp;gt;next; return head; } second = second-&amp;gt;next; } // Increment both the pointers by one until // second pointer reaches the end while (second-&amp;gt;next != NULL) { first = first-&amp;gt;next; second = second-&amp;gt;next; } // First must be pointing to the // Nth node from the end by now // So, delete the node first is pointing to first-&amp;gt;next = first-&amp;gt;next-&amp;gt;next; return head; }};" }, { "title": "leetcode(리트코드)17-Letter Combinations of a Phone Number", "url": "/posts/leetcode_Letter_Combinations_of_a_Phone_Number/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Like", "date": "2021-02-18 14:10:00 +0900", "snippet": "leetcode 17 - Letter Combinations of a Phone Number 문제입니다.1. 문제https://leetcode.com/problems/letter-combinations-of-a-phone-number/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked의 문제입니다.4. 문제 해석 전화기에 영어가 붙어있습니다. digits로 들어온 수에 적혀있는 영어들로 만들 수 있는 경우의 string들을 리턴합니다.5. codevector&amp;lt;string&amp;gt; alpha(10);class Solution {public: void getR(vector&amp;lt;string&amp;gt;&amp;amp; result,string digits,int count) { if(count==digits.size()) { result.push_back(alpha[0]); } else { for(int i=0;i&amp;lt;alpha[digits[count]-48].size();++i) { alpha[0]+=alpha[digits[count]-48][i]; getR(result,digits,count+1); alpha[0].resize(size(alpha[0])-1); } } } vector&amp;lt;string&amp;gt; letterCombinations(string digits) { alpha[0]=&quot;&quot;; alpha[1]=&quot;&quot;; alpha[2]=&quot;abc&quot;; alpha[3]=&quot;def&quot;; alpha[4]=&quot;ghi&quot;; alpha[5]=&quot;jkl&quot;; alpha[6]=&quot;mno&quot;; alpha[7]=&quot;pqrs&quot;; alpha[8]=&quot;tuv&quot;; alpha[9]=&quot;wxyz&quot;; vector&amp;lt;string&amp;gt; result; if(digits.size()==0) return result; getR(result,digits,0); return result; }};6. 결과 및 후기, 개선점시간(100%)" }, { "title": "leetcode(리트코드)2월17일 challenge11-Container With Most Water", "url": "/posts/leetcode_Container_With_Most_Water/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-02-18 13:00:00 +0900", "snippet": "leetcode February challenge17 - Container With Most Water 문제입니다.1. 문제https://leetcode.com/problems/container-with-most-water/2. Input , OutputConstraints: n == height.length 2 &amp;lt;= n &amp;lt;= 3 * 104 0 &amp;lt;= height[i] &amp;lt;= 3 * 1043. 분류 및 난이도Medium 난이도입니다.2월17일자 챌린지 문제입니다.4. 문제 해석 막대 두개를 잡아서 그 막대안의 사각형의 최댓값을 구해 리턴합니다. 당연하겠지만 브루트 포스로 이중 포문으로 접근하면 시간초과뜹니다.(제가해봄..) 그러면 양쪽에서 값을 비교하면서 접근하는 수밖에 없다고 생각했습니다.5. codeclass Solution {public: int maxArea(vector&amp;lt;int&amp;gt;&amp;amp; height) { int result = 0; //왼쪽 인덱스 int left = 0; //오른쪽 인덱스 int right = height.size()-1; while(left&amp;lt;=right) { //둘 중 작은 값을 기준으로 해야하므로 int line = min(height[left],height[right]); //넓이 계산 int area = line * (right-left); //큰 값이면 갱신해줘야하므로 result = max(area,result); // 작은 값을 옮겨야합니다. 다음은 큰값이 들어올 수도 있기 때문이죠. if(height[left]&amp;lt;height[right]) ++left; else --right; } return result; }};6. 결과 및 후기, 개선점시간(95%)" }, { "title": "leetcode(리트코드)2월16일 challenge784-Letter Case Permutation", "url": "/posts/leetcode_Letter_Case_Permutation/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-02-16 17:40:00 +0900", "snippet": "leetcode February challenge16 - Letter Case Permutation 문제입니다.1. 문제https://leetcode.com/problems/letter-case-permutation/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.2월16일자 챌린지 문제입니다.4. 문제 해석 만들 수 있는 문자열을 전부 찾아 리턴합니다. 대문자 소문자가 들어오면 두가지 경우의 수를 모두 넣어주고 숫자다 들어올 경우 무시하며 넘어갑니다. 재귀로 작성하였습니다.5. codeclass Solution {public: void cal(vector&amp;lt;string&amp;gt;&amp;amp; result,string S,int index,string temp) { //만약 끝의 인덱스에 도달했으면 벡터에 넣어줍니다. if(index==S.size()) { //cout&amp;lt;&amp;lt;temp; result.push_back(temp); return; } else { //digit if(S[index]&amp;gt;=48 &amp;amp;&amp;amp; S[index]&amp;lt;=57) cal(result,S,index+1,temp+=S[index]); else { //tolower는 소문자로 만들어줍니다. 소문자로 만들고 temp에 추가한 뒤 넘겨줍니다. cal(result,S,index+1,temp+=(tolower(S[index]))); //마지막 요소를 제거합니다. 이유는 temp가 위에서 저장된채로 밑으로 넘어가면 aAbB12 이런식으로 됩니다. 원하는 것은 ab12 aB12입니다. temp.resize(temp.size()-1); cal(result,S,index+1,temp+=(toupper(S[index]))); } } } vector&amp;lt;string&amp;gt; letterCasePermutation(string S) { //결과를 담을 변수입니다. vector&amp;lt;string&amp;gt; result; //인덱스 하나하나 접근해서 담을 임시 변수입니다. string temp=&quot;&quot;; cal(result,S,0,temp); return result; }};6. 결과 및 후기, 개선점시간(95%)" }, { "title": "leetcode(리트코드)6-ZigZag Conversion", "url": "/posts/leetcode_ZigZag_Conversion/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Like", "date": "2021-02-16 17:10:00 +0900", "snippet": "leetcode 6 - ZigZag Conversion 문제입니다.1. 문제https://leetcode.com/problems/zigzag-conversion/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked의 문제입니다.4. 문제 해석 규칙을 이용해서 만든 문자열을 리턴합니다. 브루트 포스로는 힘들어보이고, 규칙이 있어서 그것을 이용합니다. 규칙은 Nums이 4가 들어올 경우 첫줄은 6 0 / 두번째 줄 4 2 / 세번째줄 2 4 / 네번째줄 0 6 이렇게 인덱스가 이동하고 Nums가 5인 경우 8 0 / 6 2 / 4 4 / 2 6 / 0 8 이런식으로 인덱스가 이동합니다.5. codeclass Solution {public: string convert(string s, int numRows) { //iter는 인덱스를 움직이기 위한 초기값입니다. int iter = (numRows-1)*2; //numRows가 1이거나 문자열보다 크면 그냥 문자열을 반환해야합니다. if(numRows==1 || numRows &amp;gt; s.size()) return s; string result=&quot;&quot;; for(int i = 0;i&amp;lt;numRows;++i) { //처음 접근하는 numRows는 넣어줍니다. result+=s[i]; // right는 왼쪽의 규칙성입니다. !8! 0 !6! 2.. 이런식으로 동작합니다. 코드를 쓰고나니 left와 right를 반대로 썼네요.. int right = iter-(i*2); // left는 right와 반대입니다. 8 !0! 6 !2! 이런식으로 동작합니다. int left = iter-right; //초기 인덱스값입니다. int index = i; //문자열을 넘지 않도록 잘 조절합니다. for(;index&amp;lt;s.size();) { //항상 넘지 않도록 조건문을 달아줍니다. if(s.size()&amp;lt;=index+right) break; //0인경우는 더해봤자 중복값이 들어가므로 무시합니다. if(right!=0 &amp;amp;&amp;amp; s[index+right]!=&#39; &#39;) result+=s[index+right]; index+=right; if(s.size()&amp;lt;=index+left) break; if(left!=0 &amp;amp;&amp;amp; s[index+left]!=&#39; &#39;) { result+=s[index+left]; } index+=left; } } return result; }};6. 결과 및 후기, 개선점시간(89%)시간 0ms(100%)코드class Solution {public: string convert(string s, int numRows) { //크기가 1인 경우 리턴 if( 1 == numRows) return s; size_t input_size = s.size(); string result(input_size,0); //functionSwitch는 어느 시점에서 배열의 인덱스를 넘을 지 모르므로 관리하는 boolean타입의 변수입니다. bool functionSwitch = true; //output_counter는 s의 인덱스를 관리합니다. size_t output_counter = 0; //input_counter는 result의 인덱스를 관리합니다. size_t input_counter = 0; for(int row_counter = 1; row_counter &amp;lt;= numRows; row_counter++) { //첫 번째 규칙을 적굥합니다. functionSwitch = true; output_counter = row_counter - 1; while(output_counter &amp;lt; input_size) { //첫 번째 규칙 if(functionSwitch) { result[input_counter] = s[output_counter]; functionSwitch = false; // 위에서 설명한 numRows와 같은 경우는 중복값을 저장할 수 있으므로 생략합니다. if(row_counter == numRows) continue; //규칙 output_counter += 2*(numRows - row_counter); } else { result[input_counter] = s[output_counter]; functionSwitch = true; //중복값 무시 if(row_counter == 1) continue; //규칙 output_counter += 2*(row_counter - 1); } input_counter++; } } return result; }};" }, { "title": "leetcode(리트코드)2월08일 challenge284-Peeking Iterator", "url": "/posts/leetcode_Peeking_Iterator/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-02-16 16:20:00 +0900", "snippet": "leetcode February challenge08 - Peeking Iterator 문제입니다.1. 문제https://leetcode.com/problems/peeking-iterator/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.2월08일자 챌린지 문제입니다.4. 문제 해석 함수를 구현하는 문제인데, 동작방식에 대한 설명이 불친절한 것 같습니다. Discuss를 보고 이해했습니다.5. code/* * Below is the interface for Iterator, which is already defined for you. * **DO NOT** modify the interface for Iterator. * * class Iterator { * struct Data; * Data* data; * public: * Iterator(const vector&amp;lt;int&amp;gt;&amp;amp; nums); * Iterator(const Iterator&amp;amp; iter); * * // Returns the next element in the iteration. * int next(); * * // Returns true if the iteration has more elements. * bool hasNext() const; * }; */class PeekingIterator : public Iterator {public: PeekingIterator(const vector&amp;lt;int&amp;gt;&amp;amp; nums) : Iterator(nums) { // Initialize any member here. // **DO NOT** save a copy of nums and manipulate it directly. // You should only use the Iterator interface methods. } // Returns the next element in the iteration without advancing the iterator. int peek() { return Iterator(*this).next(); } // hasNext() and next() should behave the same as in the Iterator interface. // Override them if needed. int next() { return Iterator::next(); } bool hasNext() const { return Iterator::hasNext(); }};6. 결과 및 후기, 개선점Discuss를 봤으므로 적지 않습니다." }, { "title": "leetcode(리트코드)5-Longest Palindromic Substring", "url": "/posts/leetcode_Longest_Palindromic_Substring/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Like", "date": "2021-02-16 16:00:00 +0900", "snippet": "leetcode 5 - Longest Palindromic Substring 문제입니다.1. 문제https://leetcode.com/problems/longest-palindromic-substring/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked의 문제입니다.4. 문제 해석 부분 문자열의 회문을 찾는데 가장 길이가 긴 것을 찾아 리턴합니다. 어려워서 discuss를 봤습니다.5. codeclass Solution {public: string longestPalindrome(string s) { //사이즈가 작은게 들어오면 if (s.size()&amp;lt;=1) return s; int min_left=0; int max_len=1; int max_right=s.size()-1; //인덱스 mid를 기준으로 양쪽으로 검사를 한다. for (int mid=0;mid&amp;lt;s.size();){ int left=mid; int right=mid; //right는 오른쪽으로 가면서 검사하는데 +1과 같으면 오른쪽으로 이동해서 max_len값을 늘린다. 같으면 어쨋든 palindromic이다. while (right&amp;lt;max_right &amp;amp;&amp;amp; s[right+1]==s[right]) right++; // Skip duplicate characters in the middle //right로만으 일단 palindromic을 구했으므로 다음 루프때는 그보다 1 큰값에서 루프를 돌게 한다. mid=right+1; //for next iter //왼쪽으로 이동하면서 검사한다. while (right&amp;lt;max_right &amp;amp;&amp;amp; left&amp;gt;0 &amp;amp;&amp;amp; s[right+1]==s[left-1]){ right++; left--; } // Expand the selection as long it is a palindrom int new_len=right-left+1; //record best palindro cout&amp;lt;&amp;lt;new_len&amp;lt;&amp;lt;&quot;\\n&quot;; if (new_len&amp;gt;max_len){ min_left=left; max_len=new_len; } } return s.substr(min_left, max_len); }};6. 결과 및 후기, 개선점discuss를 봤으므로 올리지 않습니다." }, { "title": "leetcode(리트코드)3-Longest Substring Without Repeating Characters", "url": "/posts/leetcode_Longest_Substring_Without_Repeating_Characters/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Like", "date": "2021-02-16 07:10:00 +0900", "snippet": "leetcode 3 - Longest Substring without Repeating Characters 문제입니다.1. 문제https://leetcode.com/problems/longest-substring-without-repeating-characters/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked의 문제입니다.4. 문제 해석 중복되는 문자가 없는 가장 큰 문자열의 길이를 찾습니다.5. codec++class Solution {public: bool checkalpha[128]={false,}; int lengthOfLongestSubstring(string s) { int count = 0; int result = 0; for(size_t i=0;i&amp;lt;s.length();++i) { memset(checkalpha,false,sizeof(checkalpha)); string temp = &quot;&quot;; temp+=s[i]; count = 1; checkalpha[s[i]]=true; for(size_t j =i+1;j&amp;lt;s.length();++j) { if(checkalpha[s[j]]==true) break; else { temp+=s[j]; ++count; checkalpha[s[j]]=true; } } result = max(result,count); } return result; }};python밑의 개선 코드를 python으로 바꾸었습니다.class Solution: def lengthOfLongestSubstring(self, s: str) -&amp;gt; int: umap = {} maxlen = 0 left = 0 for right in range (0,len(s)): if umap.get(s[right]) != None: left = max(left,umap.get(s[right]) + 1) umap[s[right]] =right maxlen = max(maxlen,right-left+1) return maxlen 6. 결과 및 후기, 개선점시간(32%)4ms 코드(92%)class Solution {public: struct node{ int val = -1; }; int lengthOfLongestSubstring(string s) { int maxlen = 0; //해시맵을 선언합니다. unordered_map&amp;lt;char,node&amp;gt; umap; for(int right = 0, left = 0; right &amp;lt; s.length(); right++){ // Update left and right ptr //만약 right값이 이미 중복되어 들어온 값이라면 left를 바꿔줍니다. 다시 세줘야하기 때문 if(umap[s[right]].val != -1){ left = max(left,umap[s[right]].val + 1); } // Update the map //right값을 갱신합니다. umap[s[right]].val = right; // Calculate length til now - Local and global length maxlen = max(maxlen,right-left+1); } return maxlen; }};아무래도 2중 for문이 시간을 많이 잡아먹은 것 같습니다." }, { "title": "leetcode(리트코드)1-Two Sum", "url": "/posts/leetcode_Two_Sum/", "categories": "leetcode, Eazy", "tags": "leetcode, Top100Like, AlgorithmStudy", "date": "2021-02-16 06:10:00 +0900", "snippet": "leetcode 1 - Two Sum 문제입니다.1. 문제https://leetcode.com/problems/two-sum/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.leetcode Top 100 Liked의 문제입니다.4. 문제 해석 배열의 요소를 더해서 target을 만들 수 있으면 해당 인덱스를 벡터에 넣고 반환합니다. 답은 1가지로 주어지므로 찾으면 바로 리턴합니다.5. codec++class Solution {public: vector&amp;lt;int&amp;gt; twoSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { vector&amp;lt;int&amp;gt; result; for(size_t i=0;i&amp;lt;nums.size();++i) { for(size_t j = i+1; j&amp;lt;nums.size();++j) { if(nums[i] + nums[j]==target) { result.push_back(i); result.push_back(j); return result; } } } return result; }};pythonclass Solution: def twoSum(self, nums: List[int], target: int) -&amp;gt; List[int]: result=[] for i in range(len(nums)): for j in range(i+1,len(nums)): if nums[i] + nums[j] == target: result.append(i) result.append(j) return result6. 결과 및 후기, 개선점시간(100%)" }, { "title": "leetcode(리트코드)4-Meedian of Two Sorted Arrays", "url": "/posts/leetcode_Median_of_Two_Sorted_Arrays/", "categories": "leetcode, Hard", "tags": "leetcode, Top100Like", "date": "2021-02-16 01:00:00 +0900", "snippet": "leetcode 4 - Median of Two Sorted Arrays 문제입니다.1. 문제https://leetcode.com/problems/median-of-two-sorted-arrays/2. Input , Output3. 분류 및 난이도Hard 난이도 문제입니다.leetcode Top 100 Liked의 문제입니다.4. 문제 해석 이미 정렬된 2개의 배열을 Merge Sort를 합니다. Sort를한 결과의 mid값을 리턴합니다. 만약 배열의 크기가 짝수인 경우 mid-1까지 더해서 평균값을 리턴합니다.5. codeclass Solution {public: double findMedianSortedArrays(vector&amp;lt;int&amp;gt;&amp;amp; nums1, vector&amp;lt;int&amp;gt;&amp;amp; nums2) { //n과 m은 들어온 배열의 크기 int n = nums1.size(); int m = nums2.size(); int mid = (n+m)/2; //check는 배열의 총 크기가 짝수인 경우, 홀수인 경우 판단을 위해 넣었습니다. bool check = (n+m)%2; double result = 0; vector&amp;lt;int&amp;gt; vec; int i = 0; int j = 0; //병합정렬 while(i&amp;lt;n &amp;amp;&amp;amp; j&amp;lt;m) { //mid+1까지만 정렬하면 됩ㄴ디ㅏ. if(vec.size()==mid+1) break; if(nums1[i] &amp;lt; nums2[j]) vec.push_back(nums1[i++]); else vec.push_back(nums2[j++]); } int tmp = i &amp;gt; m ? j : i; while(i&amp;lt;n&amp;amp;&amp;amp; vec.size()!=mid+1) { vec.push_back(nums1[i++]); } while(j&amp;lt;m&amp;amp;&amp;amp; vec.size()!=mid+1) vec.push_back(nums2[j++]); //만약 배열의 총 크기가 짝수면 if(!check) { return (vec[mid] + vec[mid-1])/2.0; } return vec[mid]; }};6. 결과 및 후기, 개선점시간(86%)시간이 빠른 코드(12ms) 99%class Solution {public: double findMedianSortedArrays(vector&amp;lt;int&amp;gt;&amp;amp; a1, vector&amp;lt;int&amp;gt;&amp;amp; a2) { int n1 = a1.size(), n2 = a2.size(); if(n1 == 0 &amp;amp;&amp;amp; n2 == 0) return 0; vector&amp;lt;int&amp;gt; v(n1+n2); int i1=0,i2=0,k=0; while(i1&amp;lt;n1 &amp;amp;&amp;amp; i2&amp;lt;n2){ if(a1[i1] &amp;lt; a2[i2]){ v[k++] = a1[i1++]; } else{ v[k++] = a2[i2++]; } } while(i1&amp;lt;n1){ v[k++] = a1[i1++]; } while(i2&amp;lt;n2){ v[k++] = a2[i2++]; } if((n1+n2) %2 == 0){ int i = (n1+n2)/2, j = (n1+n2)/2 -1; return (v[i] + v[j])/2.0; } else{ return v[(n1+n2)/2]; } }};로직은 저와 똑같고 저와달리 배열의 끝까지 합병한다는 점에서 시간이 더 들거라 생각했습니다." }, { "title": "HTTP - 7 HTTP 헤더 1(1)", "url": "/posts/HTTP07/", "categories": "HTTP, 김영한_모든 개발자를 위한 HTTP 웹 기본 지식", "tags": "HTTP", "date": "2021-02-15 23:00:00 +0900", "snippet": "해당 자료는 인프런 김영한 선생님의 모든 개발자를 위한 HTTP 웹 기본 지식 강의노트입니다.1. HTTP 헤더 개요Contnet-Type에는 메시지 바디의 내용, 크기, 압축 등 정보가 들어있습니다.필요시에는 임의의 헤더 추가가 가능합니다.과거에는 RFC2616이라는 표준을 사용했는데, 이 표준의 스펙은 다음과 같습니다. General 헤더 : 메시지 전체에 적용되는 정보 Request 헤더 : 요청 정보 Response 헤더 : 응답 정보 Entity 헤더 : 엔티티 바디 정보 메시지 본문은 엔티티 본문을 전달하는 데 사용됩니다. 엔티티 본문은 요청이나 응답에서 전달할 실제의 데이터입니다. 엔티티 헤더는 엔티티 본문의 데이터를 해석할 수 있는 정보를 제공합니다.(데이터 유형, 길이, 정보)하지만, 위의 스펙은 2014년 RFC7230~7235 등장으로 폐기되었습니다.엔티티를 표현이라고 부르게 되었습니다.표현(Representation)은 representation Metadata + Representation Data,표현 = 표현 메타데이터 + 표현 데이터입니다. 메시지 본문을 통해 표현 데이터을 전달합니다. 메시지 본문을 페이로드(Payload)라고도 불립니다. 표현은 요청이나 응답에서 전달할 실제 데이터이고 Json,HTML 형식 등으로 보낼 수 있습니다. 표현 헤더는 표현 데이터를 해석할 수 있는 정보를 제공합니다.(유형, 길이, 정보 등)2. 표현 Content-Type : 표현 데이터의 형식 (Json,HTML,png 등) Content-Encoding : 표현 데이터의 압축 방식(보통 데이터를 전달하는 쪽에서 압축 후 인코딩 헤더 추가하고 데이터를 읽는 쪽에서 인코딩 헤더의 정보를 가지고 압축을 해제합니다.)gzip, deflate, identity(압축 해제 안함) Content-Language표현 데이터의 자연 언어를 표현합니다.예를 들어서 한국에서 영어 사이트를 들어가면 서버에서 한국번역 여부를 물어보는 처리에 사용될 수 있습니다. Content-Length표현 데이터의 길이입니다.Transfer-Encoding(전송 코딩)을 사용하면 Content-Length를 사용하면 안됩니다. 전송 코딩 내부에 이미 정의되어있기 때문입니다.3. 협상(콘텐츠 네고시에이션)클라이언트가 선호하는 표현방식을 클라이언트가 요청하는 방식을 말합니다. Accept : 클라이언트가 선호하는 미디어 타입 전달 Accept-Charset : 클라이언트가 선호하는 문자 인코딩 Accept-Encoding : 클라이언트가 선호하는 압축 인코딩 Accept-Language : 클라이언트가 선호하는 자연 언어협상 헤더는 요청시에만 사용합니다.위의 예시와 같이 ko라는 언어를 요청할 때 서버에서 지원하는 언어면 해당 언어로 페이지를 뿌려주는 역할을 합니다.헤더에서 지원하는 기능입니다.만약 서버에서 지원하지 않는 언어를 요청했을 때에는 다음과 같은 우선순위를 따릅니다. ko-KR 은 1이 생략된 것입니다. ko;q=0.9는 ko라는 언어에 대해 0.9의 우선순위를 갖습니다. en-US;q=0.8 또한 마찬가지입니다.구글에 임창정을 검색했을 때 나오는 네트워크 도구입니다.헤더쪽을 보면 Accept 헤더가 있는걸 볼 수 있습니다.Accept는 또한 구체적인 것을 우선순위로 갖습니다. text/plain;format=flowed 가 우선순위 1번째 text/plain이 우선순위 2번째 text/이 우선순위 3번째 (은 아무 파일 디렉터리 등입니다.) */ * 우선순위 4번째또한 구체적인 것을 기준으로 미디어 타입을 맞춥니다.text/plain은 위의 헤더에서 명시가 되지 않았지만 text/*;q=0.3을 따라 0.3의 우선순위를 갖습니다.4. 전송 방식전송 방식에는 4가지가 있습니다. 단순 전송(Content-Length) 압축 전송(Content-Encoding) 분할 전송(Transfer-Encoding) 범위 전송(Range,Content-Range)단순 전송클라이언트에서 요청을 보내고 서버에서 응답을할 때 해당 컨텐츠에 대한 길이를 알 때 길이를 보냅니다.한번에 처리하는 방식입니다.압축 전송서버에서 압축을해서 컨텐츠를 보낼 때 Content-Encoding을 추가로 넣어줘서 압축 정보와 길이를 보냅니다.분할 전송분할해서 정보를 전달합니다. 분할해서 보내기 때문에 응답이 빠르고 Content-Length를 알 수 없어서 Content-Length를 포함하면 안됩니다.범위 전송범위를 정해서 받을 수 있습니다. 실제 전송된 데이터의 길이를 Content-Length를 포함해서 전달하면 됩니다.(예제에서는 써있지 않습니다.)" }, { "title": "leetcode(리트코드)2월15일 challenge1337-The K Weakest Rows in a Matrix", "url": "/posts/leetcode_The_K_Weakest_Rows_in_a_Matrix/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-02-15 18:10:00 +0900", "snippet": "leetcode February challenge1337 - The K Weakest 문제입니다.1. 문제https://leetcode.com/problems/the-k-weakest-rows-in-a-matrix/2. Input , Output3. 분류 및 난이도Eazy 난이도입니다.2월15일자 챌린지 문제입니다.4. 문제 해석 K번째로 약한 열까지 찾아 벡터에 넣어 리턴하는 것입니다. 1은 군인이고 0은 민간인으로 행의 군사의 수가 작을수록 약한 행입니다.5. codebool pred(pair&amp;lt;int,int&amp;gt; a,pair&amp;lt;int,int&amp;gt; b){ if(a.second==b.second) return a.first&amp;lt;b.first; return a.second &amp;lt; b.second;}class Solution {public: vector&amp;lt;int&amp;gt; kWeakestRows(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; mat, int k) { vector&amp;lt;int&amp;gt; result; vector&amp;lt;pair&amp;lt;int,int&amp;gt;&amp;gt; vec; for(size_t i = 0;i&amp;lt;mat.size();++i) { int sum = 0; for(size_t j =0;j&amp;lt;mat[i].size();++j) { if(mat[i][j]==1) ++sum; } vec.push_back(make_pair(i,sum)); } sort(vec.begin(),vec.end(),pred); for(int i=0;i&amp;lt;k;++i) { result.push_back(vec[i].first); } return result; }};6. 결과 및 후기, 개선점시간(96%)" }, { "title": "leetcode(리트코드)2월07일 challenge821-Shortest Distance to a Character", "url": "/posts/leetcode_Shortest_Distance_to_a_Character/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-02-15 17:00:00 +0900", "snippet": "leetcode February challenge07 - Shortest Distance to a character 문제입니다.1. 문제https://leetcode.com/problems/shortest-distance-to-a-character/2. Input , Output3. 분류 및 난이도Eazy 난이도입니다.2월07일자 챌린지 문제입니다.4. 문제 해석 c로 들어온 문자를 기준으로 각 인덱스마다 가장 가까운 c를 찾고 거리를 벡터에 넣어 반환합니다.5. codeclass Solution {public: //들어온 문자의 위치를 담는 벡터 vector&amp;lt;int&amp;gt; findindex; //절대값으로 변환하는 함수 int abs(int x) { return x &amp;lt;0 ? -x : x; } vector&amp;lt;int&amp;gt; shortestToChar(string s, char c) { //결과 벡터 vector&amp;lt;int&amp;gt; result; //문자열을 돌면서 c와 같으면 문자의 위치를 담습니다. for(size_t i =0;i&amp;lt;s.size();++i) { if(s[i]==c) findindex.push_back(i); } int i = 0; int temp; //문자열을 다 돌때까지 for(int j = 0; j&amp;lt;s.size() &amp;amp;&amp;amp; i&amp;lt;findindex.size();++j) { //i+1을 접근해야합니다. 범위를 넘지않는 한에서 검사를 하고, 만약 다음 문자열의 위치가 더 작아지는 순간이 오면 다음 문자열의 위치를 가리키게 합니다. if(i+1 &amp;lt;findindex.size() &amp;amp;&amp;amp; abs(findindex[i]-j)&amp;gt;abs(findindex[i+1]-j) ) ++i; //분기를 나누는 이유는 i+1이 인덱스 범위를 벗어나는 경우가 있기에 처리를 해줬습니다. if(i+1&amp;lt;findindex.size()) temp= min(abs(findindex[i]-j),abs(findindex[i+1]-j)); else temp = abs(findindex[i]-j); result.push_back(temp); } return result; } };6. 결과 및 후기, 개선점시간(57%)0ms 코드(100%)class Solution {public: vector&amp;lt;int&amp;gt; shortestToChar(string s, char c) { int N = s.length(); vector&amp;lt;int&amp;gt; ans(N,0); int prev =INT_MIN/2; for (int i = 0; i &amp;lt; N; ++i) { if (s[i] == c) prev = i; ans[i] = i - prev; } prev = INT_MAX/2; for (int i = N-1; i &amp;gt;= 0; --i) { if (s[i] == c) prev = i; ans[i] = min(ans[i], prev - i); } return ans; }};위 코드는 한번 i=0부터 끝까지 훑어서 값을 넣고,i= N-1(맨 끝)부터 i=0까지 다시 훑어서 작은 값을 넣습니다." }, { "title": "leetcode(리트코드)70-Climbing Stairs", "url": "/posts/leetcode_Climbing_Stairs/", "categories": "leetcode, Eazy", "tags": "leetcode, Top100Like", "date": "2021-02-15 15:10:00 +0900", "snippet": "leetcode 70 - Climbing Stairs문제입니다.1. 문제https://leetcode.com/problems/climbing-stairs/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.leetcode Top 100 Liked의 문제입니다.4. 문제 해석 간단한 DP 문제입니다. 1step과 2step으로 계단을 올라갈 때 n에 도달하는 경우의 수 입니다.5. codeclass Solution {public: int climbStairs(int n) { int DP[46]={0,}; if(n==1) return 1; DP[0]=1; DP[1]=1; for(int i=2;i&amp;lt;=n;++i) { DP[i]= DP[i-2] + DP[i-1]; } return DP[n]; }};6. 결과 및 후기, 개선점시간(67%)위의 점화식은n=4라고 하면DP[i-2]는 DP[2]로 (1+1, 2)라는 경우의 수가 저장되어 있습니다. DP[i-1]은 DP[3]으로 (1+1+1,2+1,1+2)라는 경우의 수가 들어있습니다.DP[2]의 경우의 수에 +2를 해준 경우의 수 (1+1+2,2+2)와DP[3]의 경우의 수에 +1를 해준 경우의 수 (1+1+1+1,2+1+1,1+2+1)의 경우의 수를 합친 5가 DP[4]가 됩니다." }, { "title": "leetcode(리트코드)2월 06일 challenge199-Binary Tree Right Side View", "url": "/posts/leetcode_Binary_Tree_Right_Side_View/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Like", "date": "2021-02-15 15:00:00 +0900", "snippet": "leetcode 199 - Binary Tree Right Side View문제입니다.1. 문제https://leetcode.com/problems/binary-tree-right-side-view/2. Input , OutputConstraints: The number of nodes in the tree is in the range [0, 100]. -100 &amp;lt;= Node.val &amp;lt;= 100 3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked의 문제입니다.또한 2월 6일 Challenge 문제입니다.4. 문제 해석 오른쪽에서 트리를 봤을 때의 모습, 위 노드 -&amp;gt; 밑 노드 값을 벡터에 넣어 리턴합니다.예를 들어 1,2,3,4 가 주어지면 1,3,4를 리턴해야합니다.5. code/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: vector&amp;lt;int&amp;gt; result; bool depth[101]; void order(TreeNode* root,int _depth) { if(root-&amp;gt;right!=nullptr) { if(depth[_depth]==false) { result.push_back(root-&amp;gt;right-&amp;gt;val); depth[_depth]=true; } order(root-&amp;gt;right,_depth+1); } if(root-&amp;gt;left!=nullptr) { if(depth[_depth]==false) { result.push_back(root-&amp;gt;left-&amp;gt;val); depth[_depth]=true; } order(root-&amp;gt;left,_depth+1); } } vector&amp;lt;int&amp;gt; rightSideView(TreeNode* root) { memset(depth,false,sizeof(depth)); if(root!=nullptr) { result.push_back(root-&amp;gt;val); depth[0]=true; order(root,1); } return result; }};6. 결과 및 후기, 개선점시간(67%)0ms(100%) 코드/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: vector&amp;lt;int&amp;gt; rightSideView(TreeNode* root) { if(root == NULL) return vector&amp;lt;int&amp;gt; {}; vector&amp;lt;int&amp;gt; res, v; queue&amp;lt;TreeNode*&amp;gt; q; q.push(root); q.push(NULL); while(q.size() &amp;gt; 1) { TreeNode* curr = q.front(); q.pop(); if(curr == NULL) { q.push(NULL); res.push_back(v[v.size() - 1]); v.clear(); continue; } v.push_back(curr-&amp;gt;val); if(curr-&amp;gt;left) q.push(curr-&amp;gt;left); if(curr-&amp;gt;right) q.push(curr-&amp;gt;right); } res.push_back(v[v.size() - 1]); return res; }};이 코드에서 NULL을 넣는 이유는 구분하기 위해서입니다.예를 들어서 1,2,3,4가 들어오면 1 NULL 2 3 NULL 4 이렇게 구분하여 NULL보다 한단계 이전값을 vector에 너헝 반환합니다." }, { "title": "leetcode(리트코드)102-Binary Tree Level Order Traversal", "url": "/posts/leetcode_Binary_Tree_Level_Order_Traversal/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Like", "date": "2021-02-15 14:00:00 +0900", "snippet": "leetcode 102 - Binary Tree Level Order Traversal 문제입니다.1. 문제https://leetcode.com/problems/binary-tree-level-order-traversal/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked의 문제입니다.4. 문제 해석 트리를 level별로 2차원vector에 넣어 반환해야합니다.5. code/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: //결과 벡터 vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; order(TreeNode* root,int count) { if(root!=nullptr) { //만약 처음 들어온 깊이라면 vector를 생성하여 result 벡터에 넣어줍니다. if(count&amp;gt;result.size()) { vector&amp;lt;int&amp;gt; temp; temp.push_back(root-&amp;gt;val); result.push_back(temp); } //처음 들어온 깊이가 아니라면 기존 vector가 있다는 것이므로 결과값에 넣습니다. else result[count-1].push_back(root-&amp;gt;val); order(root-&amp;gt;left,count+1); order(root-&amp;gt;right,count+1); } return result; } vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; levelOrder(TreeNode* root) { result = order(root,1); return result; }};6. 결과 및 후기, 개선점시간(8%)이게 왜 8%가 나오는 지 몰라서 Discuss에 올렸습니다.0ms(100%) 코드/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; levelOrder(TreeNode* root) { //결과 벡터 vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; //Node를 담을 큐 queue&amp;lt;TreeNode*&amp;gt; q_node; if (root == NULL) { return {}; } //root가 null이 아니라면 queue에 넣습니다. q_node.push(root); while (!q_node.empty()) { vector&amp;lt;int&amp;gt; level_nodes; int size = q_node.size(); for (int i = 0; i &amp;lt; size; i++) { //tmp는 임시 노드입니다. TreeNode* tmp = q_node.front(); //임시 노드를 벡터에 넣습니다. level_nodes.push_back(tmp-&amp;gt;val); //left가 비어있지 않으면 큐에 넣고 if (tmp-&amp;gt;left != NULL) { q_node.push(tmp-&amp;gt;left); } //right가 비어있지 않으면 마찬가지로 큐에 넣습니다. if (tmp-&amp;gt;right != NULL) { q_node.push(tmp-&amp;gt;right); } // Don&#39;t forget to pop q_node INSIDE the for loop after visit it. q_node.pop(); } res.push_back(level_nodes); } return res; }};자식들을 한번에 넣고 처리하는 방식입니다. queue를 쓰는 방법을 배웠습니다. queue에는 예제 기준으로 3, 9, 20, 15, 7 이렇게 배열처럼 들어갈 것입니다." }, { "title": "leetcode(리트코드)94-Binary Tree Inorder Traversal", "url": "/posts/leetcode_Binary_Tree_Inorder_Traversal/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Like", "date": "2021-02-15 13:00:00 +0900", "snippet": "leetcode 94 - Binary Tree Inorder Traversal 문제입니다.1. 문제https://leetcode.com/problems/binary-tree-inorder-traversal/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked의 문제입니다.4. 문제 해석 특별할 게 없는 Inorder 문제입니다.5. code/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: vector&amp;lt;int&amp;gt; result; vector&amp;lt;int&amp;gt; inorderTraversal(TreeNode* root) { if(root!=nullptr) { inorderTraversal(root-&amp;gt;left); result.push_back(root-&amp;gt;val); inorderTraversal(root-&amp;gt;right); } return result; }};6. 결과 및 후기, 개선점시간(100%)" }, { "title": "leetcode(리트코드)2월05일 challenge71-Simplify Path", "url": "/posts/leetcode_Simplify_Path/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-02-14 18:10:00 +0900", "snippet": "leetcode February challenge05 - Simplify Path 문제입니다.1. 문제https://leetcode.com/problems/simplify-path/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.2월05일자 챌린지 문제입니다.4. 문제 해석 주어진 규칙에 맞게 path를 바꿔 return해야합니다. 영어에 약해서 처리하지 못할 예외가 많아질까봐 설명을 보고 공부했습니다.5. codeclass Solution {public: string simplifyPath(string path) { //result는 결과 //tmp는 부분 문자열을 담기위해 string result, tmp; //tmp를 저장할 벡터 vector&amp;lt;string&amp;gt; tmpvec; //문자열을 자를 수 있게 도와줍니다. stringstream str(path); // &#39;/&#39;을 기준으로 잘브니다. while(getline(str,tmp,&#39;/&#39;)) { //.이나 공백이 들어올 경우 무시합니다. if(tmp ==&quot;.&quot; || tmp==&quot;&quot;) continue; //&quot;..&quot;이 들어올 경우 만약 tmp저장벡터에 무언가 있으면 빼버립니다. if(tmp==&quot;..&quot; &amp;amp;&amp;amp; !tmpvec.empty()) tmpvec.pop_back(); //&quot;..이 들어온게 아니라면 벡터에 넣습니다. else if(tmp!=&quot;..&quot;) tmpvec.push_back(tmp); } //벡터를 끄집어내면서 &#39;/&#39;를 붙여주면서 결과에 넣어줍니다. for(auto i : tmpvec) { result+= (&quot;/&quot; + i ); } //만약 결과가 비어있다면 &#39;/&#39;를 출력합니다. if(result.empty()) { result +=&#39;/&#39;; } return result; }};6. 결과 및 후기, 개선점시간솔루션을 보고 풀었기에 x" }, { "title": "leetcode(리트코드)2월14일 challenge785-Is Graph Bipartite?", "url": "/posts/leetcode_Is_Graph_Bipartite/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-02-14 18:00:00 +0900", "snippet": "leetcode February challenge14 - Is Graph Bipartite ? 문제입니다.1. 문제https://leetcode.com/problems/is-graph-bipartite/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.2월14일자 챌린지 문제입니다.4. 문제 해석 간단하게 이분 그래프 판별 문제입니다. 백준에 똑같은 문제가 있습니다.https://kkminseok.github.io/posts/baekjoon1707/5. codeint MAP[101]={0,};class Solution {public: bool BFS(int start, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; graph) { queue&amp;lt;int&amp;gt; q; q.push(start); MAP[start] = 1; while (!q.empty()) { int curr = q.front(); q.pop(); for (int i = 0; i &amp;lt; graph[curr].size(); ++i) { int ver = graph[curr][i]; if (MAP[ver] != 0)//방문기록이 있음. { if (MAP[curr] == MAP[ver])//색이 같다. { return false; } } else { q.push(ver); MAP[ver] = 3 - MAP[curr]; } } } return true; } bool isBipartite(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; graph) { bool result = true; memset(MAP,0,sizeof(MAP)); for(size_t i =0;i&amp;lt;graph.size();++i) { if(MAP[i]==0) { result = BFS(i,graph); cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&quot; &quot;&amp;lt;&amp;lt;result&amp;lt;&amp;lt;&#39;\\n&#39;; if(result==false) return result; } } return result; }};6. 결과 및 후기, 개선점시간(96%)" }, { "title": "leetcode(리트코드)121-Best Time to Buy and Sell Stock", "url": "/posts/leetcode_Best_Time_to_Buy_and_Sell_Stock/", "categories": "leetcode, Eazy", "tags": "leetcode, Top100Like", "date": "2021-02-14 16:00:00 +0900", "snippet": "leetcode 121 - Best Time to Buy and Sell Stock 문제입니다.1. 문제https://leetcode.com/problems/best-time-to-buy-and-sell-stock/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.leetcode Top 100 Liked의 세 번째 문제입니다.4. 문제 해석 배열을 돌면서 물건을 살 때와 물건을 팔 때를 정하여 최대 이익을 구하고 그 값을 리턴합니다. 지나온 날로 돌아가 물건을 팔 수 없습니다. 배열의 크기가 10^5이므로 for문을 두 번 쓰면서 순차탐색으로는 문제를 풀 수 없습니다. 지나오면서 최소값을 저장하면 되고 최소값을 뺐을 때의 결과 값을 저장하여 비교하면 풀 수 있습니다.5. codeclass Solution {public: int maxProfit(vector&amp;lt;int&amp;gt;&amp;amp; prices) { int result = 0; int minprice = INT_MAX; for(size_t i =0;i&amp;lt;prices.size();++i) { minprice= min(minprice,prices[i]); result = max(result, prices[i]-minprice); } return result; }};6. 결과 및 후기, 개선점시간(40%)빠른 시간 코드(0ms 99%)class Solution {public: int maxProfit(vector&amp;lt;int&amp;gt;&amp;amp; p) { if(p.size()&amp;lt;=1) return 0; int mn=p[0],prof=0,n=p.size(); for(int i=1;i&amp;lt;n;i++) { mn=min(mn,p[i]); prof=max(prof,p[i]-mn); } return prof; }};똑같은데..? 뭐지" }, { "title": "leetcode(리트코드)2-Add Two Numbers", "url": "/posts/leetcode_Add_Two_Numbers/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Like", "date": "2021-02-14 15:00:00 +0900", "snippet": "leetcode 2 - Add Two Numbers 문제입니다.1. 문제https://leetcode.com/problems/add-two-numbers/2. Input , OutputConstraints: The number of nodes in each linked list is in the range [1, 100]. 0 &amp;lt;= Node.val &amp;lt;= 9 It is guaranteed that the list represents a number that does not have leading zeros.3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked의 두 번째 문제입니다.4. 문제 해석 영어를 잘 못해서 해석에서 고생을 좀 했습니다. 일단 int형이든 long long형이든 단순계산으로 풀기는 힘듭니다. 최대 100자리까지 들어오므로 표현할 수 있는 bit수를 넘어버리기 때문입니다. 그래서 string으로 표현하여 계산하기로 생각했습니다. input으로 처음에 ‘0’이 안들어올 줄 알았는데 들어오길래 해맸습니다.. 아무튼 string으로 바꿔서 자릿수 하나하나 더해줬습니다. 만약 어떤 짧은 문자열을 먼저 돌았으면 나머지 문자열을 List에 추가하기 위해 while문을 만들고 만약 돌았음에도 불구하고 carry가 남는다면 처리해주는 로직으로 짰습니다.5. code/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode* result = new ListNode(0); ListNode* location=result; string x = &quot;&quot;; string y = &quot;&quot;; while(l1!=nullptr) { x+=(to_string(l1-&amp;gt;val)); l1=l1-&amp;gt;next; } while(l2!=nullptr) { y += (to_string(l2-&amp;gt;val)); l2=l2-&amp;gt;next; } int i = 0; int j = 0; int carry=0; while(i&amp;lt;x.size() &amp;amp;&amp;amp; j&amp;lt; y.size()) { int sum = (x[i]-&#39;0&#39;) + (y[i]-&#39;0&#39;)+carry; carry= sum/10; sum%=10; ListNode* newNode = new ListNode(sum); result-&amp;gt;next= newNode; result=result-&amp;gt;next; cout&amp;lt;&amp;lt;sum&amp;lt;&amp;lt;&#39;\\n&#39;; ++i; ++j; } cout&amp;lt;&amp;lt;&quot;dasd&quot;&amp;lt;&amp;lt;carry&amp;lt;&amp;lt;&#39;\\n&#39;; while(j&amp;lt;y.size()) { int sum = (y[j]-&#39;0&#39;) + carry; carry= sum/10; sum%=10; cout&amp;lt;&amp;lt;sum&amp;lt;&amp;lt;&#39;\\n&#39;; ListNode* newNode = new ListNode(sum); result-&amp;gt;next= newNode; result=result-&amp;gt;next; ++j; } while(i&amp;lt;x.size()) { int sum = (x[i]-&#39;0&#39;) + carry; carry= sum/10; sum%=10; cout&amp;lt;&amp;lt;sum&amp;lt;&amp;lt;&#39;\\n&#39;; ListNode* newNode = new ListNode(sum); result-&amp;gt;next= newNode; result=result-&amp;gt;next; ++i; } if(carry!=0) { ListNode* newNode = new ListNode(1); result-&amp;gt;next= newNode; result=result-&amp;gt;next; } return location-&amp;gt;next; }};python개선된 코드를 python으로 재작성 하였습니다.# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&amp;gt; ListNode: sum = 0 carry = 0 x1 = ListNode() x2 = ListNode() x3 = ListNode() x3 = l1 while(l1 != None or l2!=None or carry != 0): if(l1==None): l1 = ListNode(0) x1.next=l1 if(l2==None): l2 = ListNode(0) x2.next=l2 sum= l1.val + l2.val +carry carry = sum//10 l1.val = sum%10 x1=l1 x2=l2 l1=l1.next l2=l2.next return x3 6. 결과 및 후기, 개선점시간(89%)빠른 코드를 보니 포인터를 좀 더 잘 활용했으면 쉽게 풀었을 것이라는 생각을 했습니다.. ㅠ처음에는 재귀를 생각하긴 했는데, 짜다가 골치아파서 포기했습니다.빠른 시간 코드(4ms 99%)/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { int sum=0, carry=0; ListNode *x1, *x2, *x3; //x3이 가리킴 x3=l1; //들어온 리스트들이 null이 아니고 carry가 0이아니면 while(l1!=NULL||l2!=NULL||carry!=0){ //만약 빈 리스트를 가리키고 있으면 임의로 0을 넣어버려서 계산하기 쉽게(0+어떤 수) 만들어버림!! if(l1==NULL){ l1=new ListNode(0); x1-&amp;gt;next=l1; } if(l2==NULL){ l2=new ListNode(0); x2-&amp;gt;next=l2; } //계산하는 과정 sum=l1-&amp;gt;val+l2-&amp;gt;val+carry; carry=sum/10; l1-&amp;gt;val=sum%10; //x1, x2는 l1,l2의 다음 노드를 가리킨다. x1=l1; x2=l2; l1=l1-&amp;gt;next; l2=l2-&amp;gt;next; } return x3; }};" }, { "title": "leetcode(리트코드)15-3Sum", "url": "/posts/leetcode_3Sum/", "categories": "leetcode, Medium", "tags": "leetcode, Top100Like", "date": "2021-02-14 13:00:00 +0900", "snippet": "leetcode 15 - 3Sum 문제입니다.1. 문제https://leetcode.com/problems/3sum/2. Input , Output3. 분류 및 난이도Medium 난이도 문제입니다.leetcode Top 100 Liked의 첫 번째 문제입니다.4. 문제 해석 세 숫자의 합이 0이되는 세 숫자를 찾고 result vector에 넣어야합니다. 중복이 있으면 안됩니다. 중복 처리를 해주느라 시간을 많이써서 솔루션을 보고 이해했습니다. 정렬을 해준 뒤 앞의 원소를 c를 두고 앞 뒤에서 합을 이용해 찾습니다.5. codeclass Solution {public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; threeSum(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result; sort(nums.begin(),nums.end()); for(size_t i=0;i&amp;lt;nums.size();++i) { int target = -nums[i]; int front = i+1; int back = nums.size()-1; //모두 양수로 들어올 경우 if(target &amp;lt;0) break; else { while(front&amp;lt;back) { int sum = nums[front] + nums[back]; if(target&amp;gt;sum) ++front; else if(target&amp;lt;sum) --back; //같은 경우 else { vector&amp;lt;int&amp;gt; temp(3,0); temp[0] = nums[i]; temp[1] = nums[front]; temp[2] = nums[back]; result.push_back(temp); //[-2,0,0,2,2] //-2 target index(1) 0 = front index(4) 2 = back인 경우 -2,0,2 추가되는데 밑의 처리를 해주지 않으면 그 다음 인덱스인 (2) 0 = front (3) 2 = back이 또 다시 중복으로 들어가게됨. while(front&amp;lt;back &amp;amp;&amp;amp; nums[front] == temp[1]) ++front; while(front&amp;lt;back &amp;amp;&amp;amp; nums[back] == temp[2])--back; } } while(i+1&amp;lt;nums.size() &amp;amp;&amp;amp; nums[i+1] == nums[i]) ++i; } } return result; }};6. 결과 및 후기, 개선점시간솔루션을 보았으니 사진을 넣지 않겠습니다." }, { "title": "HTTP - 6 HTTP 상태 코드", "url": "/posts/HTTP06/", "categories": "HTTP, 김영한_모든 개발자를 위한 HTTP 웹 기본 지식", "tags": "HTTP", "date": "2021-02-14 01:00:00 +0900", "snippet": "해당 자료는 인프런 김영한 선생님의 모든 개발자를 위한 HTTP 웹 기본 지식 강의노트입니다.1. HTTP 상태코드 소개상태코드란 클라이언트가 보낸 요청의 처리 상태를 응답해서 알려주는 기능을 말합니다. 1xx(Informational) : 요청이 수신되어 처리중 2xx(Successful) : 요청 정상 처리 3xx(Redirection) : 요청을 완료하려면 추가 행동이 필요 4xx(Client Error) : 클라이언트 오류, 잘못된 문법등으로 서버가 요청을 수행할 수 없을 때 5xx(Server Error) : 서버 오류, 서버가 정상 요청을 처리하지 못함.만약 모르는 상태 코드가 나타나면?예를 들어 299라던지 451같은 상태코드가 나타나면 상위상태코드로 이해하면 됩니다.299는 2xx니까 요청이 정상처리된 것.451은 4xx니까 클라이언트 오류라고 생각하시면 됩니다.1xx(Informational)요청이 수신되어 처리중거의 사용하지 않으므로 생략합니다.2. 2xx(Successful) 200 OK 201 Created 202 Accepted 204 No Content200 OK요청 성공입니다.제일 많이 접할 수 있는 요청상태입니다.201 Created요청이 성공해서 새로운 리소스가 생성된 것입니다.서버에서는 Location이라는 것에 정보를 반환합니다.202 Accepted요청이 접수되었지만 처리가 되지 않은 것입니다.보통 배치 처리같이 1시간 뒤에 처리해야하는 작업 등에 사용됩니다.204 No Content서버가 요청을 성공적으로 수행했지만, 응답 페이로드 본문에 보낼 데이터가 없을 때입니다.예를 들어 웹 문서 편집기에서 save 버튼을 누르면 서버에서 보낼 데이터가 없으므로 No Content을 사용하면 됩니다.물론 성공 실패 여부는 개발자가 직접 정해줘야합니다.3. 3xx - 리다이렉션리다이렉션은 요청이 들어왔을 때 추가적인 조치가 필요할 때 씁니다. 300 Multiple Choices 301 Moved Permanently 302 Found 303 See Other 304 Not Modified 307 Temporary Redirect 308 Permanent Redirect리다이렉션웹 브라우저는 3xx 응답의 결과에 Location 헤더가 있으면 Location 위치로 자동이동합니다.리다이렉션은 3가지 종류가 있습니다. 영구 리다이렉션 - 특정 리소스의 URI가 영구적으로 이동 /members -&amp;gt; /users /event -&amp;gt; /new-event 일시 리다이렉션 - 일시적인 변경 주문 완료 후 주문 내역 화면으로 이동 PRG: Post/Redirect/Get &amp;lt;- 뒤에서 설명하겠습니다. 특수 리다이렉션 결과 대신 캐시를 사용. 영구 리다이렉션301, 308입니다.위의 예시처럼 리소스의 URI가 영구적으로 이동할 때 사용하는 상태코드입니다.원래의 URL을 사용하지 않고, 검색 엔진 등에서도 변경을 인지합니다. 301 Moved Permanently 리다이렉트시 요청 메서드가 GET으로 변하고, 본문이 제거될 수도 있습니다.(거의 변경된다고 보면 됩니다.) 특이점으로 리다이렉트 이후 GET으로 요청을 보내고 메시지는 전달되지 않는다는 점입니다. 308 Permanent Redirect 301과 같은 기능을 하지만, 리다이렉트시 요청 메서드와 본문을 유지합니다.리다이렉트 이후 POST 요청을 보내고 메시지를 유지하여 보낸다는 점이 특이점입니다.이 둘은 잘 사용하지 않고 일시적인 리다이렉션을 더 많이 사용한다고 합니다.일시적인 리다이렉션302, 307,303이 있습니다.URL을 변경하면 안됩니다. 302 Found 리다이렉트시 요청 메서드가 GET으로 변하고, 본문이 제거될 수 있습니다. 스펙의 오류때문에 최근에는 잘 사용하지 않지만, 옛날에 많이 쓰였습니다. 307 Temporary Redirect 302와 기능은 같습니다. 리다이렉트시 요청 메서드와 본문을 유지합니다.(요청 메서드를 변경하면 안됩니다.) 303 See Other 302와 기능은 같지만 리다이렉트시 요청 메서드가 GET으로 변경됩니다. 만약 웹페이지에서 주문을 누른 뒤에 새로고침을 하면 주문이 또 들어갈 것입니다.이러한 것을 방지하기 위한 패턴이 PRG(Post/Redirect/GET)패턴입니다.PRG: 사용 전PRG 사용했을 때 로직입니다. POST로 주문 후에 주문 결과 화면은 GET 메서드로 리다이렉트 새로고침해도 결과화면을 GET으로 조회 중복 주문 대신에 결과 화면만 GET으로 요청즉 웹페이지를 반환하여 그 화면에서 새로고침을 해도 상관없게 만드는 것 같습니다.결국은 302 보다는 307, 303을 쓰는게 좋습니다.자동 리다이렉션시에 GET으로 변해도 되면 302를 사용해도 된다고 합니다.기타 리다이렉션300, 304300 Mutiple Choices : 안쓰입니다.304 Not Modified : 캐시를 목적으로 사용합니다.클라이언트에게 리소스가 수정되지 않았음을 알려줍니다. 따라서 클라이언트는 로컬 PC에 저장된 캐시를 재사용합니다. (캐시로 리다이렉트)304 응답은 응답에 메시지 바디를 포함하면 안됩니다.조건부 GET,HEAD 요청시 사용합니다.캐시에 대한 내용은 다음에 쓰겠습니다.4. 4xx, 5xx 클라이언트, 서버 오류4xx(Client Error)클라이언트 오류 클라이언트의 요청에 잘못된 문법등으로 서버가 요청을 수행할 수 없을 때입니다. 오류의 원인이 클라이언트에 있습니다.클라이언트가 이미 잘못된 요청, 데이터를 보내고 있기에 요청을 재시도해도 결과는 실패합니다.400 Bad Request클라이언트가 잘못된 요청을 해서 서버가 요청을 처리할 수 없습니다. 요청 구문, 메시지, URL 오타 등을 말합니다. 요청 파라미터가 잘못되거나, API 스펙이 맞지 않을 때 입니다.401 Unauthorized클라이언트가 해당 리소스에 대한 인증이 필요할 때입니다.예를 들어 로그인(인증 - Authentication), 권한부여(특정 리소스에 접근할 수 있는 권한 - 인가 - Authorization) 등의 상황이 있습니다.403 Forbidden서버가 요청을 이해했지만 승인을 거부함.예를 들어서 일반유저가 관리자 권한을 요청시 등이 있습니다.404 Not Found요청 리소스를 찾을 수 없음.요청 리소스가 서버에 없거나 권한이 없는 유저가 해당 리소스에 접근할 때 막기위해 사용합니다.500 Internal Server Error서버 내부 문제로 오류가 발생할 때 입니다.애매하면 500 오류를 내면 됩니다.503 Service Unavailable서비스 이용 불가상태입니다.일시적인 과부하 또는 업데이트 등으로 서버를 잠시 막아놓을 때 사용합니다.Retry-After 헤더 필드로 얼마뒤에 복구되는지 보낼 수 있습니다. 결론 403과 404 둘 중 아무거나 써도 됩니다. 숨기고 싶을 땐 404를 사용하고 오류를 정확히 알려주고 싶으면 403을 사용합니다.그리고 어떤 사용자가 조건을 만족하지 못해서 보류상태로 놔야한다고 했을 때 200을 해야할지 400을 상태코드로 해야할 지는 클라이언트와 약속이 되어 있으면 200을 내고 클라이언트가 이러한 사실을 모른다고 했을 때는 400을 오류로 내놓습니다.왜냐하면 만약 만 19세가 넘은 유저가 19세 인증을 안한상태로 리소스에 접근하려고 하는데 클라이언트도 이러한 사실을 알면 200을 상태코드로 반환합니다.이러한 사실을 모르면 400을 상태코드로 반환합니다." }, { "title": "leetcode(리트코드)2월13일 challenge1091-Shortest Path in Binary Matrix", "url": "/posts/leetcode_Shortest_Path_in_Binary_Matrix/", "categories": "leetcode, Medium", "tags": "leetcode", "date": "2021-02-13 18:30:00 +0900", "snippet": "leetcode February challenge13 - Shortest path in Binary Matrix 문제입니다.1. 문제https://leetcode.com/problems/shortest-path-in-binary-matrix2. Input , Output3. 분류 및 난이도Medium 난이도입니다.2월13일자 챌린지 문제입니다.4. 문제 해석 어렵지 않은 일반적인 BFS 문제입니다. 대각선으로 움직일 수 있다는 것이 특이점입니다.5. codeconst int MAX = 101;bool v[MAX][MAX]={false};int MAP[MAX][MAX];int dx[8]={-1,1,1,-1,-1,0,1,0};int dy[8]={1,1,-1,-1,0,1,0,-1};class Solution {public: int BFS(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid,int _size) { memset(v,false,sizeof(v)); int size = _size; //x y count queue&amp;lt;pair&amp;lt;pair&amp;lt;int,int&amp;gt;,int&amp;gt;&amp;gt; q; q.push(make_pair(make_pair(0,0),1)); v[0][0]=true; while(!q.empty()) { int x = q.front().first.first; int y = q.front().first.second; int count = q.front().second; if(x == (size-1) &amp;amp;&amp;amp; y ==(size-1)) return count; q.pop(); for(int k=0;k&amp;lt;8;++k) { int newX = x + dx[k]; int newY = y + dy[k]; if(0&amp;lt;=newX &amp;amp;&amp;amp; newX&amp;lt;size &amp;amp;&amp;amp; 0&amp;lt;=newY &amp;amp;&amp;amp; newY&amp;lt;size &amp;amp;&amp;amp; grid[newX][newY]==0 &amp;amp;&amp;amp; !v[newX][newY]) { q.push(make_pair(make_pair(newX,newY),count+1)); v[newX][newY]=true; } } } return -1; } int shortestPathBinaryMatrix(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid) { if(grid[0][0]==1) return -1; int result =BFS(grid,grid.size()); return result; }};6. 결과 및 후기, 개선점시간 93%" }, { "title": "leetcode(리트코드)2월4일 594-Longest Harmonious Subsequence", "url": "/posts/leetcode_Longest_Harmonious_Subsequence/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-02-13 17:30:00 +0900", "snippet": "leetcode February challenge04 - Logest Harmonious Subsequence 문제입니다.1. 문제https://leetcode.com/problems/longest-harmonious-subsequence/2. Input , Output3. 분류 및 난이도Eazy 난이도입니다.2월04일자 챌린지 문제입니다.4. 문제 해석 최대값과 최소값이 1이 차이가 나는 가장 긴 부분 배열을 찾고 그 길이를 리턴합니다.5. codeclass Solution {public: int findLHS(vector&amp;lt;int&amp;gt;&amp;amp; nums) { sort(nums.begin(),nums.end()); //결과 int result =0; //같은 숫자를 셉니다. int countnumf = 1; //1 을 더한 숫자를 세줍니다. int countnums = 0; //위치 int spot = nums[0]; // 1 더한 숫자를 세주는 루프문을 한 번이라도 도는지 확인합니다. bool check = false; for(size_t i=0;i&amp;lt;nums.size();++i) { cout&amp;lt;&amp;lt;&quot;i : &quot;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&#39;\\n&#39;; spot = nums[i]; //같은 값을 세줍니다. while(i+1&amp;lt;nums.size() &amp;amp;&amp;amp; spot == nums[i+1]) { ++countnumf; ++i; } spot = nums[i]+1; //1 더 큰 값을 세줍니다. while(i+1&amp;lt;nums.size() &amp;amp;&amp;amp; spot ==nums[i+1]) { check = true; ++countnums; ++i; } cout&amp;lt;&amp;lt;countnumf&amp;lt;&amp;lt;&quot; &quot;&amp;lt;&amp;lt;countnums&amp;lt;&amp;lt;&#39;\\n&#39;; if(countnums!=0) result = max(countnumf + countnums ,result); countnumf = countnums == 0 ? 1 : countnums; countnums = 0; //만약 1 더큰값을 세지 않은 경우 --i를 해줍니다. 예를 들어서 1112223라는게 있으면 2에서 3으로 넘어가버리기 때문에 --i를 통해 2로 유지해줘야합니다. if(check) { --i; check=false; } } return result; }};6. 결과 및 후기, 개선점시간이 매우 느리게 나왔습니다.이해하기 쉽고 빠른 코드(36ms)class Solution {public: int findLHS(vector&amp;lt;int&amp;gt;&amp;amp; nums) { //오름차순 정렬 sort(nums.begin(), nums.end()); int max_n = 1; int max_n_1 = 0; int res = 0; for (int i = 1; i &amp;lt; nums.size(); ++i) { //만약 같은 숫자면 if (nums[i] == nums[i - 1]) { ++max_n; } else { //같은 숫자가 아닌데 밑의 if문을 한번이라도 돌았으면 if (max_n_1 &amp;gt; 0) { //결과를 넣어줍니다. res = max(res, max_n + max_n_1); } //i+1 배열이 i 인덱스의 값보다 1클경우 if (nums[i] - nums[i - 1] == 1) { // 맨 위의 if문에서 세준 값을 넣어줍니다. max_n_1 = max_n; } //그런 경우가 없을 경우 (차이가 많이남) else { //아예 안돌았다는 표시 max_n_1 = 0; } max_n = 1; } } // 최대값을 구하는 if문을 한번이라도 돌았으면 if (max_n_1 &amp;gt; 0) { res = max(res, max_n + max_n_1); } return res; }};" }, { "title": "leetcode(리트코드)2월3일 challenge141-Linked List Cycle", "url": "/posts/leetcode_Linked_List_Cycle/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-02-13 15:50:00 +0900", "snippet": "leetcode February challenge03 - Linked List Cycle문제입니다.1. 문제https://leetcode.com/problems/linked-list-cycle/2. Input , Output3. 분류 및 난이도Eazy 난이도입니다.2월3일자 챌린지 문제입니다. leetcode를 2월 9일부터 시작해서 늦게나마 풉니다.4. 문제 해석 인풋으로 들어오는 링크드 리스트가 무한루프를 도는 리스트인지, 아닌지를 확인하여 return 해야합니다.5. code/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: bool hasCycle(ListNode *head) { for(int i=0;i&amp;lt;10001;++i) { if(head == nullptr) return false; head = head-&amp;gt;next; } return true; }};6. 결과 및 후기, 개선점좋은 코드는 아닙니다. 제한이 링크드 리스트의 사이즈 제한이 1만이라서 1만번의 반복이 지나면 false를 뱉도록 설계하였기에 제한이 커지면 커질수록 효율이 좋지 않은 코드라고 할 수 있습니다.시간효율성이 좋은 코드(0ms)/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: bool hasCycle(ListNode *head) { // 빈 리스트가 들어온 경우 if(head==NULL){ return false; } // 리스트 요소가 1개이고, next가 없는 경우 if(head-&amp;gt;next==NULL){ return false; } //slow는 1단계씩 fast는 2단계씩 next로 넘어가는데 같아지는 순간이 있다면 true를 return합니다. ListNode *slow = head; ListNode *fast = head-&amp;gt;next-&amp;gt;next; while(slow!=NULL &amp;amp;&amp;amp; fast!=NULL){ if(slow==fast){ return true; } slow = slow-&amp;gt;next; if(fast-&amp;gt;next==NULL){ return false; } fast = fast-&amp;gt;next-&amp;gt;next; } return false; }};" }, { "title": "leetcode(리트코드)448-Find All Numbers Disappeared in an Array", "url": "/posts/leetcode_Find_All_Numbers_Disappeared_in_an_Array/", "categories": "leetcode, Eazy", "tags": "leetcode, Array", "date": "2021-02-13 15:30:00 +0900", "snippet": "leetcode Array intro - Find All Numbers Disappeared in an Array 문제입니다.1. 문제https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 배열의 크기만큼 수열이 지속되어야합니다. 예를 들어서 배열의 크기가 8이면 1~8까지의 수가 있어야합니다. 만약 없으면 없는 숫자를 배열에 넣어 리턴합니다. 처음에는 추가공간을 쓰지 않고 작성하기 위해 노력을 많이했습니다. 하나의 for문안에서 처리하려고 하고, vetor.erase(), vector.push_back()을 이용해서 풀려고 하였으나, 버퍼 오버플로가 발생하여 포기.. 추가 공간을 사용하지 않고 푼 사람이 있나 Discussion에 들어가서 확인해보았습니다. 1page에서 c++로 푼 사람 중에는 그런 사람이 없었습니다. 추가공간을 사용하기로 하였지만, 하나의 for문안에서 처리하려고 또 노력했습니다만 포기했습니다. (이 문제에 거의 1시간을 써버렸기에) 최후의 수단으로 생각했던 방문처리 배열을 둬서 풀기로 했습니다. 풀렸지만 찝찝했습니다. 문제에서 배열의 크기 제한을 두지 않아서 1억개가 들어올 지 2억개가 들어올 지 가늠이 안되서 위험한 시도라고 생각했습니다. 5. codeclass Solution {public: vector&amp;lt;int&amp;gt; findDisappearedNumbers(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;int&amp;gt; result ; int size = nums.size(); bool* check = new bool[nums.size()+1]; memset(check,false,sizeof(bool) * (nums.size()+1)); for(int i = 0;i&amp;lt;size;++i) { check[nums[i]]=true; } for(int i = 1;i&amp;lt;=size;++i) { if(check[i]==false) result.push_back(i); } return result; }};6. 결과 및 후기, 개선점시간개선사항없음" }, { "title": "leetcode(리트코드)2월12일 challenge1342-Number of Steps to Reduce a Number to Zero", "url": "/posts/leetcode_Number_of_Steps_to_Reduce_a_Number_to_Zero/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-02-13 14:30:00 +0900", "snippet": "leetcode February challenge12 - Number of Steps to Reduce a Number to Zero 문제입니다.1. 문제https://leetcode.com/problems/number-of-steps-to-reduce-a-number-to-zero/2. Input , Output3. 분류 및 난이도Eazy 난이도입니다.2월12일자 챌린지 문제입니다.4. 문제 해석 주어진 값이 0으로 향하면서 짝수인 경우는 2로 나눠주고 홀수인 경우는 1을 빼줍니다. 그 과정이 몇번 있는 지 값을 계산하여 return 해줍니다.-처음에는 DP로 풀었는데, 시간이 너무 오래걸려서 BruteForce로 풀었습니다.5. codeDP 코드const int MAX = 1000001;class Solution {public: int DP[MAX]={0,}; int numberOfSteps (int num) { DP[1] = 1; DP[2] = 2; for(int i = 3;i&amp;lt;MAX;++i) { if(i%2==0) { DP[i] = DP[i/2]+1; } else { DP[i] = DP[i-1] + 1; } } return DP[num]; }};고친 코드class Solution {public: int numberOfSteps (int num) { int count = 0; while(num!=0) { if(num%2==0) { count++; num/=2; } else { count++; num-=1; } } return count; }};6. 결과 및 후기, 개선점" }, { "title": "leetcode(리트코드)414-Third Maximum Number", "url": "/posts/leetcode_Third_Maximum_Number/", "categories": "leetcode, Eazy", "tags": "leetcode, Array", "date": "2021-02-13 13:40:00 +0900", "snippet": "leetcode Array intro - Maximum Number 문제입니다.1. 문제https://leetcode.com/problems/third-maximum-number/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 3번째로 큰값을 찾는 문제입니다. 3번째로 큰 값이 없으면 가장 큰 값을 찾아 return 합니다.5. codeclass Solution {public: int thirdMax(vector&amp;lt;int&amp;gt;&amp;amp; nums) { sort(nums.begin(),nums.end(),greater&amp;lt;int&amp;gt;()); int maxnum = nums[0]; int count =0; for(size_t i=0;i&amp;lt;nums.size();++i) { if(nums[i]&amp;lt;maxnum) { ++count; maxnum = nums[i]; if(count&amp;gt;1) return maxnum; } } return nums[0]; }};6. 결과 및 후기, 개선점시간0ms 코드class Solution {public: int thirdMax(vector&amp;lt;int&amp;gt;&amp;amp; a) { long one ,two,three; // 세 변수 모드 Long형 최소값을 넣습니다. one = two = three = LONG_MIN; // vector a를 돌면서 for(auto i : a){ if(i == one || i == two || i==three) continue; // 배열의 인덱스가 처음으로 one보다 큰 값이 나오면 one, two, three 변수들의 값을 옮겨줍니다. if(i&amp;gt;one){ three = two; two = one; one = i; } //마찬가지로 인덱스로 들어온 값이 two보다 큰 값이 들어오면 값을 옮겨줍니다. else if문이라 두 번째로 걸리게 됩니다. else if(i&amp;gt;two){ three = two; two = i; } //마찬가지 else if(i&amp;gt;three){ three = i; } } return three == LONG_MIN ? one:three; }};이게 왜 0ms인지는 잘 모르겠습니다." }, { "title": "leetcode(리트코드)1051-Height Checker", "url": "/posts/leetcode_Height_Checker/", "categories": "leetcode, Eazy", "tags": "leetcode, Array", "date": "2021-02-13 13:30:00 +0900", "snippet": "leetcode Array intro - Height Checker 문제입니다.1. 문제https://leetcode.com/problems/height-checker/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 값을 정렬하는데 정렬하는 데 필요한 위치 변동의 최소값을 구하는 문제입니다. 문제 해석이 잘 못 된건지 해석하기 어려운 점이 있습니다. 문제에서 예시로 들어주는 [1,1,4,2,1,3]이 최소 2번으로 정렬이 가능하는데 문제에서 요구하는 답은 3입니다. [1,1,4,2,1,3]-&amp;gt; [1,1,1,2,4,3] 1-&amp;gt; [1,1,1,2,3,4] 2그렇기에 Bad에 투표가 많고, Discuss에서 이 문제에 대한 논의가 계속 되고 있습니다.5. codeclass Solution {public: int heightChecker(vector&amp;lt;int&amp;gt;&amp;amp; h, int res = 0) { vector&amp;lt;int&amp;gt; s = h; sort(begin(s), end(s)); for (auto i = 0; i &amp;lt; h.size(); ++i) res += h[i] != s[i]; return res; }};6. 결과 및 후기, 개선점시간" }, { "title": "leetcode(리트코드)905-Sort Array By Parity", "url": "/posts/leetcode_Sort_Array_By_Parity/", "categories": "leetcode, Eazy", "tags": "leetcode, Array", "date": "2021-02-12 15:02:00 +0900", "snippet": "leetcode Array intro - Sort Array By Parity 문제입니다.1. 문제https://leetcode.com/problems/sort-array-by-parity/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 방금 전의 포스팅과 비슷한 문제로 짝수인 값만 앞으로 보내줘 배열을 리턴하는 문제입니다.5. codeclass Solution {public: vector&amp;lt;int&amp;gt; sortArrayByParity(vector&amp;lt;int&amp;gt;&amp;amp; A) { for(size_t i=0, j = 0;i&amp;lt;A.size();++i) { if(A[i]%2 ==0) { swap(A[i],A[j++]); } } return A; }};6. 결과 및 후기, 개선점시간바로 전의 문제와 비슷해서 전 코드를 참고하였습니다.제 코드보다 시간을 반으로 줄인 코드가 있는 것 같아서 올립니다. 제코드는 4ms로 99%정도되지만 더 좋은 코드가 있네요.시간 효율성이 좋은 코드class Solution {public: vector&amp;lt;int&amp;gt; sortArrayByParity(vector&amp;lt;int&amp;gt;&amp;amp; A) { int l = 0, r = (int)A.size() - 1; while(l &amp;lt; r){ if(A[l] % 2 == 0){ l++; } else if(A[r] % 2 == 1){ r--; } else { swap(A[l++], A[r--]); } } return A; }};이 코드는 퀵정렬처럼 맨 왼쪽과 맨 오른쪽에서 좁혀가면서 배열을 검사하는 코드입니다.최악의 경우는 제 코드와 같겠지만은, 배열의 반에서 딱 끝나는 경우가 있을 수 있으므로 좋은 코드입니다." }, { "title": "leetcode(리트코드)283-Move Zeroes", "url": "/posts/leetcode_Move_Zeroes/", "categories": "leetcode, Eazy", "tags": "leetcode, Array", "date": "2021-02-12 13:30:00 +0900", "snippet": "leetcode Array intro - Move Zeroes 문제입니다.1. 문제https://leetcode.com/problems/move-zeroes/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 배열을 돌면서 0인것은 맨뒤로 아닌것은 앞으로 보내는 문제입니다.5. codeclass Solution {public: void moveZeroes(vector&amp;lt;int&amp;gt;&amp;amp; nums) { for(size_t i=0;i&amp;lt;nums.size();++i) { if(nums[i]==0) { for(int j=i+1;j&amp;lt;nums.size();++j) { if(nums[j]!=0) { int temp = nums[i]; nums[i] = nums[j]; nums[j] =temp; break; } } } } }};6. 결과 및 후기, 개선점시간시간이 8%로 하위에서 벗어나질 못했습니다.작성하면서도 마음에 걸렸던 2중 for문이 시간을 많이 잡아먹은 것 같다고 생각하고 다른 사람들 코드를 보니 전부 1중 for문으로 해결했습니다.시간 효율성이 좋은 코드class Solution {public: void moveZeroes(vector&amp;lt;int&amp;gt;&amp;amp; nums) { for(int i = 0, j = 0; i&amp;lt;nums.size(); ++i) { if(nums[i]) swap(nums[i], nums[j++]); } }};0이면 j를 냅두고 0이 아닌경우 i를 증가시켜 0에 위치된 j와 값을 바꾸는 코드입니다." }, { "title": "leetcode(리트코드)1299-Replace Elements with Greatest Element on Right Side", "url": "/posts/leetcode_Replace_Elements_with_Greatest_Element_on_Right_Side/", "categories": "leetcode, Eazy", "tags": "leetcode, Array", "date": "2021-02-12 13:02:00 +0900", "snippet": "leetcode Array intro - Replace Elements with Greatest Element on Right Side 문제입니다.1. 문제https://leetcode.com/problems/replace-elements-with-greatest-element-on-right-side/2. Input , Output3. 분류 및 난이도Eazy 난이도 문제입니다.4. 문제 해석 첫번째 요소들을 돌면서 그 오른쪽에 있는 요소들 중 가장 큰값을 배열에 넣어 리턴합니다.5. codeclass Solution {public: vector&amp;lt;int&amp;gt; replaceElements(vector&amp;lt;int&amp;gt;&amp;amp; arr) { for(size_t i =arr.size()-1;i&amp;gt;0;--i) { if(arr[i] &amp;gt; arr[i-1]) { arr[i-1]=arr[i]; } } arr.erase(arr.begin()); arr.push_back(-1); return arr; }};6. 결과 및 후기, 개선점시간효율성이 좋은 다른 코드와 로직이 비슷하므로 개선점은 없습니다." }, { "title": "leetcode(리트코드)2월11일 challenge242-Valid Anagram", "url": "/posts/leetcode_Valid_Anagram/", "categories": "leetcode, Eazy", "tags": "leetcode, String", "date": "2021-02-11 17:30:00 +0900", "snippet": "leetcode February challenge11 - Valid Anagram 문제입니다.1. 문제https://leetcode.com/problems/valid-anagram/2. Input , Output3. 분류 및 난이도Eazy 난이도입니다.2월11일자 챌린지 문제입니다.4. 문제 해석 S로 주어진 문자열을 문자순서를 바꿔 T를 만들 수 있는지 묻는 문제입니다.5. codeclass Solution {public: int alpha[26]={0,}; bool isAnagram(string s, string t) { if(s.size()!=t.size()) return false; for(size_t i=0;i&amp;lt;s.size();++i) { alpha[s[i]-97]++; } for(size_t i=0;i&amp;lt;t.size();++i) { if(alpha[t[i]-97]-1 &amp;lt;0) return false; alpha[t[i]-97]--; } return true; }};6. 결과 및 후기, 개선점시간효율성이 좋은 코드제 코드와 비슷합니다. (98%)외에 문자열을 둘 다 정렬해줘서 틀린 첨자가 있으면 false를 리턴하는 방법이 있습니다." }, { "title": "leetcode(리트코드)2월2일 challenge669-Trim a Binary Search Tree", "url": "/posts/leetcode_Trim_A_Binary_Search_Tree/", "categories": "leetcode, Medium", "tags": "leetcode, Tree", "date": "2021-02-11 16:06:00 +0900", "snippet": "leetcode February challenge02 - Trim a Binary Search 문제입니다.1. 문제https://leetcode.com/problems/trim-a-binary-search-tree/2. Input , Output3. 분류 및 난이도Medium 난이도입니다.2월2일자 챌린지 문제입니다. leetcode를 2월 9일부터 시작해서 늦게나마 풉니다.4. 문제 해석 tree와 low와 high를 줍니다. low보다 작거나 high보다 큰 값을 트리에서 잘라내야합니다. 재귀에 익숙하지 않아서 트리가 쳐내지지 않아 다른 사람들의 코드를 참고하였습니다.5. codec++/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: TreeNode* trimBST(TreeNode* root, int low, int high) { if(root!=nullptr) { if(root-&amp;gt;val &amp;gt;=low &amp;amp;&amp;amp; root-&amp;gt;val&amp;lt;=high) { //왼쪽을 검사 root-&amp;gt;left = trimBST(root-&amp;gt;left,low,high); //오른쪽을 검사 root-&amp;gt;right = trimBST(root-&amp;gt;right,low,high); //잘 마무리되면 root return return root; } //값이 작은데 오른쪽 자식이 있다면 검사를 한 뒤 리턴 if(root-&amp;gt;val&amp;lt;low) return trimBST(root-&amp;gt;right,low,high); //값이 작은데 왼쪽 자식이 있다면 검사를 한 뒤 리턴 return trimBST(root-&amp;gt;left,low,high); } return root; }};6. 결과 및 후기, 개선점시간효율성이 좋은 코드위의 코드와 비슷합니다.재귀가 아직 약하다는 것을 알았습니다." }, { "title": "leetcode(리트코드)2월1일 challenge191-Number Of 1 Bits", "url": "/posts/leetcode_Number_Of_1_Bits/", "categories": "leetcode, Eazy", "tags": "leetcode", "date": "2021-02-11 15:06:00 +0900", "snippet": "leetcode February challenge01 - Number Of 1 Bits문제입니다.1. 문제https://leetcode.com/explore/challenge/card/february-leetcoding-challenge-2021/585/week-2-february-8th-february-14th/3634/2. Input , Output3. 분류 및 난이도Eazy 난이도입니다.2월1일자 챌린지 문제입니다. leetcode를 2월 9일부터 시작해서 늦게나마 풉니다.4. 문제 해석 인풋으로 들어오는 최대 32의 길이를 갖는 값의 1의 갯수를 세줘야합니다.5. codeclass Solution {public: int hammingWeight(uint32_t n) { int result =0; while(n!=0) { if(n%2==1) ++result; n/=2; } return result; }};6. 결과 및 후기, 개선점시간효율성이 좋은 코드class Solution {public: int hammingWeight(uint32_t n) { if(n==0) return 0; else return (n&amp;amp;1) + hammingWeight(n&amp;gt;&amp;gt;1); }};1011로 들어온 경우 마지막 비트와 1을 &amp;amp;연산(둘 다 1인 경우 1을 반환)을 합니다. 그리고 1씩 shift 연산을하여 똑같은 &amp;amp;연산을 해줍니다. 1011&amp;amp; 1= 1 101&amp;amp; 1= 1 10&amp;amp; 1= 0..." }, { "title": "leetcode(리트코드)941-Valid Mountain Array", "url": "/posts/leetocde_Valid_Mountain_Array/", "categories": "leetcode, Eazy", "tags": "leetcode, Array", "date": "2021-02-11 15:02:00 +0900", "snippet": "leetcode Array intro - Valid Mountain Array 문제입니다.1. 문제https://leetcode.com/problems/number-of-1-bits/2. Input , Output3. 분류 및 난이도Eazy 난이도입니다.4. 문제 해석 배열을 돌면서 오름차순, 내림차순이 한 번 있으면 true를 반환합니다. 값이 같으면 안됩니다.5. codeclass Solution {public: bool validMountainArray(vector&amp;lt;int&amp;gt;&amp;amp; arr) { bool downhill =false; for(size_t i=0;i&amp;lt;arr.size()-1;++i) { if(arr[i]==arr[i+1]) return false; //내리막길 if(arr[i]&amp;gt;arr[i+1]) downhill=true; if(downhill &amp;amp;&amp;amp; i==0) return false; //오르막길 if(downhill &amp;amp;&amp;amp; arr[i] &amp;lt;=arr[i+1]) return false; } return downhill; }};6. 결과 및 후기, 개선점시간0ms인 사람의 java코드class Solution { public boolean validMountainArray(int[] A) { int N = A.length; int i = 0; // walk up while (i+1 &amp;lt; N &amp;amp;&amp;amp; A[i] &amp;lt; A[i+1]) i++; // peak can&#39;t be first or last if (i == 0 || i == N-1) return false; // walk down while (i+1 &amp;lt; N &amp;amp;&amp;amp; A[i] &amp;gt; A[i+1]) i++; return i == N-1; }}코드 해석을 하면, 올라가는 길인 경우 인덱스를 계속 더해줍니다.그 이후 i==0(오르막길이 없었음) or i==N-1(끝의 인덱스까지 쭉 오르막길인 경우) return false를 해줍니다.그 이후는 내리막길이므로 ++i를 해주고 i가 N-1(마지막 인덱스)인 경우 true를 반환합니다. 두 개의 산맥이 있을 경우를 제외한 것 같습니다." }, { "title": "leetcode(리트코드)1346-Check If N and Its Double Exist", "url": "/posts/leetcode_Check_If_N_and_Its_Double_Exist/", "categories": "leetcode, Eazy", "tags": "leetcode, Array", "date": "2021-02-11 14:02:00 +0900", "snippet": "leetcode Array intro - Remove Duplicates from Sorted Array 문제입니다.1. 문제https://leetcode.com/problems/check-if-n-and-its-double-exist/2. Input , Output3. 분류 및 난이도leetcode의 Array introduction에 있는 문제입니다.eazy난이도의 문제입니다.4. 문제 해석 배열을 돌면서 자기 자신을 2로나눈 값이 있는지 찾는 문제입니다. 예를 들어서 10을 2로나눈 5라는 값을 가진 인덱스가 있는 지 찾고 있으면 true, 없으면 false를 리턴합니다.5. codeclass Solution {public: //음수에도 값의 최대인 1천을 더해 인덱스에 바로 접근할 수 있게 합니다. // 예를 들어서 -8 값을 가진 인덱스라면 -8 + 1000한 992의 값을 증가시킵니다. int check[2002]={0,}; bool checkIfExist(vector&amp;lt;int&amp;gt;&amp;amp; arr) { //arr를 돌면서 값을 더해줍니다. for(size_t i=0;i&amp;lt;arr.size(); ++i) { check[arr[i]+1000]++; } for(size_t i=0;i&amp;lt;arr.size();++i) { // 배열의 요소가 minus인 경우 bool minus=false; if(arr[i]&amp;lt;0) minus=true; int nums = abs(arr[i]); //0인 경우는 조심해야합니다. 0이 두 번 들어왔으면 true를 리턴해야하고 1번만 들어왔으면 넘어가야합니다. if(nums==0) { if(check[1000]&amp;gt;1) return true; else continue; } //홀수는 제외시킵니다. if(nums%2==1) { continue; } int result = nums/2; if(minus) result=-result; // 값이 있는 지 찾습니다. if(check[result+1000]) { return true; } } return false; }};6. 결과 및 후기, 개선점시간0ms인 사람의 코드class Solution {public: bool checkIfExist(vector&amp;lt;int&amp;gt;&amp;amp; arr) { //map을 선언합니다. unordered는 그냥 map(레드블랙 트리로 구성되어 정렬되어 들어감)과 달리 해시 테이블 기반으로 정렬되어 값이 들어가지 않습니다. unordered_map&amp;lt;int, int&amp;gt; v; for(int i=0;i&amp;lt;arr.size();i++){ //만약 짝수이고 결과를 찾았다면. if(arr[i]%2==0 &amp;amp;&amp;amp; v.find((arr[i]/2))!=v.end()){ cout&amp;lt;&amp;lt;&quot;1&quot;; return true; } //반대로 자기 자신의 * 2한 값을 찾았다면 if(v.find((arr[i]*2))!=v.end()){ cout&amp;lt;&amp;lt;&quot;2&quot;; return true; } //해시에 값을 넣습니다. if(v.find(arr[i])==v.end()){ //not present v[arr[i]] = 1; } } return false; }};공간복잡도 굳이 개선할 점 없음." }, { "title": "leetcode(리트코드)2월10일 challenge138-Copy List with Random PointerGreater Tree", "url": "/posts/leetcode_Copy_List_with_Random_Pointer/", "categories": "leetcode, Medium", "tags": "leetcode, LinkedList", "date": "2021-02-11 13:02:00 +0900", "snippet": "leetcode February challenge10 - Copy List with Random 문제입니다.1. 문제https://leetcode.com/problems/copy-list-with-random-pointer/2. Input , OutputConstraints: 0 &amp;lt;= n &amp;lt;= 1000 -10000 &amp;lt;= Node.val &amp;lt;= 10000 Node.random is null or is pointing to some node in the linked list.3. 분류 및 난이도Medium의 난이도입니다.2월10일자 챌린지 문제입니다. LinkedList문제입니다.4. 문제 해석 문제는 간단합니다. input으로 주어지는 링크드 리스트와 똑같은 링크드 리스트를 만드는 것입니다. 다만 같은 주소값을 참조해선 안됩니다. 새로운 노드들을 생성하여 연결시켜줘야합니다. 그러기 위해서는 원본 리스트를 도는 temp Node와 복사본 리스트를 도는 location Node를 두어 관리하였습니다. 이 문제의 묘미는 random 이라는 노드인데, 원본노드에서 가리키는 random Node 또한 복사시켜줘야합니다. 주소값을 계산하여 풀까 하다가 최대 1천의 크기의 리스트이므로 맨앞에서부터 random 노드와 같은 주소값을 가진 노드를 찾아 반환하였습니다. 5. code/*// Definition for a Node.class Node {public: int val; Node* next; Node* random; Node(int _val) { val = _val; next = NULL; random = NULL; }};*/class Solution {public: int findrandom(Node* temp,Node* original) { if(temp-&amp;gt;random==nullptr) return -1;// null else { int result=0; while(original != temp-&amp;gt;random) { ++result; original=original-&amp;gt;next; } return result; } } Node* copyRandomList(Node* head) { //새헤드 노드를 만듦. Node* newHead; //헤드노드가 null로 들어올 경우 if(head==nullptr) return nullptr; else { //새 헤드 노드를 원본 head노드를 참조하여 만드는 과정 newHead = new Node(head-&amp;gt;val); newHead-&amp;gt;next=nullptr; newHead-&amp;gt;random=nullptr; //location은 복사본 노드, tempNode는 원본 노드를 돕니다. Node* location = newHead; Node* tempNode= head; //다음 노드가 있으면 돕니다. if(tempNode-&amp;gt;next!=nullptr) tempNode=tempNode-&amp;gt;next; //head의 다음값이 없을 경우 while문을 안돌게 합니다. while(tempNode!=nullptr &amp;amp;&amp;amp; head-&amp;gt;next!=nullptr) { //일단 val값만 복사해서 넣어줍니다. Node* newNode = new Node(tempNode-&amp;gt;val); newNode -&amp;gt; next = nullptr; newNode -&amp;gt; random = nullptr; location-&amp;gt;next = newNode; tempNode = tempNode-&amp;gt;next; location = location-&amp;gt;next; } //다시 돌면서 random에 맞게 location = newHead; tempNode=head; // random을 나중에 처리해주는 이유는 이미 생선된 리스트에서 접근을해야하므로 random을 나중에 처리한 것입니다. while(tempNode!=nullptr) { //원본 노드에서 가리키는 random값의 index를 찾습니다. int indexNum = findrandom(tempNode,head); //null을 가리키면 -1을 리턴하여 nullptr을 넣습니다. if(indexNum==-1) location-&amp;gt;random = nullptr; else { Node* find = newHead; for(int i=0;i&amp;lt;indexNum;++i) { find=find-&amp;gt;next; } location-&amp;gt;random = find; } tempNode= tempNode-&amp;gt;next; location=location-&amp;gt;next; } } return newHead; }};6. 결과 및 후기, 개선점시간효율성이 좋은 코드제 코드와 같습니다. (99%)공간 효율성이 좋은 코드위의 코드와 같아서 따로 적진 않겠습니다. (96%)" }, { "title": "HTTP - 5 HTTP 메서드 활용", "url": "/posts/HTTP05/", "categories": "HTTP, 김영한_모든 개발자를 위한 HTTP 웹 기본 지식", "tags": "HTTP", "date": "2021-02-11 01:00:00 +0900", "snippet": "해당 자료는 인프런 김영한 선생님의 모든 개발자를 위한 HTTP 웹 기본 지식 강의노트입니다.1. 클라이언트에서 서버로 데이터 전송클라이언트에서 서버로 데이터를 전달하는 방식은 크게 2가지로 나뉩니다. 쿼리 파라미터를 통한 데이터 전송 GET 정렬 필터(검색어)등 메시지 바디를 통한 데이터 전송 POST, PUT, PATCH 회원가입, 상품 주문, 리소스 등록, 리소스 변경 전송하는 상황은 4가지가 있습니다. 정적 데이터 조회 이미지, 정적 테스트 문서 등 동적 데이터 조회 검색, 게시판 목록 필터 등 HTML Form을 통한 데이터 전송 회원 가입, 상품 주문, 데이터 변경 HTTP API를 통한 데이터 전송 서버 to 서버, 앱 클라이언트, 웹 클라이언트 등 회원 가입, 상품 주문, 데이터 변경 정적 데이터 조회쿼리 파라미터 미사용ClientGET /static/star.jpg HTTP/1.1Host: localhost:8080Server경로 : /static/start.jpgHTTP/1.1 200 OKContent_Type : image/jpegContent-Length : 34012lkdsaas;djkaklfsjalksjdkl2sadkljaslkdjlkjzxkjcasd정적 데이터 조회는 이미지, 정적 텍스트 문서 등을 말합니다.조회는 GET을 사용하고 일반적으로 쿼리 파라미터 없이 리소스 경로로 단순하게 조회 가능합니다.동적 데이터 조회쿼리 파라미터 사용ClientGET /search?q=hello&amp;amp;hl=ko HTTP/1.1Host: www.google.comServer쿼리 파라미터를 기반으로 결과를 동적으로 생성주로 검색, 게시판 목록에서 정렬 필터를 사용합니다.조회는 GET 을사용해야하고, GET으로 쿼리 파라미터를 사용해서 데이터를 전달할 수 있습니다.HTML Form 데이터 전송 POST 방식Content-Type의 양식을 보면 됩니다.application/x-www-form-urlencoded 사용합니다.전송 데이터를 url encoding 처리합니다.예) abc김 -&amp;gt; abc%EA%B9%80 GET 방식GET방식에서는 보통 조회에서만 쓰이는 게 좋습니다. 규칙을 어겨 데이터를 보내는 것은 지양합시다. multipart/form-datamutipart/form-data는 웹브라우저가 알아서 데이터를 나눠줍니다.또한 파일 등을 보낼 때 사용합니다.HTML Form 전송은 GET,POST만 지원합니다. PUT, PATCH 등 지원안합니다.HTTP API 데이터 전송JSON 등 방식으로 데이터를 넘기는 것을 말합니다. 서버 to 서버 백엔드끼리 통신할 때 앱 클라이언트 아이폰, 안드로이드 웹 클라이언트 웹뷰 어플 (AJAX) , React, VueJs 같은 웹 클라이언트와 API 통신 POST,PUT,PATCH : 메시지 바디를 통해 데이터 전송 GET : 조회, 쿼리 파라미터로 데이터 전달 Content-Type : application/json을 주로 사용 (사실상 표준) TEXT, XML, JSON 등등 HTTP API와 Restful API 차이점HTTP API에 여러가지 제약 조건이 추가된 것이 REST API입니다.&amp;lt;(https://ko.wikipedia.org/wiki/REST)&amp;gt; 자원의 식별 메시지를 통한 리소스 조작 자기서술적 메시지 애플리케이션의 상태에 대한 엔진으로서 하이퍼미디어대표적으로 구현하기 어려운 부분이 마지막 부분이라고 합니다.HTML처럼 하이퍼링크가 추가되어서 다음에 어떤 API를 호출해야 하는지를 해당 링크를 통해서 받을 수 있어야 한다고 합니다.이러한 부분을 지키면서 개발하는 것을 RESTful API라고 하지만, 개발하기가 어렵고 추가 개발 비용대비 효과가 있는 것도 아니라고 합니다.그래서 많은 사람들이 해당 조건을 지키지 않아도 REST API라고 하기 때문에 HTTP API와 REST API를 거의 같은 의미로 사용하고 있습니다.그렇기에 HTTP API를 REST API라고 하는 사람들이 많기에 REST API를 HTTP API라고 이해하면 된다고 합니다. 물론 엄격하게는 다릅니다.2. HTTP API 설계 예시 HTTP API - 컬렉션 위 방식은 POST 기반 등록 POST 기반 등록이란, 신규 자원 등록을 하는 상황을 가정하였을 때 다음과 같이 URI를 구성할 수 있습니다.신규 회원 등록 -&amp;gt; /members /members 라는 것만 보내면 서버에서 100번째 유저 (/members/100)인지 101번째 유저 (/members/101)은 서버가 정해줄 일이고 클라이언트는 알 필요가 없습니다.이러한 방식을 컬렉션 방식이라고 하고, 이 컬렉션은 서버가 관리하는 리소스 디렉터리라고도 불립니다.위의 예시에서 컬렉션은 ‘/members’ 입니다. HTTP API - 스토어 위 방식은 PUT 기반 등록 PUT 기반 방식은 POST 방식과 달리 클라이언트가 리소스 URI에 대한 정보를 알고 있어야합니다.파일 등록 -&amp;gt; files/filename -&amp;gt; PUT즉, 클라이언트가 직접 리소스의 URI를 지정합니다.이러한 방식을 스토어라고 하며, 클라이언트가 관리하는 리소스 저장소를 일컫습니다.위의 예시에서 스토어는 ‘/files’입니다.현업에서는 보통 POST 방식인 컬렉션기반으로 설계를 한다고 합니다.왜냐하면 PUT 방식은 HTTP에서 지원을 안하고, PUT은 기존 자원을 덮어씌우기에 설계를 잘 해야하기 때문입니다.위의 상황에서 회원 등록은 /members/new, /members로 되어있는데 URI을 구성할 때 둘 중 어느걸로 구성해도 상관없지만, 전자의 경우 서버에서 등록을 못할 경우 오류 메시지를 보내줄 때 편리하여 김영한 선생님께서는 전자를 선호하신다 하셨습니다.회원 수정 예시도 똑같이 적용됩니다.HTML FORM은 GET, POST만 지원하므로 모든 설계가 저 두개로 이루어지면 좋겠지만, 그런 일은 거의 없다고 합니다. 또한 HTTP 메서드로 해결하기 애매한 경우가 많습니다.그럴 때 쓰는 것이 컨트롤 URI로 동사로 된 리소스 경로를 프로그래머가 지정합니다.예를 들면 /members/{id}/delete 처럼 HTML이 DELETE를 지원안할 때 직접 리소스 경로를 지정해주는 방식입니다.주의해야할 점이 POST와 GET으로 요구사항들을 설계가 전제되어야합니다.위 둘의 방식으로 해결이 안될 때 사용하는 방식입니다." }, { "title": "leetcode(리트코드)1089-Duplicate Zeros", "url": "/posts/leetcode_Duplicate_Zeros/", "categories": "leetcode, Eazy", "tags": "leetcode, Array", "date": "2021-02-10 13:08:00 +0900", "snippet": "leetcode Array intro - Duplicate Zeros 문제입니다.1. 문제https://leetcode.com/problems/duplicate-zeros/2. Input , Output3. 분류 및 난이도leetcode의 Array introduction에 있는 문제입니다.eazy난이도의 문제입니다.4. 문제 해석 0이 나타나면 0을 하나 더 배열에 넣고 기존 배열값을 뒤로 한칸 미뤄 주어진 배열의 크기만큼을 리턴하는 문제입니다.5. codeclass Solution {public: void duplicateZeros(vector&amp;lt;int&amp;gt;&amp;amp; arr) { vector&amp;lt;int&amp;gt; arr2; for(size_t i =0;i&amp;lt;arr.size();++i) { if(arr[i]==0) arr2.push_back(0); arr2.push_back(arr[i]); arr[i]=arr2[i]; } }};6. 결과 및 후기, 개선점시간굳이 개선할 점 없음." }, { "title": "leetcode(리트코드)88-Merge Sorted Array", "url": "/posts/leetcode_Merge_Sorted_Array/", "categories": "leetcode, Eazy", "tags": "leetcode, Array", "date": "2021-02-10 13:06:00 +0900", "snippet": "leetcode Array intro - Merge Sorted Array 문제입니다.1. 문제https://leetcode.com/problems/merge-sorted-array/2. Input , Output3. 분류 및 난이도leetcode의 Array introduction에 있는 문제입니다.eazy난이도의 문제입니다.4. 문제 해석 말그대로 병합정렬 문제입니다. 보통 병합정렬과 다른 점은, 배열을 미리 주어준다는 점입니다. 보통 병합정렬은 새로운 배열을 생성해야하는데, 미리 준 배열에 병합정렬을 수행해야합니다.5. codeclass Solution {public: void merge(vector&amp;lt;int&amp;gt;&amp;amp; nums1, int m, vector&amp;lt;int&amp;gt;&amp;amp; nums2, int n) { vector&amp;lt;int&amp;gt; num(nums1.size(),0); for(size_t i =0;i&amp;lt;nums1.size();++i) { num[i]=nums1[i]; } int i=0,j=0,k=0; while(i&amp;lt;m &amp;amp;&amp;amp; j&amp;lt;n) { if(num[i]&amp;lt;=nums2[j]) { nums1[k++] = num[i++]; } else nums1[k++] = nums2[j++]; } int tmp = i &amp;gt; m ? j : i; while(i&amp;lt;m) { nums1[k++] = num[i++]; } while(j&amp;lt;n) nums1[k++] = nums2[j++]; }};6. 결과 및 후기, 개선점시간이미 개선한 코드입니다.처음에는 함수를 하나 더 만들어줘서 배열들을 관리하였으나, 그럴 필요가 없다는 것을 알고 한 함수내에서 처리하도록 작성하였습니다." }, { "title": "leetcode(리트코드)27-Remove Element", "url": "/posts/leetcode_Remove-Element/", "categories": "leetcode, Eazy", "tags": "leetcode, Array", "date": "2021-02-10 13:04:00 +0900", "snippet": "leetcode Array intro - Remove Element 문제입니다.1. 문제https://leetcode.com/problems/remove-element/2. Input , Output3. 분류 및 난이도leetcode의 Array introduction에 있는 문제입니다.eazy난이도의 문제입니다.4. 문제 해석 val로 들어온 값을 새 배열을 만들지 않고 지워서 값을 리턴합니다. 다만, 지우고 남은 원소들을 앞으로 끄집어 내야합니다.5. codeclass Solution {public: int removeElement(vector&amp;lt;int&amp;gt;&amp;amp; nums, int val) { int left =0; for(size_t i =0;i&amp;lt;nums.size();++i) { if(nums[i]==val) continue; else { nums[left++] =nums[i]; } } return left; }};6. 결과 및 후기, 개선점시간굳이 개선할 점 없음." }, { "title": "leetcode(리트코드)26-Remove Duplicates from Sorted Array", "url": "/posts/leetcode_Remove_Duplicates_from_Sorted_Array/", "categories": "leetcode, Eazy", "tags": "leetcode, Array", "date": "2021-02-10 13:02:00 +0900", "snippet": "leetcode Array intro - Remove Duplicates from Sorted Array 문제입니다.1. 문제https://leetcode.com/problems/remove-duplicates-from-sorted-array/2. Input , Output3. 분류 및 난이도leetcode의 Array introduction에 있는 문제입니다.eazy난이도의 문제입니다.4. 문제 해석 중복되는 수를 제거하여 주어진 배열을 바꾸는 문제입니다.문제에서 새 배열을 만들지 말고 O(1)로 푸는 것을 권장하였습니다.5. codeclass Solution {public: int removeDuplicates(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int left =0; for(size_t i=0;i&amp;lt;nums.size();++i) { nums[left++] = nums[i]; while(i+1&amp;lt; nums.size() &amp;amp;&amp;amp; nums[i] == nums[i+1]) { ++i; } } return left; }};6. 결과 및 후기, 개선점시간굳이 개선할 점 없음." }, { "title": "HTTP - 4 HTTP 메서드", "url": "/posts/HTTP04/", "categories": "HTTP, 김영한_모든 개발자를 위한 HTTP 웹 기본 지식", "tags": "HTTP", "date": "2021-02-09 19:00:00 +0900", "snippet": "해당 자료는 인프런 김영한 선생님의 모든 개발자를 위한 HTTP 웹 기본 지식 강의노트입니다.1. HTTP API 만들기다음과 같은 요구사항이 주어지고 API를 만드는 경우가 있다고 생각해봅시다. 회원 목록 조회 회원 조회 회원 등록 회원 수정 회원 삭제처음에 설계를 하면 다음과 같이 설계할 것입니다. 회원 목록 조회/read-member-list 회원 조회/read-member-by-id 회원 등록/craete-member 회원 수정/update-member 회원 삭제/delete-member이렇게 설계하는 방식은 안좋은 방식입니다.가장 좋은 방법은 리소스와 행위를 분리하여 작성하는 방식입니다.리소스란 위에서 ‘회원’이라는 명사가 리소스입니다.행위는 ‘조회하다, 등록하다, 수정하다, 삭제하다’ 등 동사가 행위입니다.리소스를 기준으로 API를 작성해야합니다. 회원 목록 조회/members 회원 조회/members/{id} 회원 등록/members/{id} 회원 수정/members/{id} 회원 삭제/members/{id}리소스 중심으로 API를 구성하였지만, 행위를 어떻게 적용해야할 지는 뒤에 적겠습니다.2. HTTP 메서드 - GET,POSTHTTP 메서드 종류는 다음과 같습니다. GET : 리소스 조회 POST : 요청 데이터 처리(주로 등록에 사용) PUT : 리소스를 대체, 해당 리소스가 없으면 생성 PATCH : 리소스 부분 변경 DELETE : 리소스 삭제 HEAD : GET과 동일하지만 메시지 부분을 제외하고, 상태 줄과 헤더만 반환 OPTIONS : 대상 리소스에 대한 통신 가능 옵션을 설명(주로 CORS에서 사용) CONNECT : 대상 자원으로 식별되는 서버에 대한 터널을 설정(잘 사용 안함) TRACE : 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행(마찬가지로 잘 사용 안함)GETGET /search?q=hello&amp;amp;hl=ko HTTP/1.1HOST: www.google.com리소스 조회를 담당하고, 서버에 전달하고 싶은 데이터는 query(쿼리 파라미터, 쿼리 스트링)을 통해서 전달합니다. 메시지 바디를 통해서 데이터를 전달할 수 있지만, 지원하지 않는 곳이 많아서 권장하지 않습니다.POSTPOST /members HTTP/1.1Content-Type: application/json{ &quot;username&quot;:&quot;hello&quot;, &quot;age&quot;:27} 요청 데이터 처리 메시지 바디를 통해 서버로 요청 데이터 전달 서버는 요청 데이터를 처리 메시지 바디를 통해 들어온 데이터를 처리하는 모든 기능을 수행 주로 전달된 데이터로 신규 리소스 등록, 프로세스 처리에 사용 스펙: POST 메서드는 대상 리소스가 리소스의 고유 한 의미 체계에 따라 요청에 포함 된 표현을 처리하도록 요청합니다. example 회원가입처럼 신규 사용자 등록 주문에서 ‘상품 id’를 보내 주문 프로세스를 처리하는 로직 게시판 글쓰기, 댓글달기 한 문서 끝에 내용 추가 등이러한 것들은 URI에 POST 요청이 들어오면 요청 데이터를 어떻게 처리할지 리소스마다 따로 정의해야함. -&amp;gt; 정해진것이 없다. 주문에서 결제완료 -&amp;gt; 배달시작 -&amp;gt; 배달완료 처럼 단순한 값 변경을 넘어 프로세스의 상태가 변경되는 경우배달시작을 할 경우 배달업체를 부르고, 배달 취소에대한 대비 등 많은 프로세스가 돌아가는 예시 다른 메서드로 처리하기 애매한 경우JSON으로 조회 데이터를 넘겨야 하는데, GET 메서드를 사용하기 어려운 경우, 애매한 경우3. HTTP 메서드 - PUT,PATH,DELETEPUT 리소스를 대체 리소스가 있으면 대체 리소스가 없으면 생성 파일을 폴더로 옮길 때 생각(있으면 덮어버림.) POST와의 차이점 클라이언트가 리소스를 식별 PUT /members/100 HTTP/1.1 Content-Type: application/json { //&quot;username&quot;: &quot;kms&quot; &quot;age&quot;: 50 } 위의 ‘/members/100’ 처럼 클라이언트가 경로를 알고 있는 것이 차이점입니다.만약 username을 생략해서 age만 보내면 기존에 있던 username또한 null로 대체됩니다.그렇기에 PUT은 업데이트용도가 아니고, 대체용도로 사용해야 합니다. PATCH 리소스 부분 변경PATCH /members/100 HTTP/1.1Content-Type: application/json{ &quot;age&quot;: 50}PUT과 달리 기존에 있던 username은 가만히 두고 age만 바뀝니다.PATCH를 지원하지 않는 경우 POST를 사용하면 됩니다.DELETEDELETE /members/100 HTTP/1.1Host: localhost:8080리소스 삭제위의 스펙들은 HTTP METHOD 스펙이므로 약속을 어기지말고 개발을 잘해야 합니다.4. HTTP 메서드의 속성 안전(Safe Methods) 멱등(Idempotent Methods) 캐시가능(Cacheable Methods)안전 호출해도 리소스를 변경하지 않는다. 로그가 쌓여서 시스템 에러 등 외부요인은 고려하지 않습니다. GET/HEAD는 데이터 조회만 수행하므로 안전하다고 할 수 있습니다.멱등f(fx))=f(x) 한 번 호출하든 두 번 세 번 … 호출하든 결과는 같아야한다. GET : 조회는 항상 결과가 같으므로 멱등 PUT : 결과를 대체하면서 덮어버리니 멱등 DELETE : 결과를 삭제하고, 두 번 호출하든 백 번 호출하든 결과는 삭제된 상태이므로 멱등 POST : 결제를 POST로 작성한다고 하면 두 번 호출하면 결제가 두 번 되므로 멱등이 아니다. PATCH : 만약 호출할 때마다 10씩 더한다는 명세서를 작성하면 멱등이 되지 않는다. 멱등이 아니도록 작성할 수도 있다.멱등은 주로 자동 복구 메커니즘에서 활용합니다.서버가 정상 응답을 주지 못했을 때, 클라이언트가 같은 요청을 다시 해도 되는지에 대한 근거가 됩니다.멱등도 마찬가지로 외부요인으로 인한 방해는 고려하지 않습니다.캐시가능 응답 결과 리소르를 캐시해서 사용해도 되는가? GET, HEAD, POST, PATCH는 캐시 가능입니다. 하지만 POST, PATCH는 본문 내용까지 캐시 키로 고려해야 하는데, 구현이 쉽지 않아서 GET, HEAD를 주로 캐시로 사용합니다." }, { "title": "leetcode(리트코드)2월9일 challenge538-Convert BST to Greater Tree", "url": "/posts/leetcode_Convert_BST_to_Greater_Tree/", "categories": "leetcode, Medium", "tags": "leetcode, Tree", "date": "2021-02-09 17:02:00 +0900", "snippet": "leetcode February challenge09 - Convert BST to Greater Tree문제입니다.1. 문제https://leetcode.com/explore/challenge/card/february-leetcoding-challenge-2021/585/week-2-february-8th-february-14th/3634/2. Input , Output3. 분류 및 난이도Medium의 난이도입니다.2월9일자 챌린지 문제입니다. 코드는 어렵지 않으나..4. 문제 해석 right-&amp;gt; root-&amp;gt; left를 돌면서 값을 더해줘야합니다. 일반적으로 알고 있는 left-&amp;gt;root-&amp;gt;right가 아니라 처음에는 풀기 까다로웠습니다. sum이라는 변수를 선언해서 재귀를 돌면서 관리해줘야합니다.5. code/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: int sum=0; void order(TreeNode* pointer,int&amp;amp; sum){ if(pointer!=nullptr) { order(pointer-&amp;gt;right,sum); sum += pointer-&amp;gt;val; pointer-&amp;gt;val=sum; order(pointer-&amp;gt;left,sum); } } TreeNode* convertBST(TreeNode* root) { order(root,sum); return root; }};6. 결과 및 후기, 개선점시간효율성이 좋은 코드제 코드와 같습니다.공간 효율성이 좋은 코드위의 코드와 같아서 따로 적진 않겠습니다." }, { "title": "leetcode(리트코드)977-Squares of a Sorted Array", "url": "/posts/leetcode_-Squares_of_a_Sorted_Array/", "categories": "leetcode, Eazy", "tags": "leetcode, Array", "date": "2021-02-09 15:02:00 +0900", "snippet": "leetcode Array intro - Squares of a Sorted Array 문제입니다.1. 문제https://leetcode.com/explore/learn/card/fun-with-arrays/521/introduction/3240/2. Input , Output3. 분류 및 난이도leetcode의 Array introduction에 있는 문제입니다.eazy난이도의 문제입니다.어렵지 않고, leetcode가 어떤 시스템인지 인지하기 위해 풀었습니다.4. 문제 해석 직관적입니다. 배열에 들어온 값을 한 변의 길이라고 생각하고 사각형의 넓이를 구한 뒤, 정렬해서 리턴하면 됩니다. 들어온 값은 이미 오름차순으로 정렬되어 있습니다.5. codeclass Solution {public: vector&amp;lt;int&amp;gt; sortedSquares(vector&amp;lt;int&amp;gt;&amp;amp; nums) { for(size_t i=0;i&amp;lt;nums.size();++i) nums[i]*= nums[i]; sort(nums.begin(),nums.end()); return nums; }};6. 결과 및 후기, 개선점제가 제출한 코드의 시간과 메모리를 첨부하지 않기로 하였습니다.이유는 매 번 제출할 때마다 결과가 다르게 나오기 때문입니다.시간효율성이 좋은 코드class Solution {public: vector&amp;lt;int&amp;gt; sortedSquares(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int n = nums.size(); //nums의 사이즈만큼의 크기를 가진 res벡터 vector&amp;lt;int&amp;gt; res(n); //Two pointer int left = 0; int right = n-1; int i = n-1; //양쪽에서 비교하면서 절대값이 큰 값을 배열의 맨 끝부터 인덱스 0까지 값을 집어 넣습니다. while(left&amp;lt;=right) { if(abs(nums[left]) &amp;gt; abs(nums[right])) { res[i] = nums[left]*nums[left]; left++; } else { res[i] = nums[right]*nums[right]; right--; } i--; } return res; }};공간 효율성이 좋은 코드위의 코드와 같아서 따로 적진 않겠습니다." }, { "title": "leetcode(리트코드)1295-Find Numbers with Even Number of Digits", "url": "/posts/leetcode_Find_Numbers_with_Even_Number_of_Digits/", "categories": "leetcode, Eazy", "tags": "leetcode, Array", "date": "2021-02-09 14:02:00 +0900", "snippet": "leetcode Array intro - Find Numbers with Even Number of Digits 문제입니다.1. 문제https://leetcode.com/explore/learn/card/fun-with-arrays/521/introduction/3237/2. Input , Output3. 분류 및 난이도leetcode의 Array introduction에 있는 문제입니다.어렵지 않고, leetcode가 어떤 시스템인지 인지하기 위해 풀었습니다.4. 문제 해석 배열을 돌면서 짝수크기인 배열요소를 찾아줍니다. 예를 들어 12는 크기가 2이므로 카운트를 세주고 7896도 크기가 4이므로 카운트를 세줍니다.5. codeclass Solution {public: int findNumbers(vector&amp;lt;int&amp;gt;&amp;amp; nums) { //정렬 sort(nums.begin(),nums.end()); int count=0; int division; int temp=nums[0]; int init=0; while(temp!=0) { temp/=10; init++; } //맨처음 요소가 짝수이면 10, 1000,10000 등으로 맞추려고 함. if(init%2==0) --init; division = pow(10,init); for(size_t i=0;i&amp;lt;nums.size();) { //홀수라면 넘어감. if(division &amp;gt; nums[i]) { ++i; continue; } else { division*=10; //짝수라면 그 범위내에서 카운트를 세줌. 10~99, 1000~9999 ... while(i&amp;lt;nums.size() &amp;amp;&amp;amp; nums[i]&amp;lt;division&amp;amp;&amp;amp;nums[i]&amp;gt;=division/10) { ++count; ++i; } division*=10; } } return count; }};6. 결과 및 후기, 개선점시간참고로 시간은 제출할 때마다 다르다고 합니다.이유 : https://leetcode.com/discuss/general-discussion/678668/why-does-the-runtime-change-every-time-the-code-is-submitted요약 하자면 사람들이 동 시간대에 제출을 많이하면 할수록 런타임이 길어진다고 합니다.알고리즘이 차이가 나지않는 이상 거의 변동이 없다고 합니다.메모리시간효율성이 좋은 코드typedef long long ll;#define rep(i,s,n)for(ll i = s;i&amp;lt;n;i++)///////////////////////////////////////////////////////////class Solution {public: // 숫자의 자릿수를 세주는 함수. int digits(int n) { int d = 0; while (n) { n /= 10; d++; } return d; } int findNumbers(vector&amp;lt;int&amp;gt;&amp;amp; n) { int ans = 0; rep(i, 0, n.size()) { //숫자 자릿수가 짝수라면 ans에 더함. ans += (digits(n[i]) % 2 == 0); } return ans; }};공간 효율성이 좋은 코드class Solution {public: int findNumbers(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int count = 0; for(int i = 0;i&amp;lt;nums.size();i++) { //string으로 바꿔버림 string conv = to_string(nums[i]); //string의 크기가 짝수이면 count를 더함. if(conv.size() % 2 == 0) { count += 1; } } return count; }};스트링으로 바꾼다는 생각을 했는데.. 좀 더 생각할걸.." }, { "title": "leetcode(리트코드)485-Max Consecutive Ones", "url": "/posts/leetcode_Max_Consecutive_Ones/", "categories": "leetcode, Eazy", "tags": "leetcode, Array", "date": "2021-02-09 13:02:00 +0900", "snippet": "leetcode Array intro - Max Consecutive Ones 문제입니다.1. 문제https://leetcode.com/explore/learn/card/fun-with-arrays/521/introduction/3238/2. Input , Output3. 분류 및 난이도leetcode의 Array introduction에 있는 문제입니다.eazy난이도의 문제입니다.어렵지 않고, leetcode가 어떤 시스템인지 인지하기 위해 풀었습니다.4. 문제 해석 해석은 배열 속에 있는 ‘1’의 연속적인 수열의 최대크기를 찾아 리턴하는 문제입니다. 즉 ‘0’이 하나 들어오면 0을 리턴 ‘1’이 하나 들어오면 1를 리턴해야합니다.5. codeclass Solution {public: int findMaxConsecutiveOnes(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int countz = 0; int result =0; if(nums.size()==1 &amp;amp;&amp;amp;nums[0]==0) return 0; for(size_t i=0;i&amp;lt;nums.size();++i) { if(nums[i]==0) countz=0; else if(nums[i]==1) { countz++; } if(result&amp;lt;countz) result =countz; } return result; } };6. 결과 및 후기, 개선점시간메모리다시 제출했을 때leetcode의 첫 문제인데 leetcode가 마음에 드는 점은 틀렸을 때 테스트코드를 공개해주고, 시간과 메모리사용량 순위를 보여줘서 더 개선하고 싶은 자극(?)이 든다.근데 똑같은 코드를 제출할 때마다 시간이 다르게 측정되는 것 같은데 오해일수도 있으므로 다른 문제들을 풀면서 알아봐야겠다.제일 많은 사람이 본 코드직접 실행해보니 나와 시간이 똑같고 메모리는 오히려 더 많이 사용했다.. ?? simple code라 이해하기 쉽게 작성한 코드라 그런가?? 잘 모르겠다.int findMaxConsecutiveOnes(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int max_cnt = 0, cnt = 0; //auto를 지원하는 지 몰랐다. 사실 알아도 안썼음. for (auto n : nums) { // 나도 max를 사용하려 했지만, leetcode에 익숙하지 않아서 라이브러리를 불러올때마다 런타임 에러가 발생해서 그냥 안썼다.. 직접해보니 그냥 라이브러리가 기본적으로 적용되어있다..! if (n == 1) max_cnt = max(++cnt, max_cnt); else cnt = 0; } return max_cnt;}" }, { "title": "Spring - 다시 시청 중", "url": "/posts/SpringPoint11/", "categories": "Java, 3. Spring_김영한_스프링-핵심-원리-기본편", "tags": "Spring Novice", "date": "2021-02-08 18:00:00 +0900", "snippet": "현재까지의 내용이 머릿속으로 정리되지 않아서, 일단 끝까지 시청하고 처음부터 다시 정리하고 있는 중입니다." }, { "title": "HTTP - 3 HTTP 기본", "url": "/posts/HTTP03/", "categories": "HTTP, 김영한_모든 개발자를 위한 HTTP 웹 기본 지식", "tags": "HTTP", "date": "2021-02-08 14:00:00 +0900", "snippet": "해당 자료는 인프런 김영한 선생님의 모든 개발자를 위한 HTTP 웹 기본 지식 강의노트입니다.1. HTTPHTTP 메시지에 모든 것을 전송합니다. HTMl, TEXT, IMAGE, JSON, XML 등등 거의 모든 형태의 데이터 전송이 가능합니다.현재 1997년에 나온 HTTP/1.1이 중요합니다.HTTP/2, HTTP/3 도 있지만, HTTP/1.1이 가장 보편적으로 쓰이고 있습니다.TCP는 HTTP/1.1, HTTP/2를 기반 프로토콜로 갖습니다.UDP는 HTTP/3을 기반 프로토콜로 갖습니다.크롬에서 확인하는 방법은 구글 크롬에서 “임창정”을 검색한 뒤 F12를 누른 뒤, Network 탭에 들어가면Proto…을 보시면 h3-29로 되어있는데 현재 구글에서는 h3(HTTP3)버전을 사용하고 있는 것을 볼 수 있습니다.2. 클라이언트 서버 구조HTTP는 기본적으로 클라이언트-서버 구조로 동작합니다.클라이언트는 서버에 요청을 보내고, 응답을 대기합니다.서버가 요청에 대한 결과를 만들어서 응답합니다.3. 무상태 프로토콜서버가 클라이언트의 상태를 보존하지 않는다는 뜻.먼저 stateful이란 고객이 노트북 2개를 신용카드로 구매한다고 하였을 때서버 3개를 거칠 경우 그 서버에서 다른 서버로 보낼 때마다 노트북 수량 2개와 신용카드 라는 것을 서버에서 상태를 갖고있는 형태입니다. 그러므로 만약 서버가 바뀌는 경우 해당 서버에게 “노트북 2개, 신용카드 구매” 라는 것을 미리 알려줘야합니다.세션을 유지하는 것을 stateful이라고 합니다.무상태 stateless란 노트북 2개를 신용카드를 구매한다고 하였을 때서버 3개를 거칠 경우 서버가 바뀌어도 상관이 없습니다. 그렇기 때문에 응답 서버를 쉽게 바꿀 수 있고, 무한하게 서버를 증설할 수 있습니다.만약 서버 1이 다운되어 버리면 클라이언트는 서버 1이 살아나면 요청을 다시 보내야합니다.무상태는 서버 1이 다운되어도 서버 2에서 응답을 해줄 수 있는 구조를 말합니다.이렇듯 응답 서버를 많이 증설할 수 있고 이러한 것을 스케일 아웃이라고 합니다.Stateless의 한계는 모든 것을 무상태로 설계할 수 있는 경우도 있고 없는 경우도 있습니다. 또한, 데이터를 많이 보내는 단점이 있습니다.로그인의 경우는 상태 유지로 설계해야합니다. 이러한 상태유지는 최소한만 사용해야 합니다.4. 비 연결성연결에는 두가지 모델이 있습니다. 연결을 유지하는 모델과 연결을 유지하지 않는 모델이 있습니다.연결을 유지하는 모델모든 클라이언트에 연결되어, 요청이 들어오면 응답해주는 방식입니다.장점으로는 이미 연결되어 있어, 3 way handshake, html 불러오는 등 작업이 필요가 없으나 서버에서는 연결유지를 위한 자원소모가 심해집니다.위의 예제에서는 클라이언트가 3대이지만 수천 수만대의 클라이언트와 연결을 유지하는 것은 힘든일입니다.연결을 유지하지 않는 모델연결을 유지하지 않는 모델은 요청에 대한 응답을 해주고, 연결을 끊어버립니다.서버 자원을 낭비하지 않는 장점이 있지만, 매 번 3 way handshake를 해줘야하고, 자바스크립트, css 등 수많은 자원이 함께 다운로드 되어집니다.지금은 HTTP 지속연결(Persistent Connections)로 문제를 해결했습니다.요청이 들어올 때마다 연결을 다시 해줬던 것을 연결을 유지시켜 놓고 응답이 모두 완료된 후 끊어버리는 것입니다.위에서 설명했던 연결을 유지하는 모델과 차이점은 연결을 유지하는 모델은 무한대로계속 유지하는 것이고, HTTTP 지속 연결은 그보다 짧게 1분 정도 연결을 유지하는 방식을 말합니다. 웹 서버를 제공하는 서비스에서는 보통 기본적으로 적용됩니다.5. HTTP 메시지https://tools.ietf.org/html/rfc7230#section-3에 나와있는 것을 보면 HTTP-message는 다음과 같은 스펙을 갖습니다.HTTP-message = start-line *(header - field CRLF) CRLF [message-body] 요청 메시지start-line : request-line = method SP(공백) request-target SP HTTP-version CRLF(엔터)로 + method : GET, POST, PUT, DELETE … + request-target : 절대경로로 나타내는 요청 대상 (/search?~) + HTTP-version : 예제에서 쓰인 HTTP/1.1응답 메시지startline : status-line = HTTP-version SP status-code SP reason-phrases CRLF + HTTP 버전 + HTTP 상태 코드 : 200(성공), 400(클라이언트 요청오류), 500(서버 내부 오류) + 이유 문구 : 사람이 이해할 수 있는 짧은 상태 코드 설명글(OK)HTTP 헤더header-field = field-name”:” OWS field-value OWS (OWS: 띄어쓰기 허용) + field-name은 대소문자 구문이 없지만, filed-value는 구분합니다.(서버에서 자체적으로 전부 소문자 처리할 수도 있음.)헤더에는 HTTP 전송에 필요한 모든 부가정보가 들어갑니다. 메시지 바디의 내용, 크기, 압축, 인증, 클라이언트 정보 등…HTTP 메시지 바디실제 전송할 데이터로 HTML 문서, 이미지, 영상 등 byte로 표현할 수 있는 모든 데이터 전송이 가능합니다." }, { "title": "HTTP - 2 URL와 웹 브라우저 요청 흐름", "url": "/posts/HTTP02/", "categories": "HTTP, 김영한_모든 개발자를 위한 HTTP 웹 기본 지식", "tags": "HTTP", "date": "2021-02-08 13:00:00 +0900", "snippet": "해당 자료는 인프런 김영한 선생님의 모든 개발자를 위한 HTTP 웹 기본 지식 강의노트입니다.1. URI URL는 로케이터(locator), 이름(name)또는 둘 다 추가로 분류될 수 있다.이렇듯 URI는 URL과 URN을 포함합니다.둘의 방식은 위와같은 차이점이 있으며, URN은 거의 쓰이지 않으므로 저런 패턴으로 구사하는 지를 알아두면 됩니다.URIUniform : 리소스 식별하는 통일된 방식Resource : 자원, URI로 식별할 수 있는 모든 것Identifier : 다른 항목과 구분하는데 필요한 정보URL - Locator : 리소스가 있는 위치를 지정URN - Name : 리소스에 이름을 부여URN 이름만으로 실제 리소스를 찾을 수 있는 방법이 보편화 되지 않았습니다.URL 예시는 다음과 같습니다. https://www.google.com/search?q=임창정&amp;amp;hl=koURL 문법 scheme://[userinfo@]host[:port][/path][?query][#fragment]https://www.google.com/search?q=임창정&amp;amp;hl=koscheme : 주로 프로토콜 사용, http는 80포트, https는 443포트를 주로 사용, 포트는 생략 가능합니다.프로토콜이란 어떤 방식으로 자원에 접근할 것인가를 약속하는 규칙입니다.https는 http에 보안이 추가된 것입니다.userinfo : URL에 사용자 정보를 포함해서 인증할 때 사용하지만 거의 사용하지 않습니다.host : 호스트명, 도메인명, IP 주소를 입력port : 위에서 언급한 것처럼 생략이 가능하고, 생략할 땐 http : 80, https : 443으로 생각하고 생략해야합니다.path : 리소스 경로, 계층적 구조 /home/file1.jpg/users -&amp;gt; user전부를 보여주는/users/100 -&amp;gt; 100번째 user를 보여주는query : key=value 형태, ?로 시작, &amp;amp;로 추가 가능, 보통 query parameter, query string 등으로 불립니다.fragment : 잘 사용하진 않고, html 내부 북마크에서 사용. 아마 html을 문단으로 나눠서 보여주는 형식을 말하는 듯 합니다.2. 웹브라우저 요청 흐름https://www.google.com/search?q=임창정&amp;amp;hl=ko이 문장을 갖고 흐름을 정리하면 웹 브라우저가 리소스 요청 시 HTTP 요청 메시지 라는 것을 생성저번 포스팅에서 쓴 네트워크 흐름대로 흘러갑니다. SOCKET 라이브러리, 3way handshake를 통해 서버와 연결 TCP/IP 연결 HTTP 메시지가 포함된 TCP/IP 패킷 생성 패킷 정보가 인터넷으로 들어감. 서버에 요청 패킷이 들어오면 껍데기(패킷들)은 버리고, HTTP 메시지를 확인 HTTP 메시지 요청에 따라 응답패킷을 생성해서 보냄. 많은 노드들을 통해 응답 패킷이 클라이언트에 도착하고 클라이언트도 마찬가지로 패킷들은 버리고 메시지를 확인하여 HTML 렌더링을 통해 화면에 보여짐." }, { "title": "HTTP - 1 인터넷 네트워크", "url": "/posts/HTTP01/", "categories": "HTTP, 김영한_모든 개발자를 위한 HTTP 웹 기본 지식", "tags": "HTTP", "date": "2021-02-08 01:00:00 +0900", "snippet": "해당 자료는 인프런 김영한 선생님의 모든 개발자를 위한 HTTP 웹 기본 지식 강의노트입니다.1. IP(인터넷 프로토콜)IP 프로토콜은 다음과 같은 역할이 있습니다. 지정한 IP주소로 데이터 전달 패킷 단위로 전송IP 패킷 정보에 출발지, 목적지, 메시지를 형식에 맞춰 보냅니다. 그 다음 목적지에서 메시지를 받으면 목적지에서 출발지에 다시 잘받았다는 메시지를 보냅니다.그 와중에 여러 노드(서버)들을 거치기 때문에, 출발했을 때와 도착지에서 다시 출발지로 메시지를 보낼 때의 경로가 다를 수 있습니다.IP 프로토콜의 한계 비연결성 패킷을 받은 대상이 없거나 서비스 불능 상태(컴퓨터 전원이 꺼져있거나 등)이여도 패킷을 전송합니다. 비신뢰성 전송 도중 사라지거나 패킷을 보낸 순서대로 오지 않을 가능성이 있습니다. 프로그램 구분 만약 게임도하고 음악도 같은 PC에서 들으면 어떤 프로그램에서 패킷을 보내는 지 프로그램을 구분할 수 없습니다. 이러한 단점을 해결한 것이 TCP/UDP 입니다.2. TCP/UDP프로토콜 계층에 따라 메시지를 보낼 때 SOCKET 라이브러리를 통해 전달하면서 TCP( 메시지 데이터) 그 다음 IP 패킷을 담아 물리계층인 LAN카드를 통해 서버로 보냅니다.TCP에서는 다음과 같은 정보들을 담아줍니다. 출발지 PORT, 목적지 PORT, 전송제어, 순서, 검증정보 등.. 위에서 IP 프로토콜의 단점인 순서 문제 등을 해결할 수 있게 됩니다.TCP 전송 제어 프로토콜(Transmission Control Protocol) 연결지향 (연결을 하고 메시지를 보내기 때문에 서비스 불능 상태를 무시하지 않음.) - TCP 3 way handshake TCP 3 way handshake에 대한 설명을 해줍니다. 클라이언트에서 SYN(신호)(헤더) 서버에서 SYN(신호) + ACK(응답)(헤더) 클라이언트에서 ACK(응답) + 데이터전송이 연결은 논리적으로 연결되어 있습니다.중간에 수 많은 노드들을 거쳐 온 것은 신경을 안쓴다는 것입니다.또한 응답을 서로 받는 과정에서는 헤더 부분만 전송하여 응답을 주고받습니다. 데이터 전달 보증(데이터 누락 시 볼 수 있음) 서버에서 데이터를 받았으면 응답을 하므로 누락을 알 수 있다. 순서 보장 패킷을 1,2,3 순서로 보냈을 때 1,3,2 순서로 도착하면 서버에서 내부의 로직에 따라 패킷을 패킷 2번을 다시 보내게 합니다. UDPTCP와 같은 계층에 있고 다음과 같은 기능이 있습니다. 데이터 전달 보증 X 순서 보장 X 연결지향 X 단순하지만 빠름 IP와 거의 같지만 + PORT, + 체크섬 정도만 추가여러 어플리케이션을 사용하고 있을 경우 각각 어플리케이션 서버와 패킷을 주고 받는데, 어떤 어플리케이션에 패킷을 전달할 지 알 수 있게 하는 것이 PORT의 역할입니다.현재 TCP가 인터넷을 점유했기 때문에 통신 최적화를 적용하기 어려운 점을 빠르고 보급이 덜 된 UDP를 통해 최적화를 진행할 수 있게 하고 있습니다.3. PORT한번에 둘 이상 연결해야 한다면 자신의 컴퓨터의 port란 것을 열어서 패킷을 주고 받습니다.패킷을 보낼 때 port정보를 보내기 때문에 이러한 것을 알 수 있습니다.port는 보통 0 ~ 65535 할당이 가능하지만 0 ~ 1023 은 잘 알려진 포트라하여, 사용하지 않는 것이 좋습니다.4. DNSDomain Name SystemIP는 기억하기 어렵고 IP는 바뀔 가능성이 크기 때문에 DNS가 나왔습니다.도메인 명을 등록을 하고 그것을 IP로 바꾸는 것을 말합니다. IP가 바뀔 경우 도메인 구입 업체에서 제공하는 서비스를 통해 도메인 서버에 IP 변경요청을 보낼 수 있습니다.Linux 포스팅을 했을 때 비슷한 내용이 있습니다.https://kkminseok.github.io/posts/ThisisLinuxC9/" }, { "title": "Programmers_BFS/DFS02 - 네트워크", "url": "/posts/Programmers_DFS_BFS02/", "categories": "Algorithm, Programmers", "tags": "Programmers, DFS", "date": "2021-02-05 16:03:00 +0900", "snippet": "프로그래머스 - 네트워크 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/parts/120772. 분류 및 난이도Programmers 문제입니다.level 3의 문제입니다.3. 생각한 것들(문제 접근 방법) 방문처리를 해줘야한다는 점 외에는 신경쓸 일이 없습니다.4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include&amp;lt;algorithm&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;iostream&amp;gt;using namespace std;bool check[201] = { false, };void DFS(int start,int n, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; computers){ check[start] = true; for (int i = 0; i &amp;lt; n; ++i) { if (!check[i] &amp;amp;&amp;amp; computers[start][i]) DFS(i, n, computers); }}int solution(int n, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; computers) { int answer = 0; for (size_t i = 0; i &amp;lt; n; ++i) { if (!check[i]) { ++answer; DFS(i, n, computers); } } return answer;}5. 결과" }, { "title": "Programmers_BFS/DFS01 - 타겟 넘버", "url": "/posts/Programmers_DFS_BFS01/", "categories": "Algorithm, Programmers", "tags": "Programmers, DFS", "date": "2021-02-05 13:03:00 +0900", "snippet": "프로그래머스 - 타겟 넘버 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/parts/120772. 분류 및 난이도Programmers 문제입니다.level 2의 문제입니다.3. 생각한 것들(문제 접근 방법) 방법에 대해서 끝까지 연산을 해서 확인해야하므로 DFS가 적합하다고 생각하고 풀었습니다.4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include&amp;lt;iostream&amp;gt;using namespace std;int result = 0;void DFS(vector&amp;lt;int&amp;gt; numbers, int target,int count, int sum){ if (count == numbers.size()) { if(target==sum) result++; return; } DFS(numbers, target, count + 1, sum + numbers[count]); DFS(numbers, target, count + 1, sum - numbers[count]);}int solution(vector&amp;lt;int&amp;gt; numbers, int target) { int answer = 0; DFS(numbers, target,0,0); answer = result; cout &amp;lt;&amp;lt; answer; return answer;}5. 결과" }, { "title": "Programmers_DP04 - 도둑질", "url": "/posts/Programmers_DP04/", "categories": "Algorithm, Programmers", "tags": "Programmers, DP", "date": "2021-02-04 16:03:00 +0900", "snippet": "프로그래머스 - 도둑질 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/parts/120772. 분류 및 난이도Programmers 문제입니다.level 4의 문제입니다.3. 생각한 것들(문제 접근 방법) 비슷한 문제가 백준에 있습니다. 주의할 점은 처음 집을 들리면 맨 마지막 집을 들리면 안된다는 점입니다. 이부분만 잘 해결해주면 됩니다.4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include&amp;lt;algorithm&amp;gt;#include&amp;lt;iostream&amp;gt;using namespace std;int dp[1000001] = { 0, };int dp2[1000001] = { 0, };int solution(vector&amp;lt;int&amp;gt; money) { int answer = 0; //첫번째를 잘 선택해야함 dp[0] = money[0]; dp[1] = money[0]; //첫번째 집을 안 드르는 경우 dp2[0] = 0; dp2[1] = money[1]; for (size_t i = 2; i &amp;lt; money.size(); ++i) { if(i!=money.size()-1)//마지막은 들어가면 안됨. dp[i] = max(dp[i - 2] + money[i], dp[i - 1]); dp2[i] = max(dp2[i - 2] + money[i], dp2[i - 1]); } answer = max(dp[money.size() - 2],dp2[money.size()-1]); return answer;}5. 결과" }, { "title": "Programmers_DP03 - 등굣길", "url": "/posts/Programmers_DP03/", "categories": "Algorithm, Programmers", "tags": "Programmers, DP", "date": "2021-02-04 13:03:00 +0900", "snippet": "프로그래머스 - 등굣길 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/parts/120772. 분류 및 난이도Programmers 문제입니다.level 3의 문제입니다.3. 생각한 것들(문제 접근 방법) 비슷한 문제가 백준에 있습니다. 그 코드를 참고해서 DFS로 풀었습니다. 마지막 결과값에 나머지연산을 안해줘서 틀렸었습니다.4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstring&amp;gt;using namespace std;const int MAX = 201;int MAP[MAX][MAX] = { 0, };int v[MAX][MAX] = { 0, };int dx[2] = {1,0 };int dy[2] = {0,1 }; int DFS(int i, int j, int m, int n){ if (i == n - 1 &amp;amp;&amp;amp; j == m - 1) { return 1; } if (v[i][j] != -1) return v[i][j]; v[i][j] = 0; for (int k = 0; k &amp;lt; 2; ++k) { int newX = i + dx[k]; int newY = j + dy[k]; if (0 &amp;lt;= newX &amp;amp;&amp;amp; newX &amp;lt; n &amp;amp;&amp;amp; 0 &amp;lt;= newY &amp;amp;&amp;amp; newY &amp;lt; m &amp;amp;&amp;amp; MAP[newX][newY] != 1) v[i][j] += (DFS(newX, newY, m, n)% 1000000007); } return v[i][j]% 1000000007;}int solution(int m, int n, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; puddles) { int answer = 0; for (size_t i = 0; i &amp;lt; puddles.size(); ++i) { MAP[puddles[i][1]-1][puddles[i][0]-1] = 1; } memset(v, -1, sizeof(v)); answer = DFS(0, 0,m,n); return answer;}int main(){ vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; puddles(10,vector&amp;lt;int&amp;gt;(10,0)); puddles[2].push_back(2); solution(4, 3, puddles);}5. 결과" }, { "title": "Programmers_DP01 - N으로 표현", "url": "/posts/Programmers_DP01/", "categories": "Algorithm, Programmers", "tags": "Programmers, DP", "date": "2021-02-03 13:06:00 +0900", "snippet": "프로그래머스 - N으로 표현 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/parts/120772. 분류 및 난이도Programmers 문제입니다.level 3의 문제입니다.3. 생각한 것들(문제 접근 방법) DP로 푼다기 보다 DFS로 풀 수 있어서 DFS로 풀었습니다. 아마 반복되는 연산들을 DP로 풀면 시간단축에 도움이 될 것 같습니다. 범위가 어디까지인지를 안정해줘서 DP로 풀려다가 실패했습니다.4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include&amp;lt;iostream&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;cmath&amp;gt;using namespace std;const int MAX = 9;int minD = MAX;void DFS(int N, int number,int depth, int num){ if (depth &amp;gt;= MAX) { return; } if (num == number) { minD = min(depth, minD); } int op = 0; for (int i = 1; i &amp;lt;= MAX; ++i) { op = op * 10 + N; DFS(N, number, depth + i, num + op); DFS(N, number, depth + i, num - op); if (num != 0) { DFS(N, number, depth + i, num * op); DFS(N, number, depth + i, num / op); } } }int solution(int N, int number) { int answer = 0; DFS(N, number,0,0); if (minD &amp;gt; 8) answer = -1; else answer = minD; return answer;}int main(){ solution(5, 12);}5. 결과" }, { "title": "Programmers_DP02 - 정수 삼각형", "url": "/posts/Programmers_DP02/", "categories": "Algorithm, Programmers", "tags": "Programmers, DP", "date": "2021-02-03 13:03:00 +0900", "snippet": "프로그래머스 - 정수 삼각형 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/parts/120772. 분류 및 난이도Programmers 문제입니다.level 3의 문제입니다.3. 생각한 것들(문제 접근 방법) 비슷한 문제가 백준에 있어서 푸는데 수월했습니다.4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include&amp;lt;algorithm&amp;gt;#include&amp;lt;iostream&amp;gt;using namespace std;int dp[501][501] = { 0, };int solution(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; triangle) { int answer = 0; dp[0][0] = triangle[0][0]; for (size_t i = 1; i &amp;lt; triangle.size(); ++i) { for (int j = 0; j &amp;lt; triangle[i].size(); ++j) { if (j==0) { dp[i][j] = dp[i - 1][j] + triangle[i][0]; } else { dp[i][j] += max(dp[i - 1][j - 1]+ triangle[i][j], dp[i - 1][j] + triangle[i][j]); } answer = max(dp[i][j], answer); } } return answer;}5. 결과" }, { "title": "Programmers_Greedy06 - 단속카메라", "url": "/posts/Programmers_Greedy06/", "categories": "Algorithm, Programmers", "tags": "Programmers, Greedy", "date": "2021-02-02 16:03:00 +0900", "snippet": "프로그래머스 - 단속카메라 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/parts/120772. 분류 및 난이도Programmers 문제입니다.level 3의 문제입니다.3. 생각한 것들(문제 접근 방법) 생각은 어렵지 않았으나 코드에 담는데 시간이 걸렸습니다. 차가 지나가고 나서 새로 오면 일단 카메라를 설치하는 것으로 경계선을 구분했습니다. 마지막에 1을 더해준건 마지막에 카메라가 더해지지 않기 때문입니다.4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;int solution(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; routes) { int answer = 0; sort(routes.begin(), routes.end()); int stop = routes[0][1]; for (int i = 1; i &amp;lt; routes.size(); ++i) { if (stop &amp;lt; routes[i][0]) { ++answer; stop = routes[i][1]; } if (stop &amp;gt;= routes[i][1]) stop = routes[i][1]; } return answer+1;}5. 결과" }, { "title": "Programmers_Greedy05 - 구명보트", "url": "/posts/Programmers_Greedy05/", "categories": "Algorithm, Programmers", "tags": "Programmers, Greedy", "date": "2021-02-02 15:03:00 +0900", "snippet": "프로그래머스 - 구명보트 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/parts/120772. 분류 및 난이도Programmers 문제입니다.level 2의 문제입니다.3. 생각한 것들(문제 접근 방법) 퀵소트처럼 맨 뒤와 앞에서 접근하며 담을 수 없는건 한명만 담고 담을 수 있으면 담아버립니다.4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include&amp;lt;algorithm&amp;gt;#include&amp;lt;iostream&amp;gt;using namespace std;int solution(vector&amp;lt;int&amp;gt; people, int limit) { int answer = 0; int exitif = 0; sort(people.begin(), people.end()); int maxn = people.size() - 1; int minn = 0; while (minn &amp;lt;= maxn) { if (people[minn] + people[maxn] &amp;lt;= limit) { ++minn; --maxn; } else { --maxn; } answer++; } return answer;}5. 결과" }, { "title": "Programmers_Greedy04 - 큰 수 만들기", "url": "/posts/Programmers_Greedy04/", "categories": "Algorithm, Programmers", "tags": "Programmers, Greedy", "date": "2021-02-02 14:03:00 +0900", "snippet": "프로그래머스 - 큰 수 만들기 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/parts/120772. 분류 및 난이도Programmers 문제입니다.level 2의 문제입니다.3. 생각한 것들(문제 접근 방법) 처음에는 조합을 생각했습니다. 크기가 백만이라 일반적인 조합은 안되고 DP를 이용해서 풀어야할텐데, 방법을 찾지 못해서 당연히 틀렸습니다.틀린 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include&amp;lt;iostream&amp;gt;using namespace std;string result = &quot;&quot;;void Combination(string number, string temp, int size, int index, int depth){ if (temp.size() == depth) { result = result &amp;lt; temp ? temp : result; cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; &#39;\\n&#39;; } else { for (int i = index; i &amp;lt; number.size(); ++i) { temp[depth] = number[i]; Combination(number, temp, size, i + 1, depth + 1); } }}string solution(string number, int k) { string answer = &quot;&quot;; int size = number.size() - k; string temp; temp.assign(size,&#39;A&#39;); Combination(number, temp, size, 0, 0); answer = result; return answer;} DP로 풀겠다는 집념으로 여러가지 찾아봤으나 힘들 것 같아서 포기하고 타 블로그의 도움을 받았습니다.https://mtoc.tistory.com/804. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include&amp;lt;iostream&amp;gt;using namespace std;string solution(string number, int k) { string answer = &quot;&quot;; int size = number.size() - k; int start = 0; for (int i = 0; i &amp;lt; size; ++i) { char MAXnum = number[start]; int MaxIdx = start; for (int j = start; j &amp;lt;= i + k; ++j) { if (MAXnum &amp;lt; number[j]) { MAXnum = number[j]; MaxIdx = j; } } start = MaxIdx + 1; answer += MAXnum; } return answer;}5. 결과생각 한사람이 너무 대단하다고 느꼈습니다." }, { "title": "Spring - 7 의존관계 자동 주입 (2)", "url": "/posts/SpringPoint10/", "categories": "Java, 3. Spring_김영한_스프링-핵심-원리-기본편", "tags": "Spring", "date": "2021-02-02 11:00:00 +0900", "snippet": "해당 자료는 인프런 김영한 선생님의 스프링-핵심-원리-기본편 강의노트입니다.1. 조회 빈이 2개 이상 - 문제만약 DicsountPolicy의 하위 타입인 FixDiscountPolicy, RateDiscountPolicy 둘다 스프링 빈으로 선언하고 의존관계 자동 주입을 실행하면 어떻게 될까?@Componentpublic class FixDiscountPolicy implements DiscountPolicy {}~@Componentpublic class RateDiscountPolicy implements DiscountPolicy {}@Autowiredprivate DiscountPolicy discountPolicy그리고 테스트를 돌려보면 하나의 빈을 기대했는데, 두개의 빈이 발견되었다고 오류가 나타납니다.NoUniqueBeanDefinitionException: No qualifying bean of type&#39;hello.core.discount.DiscountPolicy&#39; available: expected single matching beanbut found 2: fixDiscountPolicy,rateDiscountPolicy스프링 빈을 수동 등록해서 문제를 해결해도 되지만, 의존 관계 자동 주입에서 해결하는 여러 방법이 있습니다.2. @Autowired 필드명, @Qulifier, @Primary@Autowired 필드명 매칭 @Autowired는 타입 매칭을 시도하고, 이때 여러 빈이 있으면 필드 이름, 파라미터 이름으로 빈 이름을 추가 매칭합니다.@Autowiredprivate DiscountPolicy discountPolicy-&amp;gt;@Autowiredprivate DiscountPolicy rateDiscountPolicy필드 명이 rateDiscountPolicy이므로 정상 주입됩니다.@Autowired 매칭 정리 타입 매칭 타입 매칭의 결과가 2개 이상일 때 필드명, 파라미터 명으로 빈 이름 매칭@Qualifier 사용 추가 구분자를 붙여주는 방법입니다. 주입시 추가적인 방법을 제공하는 것이고, 빈 이름을 변경하는 것은 아닙니다.@Component@Qualifier(&quot;mainDiscountPolicy&quot;) //mainDiscountPolicy라는 구분자를 붙여줍니다.public class RateDiscountPolicy implements DiscountPolicy {}//@Component@Qualifier(&quot;fixDiscountPolicy&quot;) //다른 구현체에는 fixDiscountPolicy라는 구분자를 붙여줬습니다.public class FixDiscountPolicy implements DiscountPolicy {}이제 호출하는 부분에서 구분자를 명시하여 호출해주면 됩니다.//생성자 자동 주입 시@Autowiredpublic OrderServiceImpl(MemberRepository memberRepository,@Qualifie(&quot;mainDiscountPolicy&quot;)DiscountPolicydiscountPolicy) { this.memberRepository = memberRepository; this.discountPolicy = discountPolicy;}//수정자 자동 주입 시@Autowiredpublic DiscountPolicy setDiscountPolicy(@Qualifier(&quot;mainDiscountPolicy&quot;)DiscountPolicy discountPolicy) { return discountPolicy;}만약 @Qualifier(“mainDiscountPolicy”)를 못찾으면 해당 이름을 가진 스프링 빈을 추가로 찾습니다. 만약 없으면 NoSuchBeanDefinitionException 예외가 발생합니다.@Primary 사용 @Primary는 우선순위를 정하는 방법입니다. 한계가 있지만 보편적으로 쓰는 방법이라고 합니다.rateDiscountPoliy가 우선순위를 갖도록 애노테이션을 붙여주겠습니다@Component@Primary //public class RateDiscountPolicy implements DiscountPolicy {}@Componentpublic class FixDiscountPolicy implements DiscountPolicy {}이렇게 작성하면 호출하는 코드에서는 기존 코드처럼 구현체를 직접 명시안해도 된다는 장점이 있습니다.또한 @Qualifier는 주입 하는 모든 코드에 해당 애노테이션을 붙여줘야한다는 단점이 있기에 @Primary를 자주 사용합니다.//생성자@Autowiredpublic OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) { this.memberRepository = memberRepository; this.discountPolicy = discountPolicy;}//수정자@Autowiredpublic DiscountPolicy setDiscountPolicy(DiscountPolicy discountPolicy) { return discountPolicy;}@Primary와 @Qulifier가 같이 쓰였을 땐 @Qualifier가 우선순위를 갖습니다. 스프링은 자동보다는 수동이, 넓은 범위의 선택권보다는 좁은 범위의 선택권이 우선순위를 갖기 때문입니다.3. 애노테이션 직접 만들기 애노테이션을 직접 만들어주는 이유는 위의 코드에서 구분자를 명시해주어 컴파일에서 타입 체크가 되지 않습니다.package hello.core.annotataion;import org.springframework.beans.factory.annotation.Qualifier;import java.lang.annotation.*;@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER,ElementType.TYPE, ElementType.ANNOTATION_TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Qualifier(&quot;mainDiscountPolicy&quot;) // &amp;lt;&amp;lt;&amp;lt;--public @interface MainDiscountPolicy {}~~~@Component@MainDiscountPolicypublic class RateDiscountPolicy implements DiscountPolicy {}작성했던 OrderServiceImpl도 바꿔줍니다. @Autowired public OrderServiceImpl(MemberRepository memberRepository, @MainDiscountPolicy DiscountPolicy discountPolicy){ this.memberRepository = memberRepository; this.discountPolicy = discountPolicy; }애노테이션에는 상속이라는 개념이 없습니다. 이렇게 여러 애노테이션을 모아서 사용하는 기능은 스프링이 지원해주는 기능입니다.@Qulifier 뿐만 아니라 다른 애노테이션들도 함께 조합해서 사용할 수 있습니다. 심지어 @Autowired도 재정의할 수 있지만 유지보수에 혼란을 가져다줄 수 있습니다.커스텀 애노테이션은 협업에서 의사소통을 통해 해결해야하기 때문에 꼭 필요한 곳에만 써야합니다.**4. 조회와 빈이 모두 필요할 때, List, Map **의도적으로 스프링 빈이 다 필요한 경우가 있습니다.예를 들어서 위에서 작성한 할인 서비스를 제공하는데, 클라이언트가 할인의 종류를 선택할 수 있다고 가정하면 다음과 같이 구현할 수 있습니다.test코드입니다.package hello.core.autowired;import hello.core.AutoAppConfig;import hello.core.discount.DiscountPolicy;import hello.core.member.Grade;import hello.core.member.Member;import org.assertj.core.api.Assertions;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import java.util.List;import java.util.Map;import static org.assertj.core.api.Assertions.*;public class AllBeanTest { @Test void findAllBean(){ //컨테이너에 설정들을 넣어줌. ApplicationContext ac = new AnnotationConfigApplicationContext(AutoAppConfig.class,DiscountService.class); //빈을 가져옴. DiscountService discountService = ac.getBean(DiscountService.class); //실험할 멤버를 생성 Member member = new Member(1L, &quot;userA&quot;, Grade.VIP); // discount 함수에 &quot;fixDiscountPolicy&quot;라는 클래스 명을 아예 넣고 값을 기대함 int discountPrice = discountService.discount(member,10000,&quot;fixDiscountPolicy&quot;); // 가져온 값이 천원이어야하는데 맞는가? assertThat(discountService).isInstanceOf(DiscountService.class); assertThat(discountPrice).isEqualTo(1000); //마찬가지로 20000원을 넣고 rateDiscountPolicy라는 클래스 값을 넣음. 값은 20000/10인 2000원이 리턴되어야함. int rateDiscountPolicy = discountService.discount(member, 20000, &quot;rateDiscountPolicy&quot;); assertThat(rateDiscountPolicy).isEqualTo(2000); } static class DiscountService{ // 맵으로 스프링빈값들을 가져옴. private final Map&amp;lt;String, DiscountPolicy&amp;gt; policyMap; private final List&amp;lt;DiscountPolicy&amp;gt; policies; @Autowired public DiscountService(Map&amp;lt;String, DiscountPolicy&amp;gt; policyMap, List&amp;lt;DiscountPolicy&amp;gt; policies) { this.policyMap = policyMap; this.policies = policies; System.out.println(&quot;policyMap = &quot; + policyMap); System.out.println(&quot;policies = &quot; + policies); } public int discount(Member member, int price, String discountCode) { //입력된 String 값을 기준으로 스프링 빈에서 찾아서 가져옵니다. DiscountPolicy discountPolicy = policyMap.get(discountCode); return discountPolicy.discount(member,price); } }}결과슬슬 내용이 많아지니 저도 헷갈리는 부분이 많습니다. 다른사람들의 질문을 보면서 보충하고 있지만, 머릿속에 정리가 안되고 있습니다. 빠르게 한 번 훑고 다시 복습해야할 것 같습니다." }, { "title": "Programmers_Greedy03 - 섬 연결하기", "url": "/posts/Programmers_Greedy03/", "categories": "Algorithm, Programmers", "tags": "Programmers, Greedy", "date": "2021-02-01 14:09:00 +0900", "snippet": "프로그래머스 -섬 연결하기 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/parts/120772. 분류 및 난이도Programmers 문제입니다.level 3의 문제입니다.3. 생각한 것들(문제 접근 방법) 크루스칼 알고리즘 문제입니다.4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include&amp;lt;iostream&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;//부모 노드를 가져옴int getParent(int set[], int x){ if (set[x] == x)return x; return set[x] = getParent(set, set[x]);}//부모 노드를 병합void unionParent(int set[], int a, int b){ a = getParent(set, a); b = getParent(set, b); if (a &amp;lt; b)set[b] = a; else set[a] = b;}int find(int set[], int a, int b){ a = getParent(set, a); b = getParent(set, b); if (a == b)return 1; else return 0;}class Edge {public: int node[2]; int distance; Edge(int a, int b, int distance) { this-&amp;gt;node[0] = a; this-&amp;gt;node[1] = b; this-&amp;gt;distance = distance; } bool operator&amp;lt;(Edge&amp;amp; edge) { return this-&amp;gt;distance &amp;lt; edge.distance; }};int solution(int n, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; costs) { int answer = 0; vector&amp;lt;Edge&amp;gt; v; for (size_t i = 0; i &amp;lt; costs.size(); ++i) { v.push_back(Edge(costs[i][0], costs[i][1], costs[i][2])); } sort(v.begin(), v.end()); int* set = new int[n+1]; for (int i = 0; i &amp;lt; n; ++i) { set[i] = i; } for (int i = 0; i &amp;lt; v.size(); ++i) { if (!find(set, v[i].node[0], v[i].node[1])) { answer += v[i].distance; unionParent(set, v[i].node[0], v[i].node[1]); } } return answer;}5. 결과" }, { "title": "Programmers_Greedy02 - 조이스틱", "url": "/posts/Programmers_Greedy02/", "categories": "Algorithm, Programmers", "tags": "Programmers, Greedy", "date": "2021-02-01 14:06:00 +0900", "snippet": "프로그래머스 - 조이스틱 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/parts/120772. 분류 및 난이도Programmers 문제입니다.level 2의 문제입니다.3. 생각한 것들(문제 접근 방법) 두번째 인덱스가 A인경우만 검사해주면 되는 줄 알았습니다. 테스트케이스 11에서 계속 틀려서 애를 많이 먹었습니다. 보아하니 BBBAAAB같은 예제는 BBB간다음 되돌아가서 맨 끝을 B로 만들어주는게 최선의 정답인 경우가 있었습니다. 다른 사람들의 코드를 보며 이해한대로 다시 코딩하였습니다.틀린 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include&amp;lt;iostream&amp;gt;using namespace std;int solution(string name) { int answer = 0; size_t size = name.size(); size_t index = 0; for (; index &amp;lt; size; ++index) { if (index == 1 &amp;amp;&amp;amp; name[index] == &#39;A&#39;) { while (name[index] == &#39;A&#39;) ++index; } if (name[index] - 65 &amp;gt; 13) { cout &amp;lt;&amp;lt; answer &amp;lt;&amp;lt; name[index] &amp;lt;&amp;lt; &quot;1&quot; &amp;lt;&amp;lt; &#39;\\n&#39;; answer += 91 - name[index]; cout &amp;lt;&amp;lt; 91 - name[index] &amp;lt;&amp;lt; &quot;asdsad&quot;; } else { cout &amp;lt;&amp;lt; answer &amp;lt;&amp;lt; name[index] &amp;lt;&amp;lt; &quot;2&quot; &amp;lt;&amp;lt; &#39;\\n&#39;; answer += name[index] - 65; cout &amp;lt;&amp;lt; name[index] - 65 &amp;lt;&amp;lt; &quot;qqqqqq&quot;; } ++answer; } //마지막에 인덱스를 옮긴것도 포함이 되므로 return answer - 1;}4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include&amp;lt;iostream&amp;gt;using namespace std;int solution(string name) { int answer = 0; //현재 어디인지 가르키는 변수 int move = 0; //A로 초기화 string compare(name.length(), &#39;A&#39;); while (compare != name) { //next는 다음인덱스를 왼쪽부터 돌 지 오른쪽부터 돌 지 정하는 변수 int next = 0; int left = 0; int right = 0; for (int i = 0; i &amp;lt; name.size(); ++i) { if (move + i &amp;lt; name.size()) right = move + i; else right = move + i - name.size(); if (move - i &amp;gt;= 0) left = move - i; else left = move - i + name.size(); //오른쪽으로 가야하는 경우가 우선순위를 가집니다. if (compare[right] != name[right]) next = right; else if (compare[left] != name[left])next = left; else continue; answer += i; //조이스틱 위로 누른게 빠른지, 밑으로 누른게 빠른지 answer += min(name[next] - &#39;A&#39;, &#39;Z&#39; - name[next] + 1); //값을 바꿔줌. compare[next] = name[next]; break; } move = next; } return answer;}5. 결과테스트케이스 11때문에 너무 어려웠습니다." }, { "title": "Programmers_Greedy01 - 체육복", "url": "/posts/Programmers_Greedy01/", "categories": "Algorithm, Programmers", "tags": "Programmers, Greedy", "date": "2021-02-01 14:03:00 +0900", "snippet": "프로그래머스 - 체육복 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/parts/120772. 분류 및 난이도Programmers 문제입니다.level 1의 문제입니다.3. 생각한 것들(문제 접근 방법) 학생수 보다 조금 넉넉하게 배열을 만들어 관리했습니다. 잃어버린 학생한테는 –를 여유분이 있는 학생한테는 ++를 해주었습니다. 배열을 검사하며 뒤에있는 사람이 체육복을 주는 형태로 작성하였는데, 생각해보니 앞에있는 사람이 체육복을 주는 케이스가 있었습니다. 8, [2,3,4] [1]인경우 4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include&amp;lt;iostream&amp;gt;using namespace std;int solution(int n, vector&amp;lt;int&amp;gt; lost, vector&amp;lt;int&amp;gt; reserve) { int answer = 0; int* stu = new int[n+2]; for (int i = 0; i &amp;lt; n+1; ++i) { stu[i+1] = 1; } for (size_t i = 0; i &amp;lt; reserve.size(); ++i) { stu[reserve[i]]++; } for (size_t i = 0; i &amp;lt; lost.size(); ++i) { stu[lost[i]]--; } for (int i = 1; i &amp;lt; n+1; ++i) { if (stu[i]==0) { if (i + 1 &amp;lt; n + 1 &amp;amp;&amp;amp; stu[i + 1] &amp;gt; 1) { stu[i]++; stu[i + 1]--; } else if (i - 1 &amp;gt; 0 &amp;amp;&amp;amp; stu[i - 1] &amp;gt; 1) { stu[i]++; stu[i - 1]--; } } if (stu[i] &amp;gt; 0) ++answer; cout &amp;lt;&amp;lt; stu[i] &amp;lt;&amp;lt; &quot; &quot;; } return answer;}5. 결과" }, { "title": "Baekjoon6593-상범빌딩", "url": "/posts/baekjoon6593/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, BFS", "date": "2021-01-30 16:02:00 +0900", "snippet": "백준 사이트 6593 - 상범빌딩 문제입니다.1. 문제https://www.acmicpc.net/problem/65932. Input , Output3. 분류 및 난이도BFS문제입니다.백준에서는 Gold5 난이도를 책정하고 있습니다.4. 생각한 것들 3차원 배열맵이라는 것이 특징입니다. 종료조건을 잘 설정해줘야하는 것 외에는 특이한 점은 없습니다.5. code#define _CRT_SECURE_NO_WARNINGS#include&amp;lt;cstdio&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;cstring&amp;gt;using namespace std;int L, R, C;char MAP[31][31][31] = { &#39;0&#39;, };bool v[31][31][31] = { false };int startz = 0;int startx = 0;int starty = 0;int dx[6] = { -1,0,1,0,0,0 };int dy[6] = { 0,1,0,-1,0,0 };int dz[6] = { 0,0,0,0,1,-1 };bool Input(){ scanf(&quot;%d %d %d&quot;, &amp;amp;L, &amp;amp;R, &amp;amp;C); if (L==0 &amp;amp;&amp;amp;R==0&amp;amp;&amp;amp;C ==0) return false; getchar(); for (int i = 0; i &amp;lt; L; ++i) { for (int j = 0; j &amp;lt; R; ++j) { for (int k = 0; k &amp;lt; C; ++k) { scanf(&quot;%1c&quot;, &amp;amp;MAP[i][j][k]); if (MAP[i][j][k] == &#39;S&#39;) { startz = i; startx = j; starty = k; } } getchar(); } getchar(); } return true;}int Solve(){ queue&amp;lt;pair&amp;lt;pair&amp;lt;int, int&amp;gt;,pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;gt; q; q.push(make_pair(make_pair(startz, startx), make_pair(starty,0))); v[startz][startx][starty] = true; while (!q.empty()) { int z = q.front().first.first; int x = q.front().first.second; int y = q.front().second.first; int count = q.front().second.second; q.pop(); if (MAP[z][x][y] == &#39;E&#39;) return count; for (int k = 0; k &amp;lt; 6; ++k) { int newZ = z + dz[k]; int newX = x + dx[k]; int newY = y + dy[k]; if (0 &amp;lt;= newZ &amp;amp;&amp;amp; newZ &amp;lt; L &amp;amp;&amp;amp; 0 &amp;lt;= newX &amp;amp;&amp;amp; newX &amp;lt; R &amp;amp;&amp;amp; 0 &amp;lt;= newY &amp;amp;&amp;amp; newY &amp;lt; C &amp;amp;&amp;amp; v[newZ][newX][newY] == false &amp;amp;&amp;amp; MAP[newZ][newX][newY] != &#39;#&#39;) { q.push(make_pair(make_pair(newZ, newX), make_pair(newY, count + 1))); v[newZ][newX][newY] = true; } } } return 0;}int main() { while (Input()) { int result = Solve(); if (result == 0) { printf(&quot;Trapped!\\n&quot;); } else { printf(&quot;Escaped in %d minute(s).\\n&quot;, result); } memset(v, false, sizeof(v)); memset(MAP, false, sizeof(MAP)); } return 0;}6. 후기연습하기 좋은 문제." }, { "title": "Programmers_BruteForce03 - 카펫", "url": "/posts/Programmers_Brute03/", "categories": "Algorithm, Programmers", "tags": "Programmers, Brute", "date": "2021-01-29 16:09:00 +0900", "snippet": "프로그래머스 -카펫 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/parts/120772. 분류 및 난이도Programmers 문제입니다.level 2의 문제입니다.3. 생각한 것들(문제 접근 방법) 문제 자체는 어렵지 않았으나, 왜인지 모르게 Testcase1에서 계속 틀림…. 사람들이 많이 풀지도 않았고, 나와 공통된 질문도 없어서 소인수분해로 문제를 풀기 시작했습니다. 소인수 분해를 하면서 다른사람들의 질문을 보니 점화식이 존재.. brown = (yellow의 가로 + yellow의 세로 +2) * 2 이라는 식이 있었음.. 그래서 그걸 이용해서 코드를 짰습니다. 틀린 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include&amp;lt;iostream&amp;gt;using namespace std;bool checking(int tempbrown, int tempyellow, int brown, int yellow){ for (int i = yellow; i &amp;gt; 0; --i) { if (yellow%i == 0) { if (tempbrown &amp;gt; i &amp;amp;&amp;amp; tempyellow - 1 &amp;gt; (yellow / i)) { cout &amp;lt;&amp;lt; tempbrown &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; tempyellow &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; yellow &amp;lt;&amp;lt; &#39;\\n&#39;; return true; } } } return false;}vector&amp;lt;int&amp;gt; solution(int brown, int yellow) { vector&amp;lt;int&amp;gt; answer; int sum = brown + yellow; for (int i = sum; i &amp;gt;= 1; --i) { if (sum%i == 0) { if (i &amp;lt;(sum / i)) return answer; int tempyellow = sum / i; if (tempyellow != yellow) { bool check = checking(i, tempyellow, brown, yellow); if (check) { answer.push_back(i); answer.push_back(tempyellow); return answer; } } } } return answer;}4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include&amp;lt;iostream&amp;gt;using namespace std;bool checking(int tempbrown, int tempyellow, int brown, int yellow){ for (int i = yellow; i &amp;gt; 0; --i) { if (yellow%i == 0) { if (tempbrown &amp;gt; i &amp;amp;&amp;amp; tempyellow - 1 &amp;gt; (yellow / i)) { cout &amp;lt;&amp;lt; tempbrown &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; tempyellow &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; yellow &amp;lt;&amp;lt; &#39;\\n&#39;; return true; } } } return false;}vector&amp;lt;int&amp;gt; solution(int brown, int yellow) { vector&amp;lt;int&amp;gt; answer; vector&amp;lt;int&amp;gt; sosu; int sum = brown + yellow; sosu.push_back(1); for (int i = 2; i &amp;lt;= yellow / 2; ++i) { if (yellow%i == 0) { sosu.push_back(i); cout &amp;lt;&amp;lt; i&amp;lt;&amp;lt;&quot; &quot;; } } for (size_t i =0 ; i&amp;lt;sosu.size();++i) { int div = yellow / sosu[i]; int result = (div + sosu[i] + 2) * 2; if (result == brown) { answer.push_back(div + 2); answer.push_back(sosu[i] + 2); break; } } return answer;}5. 결과테케1 틀린거에서 1시간 가까이 쓴 것 같습니다." }, { "title": "Programmers_BruteForce02 - 소수찾기", "url": "/posts/Programmers_Brute02/", "categories": "Algorithm, Programmers", "tags": "Programmers, Brute", "date": "2021-01-29 14:09:00 +0900", "snippet": "프로그래머스 -소수찾기 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/parts/120772. 분류 및 난이도Programmers 문제입니다.level 2의 문제입니다.3. 생각한 것들(문제 접근 방법) 문자열.. 어질어질 문자열의 크기만큼 에라토스테네스의 체를 이용해 소수를 저장했습니다. 그 이후 문자열의 각각 인덱스의 정수값을 카운트하여 소수 전체를 돌며 속한 값이 없으면 0을리턴하고 하나라도 존재하면 1을 리턴하여 더했습니다.4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include&amp;lt;iostream&amp;gt;#include&amp;lt;cmath&amp;gt;#include&amp;lt;cstring&amp;gt;using namespace std;bool* PrimeArray;int counting[10] = { 0, };void Eratos(int n){ PrimeArray = new bool[n + 1]; cout &amp;lt;&amp;lt; n; if (n &amp;lt;= 1) return; for (int i = 2; i &amp;lt;= n; i++) PrimeArray[i] = true; for (int i = 2; i * i &amp;lt;= n; i++) { if (PrimeArray[i]) for (int j = i * i; j &amp;lt;= n; j += i) PrimeArray[j] = false; } // 이후의 작업 ...}bool check(int* counting,int input){ while (input != 0) { int num1 = input % 10; if (counting[num1] == 0) return false; else counting[num1]--; input /= 10; } return true; }int solution(string numbers) { int answer = 0; size_t strsize = numbers.size(); int tempcount[10] = { 0, }; for (size_t i = 0; i &amp;lt; strsize; ++i) { counting[numbers[i] - 48]++; } int maxsize = pow(10, strsize); Eratos(maxsize); for (int i = 2; i &amp;lt; maxsize; ++i) { if (PrimeArray[i]) { memcpy(tempcount, counting,sizeof(counting)); answer += check(tempcount,i); } } return answer;}5. 결과" }, { "title": "Programmers_BruteForce01 - 모의고사", "url": "/posts/Programmers_Brute01/", "categories": "Algorithm, Programmers", "tags": "Programmers, Brute", "date": "2021-01-29 13:09:00 +0900", "snippet": "프로그래머스 -모의고사 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/parts/120772. 분류 및 난이도Programmers 문제입니다.level 1의 문제입니다.3. 생각한 것들(문제 접근 방법) 어렵지는 않지만, 효율성을 따지기 위해 이것저것 시도한 것 같습니다. 하나의 for문에 담으려고 하였으나 더 복잡해질 것 같아서 배열 3개로 만들어서 비교해서 넣었습니다. 모두 0문제 맞췄을 때에 대한 예외처리는 없는 것 같습니다.4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;const int MAX = 10001;int arr[MAX] = { 1,2,3, };int arr2[MAX] = { 0, };int arr3[MAX] = { 0, };int temp[5] = { 3,1,2,4,5 };int temp2[4] = { 1,3,4,5 }; bool pred(pair&amp;lt;int, int&amp;gt;&amp;amp; a, pair&amp;lt;int, int&amp;gt;&amp;amp; b){ if (a.second == b.second) return a.first &amp;lt; b.first; else return a.second &amp;gt; b.second;}vector&amp;lt;int&amp;gt; solution(vector&amp;lt;int&amp;gt; answers) { vector&amp;lt;int&amp;gt; answer; int init = 0; int init2 = 0; int init3 = 0; vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; vec; vec.push_back(make_pair(1, 0)); vec.push_back(make_pair(2, 0)); vec.push_back(make_pair(3, 0)); for (int i = 0; i &amp;lt; MAX; ++i) { arr[i] = init % 5+ 1; ++init; if (i % 2 == 0) { arr2[i] = 2; } else { arr2[i] = temp2[init2]; init2++; if (init2 &amp;gt; 3) init2 = 0; } arr3[i] = temp[init3]; if (i % 2 == 1) { init3++; if (init3 &amp;gt; 4) init3 = 0; } } for (size_t i = 0; i &amp;lt; answers.size(); ++i) { if (answers[i] == arr[i]) vec[0].second++; if (answers[i] == arr2[i]) vec[1].second++; if (answers[i] == arr3[i]) vec[2].second++; } sort(vec.begin(), vec.end(),pred); if (!(vec[0].second == 0)) { for (size_t i = 0; i &amp;lt; vec.size(); ++i) { answer.push_back(vec[i].first); if (i + 1 &amp;lt; vec.size() &amp;amp;&amp;amp; vec[i].second == vec[i + 1].second) continue; else break; } } return answer;}5. 결과" }, { "title": "Programmers_sort03 - H-index", "url": "/posts/ProgrammersSort3/", "categories": "Algorithm, Programmers", "tags": "Programmers, Sort", "date": "2021-01-28 16:09:00 +0900", "snippet": "프로그래머스 -H-index 수 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/parts/120772. 분류 및 난이도Programmers 문제입니다.level 2의 문제입니다.3. 생각한 것들(문제 접근 방법) 헷갈려서 생각하는 데 시간이 좀 걸렸습니다. 인덱스 접근만 잘 하면 풀 수 있는 문제 같았습니다.4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;int solution(vector&amp;lt;int&amp;gt; citations) { int answer = 0; sort(citations.begin(), citations.end(),greater&amp;lt;int&amp;gt;()); if (citations[0] == 0) return 0; for (size_t i = 0; i &amp;lt; citations.size(); ++i) { if (citations[i] &amp;gt; i) ++answer; } return answer;}5. 결과" }, { "title": "Programmers_sort02 - 가장 큰 수", "url": "/posts/ProgrammersSort2/", "categories": "Algorithm, Programmers", "tags": "Programmers, Sort", "date": "2021-01-28 16:09:00 +0900", "snippet": "프로그래머스 - 가장 큰 수 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/parts/120772. 분류 및 난이도Programmers 문제입니다.level 2의 문제입니다.3. 생각한 것들(문제 접근 방법) 생각 자체는 어렵지 않았습니다. 배열을 돌면서 주어진 정렬 조건대로 answer에 추가해주었습니다. 인풋으로 0이 들어올 경우를 예외처리 해주었습니다. 4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;bool pred(string&amp;amp; a, string&amp;amp; b){ return a + b &amp;gt; b + a;}string solution(vector&amp;lt;int&amp;gt; numbers) { string answer = &quot;&quot;; vector&amp;lt;string&amp;gt; vec; for (size_t i = 0; i &amp;lt; numbers.size(); ++i) { vec.push_back(to_string(numbers[i])); } sort(vec.begin(), vec.end(),pred); for (size_t i = 0; i &amp;lt; numbers.size(); ++i) answer += vec[i]; if(answer[0]==&#39;0&#39;) answer=&#39;0&#39;; return answer;}5. 결과" }, { "title": "Programmers_sort01 - K번째 수", "url": "/posts/ProgrammersSort1/", "categories": "Algorithm, Programmers", "tags": "Programmers, Sort", "date": "2021-01-28 16:09:00 +0900", "snippet": "프로그래머스 - K번째 수 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/parts/120772. 분류 및 난이도Programmers 문제입니다.level 1의 문제입니다.3. 생각한 것들(문제 접근 방법) 일이 많아서 빨리 끝내야한다는 생각에 비효율적인 코드를 마구 넣었습니다. 추천할만한 코드는 아닙니다. 반복문마다 객체 생성을 반복하면서 초기화도 반복!!… 굉장히 비효율적인 코드. 나머지는 인덱스 주어진만큼 정렬한 뒤, 정렬을 시작한 위치에서 주어진 K값을 더해 반환하였습니다. 4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;#include&amp;lt;iostream&amp;gt;using namespace std;vector&amp;lt;int&amp;gt; solution(vector&amp;lt;int&amp;gt; array, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; commands) { vector&amp;lt;int&amp;gt; answer; for (size_t i = 0; i &amp;lt; commands.size(); ++i) { int* temp = new int[array.size()]; for (size_t i = 0; i &amp;lt; array.size(); ++i) { temp[i] = array[i]; } int start = commands[i][0]-1; int end = commands[i][1]; int index = commands[i][2]-1; sort(temp+start, temp+end); answer.push_back(temp[index+start]); delete temp; } return answer;}5. 결과" }, { "title": "Baekjoon2011-암호코드", "url": "/posts/baekjoon2011/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, DP", "date": "2021-01-27 18:02:00 +0900", "snippet": "백준 사이트 2011 - 암호코드 문제입니다.1. 문제https://www.acmicpc.net/problem/20112. Input , Output3. 분류 및 난이도DP문제입니다.백준에서는 Sliver1의 난이도를 책정하고 있습니다.4. 생각한 것들 예외처리가 무진장 많습니다. 특히 0에 대한 조건처리를 잘 해줘야합니다. stoi()함수를 쓸까 했지만 쓰는게 더 복잡할 것 같아서 쓰지 않았습니다. 2차원 DP를 사용했는데 dp[?][0] 은 그 자리에 한자리가 들어올 때, dp[?][1]은 그자리에 두자리가 들어올 때 입니다.‘312’를 예를 들면 dp[3][0] = ‘31’ + ‘2’가 되는 거고 dp[3][1]은 ‘3’ + ‘12’ 가 되는 경우의 수 입니다.5. code#include&amp;lt;iostream&amp;gt;#include&amp;lt;string&amp;gt;using namespace std;int dp[5001][2] = { 0, };const int MOD = 1000000;int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); string input; cin &amp;gt;&amp;gt; input; int countzero = 0; if (input[0]-48 == 0 ) { cout &amp;lt;&amp;lt; 0; return 0; } dp[0][0] = 1; dp[0][1] = 0; int numz = 0; size_t size = input.size()-1; for (size_t i = 1; i &amp;lt; input.size(); ++i) { if (input[i] - 48 == 0) { ++countzero; if (countzero &amp;gt; 1) { cout &amp;lt;&amp;lt; 0; return 0; } } else countzero = 0; //2개인 경우 if (i &amp;gt;= 1) { if (input[i-1]-48!=0)//두자리 수 가능 { numz = ((input[i - 1] - 48) * 10) +(input[i] - 48); if (numz &amp;gt; 0 &amp;amp;&amp;amp; numz &amp;lt; 27) { if (i == 1) dp[i][1]++; else dp[i][1] = dp[i - 2][0] + dp[i - 2][1]; dp[i][1] %= MOD; } } else dp[i][1] = 0; } //하나인 경우 나중에처리 if (input[i]-48 != 0) { dp[i][0] = dp[i - 1][0] + dp[i - 1][1]; dp[i][0] %= MOD; } else { dp[i][0] = 0; } } cout &amp;lt;&amp;lt; (dp[size][0] + dp[size][1])%MOD; return 0;}6. 후기이제 2차원 DP도 뭔가 감을 잡는 듯한 느낌?.." }, { "title": "Programmers_Heap03 - 이중우선순위 큐", "url": "/posts/Programmers_Heap03/", "categories": "Algorithm, Programmers", "tags": "Programmers, Heap", "date": "2021-01-27 14:09:00 +0900", "snippet": "프로그래머스 - 이중우선순위 큐 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/parts/120772. 분류 및 난이도Programmers 문제입니다.level 3의 문제입니다.3. 생각한 것들(문제 접근 방법) 어떤 자료구조에 앞 뒤로 숫자를 넣고 빼는 것은 deque에 어울리지 않을까해서 deque를 사용했습니다. 불필요한 반복을 줄이기 위해 정렬 여부를 판단하는 bool 타입 변수 check를 두었습니다. Insert만 들어올 경우를 대비해 마지막에 한 번 더 정렬을 해줬습니다.4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include&amp;lt;deque&amp;gt;#include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;bool pred(int&amp;amp; a, int&amp;amp; b){ return a &amp;lt; b;}vector&amp;lt;int&amp;gt; solution(vector&amp;lt;string&amp;gt; operations) { vector&amp;lt;int&amp;gt; answer; deque&amp;lt;int&amp;gt; dq; string str; //정렬 판단 여부 bool check = false; for (size_t i = 0; i &amp;lt; operations.size(); ++i) { str = operations[i]; // I,D 인지 확인 char query = str[0]; //숫자가 앞에 오도록 잘라줌 str = str.substr(2); // 뒤의 숫자 문자열을 숫자 자료형으로 치환 int insert = stoi(str); if (query == &#39;I&#39;)//insert { dq.push_back(insert); //정렬해라 라는 의미 check = true; } else { if (insert == 1) { //정렬을 해야하면 if (check) { sort(dq.begin(), dq.end(),pred); check = false; } if(!dq.empty()) dq.pop_back(); } else { if (check) { sort(dq.begin(), dq.end(),pred); check = false; } if (!dq.empty()) dq.pop_front(); } } } if (dq.empty()) { answer.push_back(0); answer.push_back(0); } else { //Insert만 들어올 경우 정렬 다시 해줘야하므로 sort(dq.begin(), dq.end(), pred); answer.push_back(dq.back()); answer.push_back(dq.front()); } return answer;}5. 결과" }, { "title": "Programmers_Heap02 - 디스크 컨트롤러", "url": "/posts/Programmers_Heap02/", "categories": "Algorithm, Programmers", "tags": "Programmers, Heap", "date": "2021-01-27 13:09:00 +0900", "snippet": "프로그래머스 - 디스크 컨트롤러 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/parts/120772. 분류 및 난이도Programmers 문제입니다.level 3의 문제입니다.3. 생각한 것들(문제 접근 방법) 테스트 케이스 4,7,8,9,18이 계속 틀렸습니다. 요청시간이 온 순서대로 처리해야하기에 요청시간을 기준으로 정렬을 해줘야한다고 생각했습니다. 만약 요청 작업 중에 여러 작업의 요청이 들어오면 가장 빨리 끝낼 수 있는 것이 우선순위를 갖고, 가장 빨리 끝낼 수 있는 것 마저 같다면 요청이 먼저 온 것을 처리합니다. 작업은 단일 작업으로 해야합니다. 요청이 언제 올 지 모르기 때문입니다. -&amp;gt; 이것 때문에 틀림.틀린 코드입니다#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;iostream&amp;gt;#include&amp;lt;cmath&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;bool pred(pair&amp;lt;int, int&amp;gt; a, pair&amp;lt;int, int&amp;gt; b){ if (a.second == b.second) return a.first &amp;lt; b.first; return a.second &amp;gt; b.second;}int solution(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; jobs) { int answer = 0; int size = jobs.size(); int ms = 0; priority_queue&amp;lt;pair&amp;lt;int, int&amp;gt;, vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;, greater&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;gt; q; priority_queue&amp;lt;pair&amp;lt;int, int&amp;gt;, vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;, greater&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;gt; tempq; //요청 시간 순으로 정렬하면서 큐에 넣습니다. for (size_t i = 0; i &amp;lt; jobs.size(); ++i) { q.push(make_pair(jobs[i][0], jobs[i][1])); } while (!q.empty()) { //요청시간이 짧다면 if (q.top().first &amp;lt;= ms) { while (!q.empty() &amp;amp;&amp;amp; q.top().first &amp;lt;= ms) { int request = q.top().first; int time = q.top().second; tempq.push(make_pair(time, request)); q.pop(); } if (!tempq.empty()) { int request = tempq.top().second; int time = tempq.top().first; tempq.pop(); ms += time; answer += ms - request; } } else { //요청시간안에 들어오지 않았으면 ms를 증가시킵니다. ms++; } } while (!tempq.empty()) { int request = tempq.top().second; int time = tempq.top().first; tempq.pop(); ms += time; answer += ms - request; } answer = trunc(answer / size); return answer;}고친 점 구글링을 하다보니 2차워 벡터도 sort()함수를 통해 첫 번째 요소로 정렬이 가능하다는 점을 알았습니다. 다른 사람들의 질문을 보며 힌트를 얻고, 단일 처리코드를 제외한 다른 것들의 반복적인 코드를 제거했습니다. 위의 로직과 다른 점이 기존 배열에 직접 참조하느냐, 우선순위 큐에 넣은 값을 참조하느냐 차이인 것 같은데 왜 틀렸는 지 모르겠습니다..4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;iostream&amp;gt;#include&amp;lt;cmath&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;int solution(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; jobs) { int answer = 0; sort(jobs.begin(), jobs.end()); int ms = 0; priority_queue&amp;lt;pair&amp;lt;int, int&amp;gt;, vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;, greater&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;gt; pq; int i = 0; while (i&amp;lt;jobs.size() || !pq.empty()) { while (i&amp;lt;jobs.size() &amp;amp;&amp;amp; jobs[i][0] &amp;lt;= ms) { pq.push(make_pair(jobs[i][1], jobs[i][0])); ++i; } //작업 처리 하나만 if (!pq.empty()) { int time = pq.top().first; int request = pq.top().second; pq.pop(); ms += time; answer += (ms - request); } else { ms = jobs[i][0]; } } answer = trunc(answer / jobs.size()); return answer;}5. 결과운영체제 과목에서 이 로직을 c++로 짰었습니다.코드가 너무 길어서 참고는 안했습니다." }, { "title": "Programmers_Heap01 - 더 맵게", "url": "/posts/Programmers_Heap01/", "categories": "Algorithm, Programmers", "tags": "Programmers, Heap", "date": "2021-01-27 12:09:00 +0900", "snippet": "프로그래머스 - 더 맵게 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/parts/12077 섞은 음식의 스코빌 지수 = 가장 맵지 않은 음식의 스코빌 지수 + (두 번째로 맵지 않은 음식의 스코빌 지수 * 2)2. 분류 및 난이도Programmers 문제입니다.level 2의 문제입니다.3. 생각한 것들(문제 접근 방법) 처음 두 개의 값을 빼서 계산한 다음 다시 넣는데 정렬해서 넣어야하므로 우선순위 큐를 생각했습니다. 예외는 두 가지 상황을 고려했습니다. 처음에 아예 안들어올 때 첫 번째 요소를 큐에서 제거했는데 다음에 빼야할 두 번째 요소가 없을 때 큐 맨 앞에 있는 요소가 K를 넘을 때 반복문을 벗어납니다.4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;#include&amp;lt;queue&amp;gt;#include &amp;lt;iostream&amp;gt;using namespace std;int solution(vector&amp;lt;int&amp;gt; scoville, int K) { int answer = 0; priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, greater&amp;lt;int&amp;gt;&amp;gt; q; for (size_t i = 0; i &amp;lt; scoville.size(); ++i) { q.push(scoville[i]); } while (!q.empty() &amp;amp;&amp;amp;q.top() &amp;lt;= K ) { int Nspicy = q.top(); q.pop(); if (q.empty()) { answer = -1; break; } int Nspicy2 = q.top(); q.pop(); int mix = Nspicy + (Nspicy2 * 2); q.push(mix); ++answer; } return answer;}5. 결과" }, { "title": "Baekjoon12851-숨바꼭질 2", "url": "/posts/baekjoon12851/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, BFS", "date": "2021-01-26 18:02:00 +0900", "snippet": "백준 사이트 12851 - 숨바꼭질 2 문제입니다.1. 문제https://www.acmicpc.net/problem/128512. Input , Output3. 분류 및 난이도BFS문제입니다.백준에서는 Gold5의 난이도를 책정하고 있습니다.4. 생각한 것들 옛날에 푼 숨바꼭질 3 코드를 참고하여 DP만 계산해주었습니다. n과 k가 같은 값으로 들어올 시 DP가 0으로 초기화된 상태라 0을 내뱉는 경우를 예외처리 안해줘서 틀렸습니다.5. code#include&amp;lt;iostream&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;const int MAX = 100001;int n, k;int v[MAX];int DP[MAX] = { 0, };void Input(){ cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k; for (int i = 0; i &amp;lt; MAX; ++i) { v[i] = 100000; DP[i] = 0; }}int Solve(){ //Bfs queue&amp;lt;int&amp;gt; q; q.push(n); v[n] = 0; while (!q.empty()) { int spot = q.front(); q.pop(); if (spot == k) return v[spot]; if (spot + 1 &amp;lt; MAX &amp;amp;&amp;amp; v[spot + 1] &amp;gt; v[spot]) { q.push(spot + 1); v[spot + 1] = v[spot] + 1; DP[spot + 1] ++; } if (spot - 1 &amp;gt;= 0 &amp;amp;&amp;amp; v[spot - 1] &amp;gt; v[spot]) { q.push(spot - 1); v[spot - 1] = v[spot] + 1; DP[spot - 1] ++; } if (spot * 2 &amp;lt; MAX &amp;amp;&amp;amp; v[spot * 2] &amp;gt; v[spot]) { q.push(spot * 2); v[spot * 2] = v[spot] + 1; DP[spot * 2] ++; } }}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); Input(); int time = Solve(); if (n == k) DP[k] = 1; cout &amp;lt;&amp;lt; time &amp;lt;&amp;lt; &#39;\\n&#39; &amp;lt;&amp;lt; DP[k]; return 0;}6. 후기요새 자취방 이사 때문에 정신이 없어서 빠르게 풀려고 푼 문제." }, { "title": "Programmers_Stack/Queue04 - 프린터", "url": "/posts/Programmers_SQ04/", "categories": "Algorithm, Programmers", "tags": "Programmers, Queue", "date": "2021-01-26 16:09:00 +0900", "snippet": "프로그래머스 -스택/큐 - 프린터 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/parts/120772. 분류 및 난이도Programmers 문제입니다.스택 큐 Level 2 문제 입니다.3. 생각한 것들(문제 접근 방법) 원래 같았으면 입력이 크지 않아서 한바퀴씩 돌면서 우선순위를 찾고 해당 우선순위를 만날때까지 큐에 넣고 빼고를 반복하는 코드를 짜려고 했습니다. 이러한 반복을 줄이고자 하나의 배열을 더 두었고, 함수를 만들어 최대값을 고려시켰습니다. 예를 들면 주어진 vector들을 queue에 넣으면서 우선순위 값들을 임시 배열에 ++연산을 통해 갯수를 세며, 최대값의 인덱스가 전부 소멸되면 그 다음 최댓값을 찾는 함수를 만들었습니다. 또한 location이라는 정보를 비교연산 해줘야하므로 index값도 queue에 저장시켜 location이 맞을 때 결과를 도출하도록 만들었습니다.4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include&amp;lt;algorithm&amp;gt;#include&amp;lt;iostream&amp;gt;#include&amp;lt;queue&amp;gt;using namespace std;int maxarr[10] = { 0, };int arrmax = 9;int promax(){ if (maxarr[arrmax] != 0) { return arrmax; } else { while(maxarr[arrmax]==0) arrmax--; return arrmax; } }int solution(vector&amp;lt;int&amp;gt; priorities, int location) { int answer = 0; queue&amp;lt;pair&amp;lt;int,int&amp;gt;&amp;gt; q; for (size_t i = 0; i &amp;lt; priorities.size(); ++i) { q.push(make_pair(priorities[i],i)); maxarr[priorities[i]]++; } int count = 1; while (1) { int maxnum = promax(); int pro = q.front().first; int index = q.front().second; if (pro == maxnum) { q.pop(); maxarr[maxnum]--; if (index == location) { answer = count; break; } ++count; } else { q.pop(); q.push(make_pair(pro, index)); } } return answer;}5. 결과" }, { "title": "Programmers_Stack/Queue03 - 다리를 지나는 트럭", "url": "/posts/Programmers_SQ03/", "categories": "Algorithm, Programmers", "tags": "Programmers, Queue", "date": "2021-01-26 16:07:00 +0900", "snippet": "프로그래머스 -스택/큐 - 다리를 지나는 트럭 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/parts/120772. 분류 및 난이도Programmers 문제입니다.스택 큐 Level 2 문제 입니다.3. 생각한 것들(문제 접근 방법) 처음에는 들어갈 수 있는 최대한을 큐에 다 넣고 시간을 증가시켰는데 틀렸다고 나왔습니다.다리를 지나가는 트럭#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt;#include&amp;lt;algorithm&amp;gt;#include&amp;lt;iostream&amp;gt;using namespace std;int solution(int bridge_length, int weight, vector&amp;lt;int&amp;gt; truck_weights) { int answer = 0; queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; truckQ; int index = 0; while (index &amp;lt; truck_weights.size() || !truckQ.empty()) { while (weight &amp;gt;= truck_weights[index] &amp;amp;&amp;amp; index &amp;lt; truck_weights.size()) { truckQ.push(make_pair(truck_weights[index],++answer)); weight -= truck_weights[index]; ++index; } int tweights = truckQ.front().first; int time = truckQ.front().second; weight += tweights; answer = (time + bridge_length-1); cout &amp;lt;&amp;lt; answer &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; index &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; time &amp;lt;&amp;lt;tweights&amp;lt;&amp;lt; &#39;\\n&#39;; truckQ.pop(); } return answer+1;} 이유는 설명하기 어려운데.. q에서 나온 트럭의 시간과 위의 while문에서 한번에 집어넣는 지점에서 겹치는 지점이 있었습니다. 예를 들어서 3초에 트럭이 도착해서 4초에 넣어야하는데 3초 지점에서 while문이 루프를 돌면서 이미 4초에 무언가 넣어서 겹쳤다는 의미..입니다. 고치려고 애를 많이 썼는데, 그냥 단순하게 시간을 하나하나 증가시켜서 꼬임을 풀었습니다.4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt;#include&amp;lt;algorithm&amp;gt;#include&amp;lt;iostream&amp;gt;using namespace std;int solution(int bridge_length, int weight, vector&amp;lt;int&amp;gt; truck_weights) { int answer = 1; queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; truckQ; int index = 0; while (index &amp;lt; truck_weights.size() || !truckQ.empty()) { if(weight &amp;gt;= truck_weights[index] &amp;amp;&amp;amp; index &amp;lt; truck_weights.size()) { truckQ.push(make_pair(truck_weights[index],answer)); weight -= truck_weights[index]; ++index; } int tweights = truckQ.front().first; int time = truckQ.front().second; int temp = (time + bridge_length - 1); //간단하게 트럭이 도착했으면 pop을 합니다. if (temp == answer) { weight += tweights; truckQ.pop(); } //cout &amp;lt;&amp;lt; answer &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; index &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; time &amp;lt;&amp;lt;&quot; &quot;&amp;lt;&amp;lt;tweights&amp;lt;&amp;lt; &#39;\\n&#39;; //시간이 지난다는 의미로 ++answer.. ++answer; } return answer;}5. 결과" }, { "title": "Programmers_Stack/Queue02 - 기능개발", "url": "/posts/Programmers_SQ02/", "categories": "Algorithm, Programmers", "tags": "Programmers, Queue", "date": "2021-01-26 16:03:00 +0900", "snippet": "프로그래머스 -스택/큐 - 기능개발 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/parts/120772. 분류 및 난이도Programmers 문제입니다.스택 큐 Level 2 문제 입니다.3. 생각한 것들(문제 접근 방법) 입력의 크기가 크지도 않아서 효율성은 고려 안했습니다. 앞에서부터 선행처리가 되어야하므로 Queue를 생각했습니다. 간단하게 day라는 것을두고 day를 증가시키면서 앞에서부터 progress가 완료되었으면 pop()하는 방식으로 풀었습니다. 마지막에 q.pop()를 하면서 while문을 빠져나가버려서 불 필요한 코드를 넣게 된 거 같네요.4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include&amp;lt;queue&amp;gt;using namespace std;vector&amp;lt;int&amp;gt; solution(vector&amp;lt;int&amp;gt; progresses, vector&amp;lt;int&amp;gt; speeds) { vector&amp;lt;int&amp;gt; answer; queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; q; for (size_t i = 0; i &amp;lt; progresses.size(); ++i) { q.push(make_pair(100 - progresses[i], speeds[i])); } int day = 1; int count = 0; while (!q.empty()) { int progress = q.front().first; int speed = q.front().second; if (progress - (day * speed) &amp;lt;= 0) { ++count; //이 부분 없으면 while문 빠져나와서 마지막에 계산안해요. if (q.size() == 1) { answer.push_back(count); } q.pop(); } else { day++; if (count != 0) { answer.push_back(count); count = 0; } } } return answer;}5. 결과" }, { "title": "Programmers_Stack/Queue01 - 주식 가격", "url": "/posts/Programmers_S_Q01/", "categories": "Algorithm, Programmers", "tags": "Programmers, Stack", "date": "2021-01-26 16:01:00 +0900", "snippet": "프로그래머스 -스택/큐 - 주식 가격 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/parts/120772. 분류 및 난이도Programmers 문제입니다.스택 큐 Level 2 문제 입니다.3. 생각한 것들(문제 접근 방법) 입력 크기가 최대 10만으로 for문 2개를 사용해서 각각 인덱스에 대해 떨어지는 지점을 찾아주는 것은 시간초과가 날 것이라 생각했습니다. 하나하나 탐색하는 것은 분명 해야하는 일이나 한번에 처리할 수 있는 것이 필요했습니다. 증가하는 시점은 고려할 필요가 없습니다. 최대한 무시하려고 했습니다. 이렇게 생각하다보니 떨어지는 시점인 방금 들어온값에 비해 더 작은 값이 들어오려하면 막는 코드를 짜려 하다보니 Stack을 사용하게 되었습니다. 스택의 첫 번째 요소에는 ‘주식 가격’ 두번째 요소에는 ‘인덱스 값’을 저장하였습니다. 이렇게하면 비교는 주식가격으로 하고, 빼면서 인덱스 값으로 임시 배열에 넣으므로 불필요한 연산들을 줄일 수 있다고 생각했습니다.4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;stack&amp;gt;using namespace std;vector&amp;lt;int&amp;gt; solution(vector&amp;lt;int&amp;gt; prices) { vector&amp;lt;int&amp;gt; answer; int temp[100001]; // 첫번째는 가격, 두번째 인덱스 stack&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; s; for (size_t i = 0; i &amp;lt; prices.size(); ++i) { //배열을 다 돌지 않았는데 스택이 비어있는 경우 그냥 넣습니다. if (s.empty()) s.push(make_pair(prices[i], i)); // 새로 들어오려는 값이 더 큰 경우(무시해도 되는 경우) 그냥 넣습니다. else if (s.top().first &amp;lt;= prices[i]) { s.push(make_pair(prices[i], i)); } //들어오는 게 더 작은 경우 else { //스택 꼭대기와 비교하여 같거나 작은값이 위에 올 때까지 스택에서 뺍니다. 임시 배열에 temp[결과 인덱스] = 뺀 만큼 을 넣습니다. while (!s.empty() &amp;amp;&amp;amp; s.top().first &amp;gt; prices[i]) { int result = i - s.top().second; temp[s.top().second] = result; s.pop(); } s.push(make_pair(prices[i], i)); } } //스택이 비어있지 않은 경우 남아있는 것들은 모두 증가상태이므로 빼면서 임시 배열에 결과값을 넣어줍니다. while (!s.empty()) { temp[s.top().second] = prices.size() - s.top().second - 1; s.pop(); } //임시 배열을 돌면서 answer벡터에 넣어줍니다. for (int i = 0; i &amp;lt; prices.size(); ++i) { answer.push_back(temp[i]); } return answer;}5. 결과생각하기 너무 어렵네요." }, { "title": "Spring - 7 의존관계 자동 주입 (1)", "url": "/posts/SpringPoint09/", "categories": "Java, 3. Spring_김영한_스프링-핵심-원리-기본편", "tags": "Spring", "date": "2021-01-25 21:00:00 +0900", "snippet": "해당 자료는 인프런 김영한 선생님의 스프링-핵심-원리-기본편 강의노트입니다.1. 다양한 의존관계 주입 방법의존관계주입은 크게 4가지 방법이 있습니다. 생성자 주입 수정자 주입 필드 주입 일반 메서드 주입생성자 주입 지금까지 한 방법으로 생성자를 통해서 의존관계를 주입받는 방법입니다. 생성자 호출시점에 딱 1번만 호출되는 것이 보장되어 ‘불변,필수’ 의존관계에 사용됩니다.@Componentpublic class OrderServiceImpl implements OrderService{ private final MemberRepository memberRepository; private final DiscountPolicy discountPolicy; @Autowired public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) { this.memberRepository = memberRepository; this.discountPolicy = discountPolicy; }}생성자가 딱 1개만 있으면 @Autowired를 생략해도 자동 주입됩니다.@Componentpublic class OrderServiceImpl implements OrderService{ private final MemberRepository memberRepository; private final DiscountPolicy discountPolicy; public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) { this.memberRepository = memberRepository; this.discountPolicy = discountPolicy; }수정자 주입 setter라 불리는 필드의 값을 변경하는 메서드를 통해 의존관계를 주입합니다. 선택, 변경 가능성이 있는 의존관계에 사용하고 자바빈 프로퍼티 규약의 수정자 메서드 방식을 사용하는 방법입니다. 자바빈 프로퍼티 규약이란 get(),set() 메서드를 통해 값을 읽거나 수정하는 규칙을 말합니다. 검색하면 더 자세한 내용을 알 수 있습니다.@Componentpublic class OrderServiceImpl implements OrderService{ private MemberRepository memberRepository; private DiscountPolicy discountPolicy; @Autowired public void setDiscountPolicy(DiscountPolicy discountPolicy) { this.discountPolicy = discountPolicy; } @Autowired public void setMemberRepository(MemberRepository memberRepository){ this.memberRepository = memberRepository; } } @Autowired의 기본 동작은 주입할 대상이 없으면 오류가 발생합니다. 주입할 대상이 없어도 동작하게 하려면 @Autowired(required = false)로 지정합니다.필드 주입 필드에 주입하는 방법입니다. 추천하지 않는 방식으로 DI 프레임워크가 없으면 아무것도 할 수 없고, 외부에서 변경이 불가능해서 테스트하기 어렵다는 단점이 있습니다. 순수 자바로 테스트를 돌릴 수가 없다는 단점이 있습니다. 애플리케이션의 실제 코드와 관계 없는 테스트 코드나 특별한 상황에서 사용됩니다.@Componentpublic class OrderServiceImpl implements OrderService{ @Autowired private MemberRepository memberRepository; @Autowired private DiscountPolicy discountPolicy;}일반 메서드 주입 일반 메서드를 통해 주입 받는 방법입니다. 한번에 여러 필드를 주입 받을 수 있지만, 일반적으로 잘 사용하지 않습니다. 방식이 set주입, 생성자 주입과 비슷하여 잘 안쓰인다고 합니다. @Componentpublic class OrderServiceImpl implements OrderService { private MemberRepository memberRepository; private DiscountPolicy discountPolicy; @Autowired public void init(MemberRepository memberRepository, DiscountPolicydiscountPolicy) { this.memberRepository = memberRepository; this.discountPolicy = discountPolicy; }}2. 옵션처리주입할 스프링 빈이 없어도 동작해야할 때가 있습니다.하지만 @Autowired만 사용하면 ‘required’옵션의 기본값이 true로 되어 있어서 자동 주입 대상이 없으면 오류를 발생시킵니다.자동 주입 대상을 옵션으로 처리하는 방법은 다음 세가지가 있습니다. @Autowired(required = false) : 자동 주입할 대상이 없으면 수정자 메서드 자체가 호출이 안됩니다. org.springframework.@Nullable : 자동 주입할 대상이 없으면 null이 입력됩니다. Optional&amp;lt;&amp;gt; : 자동 주입할 대상이 없으면 Optional.empty가 입력됩니다.테스트를 위해 ‘AutowiredTest’.java 파일을 만들고 다음 코드를 테스트 해봅니다.package hello.core.autowired;import hello.core.member.Member;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.lang.Nullable;import java.util.Optional;public class AutowiredTest { @Test void Test(){ ApplicationContext ac = new AnnotationConfigApplicationContext(Testconfig.class); } static class Testconfig{ //Member class는 스프링이 관리안하고 있습니다. //1. required옵션에 false를 넣어줌 @Autowired(required = false) public void setNoBean1(Member member){ System.out.println(&quot;setNobean1 = &quot; + member); } //2. null호출 @Autowired public void setNoBean2(@Nullable Member member){ System.out.println(&quot;setNobean2 = &quot; + member); } //3. Optional.empty 호출 @Autowired public void setNoBean3(Optional&amp;lt;Member&amp;gt; member){ System.out.println(&quot;setNobean3 = &quot; + member); } }}결과를 보시면 1번의 경우 메서들 아예 호출을 안하는 것을 볼 수 있습니다.3. 생성자 주입을 선택해라생성자 주입을 사용해야하는 이유를 설명합니다.불변 대부분의 의존관계 주입은 한번 일어나면 애플리케이션 종료시점까지 의존관계를 변경할 일이 없다고 합니다. 오히려 변하면 안된다고 합니다. 수정자 주입을 사용하면 set()메서드를 public으로 열어둬야하는 단점이 있습니다. 또한 누군가 실수로 변경할 수 도 있고, 변경하면 안되는 메서드를 열어두는 것은 좋은 설계 방법이 아닙니다. 생성자 주입은 객체를 생성할 때 딱 1번 호출되는게 보장되므로 불변하게 설계할 수 있습니다.누락@Testvoid createOrder() { OrderServiceImpl orderService = new OrderServiceImpl(); orderService.createOrder(1L, &quot;itemA&quot;, 10000);} 프레임워크 없이 순수한 자바 코드를 수정자 주입을 적용하고 테스트를 돌릴려고 하면 createOrder()함수를 실행하기 위해 더미 객체라도 넣어줘야합니다. 그러지 않으면 의존 관계가 주입되지 않아 Null Point Exception이 발생합니다. 생성자 주입을 사용하면 위의 코드는 컴파일 오류가 발생합니다. 그렇기에 어떤 값의 의존관계 주입이 누락되었는 지 확인할 수 있습니다.final 키워드 생성자 주입을 사용하면 필드에 ‘final’ 키워드를 사용할 수 있습니다. 그래서 생성자에서 혹시라도 값이 설정되지 않는 오류를 컴파일 시점에 막아줍니다. 컴파일 오류가 가장 빠르고 좋은 오류라고 합니다. 정리 생성자 주입을 사용하면 프레임워크에 의존하지 않고, 순수한 자바 언어의 특징을 잘 살리는 방법이기도 합니다. 기본으로 생성자 주입을 사용하고, 필수 값이 아닌 경우에는 수정자 주입 방식을 옵션으로 부여하면 됩니다. 항상 생성자 주입을 선택하고 필드 주입은 사용하지 않는게 좋습니다.4. 롬북과 최신 트랜드 필드 주입처럼 한줄로 의존관계를 주입하는 방법이 있습니다. 롬북 라이브러리를 설정하기 전에 기본 코드를 바꿔줄 수 있습니다. private final MemberRepository memberRepository; private final DiscountPolicy discountPolicy; //생성자가 하나일 땐 Autowired 생략가능 //@Autowired public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) { this.memberRepository = memberRepository; this.discountPolicy = discountPolicy; }그 다음 룸복 라이브러리를 적용하기 위해, build.gradle 설정을 바꿔줍니다.plugins { id &#39;org.springframework.boot&#39; version &#39;2.4.2&#39; id &#39;io.spring.dependency-management&#39; version &#39;1.0.11.RELEASE&#39; id &#39;java&#39;}group = &#39;hello&#39;version = &#39;0.0.1-SNAPSHOT&#39;sourceCompatibility = &#39;11&#39;repositories { mavenCentral()}dependencies { implementation &#39;org.springframework.boot:spring-boot-starter&#39; testImplementation &#39;org.springframework.boot:spring-boot-starter-test&#39; //lombok 라이브러리 추가 시작 compileOnly &#39;org.projectlombok:lombok&#39; annotationProcessor &#39;org.projectlombok:lombok&#39; testCompileOnly &#39;org.projectlombok:lombok&#39; testAnnotationProcessor &#39;org.projectlombok:lombok&#39; //lombok 라이브러리 추가 끝 testImplementation(&#39;org.springframework.boot:spring-boot-starter-test&#39;) { exclude group: &#39;org.junit.vintage&#39;, module: &#39;junit-vintage-engine&#39; }}test { useJUnitPlatform()}이후 File -&amp;gt; settings에서 plugins을 검색해준 다음 lombok을 설치해줍니다.Annotation Processors를 검색한 다음 Enable annotation~ 을 체크해줍니다.그리고 기존 코드를 다음과 같이 바꿔주면 끝납니다.//추가!@RequiredArgsConstructorpublic class OrderServiceImpl implements OrderService{ //final 붙은 것을 가지고 생성자를 알아서 만들어줌. private final MemberRepository memberRepository; private final DiscountPolicy discountPolicy;} 최근에는 생성자를 1개 두고, @Autowired를 생략하는 방법을 주로 사용합니다. 여기에 lombok라이브러리의 @RequiredArgConstructor를 사용하면 기능은 제공하면서, 코드는 깔끔하게 사용할 수 있습니다.또한 lombok은 Getter,Setter, 등을 제공하고 있는데 간단히 테스트 코드를 작성하면package hello.core;import lombok.Getter;import lombok.Setter;import lombok.ToString;@Getter@Setter@ToStringpublic class Lombok { private int number; private String name; public static void main(String[] args) { Lombok lombok = new Lombok(); lombok.setName(&quot;hi&quot;); String temp = lombok.getName(); System.out.println(&quot;lombok = &quot; + lombok + temp); }}이렇듯 롬북을 이용하면 Get(),Set()함수를 안만들어도 되는 대단한 기능을 제공합니다." }, { "title": "Baekjoon1600-말이 되고픈 원숭이", "url": "/posts/baekjoon1600/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, BFS", "date": "2021-01-25 17:02:00 +0900", "snippet": "백준 사이트 1600 - 말이 되고픈 원숭이 문제입니다.1. 문제https://www.acmicpc.net/problem/16002. Input , Output3. 분류 및 난이도BFS문제입니다.백준에서는 Gold5의 난이도를 책정하고 있습니다.4. 생각한 것들 골드5 치고는 어려운 것 같습니다. 생각할 거리가 생각보다 많기 때문입니다. 구현 자체는 쉬운 편. 주의 해야할 점이 입력이 가로의 길이, 세로의 길이로 4와 5를 입력받으면 4 50 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 이렇게 배열이 생긴다는 것에 주의해야합니다. DP로 풀어야겠다고 생각했습니다. 최소 이동 횟수 문제가아닌 모든 경우의 수 문제인줄 알고 DP로 풀려했는데 아닌걸 보고 DP코드를 지웠습니다. 일반적인 BFS와 다르게 방문처리릍 특별하게 해줘야합니다. 다음 인풋을 예시로 들면 1 5 4 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 0 결과는 이렇게 되어야 합니다. 0 1 0 0 0 0 2 3 4 0 0 0 0 x x 0 0 0 x 5 말처럼 바로 움직여버리면 움직임을 다 소비해버려 다음과 같이 이동할 수가 없습니다. 0 0 0 0 0 0 1 2 3 0 0 0 0 x x 0 0 0 x -1 그래서 말의 이동횟수에 대한 카운트를 잘 세줘야합니다. 방문 처리를 미리 해버리면 방문하였기에 접근을 안하고, 방문 처리를 안해버리면 모든 배열을 돌아야하므로 시간초과가 날 것 입니다. 해결법은 방문처리 배열의 차원을 하나 더 두는 것입니다. 차원을 하나 더 두었기에 말처럼 이동했을 때 방문처리와 원숭이로 이동했을 때 방문처리를 관리할 수 있습니다.5. code#include&amp;lt;iostream&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;cstring&amp;gt;using namespace std;const int MAX = 201;int MAP[MAX][MAX] = { 0, };bool v[MAX][MAX][32] = { false, };int W, H, K;int dx[4] = { -1,0,1,0 };int dy[4] = { 0,1,0,-1 };int horsex[8] = { -1,-2,-2,-1,1,2, 2, 1 };int horsey[8] = { -2,-1, 1, 2,2,1,-1,-2 };void Input(){ cin &amp;gt;&amp;gt; K; cin &amp;gt;&amp;gt; W &amp;gt;&amp;gt; H; for (int i = 0; i &amp;lt; H; ++i) { for (int j = 0; j &amp;lt;W; ++j) cin &amp;gt;&amp;gt; MAP[i][j]; }}int Solve(){ //BFS //좌표 값, k 카운트 값, 이동횟수 memset(v, false, sizeof(v)); queue &amp;lt; pair&amp;lt;pair&amp;lt;int, int&amp;gt;, pair&amp;lt;int,int&amp;gt;&amp;gt;&amp;gt; q; q.push(make_pair(make_pair(0, 0), make_pair(0,0))); v[0][0][0] = true; while (!q.empty()) { int x = q.front().first.first; int y = q.front().first.second; int horse = q.front().second.first; int result = q.front().second.second; //cout &amp;lt;&amp;lt; &quot;x : &quot; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &quot;y : &quot; &amp;lt;&amp;lt; y &amp;lt;&amp;lt; &quot;horse&quot; &amp;lt;&amp;lt;horse&amp;lt;&amp;lt;&quot;result : &quot;&amp;lt;&amp;lt;result&amp;lt;&amp;lt; &#39;\\n&#39;; if (x == (H - 1) &amp;amp;&amp;amp; y == (W - 1)) return result; q.pop(); //말처럼 뛰기 if (horse &amp;lt; K) { for (int k = 0; k &amp;lt; 8; ++k) { int newX = x + horsex[k]; int newY = y + horsey[k]; //cout &amp;lt;&amp;lt; newX &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; newY &amp;lt;&amp;lt; &#39;\\n&#39;; if (0 &amp;lt;= newX &amp;amp;&amp;amp; newX &amp;lt; H &amp;amp;&amp;amp; 0 &amp;lt;= newY &amp;amp;&amp;amp; newY &amp;lt; W &amp;amp;&amp;amp; v[newX][newY][horse+1] == false &amp;amp;&amp;amp; MAP[newX][newY] !=1) { q.push(make_pair(make_pair(newX, newY),make_pair(horse+1, result+1))); v[newX][newY][horse+1] = true; } } } //말처럼 안뛰기 for (int k = 0; k &amp;lt; 4; ++k) { int newX = x + dx[k]; int newY = y + dy[k]; if (0 &amp;lt;= newX &amp;amp;&amp;amp; newX &amp;lt; H &amp;amp;&amp;amp; 0 &amp;lt;= newY &amp;amp;&amp;amp; newY &amp;lt; W &amp;amp;&amp;amp; v[newX][newY][horse] == false &amp;amp;&amp;amp; MAP[newX][newY] != 1) { q.push(make_pair(make_pair(newX, newY), make_pair(horse, result + 1))); v[newX][newY][horse] = true; } } } return -1;}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); Input(); cout&amp;lt;&amp;lt;Solve(); return 0;}6. 후기3차원 배열 == 어렵습니다." }, { "title": "Baekjoon1309-동물원", "url": "/posts/baekjoon1309/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, DP", "date": "2021-01-25 16:02:00 +0900", "snippet": "백준 사이트 1309 - 동물원 문제입니다.1. 문제https://www.acmicpc.net/problem/13092. Input , Output3. 분류 및 난이도DP문제입니다.백준에서는 Sliver1의 난이도를 책정하고 있습니다.4. 생각한 것들 규칙을 찾기위해 공책으로 n이 0, 1, 2, 3, 4 일 때를 직접 구해보았습니다. 규칙이 눈에 보이지 않았고, 실제로 계산한 n이 3일때가 틀려서 머리를 싸매고 있었던 중.. 포기하고 질문을 봤습니다. 규칙으로는 DP[n] = DP[n-2] + DP[n-1] * 2 라는 규칙이 있지만 봐도 왜그런지 이해 안되었습니다. 경우 3가지를 나눠 DP를 계산하는 방법을 보고 이해했습니다. 경우1은 현재 줄에 사자 배치를 안할 때 입니다.(윗줄에 왼쪽에 사자 있는 경우의 수 + 오른쪽에 사자 있는 경우의 수) -&amp;gt; 어디에 사자가오든 상관 없으므로 경우2는 현재 줄 왼쪽에 사자를 배치할 경우입니다.(윗줄에 사자가 없는 경우 + 오른쪽에 사자가 있는 경우) 경우3은 현재 줄 오른쪽에 사자를 배치할 경우입니다.( 윗줄에 사자가 없는 경우 + 왼쪽에 사자가 있는 경우) 5. code#include&amp;lt;iostream&amp;gt;using namespace std;const int MAX = 100002;int DP[MAX][4] = { 0, };void printDP(int n){ for (int i = 0; i &amp;lt;= n; ++i) { for (int j = 0; j &amp;lt; 3; ++j) cout &amp;lt;&amp;lt; DP[i][j] &amp;lt;&amp;lt; &quot; &quot;; cout &amp;lt;&amp;lt; &#39;\\n&#39;; }}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); int n; cin &amp;gt;&amp;gt; n; DP[1][0] = 1; DP[1][1] = 1; DP[1][2] = 1; for (int i = 2; i &amp;lt;= n; ++i) { //경우 1 미배치 하는 경우 DP[i][0] = (DP[i - 1][0] + DP[i - 1][1] + DP[i - 1][2]) % 9901; //경우 2 왼쪽 칸에 사자를 배치할 경우 DP[i][1] = (DP[i - 1][0] + DP[i - 1][2]) % 9901; //경우 3 오른쪽 칸에 사자를 배치할 경우 DP[i][2] = (DP[i - 1][0] + DP[i - 1][1]) % 9901; } cout &amp;lt;&amp;lt; (DP[n][0] + DP[n][1] + DP[n][2])%9901;}6. 후기규칙으로 푸는 점화식 증명.. 난 이렇게 못품..https://www.acmicpc.net/board/view/10263" }, { "title": "Programmers_hash04 - 베스트앨범", "url": "/posts/Programmers_hash04/", "categories": "Algorithm, Programmers", "tags": "Programmers, HASH", "date": "2021-01-25 14:05:00 +0900", "snippet": "프로그래머스 -해시 - 베스트앨범 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/parts/120772. 분류 및 난이도Programmers 문제입니다.Level 3의 문제입니다.3. 생각한 것들(문제 접근 방법) 생각해야할 게 너무 많습니다. 첫 번째로 장르에 대해 카운트 값을 관리해야하고(정렬 기준 1) 두 번째로 해당 장르에 대한 수록곡들의 재생횟수(정렬 기준 2) 세 번째로 장르들의 인덱스 값(값 도출에 인덱스를 넣어야하므로) 하지만 값들은 총 4가지로 (장르, 장르들의 합계, 수록곡의 재생목록, 인덱스) 이것을 다 관리할 수 있는 것이 c++에 있을까 생각했습니다. 없는 것 같습니다. 일단 map을 사용해서 장르들의 합계정보를 넣었습니다. map을 쓴 이유는 string에 대한 관리가 쉬워서 썼습니다. 또한 장르의 최대 갯수는 100개로 최악의 경우 1만개의 배열을 갖는 answer vector보다 작아 관리하기 쉽습니다. 문제는 map에 합계정보를 넣어도 합계정보인 value값으로 정렬이 되지 않아서 따로 vector에 넣어서 정렬해줘야합니다. 처음 벡터에는 장르,재생횟수,인덱스 정보를 넣어줬습니다. 벡터에 정보를 넣으면서 장르 map에도 합계 정보를 차곡히 쌓아줍니다. 장르를 기준으로 정렬을 하되(나중에 탐색 시 용이), 같은 장르인 경우 재생횟수, 재생횟수마저 같다면 작은 인덱스 기준으로 정렬을 해줬습니다.(밑의 pred함수) 장르 합계 map을 합계순을 정렬하기 위해 임시 벡터 (countvec)를 이용해서 합계순으로 정렬을 해줍니다. 정렬해준 벡터를 돌면서 이진 탐색을 통해 찾는 문자열에 대해 재생횟수가 많은 순으로 2번까지 해당 인덱스를 answer vector에 넣어줍니다. 만약 장르속에 수록곡이 1개인 경우도 예외처리 해줍니다.4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include&amp;lt;algorithm&amp;gt;#include&amp;lt;iostream&amp;gt;#include &amp;lt;map&amp;gt;using namespace std;bool pred(pair&amp;lt;pair&amp;lt;string, int&amp;gt;, int&amp;gt; pair1, pair&amp;lt;pair&amp;lt;string, int&amp;gt;, int&amp;gt; pair2){ if (pair1.first.first == pair2.first.first) { if (pair1.first.second == pair2.first.second) return pair1.second &amp;lt; pair2.second; else return pair1.first.second &amp;gt; pair2.first.second; } else return pair1.first.first &amp;lt; pair2.first.first;}bool countingvec(pair&amp;lt;string, int&amp;gt; a, pair&amp;lt;string, int&amp;gt; b){ return a.second &amp;gt; b.second;}int binarysearch(vector&amp;lt;pair&amp;lt;pair&amp;lt;string, int&amp;gt;, int&amp;gt;&amp;gt; vec, string str, int size){ int lower = 0; int upper = size - 1; int mid; while (lower &amp;lt;= upper) { mid = (lower + upper) / 2; if (str &amp;gt; vec[mid].first.first) lower = mid + 1; else upper = mid - 1; } return lower;}vector&amp;lt;int&amp;gt; solution(vector&amp;lt;string&amp;gt; genres, vector&amp;lt;int&amp;gt; plays) { vector&amp;lt;int&amp;gt; answer; map&amp;lt;string, int&amp;gt; m; vector&amp;lt;pair&amp;lt;pair&amp;lt;string, int&amp;gt;, int&amp;gt;&amp;gt; vec; for (size_t i = 0; i &amp;lt; genres.size(); ++i) { //cout &amp;lt;&amp;lt; vec[i].first.first &amp;lt;&amp;lt; vec[i].first.second &amp;lt;&amp;lt; vec[i].second &amp;lt;&amp;lt; &#39;\\n&#39;; vec.push_back(make_pair(make_pair(genres[i], plays[i]), i)); //map에 카운트 값을 넣는다. 맨처음꺼라면 if (m.find(vec[i].first.first) == m.end()) { m.insert(make_pair(vec[i].first.first, vec[i].first.second)); } else//찾았다면 { m[vec[i].first.first] += vec[i].first.second; } } sort(vec.begin(), vec.end(), pred); map&amp;lt;string, int&amp;gt;::iterator iter; vector&amp;lt;pair&amp;lt;string, int&amp;gt;&amp;gt; countvec(m.begin(), m.end()); sort(countvec.begin(), countvec.end(), countingvec); for (size_t i = 0; i &amp;lt; countvec.size(); ++i) { int range = 0; string findstr = &quot;&quot;; findstr += countvec[i].first; int index = binarysearch(vec, findstr, vec.size()); //cout &amp;lt;&amp;lt; findstr &amp;lt;&amp;lt; index &amp;lt;&amp;lt; &#39;\\n&#39;; for (; range &amp;lt; 2; ++range) { //1개인 경우 if (vec[index].first.first != findstr) { break; } else { answer.push_back(vec[index].second); ++index; } } } return answer;}5. 결과어렵습니다.시간도 1시간정도 걸렸습니다.다른 사람들 어떻게 풀었나 대충 봤는데 비슷해서 다행이었습니다." }, { "title": "Programmers_hash03 - 위장", "url": "/posts/Programmers_hash03/", "categories": "Algorithm, Programmers", "tags": "Programmers, HASH", "date": "2021-01-25 13:05:00 +0900", "snippet": "프로그래머스 -해시 - 위장 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/parts/120772. 분류 및 난이도Programmers 문제입니다.Level 2의 문제입니다.3. 생각한 것들(문제 접근 방법) 인풋데이터는 적은 편이라 수행시간은 고려안했습니다. 다른 문제와 같이 정렬을 이용한 꼼수로 풀려했는데, 잘 되지 않아 STL의 map을 이용했습니다. 이 부분에서 고민이 많았던게, 이미 vector에 담겨진 값들을 다시 map에 옮기는 것이 효율성을 저하한다고 생각하여 안쓰려고 했으나 쉽지 않았습니다. 처음에 틀렸었는데, 이유는 경우의 수를 세주는 부분에서 틀렸습니다. 인풋에서 옷의 종류가 중요하지 옷의 이름은 중요하지 않습니다. (값 도출에 쓰이지 않는다.) 옷을 무조건 1개 씩 입는 가지 수 + 옷을 입었을 때의 경우의 수 에서 틀렸습니다. 어떠한 옷에 대해서 안입어도 되는 것인데 다 입을 것이라고 가정하고 경우의 수를 셌습니다. 예를 들어 바지 2개 상의 1 겉옷 1개면 경우의 수는 2 * 1 * 1 로 도출했는데, 옷을 안입는 경우를 하나씩 더해주고 마지막에 옷을 하나도 안입는 경우의 수를 빼주면 됩니다. (2+1) * (1+1) * (1+1) -1(전부 안 입는 경우) 뒤의 1들은 옷을 안 입는 경우입니다. 처음에 틀린 코드 입니다.#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;#include&amp;lt;map&amp;gt;using namespace std;int solution(vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; clothes) { int answer = 0; //1가지 씩 입는 경우 answer+=clothes.size(); //문자열과 카운트 값 map&amp;lt;string,int&amp;gt; m; for(size_t i=0;i&amp;lt;clothes.size();++i) { if(m.find(clothes[i][1])==m.end()) { m.insert(make_pair(clothes[i][1],1)); } else m[clothes[i][1]]++; } if(m.size()&amp;gt;1) { int counting = 1; map&amp;lt;string,int&amp;gt;::iterator iter; for(iter = m.begin(); iter!=m.end();++iter) { counting*=(*iter).second; } answer+=counting; } return answer;}4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;#include&amp;lt;map&amp;gt;using namespace std;int solution(vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; clothes) { int answer = 0; //문자열과 카운트 값 map&amp;lt;string,int&amp;gt; m; for(size_t i=0;i&amp;lt;clothes.size();++i) { if(m.find(clothes[i][1])==m.end()) { m.insert(make_pair(clothes[i][1],1)); } else m[clothes[i][1]]++; } if(m.size()&amp;gt;1) { int counting = 1; map&amp;lt;string,int&amp;gt;::iterator iter; for(iter = m.begin(); iter!=m.end();++iter) { counting*=((*iter).second+1); } answer+=counting; answer-=1; } else { answer +=clothes.size(); } return answer;}5. 결과" }, { "title": "Programmers_hash02 - 전화번호 목록", "url": "/posts/Programmers_hash02/", "categories": "Algorithm, Programmers", "tags": "Programmers, HASH", "date": "2021-01-25 12:02:00 +0900", "snippet": "프로그래머스 -해시 - 전화번호 목록 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/parts/120772. 분류 및 난이도Programmers 문제입니다.Level 2의 문제입니다.3. 생각한 것들(문제 접근 방법) 인풋 데이터가 백만으로 큽니다. 이것 또한 순차적으로 비교하면 시간초과가 날 것이라 생각했습니다. 앞 문제와 마찬가지로 정렬을 해주면 같은 것끼리 묶이면서 문자열이 좀 더 긴 것은 뒤로 가지 않을까 하면서 정렬을 해주었습니다. 정렬을 하면 문자열 비교는 최악의 경우 백 만정도 걸리게 됩니다. 문제는 단 한번이라도 접두사를 가진 문자열이 있느냐?라는 초점에 따라 단 한번이라도 접두사를 가진 문자열을 찾으면 바로 결과를 리턴하도록 했습니다. 만약 한번도 거치지 않았다면 자동으로 true를 출력하게끔 하였습니다.4. 접근 방법을 적용한 코드#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include&amp;lt;algorithm&amp;gt;#include&amp;lt;iostream&amp;gt;using namespace std;bool compare(string a,string b, int size){ for(int i=0;i&amp;lt;size;++i) { //하나라도 다른 부분이 있다면 if(a[i]!=b[i]) { return true; } } return false;}bool solution(vector&amp;lt;string&amp;gt; phone_book) { bool answer = true; sort(phone_book.begin(),phone_book.end()); for(size_t i = 0; i&amp;lt;phone_book.size()-1;++i) { int sizet = min(phone_book[i].size(),phone_book[i+1].size()); answer = compare(phone_book[i],phone_book[i+1],sizet); if(!answer) { return answer; } } return answer;}5. 결과" }, { "title": "Programmers_hash01 - 완주하지 못한 선수", "url": "/posts/Programmers_hash01/", "categories": "Algorithm, Programmers", "tags": "Programmers, HASH", "date": "2021-01-25 10:02:00 +0900", "snippet": "프로그래머스 -해시 - 완주하지 못한 선수 문제 입니다.1. 문제https://programmers.co.kr/learn/courses/30/parts/120772. 분류 및 난이도Programmers 문제입니다.해시 중에 가장 쉬운 Level1 문제입니다.3. 생각한 것들(문제 접근 방법) 대놓고 hash 라고 써 있어서 c++ STL을 이용하려 했지만, 표준이 아닌 hash STL은 사용할 수 없었습니다. vector의 인풋이 최대 10만개 들어오고 비교대상도 99,999개라고 했으니 일반적으로 값들을 하나하나 찾아주면 효율성의 문제가 생길거라 생각했습니다. 다른 한사람만 찾으면 되기에 정렬을 하고 틀린 배열이 나온경우 결과를 리턴하는 식으로 작성하였습니다. 최악의 경우 맨 마지막 배열에서 다른 사람이 존재할 경우 배열비교 시 인덱스 범위를 벗어나므로 예외처리를 하나 해줬습니다.4. 접근 방법을 적용한 코드#include&amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;string solution(vector&amp;lt;string&amp;gt; participant, vector&amp;lt;string&amp;gt; completion) { int counting =0; string answer = &quot;&quot;; sort(participant.begin(),participant.end()); sort(completion.begin(),completion.end()); for (int size = 0;size&amp;lt;participant.size();++size) { //만약 비교대상의 인덱스를 벗어날 경우 case1인경우 if(size&amp;gt;completion.size()) { answer = participant[size]; return answer; } if(participant[size]!=completion[size]) { answer = participant[size]; return answer; } } return answer;}5. 결과" }, { "title": "Baekjoon1890-점프", "url": "/posts/baekjoon1890/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, DP", "date": "2021-01-24 17:02:00 +0900", "snippet": "백준 사이트 1890 - 점프 문제입니다.1. 문제https://www.acmicpc.net/problem/18902. Input , Output3. 분류 및 난이도DP문제입니다.백준에서는 Sliver2 난이도를 책정하고 있습니다.4. 생각한 것들 습관이 참 무섭습니다. MAP + 값저장 ? = BFS + DP다 라고 생각하면 푸는 순간 꼬입니다. BFS로 풀기가 힘든게 중복 방문처리에 대한 처리를 고려해줘야합니다. 따라서 DFS로 푸는게 낫긴합니다. 생각해보니 이 문제의 좌표의 움직임은 for문을 2번 돌린다하면 지나왔던 점은 신경을 안쓴다 입니다. 아래와 오른쪽으로만 이동하니 지나왔던 (위, 왼쪽) 은 건들일이 없다는 것입니다. 순차적으로 돌아도 시간초과가 뜨는 지는 모르나 굳이 그래줄 필요는 없기에 간단한 분기문을 통해 걸렀습니다. 그리고 조심해야할 것이 문제에 대놓고 2^63-1의 이하값이 결과로 주어진다 했기에 자료형을 잘 생각해야합니다.5. code#include&amp;lt;queue&amp;gt;#include&amp;lt;iostream&amp;gt;using namespace std;const int MAX = 101;int MAP[MAX][MAX] = { 0, };long long DP[MAX][MAX] = { 0, };int N;void Input(){ cin &amp;gt;&amp;gt; N; for (int i = 0; i &amp;lt; N; ++i) { for (int j = 0; j &amp;lt; N; ++j) cin &amp;gt;&amp;gt; MAP[i][j]; }}void Solve(){ DP[0][0] = 1; for (int i = 0; i &amp;lt; N; ++i) { for (int j = 0; j &amp;lt; N; ++j) { if (DP[i][j] == 0 || (i == N - 1 &amp;amp;&amp;amp; j == N - 1)) continue; else { int range = MAP[i][j]; int newX = i + range; int newY = j + range; if (newX &amp;lt; N) DP[newX][j] += DP[i][j]; if (newY &amp;lt; N) DP[i][newY] += DP[i][j]; } } }}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); Input(); Solve(); cout &amp;lt;&amp;lt; DP[N - 1][N - 1]; return 0;}6. 후기처음에 BFS + DP로 풀려고하니 계속 틀려서 삽질을 많이했습니다." }, { "title": "Baekjoon11559-Puyo Puyo", "url": "/posts/baekjoon11559/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, BFS", "date": "2021-01-24 16:02:00 +0900", "snippet": "백준 사이트 11559 - Puyo Puyo 문제입니다.1. 문제https://www.acmicpc.net/problem/115592. Input , Output3. 분류 및 난이도BFS문제입니다.백준에서는 Gold5의 난이도를 책정하고 있습니다.?4. 생각한 것들 피곤한 상태에서 작성한 코드라 매우 더럽습니다. 의식의 흐름대로 코드를 짰습니다. 로직 자체는 그래도 다른 사람들보다 이해하기 쉽게 짜긴 했습니다.. Down부분이 이해하기 힘들 뿐 일반 문제와 다르게 중력이라는 특이한 상황이 작용합니다. 사실 이러한 문자옮기기는 예전 카카오 코테때도 나왔던 것입니다.. 잘해둡시다. 신경 써줘야할 것은 ‘중력’이라는 점과 ‘방문 처리’의 적절한 시기입니다. 푸요를 한번에 다 터트려야한다는 말을 잘 생각해봐야합니다. 또한 변수들의 값을 중력으로 인해 내려줄 때 인덱스 범위도 잘 고려해서 코드를 짜야합니다. 18%에서 틀리는건 인덱스범위에서 문제가 나는 것입니다. 100%에서 틀리는건 푸요가 하나도 안들어왔을 때 오류가 뜬다고 하더군요. 다행히도 시간제한이 1초지만 그냥 막탐색해도 시간초과는 안뜨는 것 같습니다. 범위가 작아서 그런가봅니다. 푸요가 박살나는 과정을 보고 싶으면 주석문을 풀어서 보시길 바랍니다.5. code#include&amp;lt;iostream&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;cstring&amp;gt;using namespace std;char MAP[13][7] = { &#39;0&#39; };bool v[13][6] = { false, };int dx[4] = { -1,0,1,0 };int dy[4] = { 0,1,0,-1 };void Input() { for (int i = 0; i &amp;lt; 12; ++i) { for (int j = 0; j &amp;lt; 6; ++j) cin &amp;gt;&amp;gt; MAP[i][j]; }}bool BFS(int i, int j, char remove){ queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; q; queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; countPuyo; q.push(make_pair(i, j)); countPuyo.push(make_pair(i, j)); while (!q.empty()) { int x = q.front().first; int y = q.front().second; q.pop(); for (int k = 0; k &amp;lt; 4; ++k) { int newX = x + dx[k]; int newY = y + dy[k]; if (0 &amp;lt;= newX &amp;amp;&amp;amp; newX &amp;lt; 12 &amp;amp;&amp;amp; 0 &amp;lt;= newY &amp;amp;&amp;amp; newY &amp;lt; 6 &amp;amp;&amp;amp; MAP[newX][newY] == remove &amp;amp;&amp;amp; v[newX][newY] == false) { countPuyo.push(make_pair(newX, newY)); v[newX][newY] = true; q.push(make_pair(newX, newY)); } } } if (countPuyo.size() &amp;gt;= 4) { while (!countPuyo.empty()) { int x = countPuyo.front().first; int y = countPuyo.front().second; countPuyo.pop(); MAP[x][y] = &#39;.&#39;; } return true; } return false;}void swap(int start, int end, int col){ int range = start - end; //cout &amp;lt;&amp;lt; &quot;start &quot; &amp;lt;&amp;lt; start &amp;lt;&amp;lt; &quot; end &quot; &amp;lt;&amp;lt; end &amp;lt;&amp;lt; &quot; col&quot; &amp;lt;&amp;lt; col &amp;lt;&amp;lt; &#39;\\n&#39;; for (int i = 0; i &amp;lt; lange; ++i) { char temp = MAP[start][col]; MAP[start][col] = MAP[end][col]; MAP[end][col] = temp; --start; --end; if (end &amp;lt; 0) break; }}void Down() { bool check = false; for (int i = 0; i &amp;lt; 6; ++i) { int start = 13; for (int j = 11; j &amp;gt;= 0; --j) { if (MAP[j][i] == &#39;.&#39; &amp;amp;&amp;amp; !check) { start = j; check = true; } if (MAP[j][i] != &#39;.&#39; &amp;amp;&amp;amp; start != 13)//어디선가 걸리긴했고 문자를 만낫을 때 { int end = j;// 걸린곳의 높이 //cout &amp;lt;&amp;lt; &quot;start&quot; &amp;lt;&amp;lt; start &amp;lt;&amp;lt; &quot;end&quot; &amp;lt;&amp;lt; end &amp;lt;&amp;lt;&quot;i&quot;&amp;lt;&amp;lt;i&amp;lt;&amp;lt; &#39;\\n&#39;; swap(start, end, i); check = false; j = 11; start = 13; continue; } } check = false; }}void printMAP(){ for (int i = 0; i &amp;lt; 12; ++i) { for (int j = 0; j &amp;lt; 6; ++j) cout &amp;lt;&amp;lt; MAP[i][j] &amp;lt;&amp;lt; &quot; &quot;; cout &amp;lt;&amp;lt; &#39;\\n&#39;; } cout &amp;lt;&amp;lt; &#39;\\n&#39;;}void Solve() { int result = 0; bool check = false; bool counting = true; while (counting) { check = false; counting = false; memset(v, false, sizeof(v)); for (int i = 0; i &amp;lt; 12; ++i) { for (int j = 0; j &amp;lt; 6; ++j) { if (MAP[i][j] != &#39;.&#39; &amp;amp;&amp;amp; v[i][j] == false) { v[i][j] = true; check = BFS(i, j, MAP[i][j]); if (check == true) counting = true; } } } if (counting) ++result; //땡겨줌 //printMAP(); Down(); //cout &amp;lt;&amp;lt; &quot;땡긴 후\\n&quot;; //printMAP(); } cout &amp;lt;&amp;lt; result;}int main() { ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); Input(); Solve(); return 0;}6. 후기자면서 풀었다.. 4시간 자고 일어나서 푼 문제.." }, { "title": "Baekjoon17142-연구소3", "url": "/posts/baekjoon17142/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, BFS, DP", "date": "2021-01-23 18:02:00 +0900", "snippet": "백준 사이트 17142 - 연구소3 문제입니다.1. 문제https://www.acmicpc.net/problem/171422. Input , Output3. 분류 및 난이도BFS문제입니다.질문글을 보다보니 삼성기출문제로 나왔던 문제인 것 같습니다.백준에서는 Gold4의 난이도를 책정하고 있습니다.4. 생각한 것들 전체적으로 신경쓸 게 많은 문제였습니다. 가장 먼저 0.25초 제한으로 바이러스를 M개 고를 떄 고른 바이러스 바로 다음을 탐색하기 위해 코드를 작성해야 했습니다. BFS를 돌고 맵을 탐색하기 보다는 빈공간을 먼저 세주고 빈공간이 다 채워졌을 때 결과를 도출하도록 코드를 짰습니다. 처음에는 result(최소 시간 값을) 300정도로 줬는데 70%에서 계속 틀려서 987654321값을 주니 통과했습니다. 이것 때문에 애 많이 먹었습니다.5. code#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstring&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;algorithm&amp;gt; //maxusing namespace std;const int MAX = 51;int MAP[MAX][MAX] = { 0, };int temp[MAX][MAX];bool v[MAX][MAX] = { false, };queue&amp;lt;pair&amp;lt;pair&amp;lt;int, int&amp;gt;, int&amp;gt;&amp;gt; q;int arrx[11] = { 0, };int arry[11] = { 0, };int N, M;int counting = 0;int result = 987654321;//좌표이동int dx[4] = { -1,0,1,0 };int dy[4] = { 0,1,0,-1 };void Input() { cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; M; int temp = 0; for (int i = 0; i &amp;lt; N; ++i) { for (int j = 0; j &amp;lt; N; ++j) { cin &amp;gt;&amp;gt; temp; if (temp == 0) ++counting; MAP[i][j] = temp; } }}void BFS(){ memcpy(temp, MAP, sizeof(MAP)); memset(v, false, sizeof(v)); int tempresult = 0; int tempcounting = counting; for (int i = 0; i &amp;lt; M; ++i) { //cout &amp;lt;&amp;lt; arrx[i] &amp;lt;&amp;lt; arry[i] &amp;lt;&amp;lt; &quot;\\n&quot;; q.push(make_pair(make_pair(arrx[i], arry[i]), 0)); v[arrx[i]][arry[i]] = true; } while (!q.empty()) { int x = q.front().first.first; int y = q.front().first.second; int minu = q.front().second; q.pop(); for (int k = 0; k &amp;lt; 4; ++k) { int newX = x + dx[k]; int newY = y + dy[k]; if (0 &amp;lt;= newX &amp;amp;&amp;amp; newX &amp;lt; N &amp;amp;&amp;amp; 0 &amp;lt;= newY &amp;amp;&amp;amp; newY &amp;lt; N &amp;amp;&amp;amp; v[newX][newY] == false &amp;amp;&amp;amp; temp[newX][newY] != 1) { if (temp[newX][newY] == 0) { --tempcounting; if (tempcounting == 0) { result = min(result, minu + 1); } } temp[newX][newY] = 2; q.push(make_pair(make_pair(newX, newY), minu + 1)); v[newX][newY] = true; } } }}void virus(int x, int y, int cnt) { if (cnt == M) { BFS(); return; } bool check = false; for (int i = x; i &amp;lt; N; ++i) { int j; if (check == false) { j = y; check = true; } else j = 0; for (; j &amp;lt; N; ++j) { if (MAP[i][j] == 2) { MAP[i][j] = 3; arrx[cnt] = i; arry[cnt] = j; virus(i, j, cnt + 1); MAP[i][j] = 2; } } }}void Solve() { //바이러스 선별 먼저 //virus //복사 해두기 if (counting == 0) cout &amp;lt;&amp;lt; 0 &amp;lt;&amp;lt; &#39;\\n&#39;; else { virus(0, 0, 0); if (result == 987654321) result = -1; cout &amp;lt;&amp;lt; result; }}int main() { ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); Input(); Solve();}6. 후기사실 반쯤 포기하고 다른 사람들꺼 코드 보면서 고쳤는데, 그 로직만 바꾼 그 코드들도 70%에서 오류가 나길래 이건 나의 로직 문제가 아니고 값이 뭔가 잘 못된 것을 인지해서 result값 바꾸니까 바로 성공.." }, { "title": "Baekjoon15649-N과M(1)", "url": "/posts/baekjoon15649/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, BackTracking", "date": "2021-01-22 16:02:00 +0900", "snippet": "백준 사이트 15649 - N 과 M (1) 문제입니다.1. 문제https://www.acmicpc.net/problem/156492. Input , Output3. 분류 및 난이도백트래킹 문제입니다.백준에서는 Sliver3의 난이도를 책정하고 있습니다.4. 생각한 것들 어떻게 해야할 지는 알겠으나, 백트래킹에 익숙하지 않은 저는 꽤 고전한 문제입니다.5. code#include&amp;lt;iostream&amp;gt;#include&amp;lt;vector&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;cstring&amp;gt;using namespace std;int n, m;int arr[9];bool v[9];void Input(){ cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;}void Solve(int cnt) { if (cnt == m) { for (int i = 0; i &amp;lt; m; ++i) cout &amp;lt;&amp;lt; arr[i] &amp;lt;&amp;lt; &quot; &quot;; cout &amp;lt;&amp;lt; &#39;\\n&#39;; } else { for (int i = 1; i &amp;lt;= n; ++i) { if (!v[i]) { v[i] = true; arr[cnt] = i; Solve(cnt+1); v[i] = false; } } } }int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); Input(); memset(v, false, sizeof(v)); Solve(0);}6. 후기백트래킹 연습해야겠다." }, { "title": "Baekjoon9019-DSLR", "url": "/posts/baekjoon9019/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, BFS", "date": "2021-01-22 15:02:00 +0900", "snippet": "백준 사이트 9019 - DSLR 문제입니다.1. 문제https://www.acmicpc.net/problem/90192. Input , Output3. 분류 및 난이도BFS문제입니다.생각해야할 것들이 꽤 있는 문제입니다.백준에서는 Gold5의 난이도를 책정하고 있습니다.4. 생각한 것들 c++ 스트링은 제가 못써서 그런지 정말 오류를 많이 뱉어내는 것 같습니다.. 시간을 줄일 수 있는 방법을 모두 써야 맞을 수 있는 것 같습니다. 로직 자체는 어렵지 않으나, 4가지 경우를 모두 큐에 넣지 않도록 조심해야합니다. 테스트 케이스가 있으므로 방문처리를 전역으로 하면 안됩니다.5. code#include&amp;lt;iostream&amp;gt;#include&amp;lt;string&amp;gt;#include&amp;lt;cstring&amp;gt;#include&amp;lt;queue&amp;gt;using namespace std;int DoubleN(int x){ x *= 2; if (x &amp;gt;= 10000) x %= 10000; return x;}int Single(int x){ if (x != 0) return x - 1; else return 9999;}int Left(int x){ return ((x*10)%10000) + (x/1000);}int Right(int x){ return ((x%10)*1000) + (x/10);}//a-&amp;gt;bstring bfs(int a, int b){ bool v[10001]; memset(v, false, sizeof(v)); queue&amp;lt;pair&amp;lt;int, string&amp;gt;&amp;gt; q; q.push(make_pair(a, &quot;&quot;)); v[a] = true; while (!q.empty()) { int x = q.front().first; string logic = q.front().second; q.pop(); //cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &#39;\\n&#39;; if (x == b) return logic; //4가지 경우 //1. Double int case1 = DoubleN(x); if (v[case1] == false) { v[case1] = true; q.push(make_pair(case1, logic + &quot;D&quot;)); } //2. Single int case2 = Single(x); if (v[case2] == false) { v[case2] = true; q.push(make_pair(case2, logic + &quot;S&quot;)); } //3. Left int case3 = Left(x); if (v[case3] == false) { v[case3] = true; q.push(make_pair(case3, logic + &quot;L&quot;)); } //4. right int case4 = Right(x); if (v[case4] == false) { v[case4] = true; q.push(make_pair(case4, logic + &quot;R&quot;)); } } return &quot;&quot;;}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); int t; cin &amp;gt;&amp;gt; t; int a, b; for (int i = 0; i &amp;lt; t; ++i) { cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b; string result = bfs(a, b); cout &amp;lt;&amp;lt; result&amp;lt;&amp;lt;&#39;\\n&#39;; } return 0;}6. 후기왜 인지 힘든 문제였다." }, { "title": "Baekjoon12865-평범한 배낭", "url": "/posts/baekjoon12865/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, DP", "date": "2021-01-22 13:02:00 +0900", "snippet": "백준 사이트 12865 - 평범한 배낭 문제입니다.1. 문제https://www.acmicpc.net/problem/128652. Input , Output3. 분류 및 난이도DP문제입니다.유명한 배낭 문제입니다.백준에서는 Gold5의 난이도를 책정하고 있습니다.4. 생각한 것들 옛날에 파이썬으로 비슷한 문제를 푼 적이 있었는데, 그 때는 굉~~장히 어렵게 풀었기에 어려운 감이 있었는데, 여전히 어렵습니다.. 재귀로 풀려다 트리까지 만들어줘야할 것 같아서 그냥 고민하다가 다른사람들의 코드를 참고하였습니다. 굉장히 비효율적인 코드 같은데.. 고민하기가 더 힘듭니다. 코드의 내용은 각각 배낭마다 넣었을 때와 안 넣었을 때를 비교하는 간단한 로직이긴 합니다.5. code#include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;int n, k;class bag{public: int w; int v;};bag arr[101];int dp[101][100002];void Input(){ cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k; for (int i = 1; i &amp;lt;= n; ++i) { cin &amp;gt;&amp;gt; arr[i].w; cin &amp;gt;&amp;gt; arr[i].v; }}void Solve(){ int result = 0; for (int i = 1; i &amp;lt;= n; ++i) { int weight = arr[i].w; int val = arr[i].v; for (int j = 0; j &amp;lt;= k; ++j) { if (j &amp;lt; weight) dp[i][j] = dp[i - 1][j]; else dp[i][j] = max(dp[i - 1][j], dp[i-1][j - weight] + val); } } cout &amp;lt;&amp;lt; dp[n][k];}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); Input(); Solve(); return 0;}6. 후기나는 왤케 어려워." }, { "title": "Spring - 6 컴포넌트 스캔", "url": "/posts/SpringPoint8/", "categories": "Java, 3. Spring_김영한_스프링-핵심-원리-기본편", "tags": "Spring", "date": "2021-01-22 11:00:00 +0900", "snippet": "해당 자료는 인프런 김영한 선생님의 스프링-핵심-원리-기본편 강의노트입니다.1. 컴포넌트 스캔과 의존관계 자동 주입 시작하기지금까지는 수동으로 @Bean, XML 같은 경우는 을 통해 설정정보를 저장했습니다.하지만 이러한 설정정보가 수백 수천가지가 된다면 매 번 적어주는 것은 매우 힘든 일입니다.그래서 스프링은 자동으로 스프링 빈으로 등록하는 컴포넌트 스캔기능을 제공합니다.또한 의존관계를 자동으로 주입해주는 @Autowired 기능도 제공합니다.테스트를 위해 새로운 AutoAppConfig.java 파일을 만들겠습니다.package hello.core;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.FilterType;import static org.springframework.context.annotation.ComponentScan.*;//ComponentScan 에 들어있는 코드는 이미 다른 곳에서 등록한 빈들을 제외하고 스캔하라는 뜻입니다.@Configuration@ComponentScan( excludeFilters = @Filter(type = FilterType.ANNOTATION, classes = Configuration.class))public class AutoAppConfig { //컴포넌트 스캔을 사용하면 @Configuration이 붙은 설정 정보도 자동으로 등록되기에 Appconfig, TestConfig 설정정보도 같이 등록됩니다. //&#39;excludeFilters&#39;를 사용해 위의 설정정보들을 제외하고 스캔합니다. 보통 잘 사용하지 않는다고 합니다. //@Configuration이 스캔 대상이 된 것은 그 안에 @Componet 애노테이션이 붙어있기 때문입니다.}설정을 해주기 위해 사용하들 구현체들에게 @Component, 생성자에는 @Autowired를 달아줍니다.//MemberServiceImpl.java@Componentpublic class MemberServiceImpl implements MemberService{ private final MemberRepository memberRepository; @Autowired public MemberServiceImpl(MemberRepository memberRepository) { this.memberRepository = memberRepository; }이런 식으로 ‘OrderServiceImpl’, ‘RateDiscountPolicy’ 자바파일에도 붙여줍니다.테스트를 위해 새로운 테스트파일인, ‘AutoAppConfigTest’ 파일을 만들어 줍니다.package hello.core.scan;import hello.core.AutoAppConfig;import hello.core.member.MemberService;import org.assertj.core.api.Assertions;import org.junit.jupiter.api.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class AutoAppConfigTest { @Test void basicScan(){ ApplicationContext ac = new AnnotationConfigApplicationContext(AutoAppConfig.class); MemberService memberService = ac.getBean(MemberService.class); Assertions.assertThat(memberService).isInstanceOf(MemberService.class); }}코드에 대한 설명을 하자면, 아무것도 적어주지 않은 AutoAppConfig을 설정정보로 넣어도 컴포넌트 스캔과 Autowired덕에 빈에서 잘 꺼내는 것을 볼 수 있습니다.그리고 로그도 아주 친절하게 나옵니다.무엇이 등록되고, 무엇이 싱글톤으로 생겨났고, 의존관계 주입이 어떤식으로 되었다라고 나옵니다.@ComponentScan이 어떻게 동작하는 지 친절하게 알려주십니다. 출처 : 김영한 선생님 강의자료@Autowired가 어떻게 동작하는 지 보여줍니다. 출처 : 김영한 선생님 강의자료이러한 컴포넌트 스캔과 Autowired는 제약이 꽤 있을 것 같다고 생각하는데, 그에 대한 내용은 뒤에서 다뤄주신다고 합니다.2. 탐색 위치와 기본 스캔 대상모든 자바 클래스를 스캔하려면 오래걸립니다. 그래서 범위를 지정해줄 수 있습니다.@ComponentScan{ basePackages = {&quot;hello.core&quot;,&quot;hello.serivce&quot;}//패키지명 //or basePackages = &quot;hello.core&quot;}‘basePackages’는 탐색할 패키지의 위치를 지정합니다. 이 패키지를 포함해서 하위 패키지 모두를 탐색합니다.권장하는 방법패키지 위치를 지정하지 않고, 설정 정보 클래스를 프로젝트의 최상단에 두어 그 하위계층을 모두 탐색하게 만듭니다.최근 스프링 부트도 이러한 방식을 제공하고 있습니다. com.hello com.hello.service com.hello.controller이런식으로 되어 있다면 com.hello에 설정파일을 두어 스캔하는 것입니다.참고로 스프링 부트의 메인 메소드에 ‘@SpringBootApplication’ 애노테이션이 붙어있는데 위와 같은 방식입니다.컴포넌트 스캔은 @Component 뿐만 아니라 다음과 같은 내용도 추가로 대상에 포함시킵니다. @Component @Controller : 스프링 MVC컨트롤러에서 사용 @Service : 스프링 비즈니스 로직에 사용, 특별한 처리는 안하지만 사람들이 볼 때 여기에 비즈니스 로직이 있겠구나 인식을 도와줌. @Repository : 스프링 데이터 접근 계층에 사용, 데이터 계층의 예외를 스프링 예외로 변환해준다. -&amp;gt; DB에 관한 에러를 좀 더 잘 검출 할 수 있게끔 도와줌. @Configuration : 스프링 설정 정보에서 사용위의 애노테이션들은 전부 @Component를 포함하고 있기 때문입니다. 참고: 사실 애노테이션에는 상속관계라는 것이 없다. 그래서 이렇게 애노테이션이 특정 애노테이션을 들고 있는 것을 인식할 수 있는 것은 자바 언어가 지원하는 기능은 아니고, 스프링이 지원하는 기능입니다. 참고: useDefaultFilters 옵션은 기본으로 켜져있는데, 이 옵션을 끄면 기본 스캔 대상들이 제외된다. 그냥 이런 옵션이 있구나 정도 알고 넘어갑니다.3. 필터 includeFilters : 컴포넌트 스캔 대상을 추가로 지정한다. excludeFilters : 컴포넌트 스캔에서 제외할 대상을 지정한다.테스트를 작성해보겠습니다. 애노테이션을 간단하게 직접만들어서 애노테이션에 따라 어떤 클래스는 스캔하고, 어떤 클래스는 스캔에서 제외시키겠습니다.//MyExcludeComponent.annotation//MyIncludeComponent도 같은 방식으로 만들어줍니다. package hello.core.scan;import java.lang.annotation.*;@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface MyExcludeComponent {}//beanA. java파일//beanB 자바파일은 애노테이션을 @MyExcludeComponent로 바꿔줍니다.package hello.core.scan;@MyIncludeComponentpublic class beanA {}package hello.core.scan;import org.junit.jupiter.api.Assertions;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.NoSuchBeanDefinitionException;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.FilterType;import org.springframework.stereotype.Component;import static org.springframework.context.annotation.ComponentScan.*;import static org.springframework.context.annotation.FilterType.*;public class ComponentFilerAppConfigTest { @Test void FilterScan(){ ApplicationContext ac = new AnnotationConfigApplicationContext(ComponentFilterAppConfig.class); beanA beanA = ac.getBean(&quot;beanA&quot;, beanA.class); //에러 beanA beanB = ac.getBean(&quot;beanB&quot;, beanB.class); //테스트 마무리 Assertions.assertThrows(NoSuchBeanDefinitionException.class, () -&amp;gt; ac.getBean(&quot;beanB&quot;, beanB.class) ); } @Configuration @ComponentScan( includeFilters = @Filter(type = ANNOTATION, classes = MyIncludeComponent.class), excludeFilters = @Filter(type = ANNOTATION,classes = MyExcludeComponent.class) ) static class ComponentFilterAppConfig{ }}결과를 보시면 beanB는 스프링 빈에 들어가지 않은것을 알 수 있습니다.Type에는 5가지 옵션이 있습니다. ANNOTATION: 기본값, 애노테이션을 인식해서 동작한다. ex) org.example.SomeAnnotation ASSIGNABLE_TYPE: 지정한 타입과 자식 타입을 인식해서 동작한다. ex) org.example.SomeClass ASPECTJ: AspectJ 패턴 사용 ex) org.example..*Service+ REGEX: 정규 표현식 ex) org.example.Default.* CUSTOM: TypeFilter 이라는 인터페이스를 구현해서 처리 ex) org.example.MyTypeFilter따라서 beanA를 위의 코드에서 빼고싶으면 다음과 같이 수정해주면 됩니다.excludeFilters = @Filter(type = ANNOTATION,classes = MyExcludeComponent.class), @Filter(type = FilterType.ASSIGNABLE_TYPE, classes = BeanA.class) 참고: @Component 면 충분하기 때문에, includeFilters 를 사용할 일은 거의 없습니다. excludeFilters는 여러가지 이유로 간혹 사용할 때가 있지만 많지는 않다고 하십니다. 특히 최근 스프링 부트는 컴포넌트 스캔을 기본으로 제공하는데, 개인적으로는 옵션을 변경하면서 사용하기보다는 스프링의 기본 설정에 최대한 맞추어 사용하는 것을 권장하고, 선호하는 편이라고 하십니다.4. 중복 등록과 충돌컴포넌트 스캔에서 같은 빈 이름을 등록하면 충돌이납니다.다음 두가지 상황이 있습니다. 자동 빈 등록 vs 자동 빈 등록 수동 빈 등록 vs 자동 빈 등록먼저 자동 빈 등록 vs 자동 빈 등록은 ‘ConflictingBeanDefinitionException’라는 에러를 뱉어냅니다.문제는 수동 빈 등록 vs 자동 빈 등록인데,원래는 수동 빈으로 등록한 것이 우선권을 가져 기존 빈에 오버라이딩을 했었습니다.로그도 ‘Overriding bean definition for bean ‘memoryMemberRepository’ with a different definition: replacing’ 이렇게 찍힙니다.의도적으로 한 것이라면은 다행이지만 의도적이지 않은 것이면 오류잡기가 굉장히 힘들어 집니다.이러한 문제점이 많이 발생하여 최근 스프링 부트에서는 ‘Consider renaming one of the beans or enabling overriding by settingspring.main.allow-bean-definition-overriding=true’라는 오류를 뱉어내도록 기본 값을 바꿨다고 합니다." }, { "title": "Spring - 5 싱글톤 컨테이너", "url": "/posts/SpringPoint7/", "categories": "Java, 3. Spring_김영한_스프링-핵심-원리-기본편", "tags": "Spring", "date": "2021-01-21 11:00:00 +0900", "snippet": "해당 자료는 인프런 김영한 선생님의 스프링-핵심-원리-기본편 강의노트입니다.1. 웹 애플리케이션과 싱글톤 만약에 여러 사용자가 동시에 서버에 요청한다면 스프링 없는 순수한 DI컨테이너는 매 번 객체를 생성할 것 입니다.테스트를 위해 ‘SingletonTest’.java 테스트 파일을 만든 후 두 객체를 생성해서 객체참조값이 같은 지 확인하겠습니다.package hello.core.singletone;import hello.core.Appconfig;import hello.core.member.MemberService;import org.assertj.core.api.Assertions;import org.junit.jupiter.api.DisplayName;import org.junit.jupiter.api.Test;public class SingletonTest { @Test @DisplayName(&quot;스프링없는 순수한 DI 컨테이너&quot;) void pureContainer(){ Appconfig appconfig = new Appconfig(); //1. 조회 : 객체 하나 생성 MemberService memberService1 = appconfig.memberService(); //2. 조회 : 객체 하나 생성 MemberService memberService2 = appconfig.memberService(); //같은지 확인 System.out.println(&quot;memberService1 = &quot; + memberService1); System.out.println(&quot;memberService2 = &quot; + memberService2); //눈으로 보는건 안좋음 테스트 로직작성 Assertions.assertThat(memberService1).isNotSameAs(memberService2); }}보시면은 두 객체의 참조가 달라서 서비스 요청시 매번 생기는 것을 알 수 있습니다. 이러한 방식은 메모리 낭비가 너무 심합니다.따라서 객체가 하나만 생성되고 그 객체를 공유하는 방식으로 설계하면 됩니다.2. 싱글톤 패턴 클래스의 인스턴스가 딱 1개만 생성될 수 있도록 보장하는 디자인 패턴 입니다. private 생성자를 사용해 새로운 객체가 생기는 것을 막습니다. 테스트를 위해 ‘SingletonService’.java 파일을 테스트 폴더안에 생성합니다.package hello.core.singletone;public class SingletonService { //1. static 영역에 객체를 딱 1개만 생성합니다. private static final SingletonService instance = new SingletonService(); //2. public으로 열어서 객체 인스턴스가 필요하면 getInstance()를 통해 조회하도록 허용합니다. public static SingletonService getInstance(){ return instance; } //3. private 생성자를 통해 새로운 객체가 생기는 것을 막습니다. private SingletonService(){} public void logic(){ System.out.println(&quot;싱글톤 로직 객체 출력&quot;); }}이제 외부에서 사용하려면 컴파일에러가 나타날 것입니다.진짜로 동일한 객체를 공유하는지 테스트해보기 위해 아까 만들어둔 테스트 파일에 singletonServiceTest메소드를 넣습니다.@Test @DisplayName(&quot;싱글톤 패턴 테스트&quot;) void singletonServiceTest(){ //new SingletonService() private으로 막아놔서 에러가 뜬다. //1. 조회 : 객체 호출 SingletonService singletonService1 =SingletonService.getInstance(); //2. 조회 : 객체 호출 SingletonService singletonService2 =SingletonService.getInstance(); //눈으로 확인 System.out.println(&quot;singletonService1 = &quot; + singletonService1); System.out.println(&quot;singletonService2 = &quot; + singletonService2); //테스트 확인 Assertions.assertThat(singletonService1).isSameAs(singletonService2); }하지만 이러한 싱글톤 패턴에도 단점이 있습니다. 싱글톤 패턴을 구현하는 코드 자체가 많이 들어간다. 의존관계상 클라이언트가 구체 클래스에 의존한다. DIP를 위반한다. 클라이언트가 구체 클래스에 의존해서 OCP 원칙을 위반할 가능성이 높다. 테스트하기 어렵다. 내부 속성을 변경하거나 초기화 하기 어렵다. private 생성자로 자식 클래스를 만들기 어렵다. 결론적으로 유연성이 떨어진다. 안티패턴으로 불리기도 한다.스프링은 위의 단점들을 해결한 기술을 제공하고 있습니다.3. 싱글톤 컨테이너스프링 컨테이너는 싱글톤 패턴의 문제점을 해결하면서, 객체 인스턴스를 싱글톤(1개만 생성)으로 관리합니다.저희가 생성했던 빈들이 전부 싱글톤 패턴이 적용되어 저장되는 것들 입니다.스프링 컨테이너는 싱글톤 컨테이너 역할을 합니다. 싱글톤 객체를 생성하고 관리하는 기능을 싱글톤 레지스트리라 합니다. 더이상 코드를 지저분하게 작성안해도 됩니다. DIP, OCP, 테스트, private 생성자로 부터 자유롭게 싱글톤을 사용할 수 있습니다.테스트를 위해 위에 작성한 테스트 파일에 새로운 테스트를 넣어줍니다.전에 빈에 넣어줬던 객체들을 꺼내봅니다. @Test @DisplayName(&quot;스프링 싱글톤 테스트&quot;) void singletonServiceSpring(){ ApplicationContext ac = new AnnotationConfigApplicationContext(Appconfig.class); MemberService memberService1 = ac.getBean(&quot;memberService&quot;,MemberService.class); MemberService memberService2 = ac.getBean(&quot;memberService&quot;,MemberService.class); //같은지 확인 System.out.println(&quot;memberService1 = &quot; + memberService1); System.out.println(&quot;memberService2 = &quot; + memberService2); //눈으로 보는건 안좋음 테스트 로직작성 Assertions.assertThat(memberService1).isSameAs(memberService2); }테스트 결과를 보면 객체의 참조값이 동일한 것을 확인할 수 있습니다. Note: 스프링의 기본 빈 등록 방식은 싱글톤이지만, 싱글톤 방식만 지원하는 것은 아니다. 요청할 때 마다 새로운 객체를 생성해서 반환하는 기능도 제공합니다. 자세한 내용은 뒤에 빈 스코프에서 나옵니다.하지만 이러한 싱글톤 방식에도 주의할 점이 있습니다.4. 싱글톤 방식의 주의점싱글톤 방식은 여러 클라이언트가 하나의 객체 인스턴스를 공유하기 때문에 싱글톤 객체는 상태를 유지(stateful)하게 설계하면 안됩니다. 무상태(stateless)로 설계해야 합니다. 특정 클라이언트에 의존적인 필드가 있으면 안된다. 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다! 가급적 읽기만 가능해야 한다. 필드 대신에 자바에서 공유되지 않는, 지역변수, 파라미터, ThreadLocal 등을 사용해야 한다. 문제점을 보기위해 main에 ‘StatefulService’ 자바 파일을 생성합니다.package hello.core;public class StatefulService { private int price; public void order(String name, int price){ System.out.println(&quot;name = &quot; + name + &quot;price = &quot; + price); this.price=price;// 문제 발생지점 } public int getPrice(){ return price; }}ctrl + shift + t를 눌러 테스트파일을 생성합니다.package hello.core;import org.assertj.core.api.Assertions;import org.junit.jupiter.api.DisplayName;import org.junit.jupiter.api.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.annotation.Bean;import static org.junit.jupiter.api.Assertions.*;class StatefulServiceTest { @Test void StatefulServiceSingleton(){ ApplicationContext ac = new AnnotationConfigApplicationContext(Testconfig.class); //객체 두개 생성 StatefulService statefulService1 = ac.getBean(&quot;statefulService&quot;, StatefulService.class); StatefulService statefulService2 = ac.getBean(&quot;statefulService&quot;, StatefulService.class); //userA가 만원 주문 statefulService1.order(&quot;userA&quot;,10000); //userB가 2만원 주문 statefulService2.order(&quot;userB&quot;,20000); //조회 만원이찍혀야함. int price = statefulService1.getPrice(); //2만원 찍힘. System.out.println(&quot;price = &quot; + price); //테스트 마무리를 위한 코드. Assertions.assertThat(price).isEqualTo(20000); } static class Testconfig{ @Bean public StatefulService statefulService(){ return new StatefulService(); } }}실행을 하면 다음과 같이 만원이 찍혀야하는데 2만원이 찍히는 것을 확인할 수 있습니다. price라는 공유 필드를 사용하고, 그 값을 변경해서 나타나는 오류입니다. 때문에 항상 스프링 빈은 무상태(stateless)로 설계해야합니다.위의 문제점을 고치기 위해 main 코드를 바꿔줍니다.package hello.core;public class StatefulService { public int order(String name, int price){ System.out.println(&quot;name = &quot; + name + &quot;price = &quot; + price); return price; }}테스트 코드도 바꿔줍니다. @Test void StatefulServiceSingleton(){ ApplicationContext ac = new AnnotationConfigApplicationContext(Testconfig.class); //객체 두개 생성 StatefulService statefulService1 = ac.getBean(&quot;statefulService&quot;, StatefulService.class); StatefulService statefulService2 = ac.getBean(&quot;statefulService&quot;, StatefulService.class); //userA가 만원 주문 int price1 = statefulService1.order(&quot;userA&quot;, 10000); //userB가 2만원 주문 int price2 = statefulService2.order(&quot;userB&quot;, 20000); //조회 System.out.println(&quot;price = &quot; + price1); //테스트 마무리를 위한 코드. Assertions.assertThat(price1).isEqualTo(10000); }5. @Configuration과 싱글톤옛날에 작성한 Appconfig 코드를 보면 이상한 점이 있습니다.@Configurationpublic class Appconfig { //ctrl + alt + m @Bean public MemberService memberService(){ return new MemberServiceImpl(memberRepository()); } @Bean public OrderServiceImpl orderService(){ return new OrderServiceImpl(memberRepository(), discountPolicy()); } @Bean public MemberRepository memberRepository() { return new MemoryMemberRepository(); }....‘memberService()’가 호출되면서 memberRepository()가 호출됩니다.그리고 새로운 MemoryMemberRepository를 반환하는데‘orderService()’에서도 memberRepository()가 호출되면서 MemoryMemberRepository를 반환하는데 이 둘을 달라야 정상입니다.확인하기위해 테스트 코드를 작성하겠습니다.저 둘의 구현체 코드에 할당된 MemberRepository를 반환하는 메소드를 만들겠습니다. public MemberRepository getMemberRepository(){ return memberRepository; }‘ConfigurationSingletonTest’ test파일을 만듭니다.package hello.core.singletone;import hello.core.Appconfig;import hello.core.member.MemberRepository;import hello.core.member.MemberServiceImpl;import hello.core.order.OrderServiceImpl;import org.assertj.core.api.Assertions;import org.junit.jupiter.api.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class ConfigurationSingletonTest { @Test void ConfigurationTest(){ ApplicationContext ac = new AnnotationConfigApplicationContext(Appconfig.class); MemberServiceImpl memberService = ac.getBean(&quot;memberService&quot;, MemberServiceImpl.class); OrderServiceImpl orderService = ac.getBean(&quot;orderService&quot;, OrderServiceImpl.class); MemberRepository memberRepository = ac.getBean(&quot;memberRepository&quot;, MemberRepository.class); System.out.println(&quot;memberRepository = &quot; + memberRepository); System.out.println(&quot;orderService = &quot; + orderService.getMemberRepository()); System.out.println(&quot;memberService = &quot; + memberService.getMemberRepository()); //테스트 마무리를 위한 Assertions.assertThat(orderService.getMemberRepository()).isSameAs(memberRepository); Assertions.assertThat(memberService.getMemberRepository()).isSameAs(memberRepository); }}결과를 보시면 모두 똑같은 memberRepository입니다.혹시 두 번 호출이 안되는 것인지 확인하기 위해 Appconfig.java에 새로운 코드를 메소드마다 넣어줍니다. @Bean public MemberService memberService(){ System.out.println(&quot;call Appconfig.memberService&quot;); return new MemberServiceImpl(memberRepository()); } @Bean public OrderServiceImpl orderService(){ System.out.println(&quot;call Appconfig.orderService&quot;); return new OrderServiceImpl(memberRepository(), discountPolicy()); } @Bean public MemberRepository memberRepository() { System.out.println(&quot;call Appconfig.memberRepository&quot;); return new MemoryMemberRepository(); }테스트코드를 실행해봅니다.보시면 각 메소드가 실행되는 것을 확인할 수 있습니다.어떤 일인지 알아보겠습니다.6. @Configuration과 바이트코드 조작위처럼 이미 생성된 자식에 다시 들어가지 않는 이유는 @Configuration 때문입니다.테스트를 위해 새로운 테스트 코드를 작성해보겠습니다. @Test void configurationDeep(){ ApplicationContext ac = new AnnotationConfigApplicationContext(Appconfig.class); //Appconfig도 스프링 빈으로 등록됩니다. Appconfig bean = ac.getBean(Appconfig.class); System.out.println(&quot;bean = &quot; + bean.getClass()); }맨 밑줄 결과를 보면 뒤에 이상한 것들이 많이 붙은 것을 볼 수 있습니다.이것은 내가 만든 클래스가 아니라 스프링이 CGLIB라는 바이트코드 조작 라이브러리를 사용해서 AppConfig 클래스를 상속받은 임의의 다른 클래스를 만들고, 그 다른 클래스를 스프링 빈으로 등록한 것입니다.예상하기로는 이미 스프링 컨테이너에 있으면 스프링 컨테이너에서 찾아서 반환해주고 없으면 스프링 컨테이너에 등록하여 반환하는 로직이 있을 것이라고 생각합니다. 이 덕분에 싱글톤이 보장됩니다.@Configuration을 없애면 CGLIB 기술이 적용안된 Appconfig이 그대로 스프링 빈에 등록되어 처음에 예상했던대로 매 번 객체를 생성하게 됩니다.따라서 스프링빈에 등록되지만, 싱글톤은 보장이 안되기에 스프링 설정 정보는@Configuration을 붙여줘야 합니다." }, { "title": "Baekjoon1707-이분 그래프", "url": "/posts/baekjoon1707/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, BFS, AlgorithmStudy", "date": "2021-01-20 16:02:00 +0900", "snippet": "백준 사이트 1707 - 이분그래프 문제입니다.1. 문제https://www.acmicpc.net/problem/17072. Input , Output3. 분류 및 난이도BFS문제입니다.백준에서는 Gold4난이도를 책정하고 있습니다.4. 생각한 것들 다 풀고 보니 기준을 뭘로하느냐에 따라 이 문제가 hell이 될 수 있고 eazy가 될 수 있습니다. 그래프 문제상 반례를 찾기 힘들어서 처음에 기준을 잘 잡아야합니다. 처음에는 방문처리를 위해 배열을 한 개 더 두었는데, 그거 때문에 틀렸습니다. 게시판에 있는 반례 포함 다 돌아갔으나 왜 틀렸는 지 모름.. 처음부터 다시해서 배열하나로 방문처리와 색에 대한 정보를 저장했습니다. 대부분이 이렇게 풀었습니다. 저도 이렇게 푸니 맞긴 하던데.. 위의 코드는 왜 틀렸는지.. 5. codec++#include&amp;lt;iostream&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;cstring&amp;gt;using namespace std;int map[20001] = { 0 };int t, v, e;bool BFS(int start, vector&amp;lt;int&amp;gt; vec[]){ queue&amp;lt;int&amp;gt; q; q.push(start); map[start] = 1; while (!q.empty()) { int curr = q.front(); q.pop(); for (int i = 0; i &amp;lt; vec[curr].size(); ++i) { int ver = vec[curr][i]; if (map[ver] != 0)//방문기록이 있음. { if (map[curr] == map[ver])//색이 같다. { return false; } } else { q.push(ver); map[ver] = 3 - map[curr]; } } } return true;}void Input(){ cin &amp;gt;&amp;gt; t; for (int i = 0; i &amp;lt; t; ++i) { memset(map, 0, sizeof(map)); bool result = true; vector&amp;lt;int&amp;gt; vec[20001]; cin &amp;gt;&amp;gt; v &amp;gt;&amp;gt; e; int first = 0; int second = 0; for (int j = 0; j &amp;lt; e; ++j) { cin &amp;gt;&amp;gt; first &amp;gt;&amp;gt; second; vec[first].push_back(second); vec[second].push_back(first); } for (int i = 1; i &amp;lt;= v; ++i) { if (map[i] == 0) { result = BFS(i, vec); if (result == false) { cout &amp;lt;&amp;lt; &quot;NO\\n&quot;; break; } } } if (result) cout &amp;lt;&amp;lt; &quot;YES\\n&quot;; }}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); Input(); return 0;}pythonfrom collections import dequedef BFS(start,li,mapz): queue = deque([start]) mapz[start] = 1 while queue: curr = queue.popleft() for i in range (0,len(li[curr])): ver = li[curr][i] if mapz[ver] != 0: if mapz[curr] == mapz[ver]: return False else : queue.append(ver) mapz[ver] = 3-mapz[curr] return Truet = int(input())for i in range (0,t): mapz = [0] * 20001 result = True li = [] for j in range (0,20001): line = [] li.append(line) v,e = map(int,input().split()) for j in range (0,e): first,second = map(int,input().split()) li[first].append(second) li[second].append(first) for i in range(1,v+1): if mapz[i] == 0 : result = BFS(i,li,mapz) if result == False : print(&quot;NO&quot;) break if result : print(&quot;YES&quot;)6. 후기삽질을 너무 많이 한 문제입니다." }, { "title": "Baekjoon2225-합분해", "url": "/posts/baekjoon2225/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, DP", "date": "2021-01-20 13:02:00 +0900", "snippet": "백준 사이트 2225 - 합분해 문제입니다.1. 문제https://www.acmicpc.net/problem/22252. Input , Output3. 분류 및 난이도DP문제입니다.비슷한 문제가 꽤나 많고, 규칙만 찾으면 어렵지 않습니다.백준에서는 Gold5의 난이도를 책정하고 있습니다.4. 생각한 것들 공책에 먼저 그려보았습니다. n과 k가 다를 때라는 2차원 테이블을 만들었습니다. 먼저 k가 1일때 는 모두 1이라는 사실을 알았습니다. (숫자 1개로 N을 1개만 만들 수 있음) 초기화할 때 k가 1일경우 모두 1을 넣었습니다. n이 입력으로 0이 들어오진 않지만 0일 때도 생각해줬습니다. 이유는 (2 + 0 + 0)이런식으로 2를 3가지 숫자로 만들 수 있어서 그려보니 점화식을 찾았습니다. 4가지수 (k=4)로 4를 만드는 경우의 수를 예시로 들겠습니다.(n=4)위의 점화식 대로 프로그램을 작성한 dp예 (dp[1][~])부분 부터 출력이라 dp[0][~]이 1이라고 생각하고 보시면 됩니다.5. code#include&amp;lt;iostream&amp;gt;const int mok = 1000000000;const int MAX = 201;using namespace std;int dp[MAX][MAX] = { 0, };int n, k;int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k; for (int i = 0; i &amp;lt;= k; ++i) dp[0][i] = 1; for (int i = 0; i &amp;lt;= n; ++i) dp[i][1] = 1; for (int i = 0; i &amp;lt;= n; ++i) dp[i][2] = i + 1; for (int i = 1; i &amp;lt;= n; ++i) { for (int j = 3; j &amp;lt;= k; ++j) { for (int r = 0; r &amp;lt;= i; ++r) { dp[i][j] += dp[r][j-1]; dp[i][j] %= mok; } } } cout &amp;lt;&amp;lt; dp[n][k];}6. 후기1차원으로 푼 사람들도 많네요." }, { "title": "Spring - 4 스프링 컨테이너와 스프링 빈", "url": "/posts/SpringPoint6/", "categories": "Java, 3. Spring_김영한_스프링-핵심-원리-기본편", "tags": "Spring", "date": "2021-01-20 11:00:00 +0900", "snippet": "해당 자료는 인프런 김영한 선생님의 스프링-핵심-원리-기본편 강의노트입니다.1. 스프링 컨테이너 생성ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); ApplicationContext를 스프링 컨테이너라고 한다. 또한 인터페이스입니다. (다형성이 적용 됨.) 스프링 컨테이너는 XML로 만들 수도 있고 애노테이션 기반 자바 설정파일로 만들 수 있습니다. (최근에는 애노테이션 기반을 많이 씀.) Appconfig을 사용했던 방식이 애노테이션 기반 자바 설정파일로 만든 것입니다. new AnnotationConfigApplicationContext는 ApplicationContext 인터페이스의 구현체입니다. 스프링 컨테이너는 Bean Factory, ApplicationContext로 나뉘지만 Bean Factory를 직접적으로 쓰는 경우가 거의 없어서 일반적으로 ApplicationContext를 스프링 컨테이너라고 합니다. 스프링 컨테이너 생성 과정은 다음과 같습니다. 1.스프링 컨테이너 생성. (Appconfig과 같이 구성 정보 지정 필요) 2.스프링 빈 등록 (빈 이름을 직접 부여할 수 있다. 이름이 중복되서는 안된다.) 3.스프링 빈 의존관계 설정 - 준비 4.스프링 빈 의존관계 설정 - 완료 (설정을 참고하여 의존관계를 주입한다. ) 2. 컨테이너에 등록된 모든 빈 조회패키지명은 아무렇게 하고 ‘ApplicationContextInfoTest’ java파일을 test폴더 안에 만들어줍시다.package hello.core.bean;import hello.core.Appconfig;import org.junit.jupiter.api.DisplayName;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.config.BeanDefinition;import org.springframework.context.annotation.AnnotationConfigApplicationContext;class ApplicationContextInfoTest { AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(Appconfig.class); @Test @DisplayName(&quot;모든 빈 출력하기&quot;) void findAllbean(){ //alt + enter하면 반환형에 맞는 자료형, 변수 넣어줍니다. //ac 컨테이너 안에 들어있는 빈들의 모든 이름을 String에 넣습니다. String[] beanDefinitionNames = ac.getBeanDefinitionNames(); //iter 를 입력 후 tab키를 누르면 자동으로 for문이 만들어집니다. for (String beanDefinitionName : beanDefinitionNames) { //정의된 이름을 하나하나 꺼내면서 bean이라는 Object자료형을 가진 변수에 넣어줍니다. Object bean = ac.getBean(beanDefinitionName); //출력 System.out.println(&quot;name = &quot; + beanDefinitionName + &quot;object = &quot; + bean); } } @Test @DisplayName(&quot;애플리케이션 빈 출력하기&quot;) void findApplicationBean(){ //마찬가지로 정의된 빈의 이름들을 가져옵니다. String[] beanDefinitionNames = ac.getBeanDefinitionNames(); for (String beanDefinitionName : beanDefinitionNames) { //BeanDefinition 자료형을 반환합니다. BeanDefinition beanDefinition = ac.getBeanDefinition(beanDefinitionName); //Role ROLE_APPLICATION: 직접 등록한 애플리케이션 빈 //Role ROLE_INFRASTRUCTURE: 스프링이 내부에서 사용하는 빈 if(beanDefinition.getRole() == BeanDefinition.ROLE_APPLICATION){ Object bean = ac.getBean(beanDefinitionName); System.out.println(&quot;name = &quot; + beanDefinitionName + &quot;object = &quot; + bean); } } }} findApplicationBean()안에 ROLE_APPLICATION을 테스트했을 때입니다. findApplicationBean()안에 ROLE_INFRASTRUCTURE을 테스트했을 때입니다. 3. 스프링 빈 조회 - 기본 스프링 컨테이너에서 스프링 빈을 찾는 가장 기본적인 방법입니다. ac.getBean(빈이름, 타입);ac.getBean(타입); 조회 대상이 없으면 다음과 같은 예외를 발생시킵니다. NoSuchBeanDefinitionException: No bean named ‘xxxxx’ available 예제로 보기위해 Test 폴더 안에 임의의 패키지를 만들고 ‘ApplicationContextBasicFindTest’.java test파일을 만들어줍니다.package hello.core.bean;import hello.core.Appconfig;import hello.core.member.MemberSerivceImpl;import hello.core.member.MemberService;import org.assertj.core.api.Assertions;import org.junit.jupiter.api.DisplayName;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.NoSuchBeanDefinitionException;import org.springframework.context.annotation.AnnotationConfigApplicationContext;class ApplicationContextBasicFindTest { AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(Appconfig.class); @Test @DisplayName(&quot;빈 이름, 타입 조회&quot;) void findBeanByName(){ MemberService memberService = ac.getBean(&quot;memberService&quot;, MemberService.class); Assertions.assertThat(memberService).isInstanceOf(MemberSerivceImpl.class); } @Test @DisplayName(&quot;타입으로 조회&quot;) void findBeanByType(){ MemberSerivceImpl memberService = ac.getBean(MemberSerivceImpl.class); Assertions.assertThat(memberService).isInstanceOf(MemberSerivceImpl.class); } //안좋은 방법이지만 -&amp;gt; 구체에 의존하므로 ,참고용으로 @Test @DisplayName(&quot;구체 타입으로 조회&quot;) void findBeanByName2(){ MemberSerivceImpl memberService = ac.getBean(&quot;memberService&quot;, MemberSerivceImpl.class); Assertions.assertThat(memberService).isInstanceOf(MemberSerivceImpl.class); } //이름이 없을 때 테스트 @Test @DisplayName(&quot;빈 이름으로 조회 x&quot;) void findBeanByNameX(){ //MemberSerivceImpl xxxxx = ac.getBean(&quot;XXXXX&quot;, MemberSerivceImpl.class); //가급적 밑의 Assertions도 Alt + Enter로 생랼하자. org.junit.jupiter.api.Assertions.assertThrows(NoSuchBeanDefinitionException.class, () -&amp;gt;ac.getBean(&quot;XXXXX&quot;, MemberSerivceImpl.class)); }}4. 스프링 빈 조회 - 동일한 타입이 둘 이상 타입으로 조회 시 같은 타입의 스프링 빈이 둘 이상 존재하면 오류를 발생시킬 수 있습니다. 테스트를 위해 Test 폴더 안에 ‘ApplicationContextSameBeanFindTest’.java 테스트 파일을 만듭니다.package hello.core.bean;import hello.core.member.Member;import hello.core.member.MemberRepository;import hello.core.member.MemoryMemberRepository;import org.junit.jupiter.api.Assertions;import org.junit.jupiter.api.DisplayName;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.NoUniqueBeanDefinitionException;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import java.util.Map;class ApplicationContextSameBeanFindTest { //밑의 설정을 컨테이너에 등록해줍니다. AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(SameBeanConfig.class); //테스트 파일 안에서만 사용할 것. @Configuration static class SameBeanConfig{ @Bean public MemberRepository memberRepository1(){ return new MemoryMemberRepository(); } @Bean public MemberRepository memberRepository2(){ return new MemoryMemberRepository(); } } //같은 타입이 둘 이상 있으면 오류를 발생. @Test @DisplayName(&quot;타입으로 조회시 같은 타입이 둘 이상 있으면, 중복 오류가 발생한다&quot;) void findBeanByTypeDuplicate(){ //ac.getBean(MemberRepository.class)를 하면 오류가 발생 //그냥 조회하면 밑과같은 오류(NoUniqueBeanDefinitionException)가 뜨므로 해당 오류를 넣어서 테스트를 완료한다. Assertions.assertThrows(NoUniqueBeanDefinitionException.class, () -&amp;gt; ac.getBean(MemberRepository.class)); } @Test @DisplayName(&quot;특정 타입을 모두 조회하기&quot;) void findBeanByType(){ //Alt + Enter 애용!! Map&amp;lt;String, MemberRepository&amp;gt; beansOfType = ac.getBeansOfType(MemberRepository.class); //iter + tab키 for (String key : beansOfType.keySet()) { System.out.println(&quot;key = &quot; + key + &quot;value = &quot; + beansOfType.get(key)); } System.out.println(&quot;beansOfType = &quot; + beansOfType); org.assertj.core.api.Assertions.assertThat(beansOfType.size()).isEqualTo(2); }}5. 스프링 빈 조회 - 상속 관계 스프링 빈이 상속관계로 이루어져 있을 경우 부모 타입을 조회할 경우 모든 자식들이 조회됩니다. 따라서 모든 객체들의 상위 객체인 ‘Object’ 타입으로 조회 시, 모든 스프링 빈을 조회할 수 있습니다. 출처 : 김영한 선생님의 강의자료 예제코드를 작성하기 위해 새로운 테스트 파일인 ‘ApplicationContextExtendsFindTest’.java 테스트 파일을 만듭니다.package hello.core.bean;import hello.core.discount.DiscountPolicy;import hello.core.discount.FixDiscountPolicy;import hello.core.discount.RateDiscountPolicy;import org.junit.jupiter.api.Assertions;import org.junit.jupiter.api.DisplayName;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.NoUniqueBeanDefinitionException;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import java.util.Map;class ApplicationContextExtendsFindTest { AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(TestConfig.class); @Configuration static class TestConfig{ @Bean public DiscountPolicy rateDiscountPolicy(){ return new RateDiscountPolicy(); } @Bean public DiscountPolicy fixDiscountPolicy(){ return new FixDiscountPolicy(); } } @Test @DisplayName(&quot;부모 타입으로 조회시, 자식이 둘 이상 있으면, 중복 오류가 발생한다&quot;) void findBeanByParentDuplicate(){ //이 코드는 예외를 발생 // Map&amp;lt;String, DiscountPolicy&amp;gt; beansOfType = ac.getBeansOfType(DiscountPolicy.class); Assertions.assertThrows(NoUniqueBeanDefinitionException.class, () -&amp;gt; ac.getBean(DiscountPolicy.class)); }} 위를 해결하기 위해선 두가지 방법이 있습니다. 직접 자식 빈 이름을 명시해주거나, 자식 빈의 타입이 하나일 경우 그 타입으로 조회하는 방법입니다.(안좋음) @Test @DisplayName(&quot;부모 타입으로 조회시, 자식이 둘 이상 있으면, 빈 이름을 지정하면 된다&quot;) void findBeanByChildName(){ DiscountPolicy rateDiscountPolicy = ac.getBean(&quot;rateDiscountPolicy&quot;, DiscountPolicy.class); assertThat(rateDiscountPolicy).isInstanceOf(RateDiscountPolicy.class); }//안좋은 방법@Test@DisplayName(&quot;특정 하위 타입으로 조회&quot;)void findBeanByChildType(){ RateDiscountPolicy bean = ac.getBean(RateDiscountPolicy.class); assertThat(bean).isInstanceOf(RateDiscountPolicy.class);} 부모 타입으로 조회하기, 부모타입으로 조회하기 (object) @Test @DisplayName(&quot;부모 타입으로 조회하기&quot;) void findBeanByParentType(){ Map&amp;lt;String, DiscountPolicy&amp;gt; beansOfType = ac.getBeansOfType(DiscountPolicy.class); assertThat(beansOfType.size()).isEqualTo(2); for (String key : beansOfType.keySet()) { System.out.println(&quot;key = &quot; + key + &quot; value = &quot; + beansOfType.get(key)); } } @Test @DisplayName(&quot;부모 타입으로 조회하기 object&quot;) void findBeanByParentObject(){ Map&amp;lt;String, Object&amp;gt; beansOfType = ac.getBeansOfType(Object.class); for (String key : beansOfType.keySet()) { System.out.println(&quot;key = &quot; + key + &quot; value = &quot; + beansOfType.get(key)); } }**6. Bean Factory 와 ApplicationContextBean Factory Bean Factory는 스프링 컨테이너의 최상위 인터페이스 입니다. 스프링 빈을 관리하고 조회하는 역할을 합니다.(getBean())ApplicationContext Bean Factory 기능을 모두 상속 받아서 사용합니다. 빈을 관리하고 검색하는 Bean Factory 기능 뿐만아니라 수 많은 부가기능을 갖고 있습니다. 메시지 소스, 환경변수, 애플리케이션 이벤트, 편리한 리소스 조회 등 다양한 기능을 포함하고 있습니다. Bean Factory를 직접 조회해서 사용할 일이 거의 없기에 부가 기능이 포함된 ApplicationContext를 사용합니다.따라서 Bean Factory나 ApplicationContext를 스프링 컨테이너라고 불립니다.7. 다양한 설정 형식 지원 - 자바 코드, XML애노테이션 기반 자바 코드 설정지금까지 했던 것들 입니다. 과거에는 XML을 사용했습니다.XML 설정최근에는 잘 사용하지 않지만 레거시 프로젝트에서 많이 사용하고 있기에 알아두어야 합니다.또 XML을 사용하면 컴파일 없이 빈 설정 정보를 변경할 수 있다는 이점이 있습니다.‘GenericXmlApplicationContext’를 사용하면서 ‘xml’설정 파일을 넘기면 됩니다.테스트를 위해 ‘XmlAppContext’ test파일을 만듭니다.package hello.core.bean;import hello.core.member.MemberService;import org.assertj.core.api.Assertions;import org.junit.jupiter.api.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.GenericApplicationContext;public class XmlAppContext { @Test void xmlAppContext(){ ApplicationContext ac = new GenericXmlApplicationContext(&quot;appConfig.xml&quot;); MemberService memberService = ac.getBean(&quot;memberService&quot;,MemberService.class); Assertions.assertThat(memberService).isInstanceOf(MemberService.class); }}설정을 위한 appConfig.xml 파일은 메인에서 resources에 만듭니다. 테스트에서는 테스트 안에 넣어도 상관 없다고 하십니다.appConfig.xml을 작성하다가 저의 memberServiceImpl 클래스가 memberServcieImpl로 오타가 나 있었습니다.. 수정했습니다.&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&amp;gt; &amp;lt;bean id=&quot;memberService&quot; class=&quot;hello.core.member.MemberServiceImpl&quot;&amp;gt; &amp;lt;constructor-arg name=&quot;memberRepository&quot; ref=&quot;memberRepository&quot; /&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;bean id=&quot;memberRepository&quot; class=&quot;hello.core.member.MemoryMemberRepository&quot; /&amp;gt; &amp;lt;bean id=&quot;orderService&quot; class=&quot;hello.core.order.OrderServiceImpl&quot;&amp;gt; &amp;lt;constructor-arg name=&quot;memberRepository&quot; ref=&quot;memberRepository&quot; /&amp;gt; &amp;lt;constructor-arg name=&quot;discountPolicy&quot; ref=&quot;discountPolicy&quot; /&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;bean id=&quot;discountPolicy&quot; class=&quot;hello.core.discount.RateDiscountPolicy&quot; /&amp;gt;&amp;lt;/beans&amp;gt; 자바 설정과 거의 비슷하지만, 하드 코딩해야하는 단점이 있는 것 같습니다. 그래도 해석할 수 있게하자면 constructor-arg -&amp;gt; 생성자 name 이름 ref 레퍼런스 값 id는 찾을 때 사용할 이름, class는 파일경로입니다.8. 스프링 빈 설정 메타 정보 - BeanDefinition 스프링의 중심에는 ‘BeanDefintion’이라는 추상화가 있습니다. XML을 읽어서 BeanDefinition을 만든다. java 코드를 읽어서 BeanDefinition을 만든다. 즉 스프링 컨테이너는 뭐가 되었든 BeanDefintion만 알면 됩니다. 이것도 역할과 구현을 나눈 것입니다. BeanDefintion을 빈 설정 메타정보라고 합니다. ‘AnnotationConfigApplicationContext’ 는 ‘AnnotatedBeanDefinitionReader’ 를 사용해서 AppConfig.class 를 읽고 BeanDefinition 을 생성합니다. ‘GenericXmlApplicationContext’ 는 ‘XmlBeanDefinitionReader’ 를 사용해서 appConfig.xml 설정정보를 읽고 BeanDefinition 을 생성합니다. 새로운 형식의 설정 정보가 추가되면, XxxBeanDefinitionReader를 만들어서 BeanDefinition 을 생성하면 됩니다. 예제 코드를 작성하기 위해 BeanDefinitionTest.java 파일을 만듭니다.먼저 자바설정 파일을 읽었을 때입니다.package hello.core.bean;import hello.core.Appconfig;import org.junit.jupiter.api.DisplayName;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.config.BeanDefinition;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class BeanDefinitionTest { AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(Appconfig.class); @Test @DisplayName(&quot;빈 설정 메타정보 확인&quot;) void findApplicationBean(){ String[] beanDefinitionNames = ac.getBeanDefinitionNames(); for (String beanDefinitionName : beanDefinitionNames) { BeanDefinition beanDefinition = ac.getBeanDefinition(beanDefinitionName); //우리가 설정한 빈들만 if(beanDefinition.getRole() == BeanDefinition.ROLE_APPLICATION){ System.out.println(&quot;beanDefinitionName&quot; + beanDefinitionName + &quot;beanDefinition = &quot; + beanDefinition); } } }} XML파일을 읽었을 때 입니다. //AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(Appconfig.class); GenericXmlApplicationContext ac = new GenericXmlApplicationContext(&quot;appConfig.xml&quot;); //로 수정해줍시다.출력 결과를 보면 둘의 출력결과가 다른 것을 확인할 수 있는데, 자바 설정파일로 할 경우 Bean Factory라는 것을 거쳐 간다고 합니다.참고 BeanDefinition정보 BeanClassName: 생성할 빈의 클래스 명(자바 설정 처럼 팩토리 역할의 빈을 사용하면 없음) factoryBeanName: 팩토리 역할의 빈을 사용할 경우 이름, 예) appConfig factoryMethodName: 빈을 생성할 팩토리 메서드 지정, 예) memberService Scope: 싱글톤(기본값) lazyInit: 스프링 컨테이너를 생성할 때 빈을 생성하는 것이 아니라, 실제 빈을 사용할 때 까지 최대한 생성을 지연처리 하는지 여부 InitMethodName: 빈을 생성하고, 의존관계를 적용한 뒤에 호출되는 초기화 메서드 명 DestroyMethodName: 빈의 생명주기가 끝나서 제거하기 직전에 호출되는 메서드 명 Constructor arguments, Properties: 의존관계 주입에서 사용한다. (자바 설정 처럼 팩토리 역할의 빈을 사용하면 없음)" }, { "title": "Spring - 3 스프링 핵심 원리 - 객체 지향 원리 적용(2)", "url": "/posts/SpringPoint5/", "categories": "Java, 3. Spring_김영한_스프링-핵심-원리-기본편", "tags": "Spring", "date": "2021-01-19 11:00:00 +0900", "snippet": "해당 자료는 인프런 김영한 선생님의 스프링-핵심-원리-기본편 강의노트입니다.6. 정리 SRP 단일 책임 원칙 구현 객체를 생성하고 연결하는 책임은 Appconfing이 담당. 클라이언트 객체는 실행하는 책임만 담당. 따라서 SRP 단일 책임 원칙을 따름. DIP 의존관계 역전 원칙 먼저 클라이언트가 추상화에 의존하도록 수정함. 이것만으로는 실행이 되지 않기에 Appconfig을 통해 의존관계를 주입하였다. DIP 원칙을 따름 OCP 어플리케이션의 사용영역과 구성영역(Appconfig)으로 나눔. Appconfig가 의존관계를 ‘FixDiscountPolicy’에서 ‘RateDiscountPolicy’로 변경해서 클라이언트 코드에 주입하므로 클라이언트 코드는 변경하지 않아도 된다. 소프트웨어 요소를 확장해도 사용영역 변경에는 닫혀있으므로 OCP 원칙을 따름. 7. IOC,DI, 컨테이너 IOC(제어의 역전) 기존 코드는 클라이언트 구현 객체가 서버 구현 객체를 생성하여, 연결하고 실행했다. 한마디로 클라이언트 구현 객체가 프로그램 제어권을 가직 있었다. 반면 Appconfig을 만든 이후로는 제어권을 Appconfig이 가져갔다. 심지어 Impl 클래스들도 Appconfig이 생성한다. 또한 굳이 Impl 클래스들이 아니여도 Appconfig이 다른 클래스들의 객체를 생성하고 실행할 수 있다. Impl 클래스들은 그런 사실도 모른채 수행될 뿐이다. 이렇듯 프로그램의 제어의 흐름을 직접 제어하는게 아니고 외부에서 제어하는 것을 IOC(제어의 역전)이라고 부른다. 프레임 워크 vs 라이브러리 프레임 워크 : 내가 작성한 코드를 제어하고, 대신 실행하면 프레임워크(ex ) junit 테스트 도구들 나는 @Test만 써줬는데 처리는 알아서해줌) 라이브 러리 : 내가 작성한 코드가 직접 제어의 흐름을 담당한다면 라이브러리다. 의존관계 주입 (DI) 의존관계는 정적인 클래스 의존 관계와 동적인 객체(인스턴스) 의존관계로 나누어 생각해야한다. 정적인 클래스 의존관계는 실행을 안해도 자료형으로 판단할 수 있는 의존관계들이다. 동적인 클래스는 예제에서 Discount처럼 FixDiscount가 올 지 RateDiscount가 올 지 실행해봐야 아는 의존관계를 말한다. 의존관계 주입을 하면 동적인 객체 의존관계를 쉽게 바꿀 수 있다는 장점이 있다. IOC 컨테이너, DI 컨테이너 Appconfig처럼 객체를 생성하고 의존관계를 연결해 주는 것을 IOC 컨테이너, DI 컨테이너 라고 부른다. 최근에는 DI 컨테이너라고 많이 한다. 또는 어샘블러, 오브젝트 팩토리로도 부른다. 8. Spring으로 변환Appconfig을 Spring으로 변환하려면 간단하게 할 수 있습니다.@Configurationpublic class Appconfig { //ctrl + alt + m @Bean public MemberService memberService(){ return new MemberSerivceImpl(memberRepository()); } @Bean public OrderServiceImpl orderService(){ return new OrderServiceImpl(memberRepository(), discountPolicy()); }이렇게 @Configuration, @Bean을 모든 메소드에 붙여줍니다. 스프링 컨테이너에 스프링 빈으로 등록한다는 뜻입니다.이러면 메인메소드에서의 호출 방식도 달라지기에 바꿔줍니다.MemberApp.java을 바꿔줍니다.package hello.core;import hello.core.member.Grade;import hello.core.member.Member;import hello.core.member.MemberSerivceImpl;import hello.core.member.MemberService;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class MemberApp { //psvm public static void main(String[] args) { //MemberService memberService = new MemberSerivceImpl(); //Appconfig appconfig = new Appconfig(); //MemberService memberService = appconfig.memberService(); //추가사항 ApplicationContext applicationContext = new AnnotationConfigApplicationContext(Appconfig.class); MemberService memberService = applicationContext.getBean(&quot;memberService&quot;, MemberService.class); // Member member = new Member(1L,&quot;memberA&quot;, Grade.VIP); memberService.join(member); Member findMember = memberService.findMember(1L); //sout System.out.println(&quot;new member = &quot; + member.getName()); System.out.println(&quot;find member = &quot; + findMember.getName()); }}제대로 돌아가는 지 실행해봅니다.로그가 많이찍히지만 잘 돌아가는 것을 볼 수 있습니다.같은 방식으로 orderApp도 수정해 줍니다.package hello.core;import hello.core.member.*;import hello.core.order.Order;import hello.core.order.OrderService;import hello.core.order.OrderServiceImpl;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class orderApp { public static void main(String[] args) { //MemberService memberService = new MemberSerivceImpl(); //OrderService orderService = new OrderServiceImpl(); /* Appconfig appconfig = new Appconfig(); MemberService memberService = appconfig.memberService(); OrderServiceImpl orderService = appconfig.orderService(); */ //추가 부분 ApplicationContext applicationContext = new AnnotationConfigApplicationContext(Appconfig.class); MemberService memberService = applicationContext.getBean(&quot;memberService&quot;, MemberService.class); OrderService orderService = applicationContext.getBean(&quot;orderService&quot;, OrderService.class); // Long memberId = 1L; Member member = new Member(memberId,&quot;memberA&quot;, Grade.VIP); memberService.join(member); Order order = orderService.createOrder(memberId, &quot;itemA&quot;, 20000); System.out.println(&quot;order = &quot;+ order); }}이것또한 잘 실행됩니다.저는 문득 생각했습니다.코드도 더 길고 기존 방식에서 굳이 이름이 같은 메소드를 찾아서 써줘야하는 이 방식이 뭐가 좋은거지..? 무료 버전에서는 메소드이름을 찾아서 써줘야하는 것 같습니다. 유료버전은 컨테이너 빈에 등록된 이름을 자동으로 찾아준다고 합니다.라고 생각했던 것도 잠시.. 김영한 선생님이 이런 생각을 해야 된다고 하시면서 굉장히 많은 장점이 있고 이제 알려준다고 하시니 다음 포스팅에서 배우면서 쓰겠습니다." }, { "title": "Spring - 3 스프링 핵심 원리 - 객체 지향 원리 적용(1)", "url": "/posts/SpringPoint4/", "categories": "Java, 3. Spring_김영한_스프링-핵심-원리-기본편", "tags": "Spring", "date": "2021-01-19 10:00:00 +0900", "snippet": "해당 자료는 인프런 김영한 선생님의 스프링-핵심-원리-기본편 강의노트입니다.1. 새로운 할인 정책 적용저번에 작성한 무조건 1천원 할인을 구매 가격의 10%할인으로 바꾼다고 했을 때 객체 지향으로 코드를 작성하지 않았으면 뜯어 고쳤어야했습니다.interface 파일에 맞게 새로운 클래스만 작성해주면 거기에 끼우면 원하는 할인 정책을 적용할 수 있습니다.discount 패키지 안에 ‘RateDiscountPolicy’ java파일을 만듭니다.package hello.core.discount;import hello.core.member.Grade;import hello.core.member.Member;public class RateDiscountPolicy implements DiscountPolicy{ private int discountpercent = 10; // ctrl + shift + T = test작성 @Override public int discount(Member member, int price) { if(member.getGrade() == Grade.VIP){ return price * discountpercent / 100; } else return 0; }} vip일 때 price는 들어온 값의 할인금액을 리턴하고 있습니다. 테스트를 작성해보겠습니다. 위의 주석처럼 해당 단축키를 눌러 테스트 파일을 만듭니다. package hello.core.discount;import hello.core.member.Grade;import hello.core.member.Member;import org.assertj.core.api.Assertions;import org.junit.jupiter.api.DisplayName;import org.junit.jupiter.api.Test;import static org.assertj.core.api.Assertions.*;import static org.junit.jupiter.api.Assertions.*;class RateDiscountPolicyTest { RateDiscountPolicy rateDiscountPolicy = new RateDiscountPolicy(); @Test @DisplayName(&quot;VIP면 10% 할인되어야 한다.&quot;) void vip_o(){ //given Member member = new Member(1L,&quot;memberVIP&quot;, Grade.VIP); //when int discount = rateDiscountPolicy.discount(member,10000); //then //Assertions에 Alt + Enter로 줄이기 assertThat(discount).isEqualTo(1000); } //VIP가 아닐 때 @Test @DisplayName(&quot;VIP가 아니면 할인되지 않아야한다.&quot;) void vip_x(){ //given Member member = new Member(1L,&quot;memberBASIC&quot;,Grade.BASIC); //when int discount = rateDiscountPolicy.discount(member,10000); //then assertThat(discount).isEqualTo(1000); }}테스트를 돌려보면 밑의 코드에서 0을 기대하고 있지만 1000이라는 값이 들어와 테스트가 돌아가지 않는 것을 볼 수 있습니다.@DisplayName은 테스트 이름이 한글로 보일 수 있게 도와줍니다. 만약 적용이 안되면 setting에서 build를 Grale -&amp;gt; Intellij IDEA로 바꾸셔야합니다.2. 새로운 할인 정책과 문제점 위의 코드를 돌아가게 하려면, ‘OrderSerivceImpl’을 밑처럼 고치면 됩니다.public class OrderServiceImpl implements OrderService{ MemberRepository memberRepository = new MemoryMemberRepository(); DiscountPolicy discountPolicy = new RateDiscountPolicy();여기서 문제가 발생합니다.수정해야할 것이 OrderServiceImpl의 코드이고 그 코드가 구현체를 바꾸는 코드이기 때문입니다.DIP는 추상화에 따라야하는데 구현체에 의존하는 위의 코드는 DIP를 위반하는 행위입니다.DIP를 준수하기 위해 밑의 코드처럼 바꿔줘야합니다.public class OrderServiceImpl implements OrderService{ MemberRepository memberRepository = new MemoryMemberRepository(); //discount만 보세요 위는 무시 DiscountPolicy discountPolicy;하지만 위의 코드는 돌아가지 않습니다. 아무것도 할당되지 않았기 때문입니다.그래서 누군가가 클라이언트인 OrderSeviceImpl에 DiscountPolicy 구현 객체를 대신 생성하고 주입해줘야 합니다.3. 관심사 분리위의 코드의 문제는 OrderServiceImpl 클래스에서 discount 객체와 memberRepository 객체를 정해주는 책임을 갖고 있습니다.OrderService에 대한 서비스만 실행하는 클래스가 다른 객체를 임의로 정해서 실행한다는 것은 다양한 책임을 지니고 있습니다.관심사를 분리하기 위해 구현 객체를 생성하고 연결하는 책임을 가진 별도의 설정 클래스를 만듭니다.Appconfig.java 파일을 만듭니다.package hello.core;import hello.core.discount.FixDiscountPolicy;import hello.core.member.MemberSerivceImpl;import hello.core.member.MemberService;import hello.core.member.MemoryMemberRepository;import hello.core.order.OrderServiceImpl;public class Appconfig { public MemberService memberService(){ return new MemberSerivceImpl(new MemoryMemberRepository()); } public OrderServiceImpl orderService(){ return new OrderServiceImpl(new MemoryMemberRepository(), new FixDiscountPolicy()); }} 위의 코드를 설명하기 전에 먼저 위에서 작성한 MemberServiceImpl class와 OrderServiceImpl을 저 코드에 맞게 수정해줍니다. MemberServiceImpl package hello.core.member;public class MemberSerivceImpl implements MemberService{ private final MemberRepository memberRepository; public MemberSerivceImpl(MemberRepository memberRepository) { this.memberRepository = memberRepository; } @Override public void join(Member member) { memberRepository.save(member); } @Override public Member findMember(Long memberId) { return memberRepository.findById(memberId); }} OrderServiceImplpackage hello.core.order;import hello.core.discount.DiscountPolicy;import hello.core.member.Member;import hello.core.member.MemberRepository;public class OrderServiceImpl implements OrderService{ private final MemberRepository memberRepository; private final DiscountPolicy discountPolicy; public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) { this.memberRepository = memberRepository; this.discountPolicy = discountPolicy; } @Override public Order createOrder(Long memberId, String itemName, int itemPrice) { Member member = memberRepository.findById(memberId); int discountPrice= discountPolicy.discount(member,itemPrice); return new Order(memberId,itemName,itemPrice,discountPrice); }} OrderServiceImpl 코드를 보면 Order클래스는 discountPolicy에 어떤 구현체가 오던지 신경을 안쓰고 있습니다. 생성자를 통해 어떤 객체를 주입받는 지는 Appconfig 클래스에서 결정됩니다. 위의 클래스들은 이제 실행에만 집중하면 되고 의존관계에 대한 고민은 외부에 맡기면 됩니다. 객체의 생성과 연결은 Appconfig이 담당하고 위의 클래스들은 이제 추상화에만 의존하므로 DIP를 위배하지 않습니다. Appconfig은 MemoryMemberRepository 객체를 생성하고 그 참조값을 MemberServiceImpl을 생성하면서 생성자로 전달합니다. MemberServiceImpl 입장에서 의존관계를 마치 외부에서 주입하는 것과 같아서 DI(Dependency Injection), 의존관계 주입, 의존성 주입이라고 부릅니다. 위의 코드를 테스트 하기위해 작성했던 MemberApp코드를 바꿔줍니다.package hello.core;import hello.core.member.Grade;import hello.core.member.Member;import hello.core.member.MemberService;public class MemberApp { //psvm public static void main(String[] args) { //MemberService memberService = new MemberSerivceImpl(); //추가된 사항 이제 매번 Appconfig 객체를 생성해서 필요한것만 찾아 가져오면 됩니다. Appconfig appconfig = new Appconfig(); MemberService memberService = appconfig.memberService(); // Member member = new Member(1L,&quot;memberA&quot;, Grade.VIP); memberService.join(member); Member findMember = memberService.findMember(1L); //sout System.out.println(&quot;new member = &quot; + member.getName()); System.out.println(&quot;find member = &quot; + findMember.getName()); }}마찬가지로 OrderApp도 수정해줍니다.package hello.core;import hello.core.member.*;import hello.core.order.Order;import hello.core.order.OrderServiceImpl;public class orderApp { public static void main(String[] args) { //MemberService memberService = new MemberSerivceImpl(); //OrderService orderService = new OrderServiceImpl(); //추가된 코드 Appconfig appconfig = new Appconfig(); MemberService memberService = appconfig.memberService(); OrderServiceImpl orderService = appconfig.orderService(); // Long memberId = 1L; Member member = new Member(memberId,&quot;memberA&quot;, Grade.VIP); memberService.join(member); Order order = orderService.createOrder(memberId, &quot;itemA&quot;, 10000); System.out.println(&quot;order = &quot;+ order); }}테스트 코드들도 수정해줍니다. MemberServiceTest를 수정해줍니다.package hello.core.member;import hello.core.Appconfig;import org.assertj.core.api.Assertions;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;public class MemberServiceTest { //추가 코드 MemberService memberService; //테스트 수행전에 실행됩니다. @BeforeEach public void beforeEach(){ Appconfig appconfig = new Appconfig(); memberService = appconfig.memberService(); //선언과 대입을 따로하는 이유는 좀 더 직관적으로 무엇을 테스트하는 지 보기 위함입니다. } // @Test void join(){ //given Member member = new Member(1L,&quot;memberA&quot;,Grade.VIP); //when memberService.join(member); Member findmember = memberService.findMember(1L); //then Assertions.assertThat(findmember).isEqualTo(member); }}마찬가지로 orderTest도 수정해줍니다.package hello.core.order;import hello.core.Appconfig;import hello.core.member.Grade;import hello.core.member.Member;import hello.core.member.MemberSerivceImpl;import hello.core.member.MemberService;import org.assertj.core.api.Assertions;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;public class OrderServiceTest {// MemberService memberService = new MemberSerivceImpl(); // OrderService orderService = new OrderServiceImpl(); MemberService memberService; OrderService orderService; @BeforeEach public void beforeEach(){ Appconfig appconfig = new Appconfig(); memberService = appconfig.memberService(); orderService = appconfig.orderService(); } @Test void CreateOrder(){ Long memberId=1L; Member member = new Member(memberId,&quot;memberA&quot;, Grade.VIP); memberService.join(member); Order order = orderService.createOrder(memberId,&quot;itemA&quot;,10000); Assertions.assertThat(order.getDiscountPrice()).isEqualTo(1000); }} APPconfig을 통해 관심사를 확실하게 분리하였습니다. 각각의 서비스는 이제 실행에만 집중하면 됩니다.4. Appconfig 리팩터링기존 Appconfig을 리팩터링 해야합니다. new MemoryMemberRespoitory라는 중복이 있고, 한 눈에 들어오지 않습니다.package hello.core;import hello.core.discount.DiscountPolicy;import hello.core.discount.FixDiscountPolicy;import hello.core.member.MemberRepository;import hello.core.member.MemberSerivceImpl;import hello.core.member.MemberService;import hello.core.member.MemoryMemberRepository;import hello.core.order.OrderServiceImpl;public class Appconfig { //ctrl + alt + m public MemberService memberService(){ return new MemberSerivceImpl(memberRepository()); } public OrderServiceImpl orderService(){ return new OrderServiceImpl(memberRepository(), discountPolicy()); } public MemberRepository memberRepository() { return new MemoryMemberRepository(); } public DiscountPolicy discountPolicy(){ return new FixDiscountPolicy(); }} 이제 한 눈에 각 함수들이 무슨 역할을 하는지 알 수 있고, 중복도 제거된 Appconfig을 만들었습니다.5. 새로운 구조와 할인 정책 적용 Test를 돌려보기위해서는 한개의 코드만 수정하면 됩니다. Appconfig에서 다음 코드만 바꿔주면 원하는 할인정책으로 적용되는 것을 볼 수 있습니다. public DiscountPolicy discountPolicy(){ //return new FixDiscountPolicy(); return new RateDiscountPolicy(); }" }, { "title": "Baekjoon1068-트리", "url": "/posts/baekjoon1068/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, DFS", "date": "2021-01-18 19:02:00 +0900", "snippet": "백준 사이트 1068 - 트리 문제입니다.1. 문제https://www.acmicpc.net/problem/10682. Input , Output3. 분류 및 난이도DFS 문제입니다.백준에서는 Slive1 난이도를 책정하고 있습니다.4. 생각한 것들 트리 구현을 어떻게 할까..? 배열을 사용하면 일자로 트리가 진행될 경우 2^50의 배열의 크기가 필요하므로 배열로 만들 수 없습니다. 그리고 이진트리라는 말이 없으므로 자식이 여러개일 수 있습니다. 벡터를 통해 만들어줍니다. DFS 조건문? 트리 자식을 돌아다니다가 remove 값으로 들어온 트리자식을 만나면 return을 해버려 방문을 중단합니다. 만약 자식이 1명이고 마침 그 자식이 제거해야하는 것이면 부모 노드는 리프노드가 되므로 갯수를 세주고 방문을 돌아갑니다. 예외가 좀 많아서 정답률이 낮은 것 같습니다.5. code#include&amp;lt;iostream&amp;gt;#include&amp;lt;vector&amp;gt;using namespace std;vector&amp;lt;int&amp;gt; v[51];int removenode = 0;int result = 0;void DFS(int now){ if (removenode == now) return; if (v[now].size() == 0) { ++result; return; } else if (v[now].size() == 1) { if (v[now][0] == removenode) { ++result; } } for (int i = 0; i &amp;lt; v[now].size(); ++i) DFS(v[now][i]); }int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); int n; int node = 0; int temp = 0; int remove = 0; cin &amp;gt;&amp;gt; n; for (int i = 0; i &amp;lt; n; ++i) { cin &amp;gt;&amp;gt; temp; if (temp != -1) { v[temp].push_back(i); } else node = i; } cin &amp;gt;&amp;gt; removenode; DFS(node); cout &amp;lt;&amp;lt; result; }6. 후기DFS같은 재귀는 언제나 어려운것 같습니다.BFS만세" }, { "title": "Baekjoon1520-내리막 길", "url": "/posts/baekjoon1520/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, DP, DFS", "date": "2021-01-18 17:02:00 +0900", "snippet": "백준 사이트 1520 - 내리막 길 문제입니다.1. 문제https://www.acmicpc.net/problem/15202. Input , Output3. 분류 및 난이도DP와 DFS의 혼합 문제입니다.꽤나 어려웠습니다.백준에서는 Gold4의 난이도를 책정하고 있습니다.4. 생각한 것들 BFS로 풀 수 있는가? 시도한 사람들은 있습니다. 저는 시도하다가 메모제이션과 연결하기 어려워서 포기했습니다. 메모제이션과 DFS의 연결 이것이 핵심입니다. DFS 동작방식을 잘 알고 있어야 풀 수 있는 것 같습니다. 5. code#include&amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;#include&amp;lt;cstring&amp;gt;using namespace std;const int MAX = 501;int N, M;int MAP[MAX][MAX] = { 0, };int dp[MAX][MAX];int dx[4] = { -1, 0,1,0 };int dy[4] = { 0,1,0,-1 };void Input(){ cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; M; for (int i = 0; i &amp;lt; N; ++i) { for (int j = 0; j &amp;lt; M; ++j) { cin &amp;gt;&amp;gt; MAP[i][j]; dp[i][j] = 0; } }}int DFS(int i, int j){ if (i == N - 1 &amp;amp;&amp;amp; j == M - 1) return 1; if (dp[i][j] != -1) return dp[i][j]; dp[i][j] = 0; for (int k = 0; k &amp;lt; 4; ++k) { int newx = i + dx[k]; int newy = j + dy[k]; if (0 &amp;lt;= newx &amp;amp;&amp;amp; newx &amp;lt; N &amp;amp;&amp;amp; 0 &amp;lt;= newy &amp;amp;&amp;amp; newy &amp;lt; M &amp;amp;&amp;amp; MAP[newx][newy] &amp;lt; MAP[i][j]) { dp[i][j] += DFS(newx, newy); } } return dp[i][j];}void Solve(){ //DFS memset(dp, -1, sizeof(dp)); cout &amp;lt;&amp;lt; DFS(0, 0);}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); Input(); Solve();}6. 후기코드는 짧지만 어려웠습니다." }, { "title": "Spring - 2 스프링 핵심 원리 1(2)", "url": "/posts/SpringPoint3/", "categories": "Java, 3. Spring_김영한_스프링-핵심-원리-기본편", "tags": "Spring", "date": "2021-01-18 16:00:00 +0900", "snippet": "해당 자료는 인프런 김영한 선생님의 스프링-핵심-원리-기본편 강의노트입니다.5. 회원 도메인 실행과 테스트 먼저 눈으로 확인해보기 위해 일반적으로 안좋은 테스트하는 방법을 소개하겠습니다.이렇게 java파일을 만들어주고package hello.core;import hello.core.member.Grade;import hello.core.member.Member;import hello.core.member.MemberSerivceImpl;import hello.core.member.MemberService;public class MemberApp { //psvm public static void main(String[] args) { MemberService memberService = new MemberSerivceImpl(); Member member = new Member(1L,&quot;memberA&quot;, Grade.VIP); memberService.join(member); Member findMember = memberService.findMember(1L); //sout System.out.println(&quot;new member = &quot; + member.getName()); System.out.println(&quot;find member = &quot; + findMember.getName()); }}임의로 멤버 객체를 넣어주고 find()함수를 통해 같은지 확인합니다.별로 좋은 테스트가 아닙니다. 이번엔 Junit을 이용한 테스트 방법입니다.해당 위치에 패키지와 test.java파일을 만들어줍니다.package hello.core.member;import org.assertj.core.api.Assertions;import org.junit.jupiter.api.Test;public class MemberServiceTest { MemberService memberService = new MemberSerivceImpl(); @Test void join(){ //given Member member = new Member(1L,&quot;memberA&quot;,Grade.VIP); //when memberService.join(member); Member findmember = memberService.findMember(1L); //then Assertions.assertThat(findmember).isEqualTo(member); }}이렇게 작성하고 테스트를 돌리면 초록불이 뜨면서 테스트가 완료됩니다.이렇게 작성한 자바코드들은 문제를 띄고있습니다.저번 포스트에 작성한 자바 코드를 보면public class MemberSerivceImpl implements MemberService{ private final MemberRepository memberRepository = new MemoryMemberRepository(); ~~}이런 코드가 있는데 MemberServiceImpl은 MemberRepository 추상화에 의존하고 있지만 MemberRepository는 new로 생성한 MemoryMemberRepository() 객체에 의존하는 문제점이 있습니다.이러한 문제점은 ‘주문’까지 만들고 고친다고 합니다.6. 주문과 할인 도메인 설계회원 도메인 설계와 마찬가지로 주문과 할인에 대한 클래스 다이어그램 등 강의자료를 그대로 쓸 순 없으니 넘어가겠습니다.추후 제가 따로 작성해서 올리겠습니다.7. 주문과 할인 도메인 개발먼저 할인 정책에 대한 인터페이스를 작성하겠습니다.위의 경로에 인터페이스 파일을 만들어줍니다.package hello.core.discount;import hello.core.member.Member;public interface DiscountPolicy { /* return : 할인 금액 */ int discount(Member member, int price);}똑같은 경로에 FixDiscountPolicy.java 파일을 만들어주고 구현합니다.package hello.core.discount;import hello.core.member.Grade;import hello.core.member.Member;public class FixDiscountPolicy implements DiscountPolicy{ private int discountFixAmount = 1000; @Override public int discount(Member member, int price) { if(member.getGrade() == Grade.VIP) return discountFixAmount; else return 0; }}회원등급이 VIP인 경우에 고정된 할인금액을 리턴하는 함수입니다.그 다음 회원이 주문을 하므로 주문 서비스를 만들어야합니다.order 패키지를 만들어주고 도메인을 담기위한 Order.java 파일을 만들어줍니다. 밑의 코드는 memberId, itemName, itemPrice, discountPrice의 get(), set(), 생성자, toString()-&amp;gt; 출력용 함수를 만들어준 것 입니다. Alt + Insert 애용합시다.package hello.core.order;public class Order { private Long memberId; private String itemName; private int itemPrice; private int discountPrice; public int calculatePrice(){ return itemPrice-discountPrice; } @Override public String toString() { return &quot;Order{&quot; + &quot;memberId=&quot; + memberId + &quot;, itemName=&#39;&quot; + itemName + &#39;\\&#39;&#39; + &quot;, itemPrice=&quot; + itemPrice + &quot;, discountPrice=&quot; + discountPrice + &#39;}&#39;; } public Long getMemberId() { return memberId; } public void setMemberId(Long memberId) { this.memberId = memberId; } public String getItemName() { return itemName; } public void setItemName(String itemName) { this.itemName = itemName; } public int getItemPrice() { return itemPrice; } public void setItemPrice(int itemPrice) { this.itemPrice = itemPrice; } public int getDiscountPrice() { return discountPrice; } public void setDiscountPrice(int discountPrice) { this.discountPrice = discountPrice; } public Order(Long memberId, String itemName, int itemPrice, int discountPrice) { this.memberId = memberId; this.itemName = itemName; this.itemPrice = itemPrice; this.discountPrice = discountPrice; }}그리고 서비스를 위한 OrderService 인터페이스 파일을 만들어줍니다.package hello.core.order;public interface OrderService { Order createOrder(Long memberId,String itemName, int itemPrice);}OrderServiceImpl.java 파일을 만들어줍니다.package hello.core.order;import hello.core.discount.DiscountPolicy;import hello.core.discount.FixDiscountPolicy;import hello.core.member.Member;import hello.core.member.MemberRepository;import hello.core.member.MemoryMemberRepository;public class OrderServiceImpl implements OrderService{ MemberRepository memberRepository = new MemoryMemberRepository(); DiscountPolicy discountPolicy = new FixDiscountPolicy(); @Override public Order createOrder(Long memberId, String itemName, int itemPrice) { Member member = memberRepository.findById(memberId); int discountPrice= discountPolicy.discount(member,itemPrice); return new Order(memberId,itemName,itemPrice,discountPrice); }}위의 코드는 설계가 잘 된 코드라고 합니다. 어떤 한개를 고친다할 때 그 객체 외 다른 객체는 건들지 않기 때문이라고 합니다.최종 폴더 상황8. 주문과 할인 도메인 테스트 저번에 작성했던 메인메소드로 테스트하는 코드입니다.orderApp.java 파일을 만들어줍니다.package hello.core;import hello.core.member.*;import hello.core.order.Order;import hello.core.order.OrderService;import hello.core.order.OrderServiceImpl;public class orderApp { public static void main(String[] args) { MemberService memberService = new MemberSerivceImpl(); OrderService orderService = new OrderServiceImpl(); Long memberId = 1L; Member member = new Member(memberId,&quot;memberA&quot;, Grade.VIP); memberService.join(member); Order order = orderService.createOrder(memberId, &quot;itemA&quot;, 10000); System.out.println(&quot;order = &quot;+ order); }} 새로운 멤버를 만들어서 아이템 주문을 한다음 해당 객체에 들어있는 값들을 출력합니다.위의 사진처럼 discountPrice 변수에 1000이 들어있으면 됩니다.다음은 Junit을 사용한 테스트 입니다.해당 경로에 package와 test파일을 만들어주고package hello.core.order;import hello.core.member.Grade;import hello.core.member.Member;import hello.core.member.MemberSerivceImpl;import hello.core.member.MemberService;import org.assertj.core.api.Assertions;import org.junit.jupiter.api.Test;public class OrderServiceTest { MemberService memberService = new MemberSerivceImpl(); OrderService orderService = new OrderServiceImpl(); @Test void CreateOrder(){ Long memberId=1L; Member member = new Member(memberId,&quot;memberA&quot;, Grade.VIP); memberService.join(member); Order order = orderService.createOrder(memberId,&quot;itemA&quot;,10000); Assertions.assertThat(order.getDiscountPrice()).isEqualTo(1000); }}새로운 멤버를 넣고 Assetions을 이용하여 테스트를 진행하면 녹색불이 뜹니다.다음 강의에서는 만약 할인정책이 다른 객체를 넣으면 문제가 발생하는 지 발생하면 어떤 문제가 발생하는 지 보겠습니다." }, { "title": "Spring - 2 스프링 핵심 원리 1(1)", "url": "/posts/SpringPoint2/", "categories": "Java, 3. Spring_김영한_스프링-핵심-원리-기본편", "tags": "Spring", "date": "2021-01-18 11:00:00 +0900", "snippet": "해당 자료는 인프런 김영한 선생님의 스프링-핵심-원리-기본편 강의노트입니다.1. 프로젝트 생성 인터페이스와 객체를 나누어서 예제를 만듭니다. java로 먼저 만들고 유연하게 작동하는지 먼저 확인합니다. https://start.spring.io/ 이 링크에서 다음과 같이 설정해 준 뒤, Generate를 눌러줍니다. 적당한 폴더에 압축을 풀어준 뒤, Intellij에서 해당 프로젝트의 build.gradle 파일을 불러옵니다. 라이브러리의 설치가 끝난 뒤 실행을 해보아서 잘 작동되는 지 확인합니다. 실행시간을 빨리하기 위해 File -&amp;gt; setting에 들어가 ‘gradle’을 검색한 뒤 ‘Build and run using’, ‘Run tests using’을 Intellij IDEA로바꿔줍니다.2. 요구사항 설계 회원 회원을 가입하고 조회할 수 있다. 회원은 일반과 VIP 두 가지 등급이 있다. 회원 데이터는 자체 DB를 구축할 수 있고, 외부 시스템과 연동할 수 있다. (미확정) 주문과 할인 정책 회원은 상품을 주문할 수 있다. 회원 등급에 따라 할인 정책을 적용할 수 있다. 할인 정책은 모든 VIP는 1000원을 할인해주는 고정 금액 할인을 적용해달라. (나중에 변경 될 수 있다.) 할인 정책은 변경 가능성이 높다. 회사의 기본 할인 정책을 아직 정하지 못했고, 오픈 직전까지 고민을 미루고 싶다. 최악의 경우 할인을 적용하지 않을 수 도 있다. (미확정) 위의 예제는 김영한 선생님의 스프링-핵심-원리 강의 예제입니다. 출처!! 순수 java로만 작성할 것이며 스프링 부트를 사용한 것은 프로젝트 환경설정을 편히 하기 위함이라고 합니다.!!3. 회원 도메인 설계 강의에서 위의 요구사항을 토대로 회원에 대한 객체 다이어그램, 클래스 다이어그램, 설계에 대한 설명을 해주셨습니다.그대로 블로그에 옮기는 것은 아닌 것 같아서 옮기지 않겠습니다.4. 회원 도메인 개발 ‘member’라는 package를 만들고 일반 회원과 VIP 등급을 넣기 위한 ‘Grade’ enum을 만듭니다.package hello.core.member;public enum Grade { BASIC, //일반 회원 VIP //VIP} ‘회원’ 객체를 만들기 위한 ‘Member’ 클래스를 만듭니다. Member 클래스는 id(인덱스), name(이름), grade(회원등급)을 멤버로 갖습니다. 윈도우에서는 Alt + Insert 키로 생성자와 get(),set() 함수를 만들어 줍니다.package hello.core.member;public class Member { private Long id; private String name; private Grade grade; public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Grade getGrade() { return grade; } public void setGrade(Grade grade) { this.grade = grade; } public Member(Long id, String name, Grade grade) { this.id = id; this.name = name; this.grade = grade; }} 멤버 서비스 객체는 저장소에 의존하므로 저장소를 먼저 만들어줍니다. ‘MemberRepository’ 인터페이스를 만들어줍니다. 인터페이스 구현체 중 하나인 ‘MemoryMemberRepository’ 클래스를 위와같은 방식으로 만들어 줍니다.package hello.core.member;import java.util.HashMap;import java.util.Map;public class MemoryMemberRepository implements MemberRepository { private static Map&amp;lt;Long,Member&amp;gt; store = new HashMap&amp;lt;&amp;gt;(); @Override public void save(Member member) { //hash MAP에 넣습니다. store.put(member.getId(),member); } @Override public Member findById(Long memberId) { //hash MAP에서 꺼냅니다. return store.get(memberId); }} 마지막으로 ‘MemberService’ 인터페이스를 만들어 줍니다. 위의 저장소들은 DB가 정해지지 않아 인터페이스를 따로 구축한 것인데 service는 변동사항이 없어 인터페이스를 안만들어줘도 됩니다. 하지만 이상적으로는 모든 구체에 인터페이스를 작성하는 것이 좋다고 합니다.package hello.core.member;public interface MemberService { void join(Member member); Member findMember(Long memberId);} ‘MemeberServiceImpl’ 클래스를 만들어줍니다. 서비스와 같이 구체가 1개인 경우 뒤에 Impl을 적어주는 것이 관례라고 합니다.package hello.core.member;public class MemberSerivceImpl implements MemberService{ //저장소를 가져다 쓸 것이므로 private final MemberRepository memberRepository = new MemoryMemberRepository(); @Override public void join(Member member) { //받아온 member를 save()을 통해 저장합니다. memberRepository.save(member); } @Override public Member findMember(Long memberId) { // 받은 ID를 토대로 리턴합니다. return memberRepository.findById(memberId); }}" }, { "title": "Spring - 1 객체 지향 설계와 스프링", "url": "/posts/SpringPoint/", "categories": "Java, 3. Spring_김영한_스프링-핵심-원리-기본편", "tags": "Spring", "date": "2021-01-18 10:00:00 +0900", "snippet": "해당 자료는 인프런 김영한 선생님의 스프링-핵심-원리-기본편 강의노트입니다.1. 스프링 역사 EJB라는 것을 초창기에 썼었는데, 그 당시 이론 자체는 좋았으나 비쌌고, 가장 큰 문제는 어렵고 복잡했다고 합니다. 두 명의 개발자(Gavin King, Road Johnson)가 EJB를 비판하면서 만든 것이 각각 하이버네이트와 스프링을 만들었습니다. 로드 존슨이 책을 집필하면서 3만줄의 스프링 기반코드를 뿌려 개발자들이 그 코드들을 가져다 쓰기 시작했습니다. 유겐 휠러라는 개발자와 얀 카로프는 책으로 냅두기 아까워서 로드 존슨에게 오픈소스 프로젝트를 제안하였고, 유겐 휠러가 스프링의 핵심 코드를 지금도 개발하고 있습니다. 스프링의 이름은 J2EE(EJB)라는 겨울을 넘어 새로운 시작이라는 뜻으로 지었다고 합니다. 스프링은 처음 XML을 지원하여 XML 편의 기능을 지원했는데, 2009년 스프링 프레임워크 3.0 에서 자바를 사용할 수 있게 만들었습니다. 그리고 2014년 스프링을 편하게 쓸 수 있는 스프링부트가 출시되었습니다.2. 스프링이란? 스프링은 여러가지의 기술이 있습니다. 필수적으로는 프레임워크, 부트가 있고 선택적으로 밑과 같은 기술들이 있습니다. 스프링 데이터, 세션, 시큐리티, Rest Docs, 스프링 배치, 클라우드 등 이 있습니다. 스프링 프레임 워크는 다양한 기술이 있습니다. 스프링 DI 컨테이너, MVC, 트랜잭션, 캐시, 테스트 지원, 코틀린 또는 그루비 언어 등이 있습니다. 스프링 부트의 특징은 다음과 같습니다. 스프링을 편리하게 사용할 수 있도록 지원합니다. Tomcat 같은 웹 서버를 내장해서 별도의 웹 서버를 설치하지 않아도 됩니다. starter를 통한 손쉬운 빌드가 가능해집니다. 버전에 맞는 외부 라이브러리를 알아서 가져옵니다. 스프링 부트는 스프링 프레임워크를 사용해서 도와주는 기술이고 단독적으로 쓰기에는 어렵다고 합니다. 스프링은 스프링 DI 컨테이너 기술, 프레임웤, 그 모두를 포함한 의미를 스프링이라고 이야기할 수 있습니다.스프링은 객체 지향 언어인 자바 언어 기반의 프레임워크 입니다. 객체 지향이 가진 특징을 가장 크게 살릴 수 있는 것이 스프링입니다. 이를 토대로 좋은 객체 지향 애플리케이션을 만들 수 있게 됩니다. 이것이 스프링의 핵심입니다.3. 좋은 객체 지향 프로그래밍이란? 객체는 메시지를 주고 받고 데이터를 처리합니다. 또한 객체 지향 프로그래밍은 프로그램을 유연하고 변경이 용이하게 만들기가 가능해서 개발에 많이 사용합니다. 클라이언트는 대상의 역할(인터페이스)만 알면됩니다. 클라이언트는 구현 대상의 내부 구조를 몰라도 됩니다. 클라이언트는 구현 대상의 내부 구조가 변경되어도 영향을 받지 않습니다. 클라이언트는 구현 대상 자체를 변경해도 영향을 받지 않습니다. 객체를 설계할 때 역할과 구현을 명확히 분리해야합니다. 클라이언트(요청)가 중요합니다. 자바 언어의 다형성은 대표적으로 오버라이딩이 있습니다. 스프링은 다형성을 편리하게 사용할 수 있도록 도와주는 것입니다.4. SOLID이란? SRP 단일 책임 원칙 Single responsibility principle 계층으로 나누어서 코딩 합니다. 하나의 범위 안에 DB접근 기술, 뷰 설계 등 다 들어가 있는건 안좋은 설계입니다. 변경이 있을 때 하나의 클래스만 고치면 단일 책임 원칙을 잘 따르는 것 OCP 개방 폐쇄 원칙 Open/close principle 확장에는 열려 있으나 변경에는 닫혀있어야 합니다. 다형성을 생각해보면 그렇습니다. 제 생각에는 확장을 할 때 다른 객체까지 건들지 않고 하는 것이고 변경에는 변경 코드가 다른 객체에 영향을 안주는게 좋은 코드라고 말하는 것 같습니다. LSP 리스코프 치환원치 Liskov substitution principle 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 합니다. 예시로 자동차 엑셀을 밟으면 속도가 증가해야하는데 뒤로가게 구현하면 위의 원칙을 위반하는 행위입니다. ISP 인터페이스 분리 원칙 Interface segregation principle 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫습니다. 사용자 클라이언트 -&amp;gt; 운전자 클라이언트, 정비사 클라이언트로 분리 인터페이스가 명확해지고, 대체 가능성이 높아집니다. DIP 의존관계 역전 원칙 Dependency inversion principle 프로그래머는 “추상화에 의존해야지, 구체화에 의존하면 안된다.” 라는 원칙을 따라는 방법 중 하나입니다. 역할에 의존한다는 말과 같은 말입니다. 예를 들어서 로미오역할이 어떤 배우여야 된다는 것은 안된다는 것입니다. 즉 대체가 안되면 안된다는 말입니다. 정리 객체 지향의 핵심은 다형성입니다. 다형성 만으로는 OCP,DIP를 지킬 수 없습니다. 따라서 무언가 더 필요한데, 스프링에서 지원합니다. 5. 객체지향 설계와 스프링 스프링은 다음 기술로 OCP와 DIP를 가능하게 지원합니다. DI : 의존 관계, 의존성 주입 DI 컨테이너 제공 모든 설계에 역할과 구현을 분리해야합니다." }, { "title": "Baekjoon1753-최단경로", "url": "/posts/baekjoon1753/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, Graph", "date": "2021-01-16 16:02:00 +0900", "snippet": "백준 사이트 1753 - 최단경로 문제입니다.1. 문제https://www.acmicpc.net/problem/17532. Input , Output3. 분류 및 난이도그래프 다익스트라 문제입니다.백준에서는 Gold5난이도를 책정하고 있습니다.4. 생각한 것들 다익스트라에 익숙하지 않아 겁내했던 문제입니다. 그 덕에 멘탈이 박살났습니다. 많이 틀렸고 많이 고쳤습니다. 가중치를 먼저 꺼내야한다는 것이 포인트입니다. 가중치를 기준으로 꺼내는게 맞으니까요.5. code#include&amp;lt;iostream&amp;gt;#include&amp;lt;vector&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;const int INF = 987654321;const int MAX = 20010;int V,E;int current;vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; v[MAX];int di[MAX];void Input(){ int start, end, weight; cin &amp;gt;&amp;gt; V &amp;gt;&amp;gt; E; cin &amp;gt;&amp;gt; current; for (int i = 0; i &amp;lt; E; ++i) { cin &amp;gt;&amp;gt; start &amp;gt;&amp;gt; end &amp;gt;&amp;gt; weight; v[start].push_back(make_pair(end, weight)); } for (int i = 1; i &amp;lt;= V; ++i) di[i] = INF;}void dijkstra(int start){ di[start] = 0; priority_queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; pq; pq.push(make_pair(0,start)); while (!pq.empty()) { int distance = -pq.top().first; int curr = pq.top().second; pq.pop(); for (int i = 0; i &amp;lt; v[curr].size(); ++i) { int next = v[curr][i].first; int nextDistance = v[curr][i].second+distance; if (nextDistance &amp;lt; di[next]) { di[next] = nextDistance; pq.push(make_pair(-nextDistance,next)); } } }}void Solve(){ //다익스트라 dijkstra(current);}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); Input(); Solve(); for (int i = 1; i &amp;lt;= V; ++i) { if (di[i] != INF) cout &amp;lt;&amp;lt; di[i] &amp;lt;&amp;lt; &#39;\\n&#39;; else cout &amp;lt;&amp;lt; &quot;INF\\n&quot;; } return 0;}6. 후기이거풀고 너무 힘들어서 집감…" }, { "title": "Baekjoon1987-알파벳", "url": "/posts/baekjoon1987/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, DFS", "date": "2021-01-16 14:02:00 +0900", "snippet": "백준 사이트 1987 - 알파벳 문제입니다.1. 문제https://www.acmicpc.net/problem/19872. Input , Output3. 분류 및 난이도DFS문제입니다.BFS로는 풀기 어렵다고 생각합니다. 이유는 밑에 쓰겠습니다.백준에서는 Gold4 난이도를 책정하고 있습니다.4. 생각한 것들 삽질을 엄청 많이한 문제입니다. BFS로 풀어볼까? BFS는 자신이 있으니까 BFS로 구현해볼까 했습니다. 실제로 ‘치즈’ 문제도 DFS로 분류되어 있지만 BFS 풀었기 때문입니다.BFS로 풀기 힘든 이유는 너비 탐색 조건을 까다롭게 하기 때문입니다. 당장 첫 예제만 봐도 0,1과 1,0이 ‘A’라서 방문처리를 풀어줘야하는데 그 부분에서 어려움이 있습니다. DFS로 풀어야하는 것은 맞는데, 인자로 count를 넘길까? 저는 인자를 많이 쓰는 것을 싫어해서.. 왜그런지 모르겠지만 2차원 DP를 만들어서 결과값들을 저장했습니다.이 부분에서 엄청 애 썼는데 왠지 몰라도 오류가 많이 발생했습니다. 똥고집으로 해결하고 싶어서 30분 이상 썼습니다. 포기하고 인자로 count값을 넘기자. -&amp;gt; 해결5. code#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstring&amp;gt;using namespace std;const int MAX = 22;int r, c;int result = 1;char MAP[MAX][MAX] = { &#39;0&#39;, };bool check[30] = { false, };int dx[4] = { -1,0,1,0 };int dy[4] = { 0,1,0,-1};void DFS(int i, int j,int count){ result = max(result, count); check[MAP[i][j] - 65] = true; for (int k = 0; k &amp;lt; 4; ++k) { int newX = i + dx[k]; int newY = j + dy[k]; if (0 &amp;lt;= newX &amp;amp;&amp;amp; newX &amp;lt; r &amp;amp;&amp;amp; 0 &amp;lt;= newY &amp;amp;&amp;amp; newY &amp;lt; c &amp;amp;&amp;amp; !check[MAP[newX][newY]-65]) { DFS(newX, newY,count+1); check[MAP[newX][newY] - 65] = false; } }}void Input(){ cin &amp;gt;&amp;gt; r &amp;gt;&amp;gt; c; for (int i = 0; i &amp;lt; r; ++i) { cin&amp;gt;&amp;gt;MAP[i]; }}void Solve(){ memset(check, false, sizeof(check)); DFS(0, 0,1); cout &amp;lt;&amp;lt; result;}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); Input(); Solve();}6. 후기풀고 나니 어렵진 않은데 시간을 너무 써서 찝찝한 문제.." }, { "title": "Baekjoon11054-가장 긴 바이토닉 부분 수열", "url": "/posts/baekjoon11054/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, DP", "date": "2021-01-16 13:02:00 +0900", "snippet": "백준 사이트 2638 - 치즈 문제입니다.1. 문제https://www.acmicpc.net/problem/110542. Input , Output3. 분류 및 난이도DP문제입니다.어려웠습니다.백준에서는 Gold3의 난이도를 책정하고 있습니다.4. 생각한 것들 점화식을 구하기 위해 노트에 써내려가봤습니다. 맨 처음 알게된 사실은 하나의 dp에 정보를 담을 수 없다는 것 입니다. 어떠한 인덱스를 기준으로 이 인덱스가 커지는 수열에 포함되는게 맞는지 줄어드는 수열에 포함되는지 맞는지 생각해야합니다. -&amp;gt; dp2개 써야합니다.(updp, downdp) 2개를 쓰는건 알았지만 증가하는 수열에도 {1,2,5,5,4,5} 이런 식으로 있으면 맨 뒤에있는 5가 최대가 되는 기준이 필요했습니다. 인덱스 기준으로 전에 있던 값들에 대한 dp들을 비교합니다. 커지는 수열은 ‘줄어들다가 커질 수 ‘없으므로 updp만 보면 됩니다. 감소하는 수열은 {5,10,4,10,3,5,1} 이런 예시가 있다고 합시다. 처음에는 인덱스 기준으로 가장 가깝고 값보다 큰 것을 찾아 dp를 넣었습니다. 틀렸습니다. 위의 예제에서 맨 뒤의 1 기준으로 바로 앞 5의 dp를 넣으면 틀립니다. 그래서 이것도 자신의 앞의 dp정보를 다 확인해야하는데, dp에 넣으려면 downdp 뿐만아니라 updp도 봐야합니다. 다 증가하고 이제 감소하기 시작하는 부분, 감소하고 있던 경우 2가지 경우가 있기 때문입니다. 여담으로 input이 ‘1 1’ 들어오면 결과값은 1을 내야합니다. 이 실수에 한 번 틀렸습니다. 하나 더 실수할만한 사실은 맨 뒤의 값이 항상 결과값일 수 없습니다. {5,4,3,2,4} 수열인 경우 맨 뒤인 ‘4’가 아닌 그 앞인 ‘2’ 기준으로 4를 도출해내야합니다. 5. code#include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); int n=0; int result = 1; cin &amp;gt;&amp;gt; n; int* arr = new int[n + 1]; int* dpup = new int[n + 1]; int* dpdown = new int[n + 1]; for (int i = 1; i &amp;lt;= n; ++i) { cin &amp;gt;&amp;gt; arr[i]; dpup[i] = 1; dpdown[i] = 1; } for (int i = 2; i &amp;lt;= n; ++i) { int maxnum = 0; for (int j = i - 1; j &amp;gt; 0; --j) { //up 갱신 //up 같은 경우는 자신보다 작은 값을 다 찾고 그 dp+1 up끼리만 해야함. if (arr[i] &amp;gt; arr[j]) { if (maxnum &amp;lt; dpup[j]) maxnum = dpup[j]; } } dpup[i] = maxnum + 1; maxnum = 0; int temp = 0; for (int j = i - 1; j &amp;gt; 0; --j) { //dpdown은 자기보다 큰 값에서 up,down비교해서 큰 값 if (arr[i] &amp;lt; arr[j]) { if (maxnum &amp;lt; max(dpdown[j], dpup[j]))// 둘중 하나보다 작으면 maxnum = max(dpdown[j], dpup[j]); } } dpdown[i] = maxnum + 1; if (result &amp;lt; dpup[i]) result = dpup[i]; else if (result &amp;lt; dpdown[i]) result = dpdown[i]; } cout &amp;lt;&amp;lt; result; delete dpup; delete dpdown; delete arr; return 0;}6. 후기골드 3문제라 쫄았는데..쫀 만큼 좀 어려웠다. 머리 좀 아팠음." }, { "title": "Baekjoon2638-치즈", "url": "/posts/baekjoon2638/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, BFS", "date": "2021-01-15 19:02:00 +0900", "snippet": "백준 사이트 2638 - 치즈 문제입니다.1. 문제https://www.acmicpc.net/problem/26382. Input , Output3. 분류 및 난이도BFS문제입니다.시간이랑 메모리가 넉넉한 편은 아니지만 어렵지 않습니다.백준에서는 Gold4의 난이도를 책정하고 있습니다.4. 생각한 것들 비슷한 문제로 치즈 2가 있습니다. 그것과 다른점은 면 2개를 세줘야한다는 점이 다릅니다. DFS로 분류되어있지만 BFS로 풀었습니다. 메모리를 줄이기 위해 맵을 bool 형태로 만들고 하나의 while문에 끝내려고 노력했습니다. 어차피 0,0부터 돌면서 BFS를하든 DFS를 하든 안쪽 공기는 못 도므로 방문 안한 공기는 내부 공기로 취급했습니다. 한번 돌았을 때 밖으로 노출되는 공기들이 새로 생기므로 다시 한번 돌아주는 방법으로 했습니다.5. code#include&amp;lt;iostream&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;cstring&amp;gt;using namespace std;const int MAX = 101;bool MAP[MAX][MAX] = { false, };bool v[MAX][MAX] = { false, };int n, m;int dx[4] = { -1,0,1,0 };int dy[4] = { 0,1,0,-1 };int cheese = 0;int hour = 0;void printMAP(){ for (int i = 0; i &amp;lt; n; ++i) { for (int j = 0; j &amp;lt; m; ++j) cout &amp;lt;&amp;lt; MAP[i][j] &amp;lt;&amp;lt; &quot; &quot;; cout &amp;lt;&amp;lt; &#39;\\n&#39;; } cout &amp;lt;&amp;lt; &#39;\\n&#39;;}void Input(){ cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; for (int i = 0; i &amp;lt; n; ++i) { for (int j = 0; j &amp;lt; m; ++j) { cin &amp;gt;&amp;gt; MAP[i][j]; if (MAP[i][j]) ++cheese; } }}void Solve(){ queue&amp;lt;pair&amp;lt;int,int&amp;gt;&amp;gt; q; while (cheese != 0) { memset(v, false, sizeof(v)); q.push(make_pair(0, 0)); //먼저 외부 공기들은 다 check 상태로 만듬 while (!q.empty()) { int x = q.front().first; int y = q.front().second; q.pop(); for (int k = 0; k &amp;lt; 4; ++k) { int newX = x + dx[k]; int newY = y + dy[k]; //공기 이면서 한번도 안돈 공기 if (0 &amp;lt;= newX &amp;amp;&amp;amp; newX &amp;lt; n &amp;amp;&amp;amp; 0 &amp;lt;= newY &amp;amp;&amp;amp; newY &amp;lt; m &amp;amp;&amp;amp; MAP[newX][newY] == false &amp;amp;&amp;amp; v[newX][newY] == false) { v[newX][newY] = true; q.push(make_pair(newX, newY)); } } } //공기들은 다 check로 바꿈 이제 돌면서 치즈삭제 for (int i = 0; i &amp;lt; n; ++i) { for (int j = 0; j &amp;lt; m; ++j) { if (MAP[i][j] == true) { //상하좌우검사 int count = 0; for (int k = 0; k &amp;lt; 4; ++k) { int newX = i + dx[k]; int newY = j + dy[k]; if (0 &amp;lt;= newX &amp;amp;&amp;amp; newX &amp;lt; n &amp;amp;&amp;amp; 0 &amp;lt;= newY &amp;amp;&amp;amp; newY &amp;lt; m &amp;amp;&amp;amp; v[newX][newY] == true &amp;amp;&amp;amp; MAP[newX][newY]==false)// 즉 공기이고 이미 외각 쪽 공기라면 { ++count; } } if (count &amp;gt;= 2)//녹일 치즈 { MAP[i][j] = false; --cheese; } } } } ++hour; //printMAP(); } cout &amp;lt;&amp;lt; hour;}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); Input(); Solve();}6. 후기처음에는 매번 공기를 찾아 BFS를 하는게 시간상의 손해인 것 같았다.그래서 한번에 처리하려고 하다가 무한루프에 빠져 틀렸다.8 90 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 00 1 1 0 0 0 1 1 00 1 0 1 1 1 0 1 00 1 0 0 1 0 0 1 00 1 0 1 1 1 0 1 00 1 1 0 0 0 1 1 00 0 0 0 0 0 0 0 0이 예제를 돌려서 고쳤다." }, { "title": "Baekjoon2294-동전 2", "url": "/posts/baekjoon2294/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, DP", "date": "2021-01-15 19:01:00 +0900", "snippet": "백준 사이트 2294 - 동전 2 문제입니다.1. 문제https://www.acmicpc.net/problem/22942. Input , Output3. 분류 및 난이도DP문제입니다.동전 1의 문제에서 모든 경우의 수 -&amp;gt; 최소값으로 바뀐 것입니다.백준에서는 Sliver1의 난이도를 책정하고 있습니다.4. 생각한 것들 동전 1의 코드를 참고하였습니다. memset()함수를 이용해서 0이 아닌 값으로 초기화하는 것은 굉장한 위험이 따릅니다. Byte 계산 때문이라는데 자세한건 ‘memset 주의할 점’으로 검색하면 많이 나옵니다.5. code#include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;int dp[10001] = { 0, };int arr[101] = { 0, };int n, k;//확인용 함수void dpprint(){ for (int i = 0; i &amp;lt;= k; ++i) { cout &amp;lt;&amp;lt; dp[i] &amp;lt;&amp;lt; &quot; &quot;; }}void Input(){ cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k; for (int i = 0; i &amp;lt; n; ++i) cin &amp;gt;&amp;gt; arr[i]; //dp초기화 for (int i = 0; i &amp;lt;= k; ++i) { dp[i] = 10001; }}void Solve(){ for (int i = 0; i &amp;lt; n; ++i) { for (int j = arr[i]; j &amp;lt;= k; ++j) { if (j - arr[i] &amp;gt; 0) dp[j] = min(dp[j - arr[i]] + 1, dp[j]); else dp[j] = 1; } } if (dp[k] == 10001) cout &amp;lt;&amp;lt; -1; else cout &amp;lt;&amp;lt; dp[k];}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); Input(); Solve(); return 0;}6. 후기어렵지 않았다. 빠르게 풀려고 노력했다." }, { "title": "이것이 리눅스다. - 9. 네임 서버 설치와 운영 (중지)", "url": "/posts/ThisisLinuxC9/", "categories": "Linux, ThisisLinux(since2016Stop)", "tags": "This is Linux", "date": "2021-01-15 13:00:00 +0900", "snippet": "한빛 미디어의 이것이 리눅스다. 책을 정리한 자료입니다.9.1 네임 서버의 개념 네임 서버는 DNS(Domain Name System) 서버라고도 하며 URL을 IP주소로 변환하는 일을 하는 서버입니다. 옛날에는 hosts 파일을 가지고 IP를 알았다고 합니다. 호스트파일을 열어보겠습니다.Server에서 root권한으로 다음 명령어를 입력합니다.nslookupwww.nate.comwww.naver.com 등등.. 보고싶은 URL자신의 컴퓨터에 네임서버를 작동시키지 않아도위에서 나온 IP를 주소창에 입력하면 해당 페이지가 나옵니다.vi /etc/resolv.conf에서 nameserver ~ 부분 &#39;#&#39;으로 주석처리그 이후 인터넷에 ‘naver.com’을 입력하면 찾을 수 없다고 나옵니다.하지만 위에서 찾은 IP주소를 넣어주면 접속이 됩니다.라는데.. 저는 잘 안됩니다. 구글링해도 잘 안나오길래 일단 넘어가고 진행했습니다.naver는 안되는 것 같습니다. 저희 학교인 ‘163.180.96.211’은 잘됩니다.. 왜지?..위의 상태에서 /etc/hosts 파일을 이용해서 IP입력 말고 URL 입력으로 들어가는 예제입니다.이 예제는 잘 됩니다.vi /etc/hostsnate.com의 주소는 각자 다를 수 있습니다.위처럼 수정하고 주소창에 ‘www.nate.com’을 검색하면 잘 나옵니다.만약 위의 파일을 밑처럼 바꾸면 경희대로 갈 수도 있습니다.IP주소를 얻는 흐름도는 다음과 같습니다. /etc/resolve.conf 보다 /etc/hosts가 우선순위에 있다는 것입니다. 그렇기에 hosts에 저장된 URL만 입력해도 홈페이지가 나타는 것입니다. 네임서버가 있어야하는 이유는 제가 실습하면서 저 위의 IP들을 많이 쓰면서 외워버렸지만, 처음에 ip주소를 찾는 번거로움이 너무 답답했습니다. 그 때문에 바로바로 전환을 도와주는 서버가 있어야 한다는게 제 생각입니다.9.2 네임 서버의 구축9.2.1 도메인 이름 체계인터넷이 보급되지 않았을 때 1대의 네임 서버만으로도 IP주소를 알 수 있었습니다. 하지만 인터넷이 폭발적으로 확장되기 시작했고, 1대로 관리하기 어려워졌습니다. 그래서 트리 구조 형태의 도메인 이름 체계가 고안되었습니다.위의 사진에서 1단계 네임 서버는 net, com, org, … 등이 있는데 com 네임서버는 그 하위 자식들인 nate, google, naver만 관리하면 됩니다.9.2.2 로컬 네임 서버가 작동하는 순서리눅스에는 위에서 살펴본 /etc/resolv.conf 파일에 ‘nameserver IP주소’ 형식으로 설정되어 있습니다.이 네임 서버를 로컬 네임 서버라고 부르는데, 이 로컬 네임 서버가 전세계의 도메인을 관리할 수 없기 때문에 다른 네임서버에 요청을 보냅니다. 출처: https://wikidocs.net/9668 위의 사진도 잘 안보이시면 여기서 찾으시면 됩니다.www.nate.com를 입력했을 때를 가정하면 순서는 다음과 같습니다. www.nate.com 입력 리눅스 경우 /etc/resolv.conf에서 ‘nameserver 네임서버ip’부분을 찾아 로컬 네임 서버 컴퓨터를 알아냄 로컬 네임 서버에 위의 주소를 물어봄 자신의 캐시 DB에 있으면 알려주지만 없으면 ‘ROOT 네임 서버’에 물어봄. ‘ROOT 네임 서버’도 모르므로 ‘com 네임 서버’의 주소를 알려주면서 거기에 물어보라고 함. ‘com 네임 서버’도 모르므로 ‘nate.com’을 관리하는 네임 서버의 주소를 알려주면서 물어보라고 함. ‘nate.com 네임 서버’는 네이트에서 구축한 네임 서버로 ip주소를 알고 있어서 알려줌. pc는 받은 ip로 접속을 시도함.9.2.3 캐싱 전용 네임 서버Cash Only Nameserver라고 불리는 이 서버는 URL로 IP 주소를 얻고자 할 때, 해당하는 URL의 IP 주소를 알려주는 네임 서버를 말합니다.네임 서버 구축 예제가 있는데 책 집필 시간이 지나 패키지 버전 오류로 인해 진행할 수 없습니다. 읽고 넘어갔습니다.해결 법을 위해 재설치 등 방법을 사용해보았으나 결과적으로yum -y install bind bind-chroot의 문제점은 제가 가지고 있는 패키지 버전이 너무 높아서 의존성에 의해 위의 패키지를 다운받을 수 없다고 합니다.그 패키지는 CentOS가 설치될 때 자동으로 설치되는 것으로 CentOS7의 부 버전이 너무 높은건가 싶어서 CentOS7중 버전이 낮은 것을 따로 다시 설치해야할 것 같아서 시간이 좀 걸릴 것 같습니다.9.2.4 마스터 네임 서버 자신이 별도로 관리하는 도메인이 있으며, 외부에서 자신이 관리하는 컴퓨터의 IP 주소를 물어볼 때, 자신의 DB에서 찾아서 알려주는 네임 서버를 ‘마스터 네임 서버’라고 부릅니다.9.2.5 라운드 로빈 방식의 네임 서버 요청 많은 서버는 웹 서버를 1대가 아니고 여러 대가 있을텐데 요청이 들어올 때 교대로 처리하는 방식을 라운드 로빈방식이라고 합니다.버전 차이가 나서 극복 하려고 했으나 잘 되지 않습니다. 책도 절판인데다가 새로운 버전의 책이 동일한 방식으로 계속 나오고 있고 카페를 둘러보니 재설치 외에 방법은 없다고 하니 다음에 리눅스 공부할 기회가 있을 때 해야할 것 같습니다." }, { "title": "Baekjoon13023-ABCDE", "url": "/posts/baekjoon13023/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, DFS", "date": "2021-01-14 20:01:00 +0900", "snippet": "백준 사이트 13023 - ABCDE 문제입니다.1. 문제https://www.acmicpc.net/problem/130232. Input , Output3. 분류 및 난이도DFS문제입니다.백준에서는 Gold5 난이도를 책정하고 있습니다.4. 생각한 것들 DFS를 생각하면 쉽습니다. 범위가 크지않아서 조건에 만족하는 것을 찾을때까지 돌면됩니다.5. code#include&amp;lt;iostream&amp;gt;#include&amp;lt;vector&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;cstring&amp;gt;using namespace std;int n, m;vector&amp;lt;int&amp;gt; vec[2001];bool v[2001] = { false, };void Input(){ cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; int person1, person2; for (int i = 0; i &amp;lt; m; ++i) { cin &amp;gt;&amp;gt; person1 &amp;gt;&amp;gt; person2; vec[person1].push_back(person2); vec[person2].push_back(person1); }}void dfs(int start,int count){ if (count == 4) { cout &amp;lt;&amp;lt; 1 &amp;lt;&amp;lt; &#39;\\n&#39;; exit(0); } for (int i = 0; i &amp;lt; vec[start].size(); ++i) { if (!v[vec[start][i]]) { v[start] = 1; dfs(vec[start][i], count + 1); v[start] = 0; } }}void Solve(){ for (int i = 0; i &amp;lt; n; ++i) { memset(v, false, sizeof(v)); dfs(i, 0); } cout &amp;lt;&amp;lt; 0 &amp;lt;&amp;lt; &#39;\\n&#39;;}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); Input(); Solve(); }6. 후기no" }, { "title": "Baekjoon13549-숨바꼭질3", "url": "/posts/baekjoon13549/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, BFS", "date": "2021-01-14 19:01:00 +0900", "snippet": "백준 사이트 13549 - 숨바꼭질3 문제입니다.1. 문제https://www.acmicpc.net/problem/135492. Input , Output3. 분류 및 난이도BFS문제입니다. 일반 BFS와 다르게 가중치들이 있어서 queue에서 가중치를 정해주거나 다익스트라 알고리즘을 사용해야합니다.백준에서는 Gold5난이도를 책정하고 있다.4. 생각한 것들 일반적인 queue, bfs로는 안풀립니다. dqueue로 바꿔서 풀어볼까 했지만 이것도 일반적인 방법으론 안됩니다. 인덱스에 가중치를 줘서 풀었습니다. memset이 너무 범위가 커서그런지 쓰레기값이 들어가서 배열 하나하나 MAX값을 넣어줬습니다.5. code#include&amp;lt;iostream&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;const int MAX = 100001;int n, k;int v[MAX];void Input(){ cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k; for (int i = 0; i &amp;lt; MAX; ++i) { v[i] = 100000; }}int Solve(){ //Bfs queue&amp;lt;int&amp;gt; q; q.push(n); v[n] = 0; while (!q.empty()) { int spot = q.front(); q.pop(); if (spot == k) return v[spot]; if (spot + 1 &amp;lt; MAX &amp;amp;&amp;amp; v[spot + 1] &amp;gt; v[spot]) { q.push(spot + 1); v[spot + 1] = v[spot] + 1; } if (spot - 1 &amp;gt;= 0 &amp;amp;&amp;amp; v[spot - 1] &amp;gt; v[spot]) { q.push(spot - 1); v[spot - 1] = v[spot] + 1; } if (spot * 2 &amp;lt; MAX &amp;amp;&amp;amp; v[spot * 2] &amp;gt; v[spot]) { q.push(spot * 2); v[spot * 2] = v[spot]; } }}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); Input(); cout &amp;lt;&amp;lt; Solve(); return 0;}6. 후기가중치에 대한건 공부를 안했기에 어려웠다.누가 dqueue로 풀었다고 자랑스럽게 코드를 올려놨던데… 그거 안됨." }, { "title": "Baekjoon11048-이동하기", "url": "/posts/baekjoon11048/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, DP", "date": "2021-01-14 19:00:00 +0900", "snippet": "백준 사이트 11048 - 이동하기 문제입니다.1. 문제https://www.acmicpc.net/problem/110482. Input , Output3. 분류 및 난이도DB문제입니다.백준에서는 Sliver1 난이도를 책정하고 있습니다.4. 생각한 것들 일반적 dp문제라 그냥 풀었다. 범위만 벗어나지 않게 조심했다.5. code#include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;int arr[1001][1001];int dp[1001][1001]; void Solve(){ int n, m; cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; for (int i = 0; i &amp;lt; n; ++i) { for (int j = 0; j &amp;lt; m; ++j) { cin &amp;gt;&amp;gt; arr[i][j]; if (i == 0 &amp;amp;&amp;amp; j == 0) dp[0][0] = arr[0][0];//첫 원소는 넣어줘야한다. if (i == 0 &amp;amp;&amp;amp; j != 0) dp[i][j] = dp[i][j - 1] + arr[i][j];// 맨위는 오른쪽 원소까지의 합을 값을 더한다. if (j == 0 &amp;amp;&amp;amp; i != 0) dp[i][j] = dp[i - 1][j] + arr[i][j];//맨 왼쪽은 위쪽 원소까지의 합을 더한다. } } for (int i = 1; i &amp;lt; n; ++i) { for (int j = 1; j &amp;lt; m; ++j) { dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + arr[i][j]; } } cout &amp;lt;&amp;lt; dp[n-1][m-1];}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); Solve(); return 0;}6. 후기어렵지 않았습니다." }, { "title": "이것이 리눅스다. - 8. 원격지 시스템 관리하기", "url": "/posts/ThisisLinux8/", "categories": "Linux, ThisisLinux(since2016Stop)", "tags": "This is Linux", "date": "2021-01-14 16:00:00 +0900", "snippet": "한빛 미디어의 이것이 리눅스다. 책을 정리한 자료입니다.8.1 텔넷 서버 지금은 인기가 없지만 전통적으로 사용되어 온 원격 접속 방법입니다. 리눅스 서버에 텔넷 서버를 설치했다면, 원격지에서 리눅스 서버에 접속할 PC에는 텔넷 클라이언트 프로그램이 필요합니다. 운영체제 대부분은 기본적으로 텔넷 클라이언트 프로그램이 내장되어 있으므로 별 문제는 없습니다.텔넷 서버 구축rootyum -y install telnet-server //텔넷 서버 설치systemctl start telnet.socket // 서비스 시작systemctl status telnet.socket // 서비스 상태 확인 1.유저생성adduser teluserpasswd teluser //password는 teluser로 설정yum -y install telnet // 텔넷 클라이언트 설치telnet 서버IP주소 // 텔넷 클라이언트를 이용해서 접속 2.window에서 텔넷 접속하기먼저 텔넷 클라이언트가 설치되어있는 지 확인합니다.다음 경로로 들어가 [텔넷 클라이언트]를 체크해줍니다.telnet 서버IP주소 // 해도 안된다. 서버에 방화벽이 막기 때문이다. 3.서버의 방/화벽인 보안수준 설정을 변경합니다.firewall-config //방화벽 설정창 열기다음과 같이 바꿔줍니다.이후 [옵션]-&amp;gt;[firewalld 다시불러오기]를 선택합니다.systemctl enable telnet.socket // 재부팅 후에도 텔넷 서버가 계속 가동되도록 함.이제 윈도우에서 접속하면 됩니다.root계정으로 접속못하게 CentOs가 막아놨는데 root로 접속하고 싶으면 서버에서 한가지 일을 해줘야합니다.mv /etc/securetty /etc/securetty.bak //파일을 이름을 바꿔버림orsu - 를 통해 접속8.2 OpenSSH 서버 텔넷과 용도는 같지만 보안이 더 강화된 서버입니다. 텔넷은 서버와 클라이언트 사이에 데이터를 전송할 때 암호화를 하지 않아 해킹의 위험이 있는데, 이를 해결하기 위해 사용하는 것이 OpenSSH서버입니다.OpenSSH구축 1.CentOs는 기본적으로 서버가 설치되어 있기에 가동시켜주면된다.systemctl status sshd //서버 가동중인지 확인 2.client에서 telnet처럼 명령어로 접속합니다. //ssh 사용자이름@호스트이름 or ssh 사용자이름@ip주소 접속이 안되면 방화벽 설정에서 ssh에 체크해줘야합니다. 3.window client에서 접속하기‘putty’라는 SW를 받아서 사용하면 됩니다. ssh기본적인 port번호는 22입니다.8.3 VNC 서버 기존 원격지 서버에서 터미널에서 작업을 하는 것이 아닌 그래픽 환경에서 작업할 수 있게 도와줍니다. X 윈도에서 제공하는 명령어를 쓸 수가 없기에 필요성이 있습니다. 그래픽 화면을 전송하는 원리로 텔넷과 비교했을 때 많이 느려지는 단점이 있습니다.서버.root에서 다음 명령어를 쳐줍니다.yum -y install tigervnc-server vnc 서버는 접속할 사용자를 지정하고, 사용자에게 디스플레이 번호를 할당해야합니다. 이 예제에서는 centos 사용자, 디스플레이번호 1번으로 지정했습니다.cp /lib/systemd/system/vncserver@.service /etc/systemd/system/vncserver@:1.service 위의 명령어는 vnc설정파일을 centos 사용자 설정 파일용으로 복사한 것입니다.vi /etc/systemd/system/vncserver@:1.service //파일 편집그리고 ‘firewall-config’ 명령어를 통해 ‘vnc-server’ 서비스를 허용하고 [옵션]-&amp;gt;[Firewalld 다시 불러오기]를 선택합니다.su - centos // centos 사용자로 접속vncserver //vnc서버 실행//password 설정은 알아서이제 클라이언트에서 접속해봅니다.centos에서 접속해서 vnc 클라이언트 프로그램을 설치합니다.su -c &#39;yum -y install tigervnc&#39;vncviwer IP주소:디스플레이번호윈도우에서 하기VNC클라이언트를 다운받고 똑같이 IP주소:디스플레이번호 하면 됩니다." }, { "title": "이것이 리눅스다. - 7. 셸 스크립트 프로그래밍", "url": "/posts/ThisisLinuxC7/", "categories": "Linux, ThisisLinux(since2016Stop)", "tags": "This is Linux", "date": "2021-01-14 13:00:00 +0900", "snippet": "한빛 미디어의 이것이 리눅스다. 책을 정리한 자료입니다.7.1 셸의 기본 셸은 사용자가 입력한 명령을 해석해 커널에 전달하거나, 커널의 처리 결과를 사용자에게 전달하는 역할을 합니다.7.1.1 CentOS의 bash셸CentOS에서 기본적으로 사용하는 셸의 이름은 bash이며 bash셸이라고 읽습니다. Alias 기능(명령어 단축 기능) History 기능 연산 기능 Job Control 기능 자동 이름 완성 기능(Tab) 프롬프트 제어 기능 명령 편집 기능7.1.2 환경 변수셸은 여러 가지 환경 변수를 갖습니다. 설정된 환경 변수는 ‘echo$환경 변수이름’형식으로 실행하면 확인할 수 있습니다.환경 변수 값을 변경하려면 ‘export 환경변수=값’ 형식을 실행합니다.‘printenv’명령어를 실행하면 출력됩니다.7.2 셸 스크립트 프로그래밍 실습 리눅스의 많은 부분이 셸스크립트로 작성되었기에 배워두면 좋다고 합니다.7.2.1 셸 스크립트 작성과 실행셸 스크립트 작성vi name.sh첫 번째줄의 의미는 bash를 사용하겠다는 의미로 꼭 써야합니다.sh name.sh //실행7.2.2 변수 변수의 기본 셸 스크립트에서는 미리 선언하는 것이 아닌 처음 변수에 값이 할당되면 자동으로 변수가 생성된다. 변수에 넣는 모든 값은 ‘문자열’ 취급 -&amp;gt; 숫자를 넣어도 문자열 취급 대소문자 구분, 대입 시 ‘=’ 좌우에 공백이 없어야함. 변수의 입력과 출력’$’라는 문자가 들어간 글자를 출력하려면 ‘‘로 묶어주거나 앞에 ‘&#39;를 붙여야합니다. 또한, ““로 변수를 묶거나 묶지않아도 됩니다.#!/bin/shmyvar=&quot;Hi Woo&quot;echo $myvar //정상출력echo &quot;$myvar&quot; //정상출력echo &#39;$myvar&#39; //&#39;$myvar&#39;출력echo \\$myvar //$를 문자열 취급하여 $myvar출력echo input plz :read myvarecho &#39;$myvar&#39; = $myvarexit 0숫자 계산 기본적으로 변수에 넣은 값은 모두 문자열 취급하므로 ‘expr’키워드를 사용해야 합니다. (`) 키로 수식을 묶어야 한다고 합니다. 괄호를 사용하려면 ‘&#39;를 붙여줘야한다고 합니다. 사칙연산 중 곱하기(*)에도 ‘&#39;를 붙여줘야한다고 합니다.#!/bin/shnum1=100num2=$num1+200echo $num2num3=`expr $num1 + 200`echo $num3num4=`expr \\( $num1 + 200 \\) / 10 \\* 2`echo $num4exit 0에러가 2번 났는데 주의점이 있습니다. 첫 번째는 ‘ 따옴표가 1번옆에 있는 ` 이걸 써야한다는 점 두 번째는 괄호에서 ‘(‘ 이부분 에 붙여 쓰면 에러납니다. 그래서 한 칸 띄고 써줘야합니다.파라미터 변수 파라미터 변수는 ‘$0’, ‘$1’ 등의 형태를 갖습니다. 이는 실행하는 명령의 부분 하나하나를 변수로 지정한다는 의미입니다. 예를 들어 ‘yum -y install gftp’는 yum은 $0, -y는 $1… 이런 식입니다.vi paravar.sh#!/bin/shecho &quot;first excute file name is &amp;lt;$0&amp;gt;&quot;echo &quot;first parameter is &amp;lt;$1&amp;gt;, second parameter is &amp;lt;$2&amp;gt;&quot;echo &quot;all of parameter is &amp;lt;$*&amp;gt;&quot;exit 07.2.3 if문과 case문 if문의 주의점은 [조건]의 각 단어는 모두 공백이 있어야 합니다.vi if1.sh#!/bin/shif [ &quot;woo&quot; = &quot;woo&quot; ]then echo &quot;true&quot;fiexit 0sh if1.sh뒤에는 vi로 문서여는 명령어와 sh로 실행하는 명령어를 적지 않겠습니다. 모두 직접해봤으니 안되는 예제는 없습니다.if else문#!/bin/shif [ &quot;woo&quot; != &quot;woo&quot; ]then echo &quot;true&quot;else echo &quot;false&quot;fiexit 0조건에 들어가는 비교 연산자#!/bin/shif [ 100 -eq 200 ]then echo &quot;100 equal 200&quot;else echo &quot;100 nequal 200&quot;fiexit 0파일과 관련된 조건#!/bin/shfname=/lib/systemd/system/httpd.serviceif [ -f $fname ]then head -5 $fnameelse echo &quot;not install web service&quot;fiexit 0case~esac문 if문은 참과 거짓이라는 두 가지 경우만 사용할 수 있습니다. 2중 분기인 if문과 다르게 다중분기인 case문을 사용해봅니다.#!/bin/shcase &quot;$1&quot; in start) echo &quot;start!&quot;;; stop) echo &quot;stop!&quot;;; restart) echo &quot;restart!&quot;;; *) echo &quot;nothing&quot;;;esacexit 0사용방법은sh case1.sh stopsh case1.sh startsh case1.sh restartsh case1.sh 아무글자AND, OR 관계 연산자 and는 ‘-a’ 또는 ‘&amp;amp;&amp;amp;’를 사용하며 or는 ‘-o’ 또는 ‘   ‘를 사용한다. #!/bin/shecho &quot;input filename&quot;read fnameif [ -f $fname ] &amp;amp;&amp;amp; [ -s $fname ] ; then head -5 $fnameelse echo &quot;found not file or size is zero&quot;fiexit 07.2.4 반복문for~in문for i in 1 2 3 4 5 6 7 8 9 10do hap=`expr $hap + $i`doneecho &quot;sum of 1 ~ 10&quot; : $hapexit 0//현재 디렉터리에 있는 셸 스크립트 파일 이름과 앞 3줄 출력for fname in $(ls *.sh)do echo &quot;-----$fname-----&quot; head -3 $fnamedoneexit 0 정말 불편하다..while문#!/bin/shwhile [ 1 ]do echo &quot;CentOS 7&quot;doneexit 0//1부터 10까지 합#!/bin/shhap=0i=1while [ $i -le 10 ]do hap=`expr $hap + $i` i=`expr $i + 1`doneecho &quot;sum of 1 ~ 10 : &quot; $hapexit 0 for문보다는 낫네..until문 until문은 while문과 용도가 거의 같지만, 조건식이 거짓인 동안 계속 반복합니다. 1~10 합 코드의 while문을 다음과 같이 바꾸면 됩니다. until [ $i -gt 10 ]break,continue,exit,return문while [ 1 ] ; do read input case $input in b | B) break;; c | C) echo &quot; continue is return to while&quot; continue;; e | E) echo &quot; exit is exit function&quot; exit 1;; esac;doneecho &quot;input beak&quot;exit 07.2.4 기타 알아둘 내용사용자 정의 함수#!/bin/shmyFunction(){ echo &quot;in function&quot; return}echo &quot;start program&quot;myFunctionecho &quot;exit program&quot;exit 0함수 파라미터 사용 함수 안에서는$1 , $2 …로 사용합니다.#!/bin/shhap (){echo `expr $1 + $2`}echo &quot;10 + 20&quot;hap 10 20exit 0eval 문자열을 명령문으로 인식하고 실행합니다.#!/bin/shstr=&quot;ls -l anaconda-ks.cfg&quot;echo $streval $strexit 0export 외부 변수로 선언하여 다름 프로그램에서도 사용할 수 있게 합니다.vi exp1.sh#!/bin/shecho $var1echo $var2exit 0vi exp2.sh!/bin/shvar1=&quot;local var&quot;export var2=&quot;export var&quot;sh exp1.shexit 0sh exp2.shprintf c 언어의 printf() 함수와 비슷하게 형식을 지정해서 출력할 수 있습니다.#!/bin/shvar1=100.5var2=&quot;fun...linux&quot;printf &quot;%5.2f \\n\\n \\t %s \\n&quot; $var1 &quot;$var2&quot;exitset과 $(명령어) 리눅스 명령어를 결과로 사용하려면 ‘$(명령어)’ 형식을 사용해야 합니다. 또 결과를 파라미터로 사용하고자 할 때는 ‘set’ 명령어와 함게 사용합니다.#!/bin/shecho &quot;today is $(date)&quot;set $(date)echo &quot;today is $4&quot;exit 0shift 파라미터 변수를 왼쪽으로 한 단계씩 아래로 쉬프트(이동)시킵니다. 기존 코드의 문제점```console#!/bin/shmyfunc(){ echo $1 $2 $3 $4 $5 $6 $7 $8 $9 $10 $11}myfunc AAA BBB CCC DDD EEE FFF GGG HHH III JJJ KKKexit 0 ![](/assets/img/sample/Linux/ThisisLinux/C7/result5.JPG) - AAA0, AAA1이 나온 이유는 $10을 $1 + 0으로 인식하기 때문입니다. 따라서 shift연산을 해줘야합니다.- 개선한 코드```console#!/bin/shmyfunc(){ str=&quot;&quot; while [ &quot;$1&quot; != &quot;&quot; ] ; do str=&quot;$str $1&quot; shift done echo $str}myfunc AAA BBB CCC DDD EEE FFF GGG HHH III JJJ KKKexit 0다 따라치느라 너무 힘들었다.. 후 기본적인 문법지식이 있으면 셸 문법봐도 대강 이해할 것이라 생각합니다. 제가 그랬으니까요.." }, { "title": "이것이 리눅스다. - 6. 하드디스크 할당과 사용자별 공간할당(3)", "url": "/posts/ThisisLinuxC6_2/", "categories": "Linux, ThisisLinux(since2016Stop)", "tags": "This is Linux", "date": "2021-01-14 12:00:00 +0900", "snippet": "한빛 미디어의 이것이 리눅스다. 책을 정리한 자료입니다.6.3 LVM LVM은 Logical Volume Manager의 약자입니다. 논리 하드디스크 관리자라고 할 수 있습니다. LVM은 여러 개의 하드디스크를 합쳐서 한 개의 파티션으로 구성한 뒤, 나눌 수 있습니다. 2TB 2개를 합쳐 4TB를 만들고 1TB + 3TB로 분리가 가능합니다. 물리 불륨(Physical Volume) : /dev/sda1, /dev/sdb1 등의 파티션을 말합니다. 불륨 그룹(Volume Group) : 물리 불륨을 합쳐서 1개의 물리 그룹으로 만든 것입니다. 논리 불륨(Logical Volume) : 불륨 그룹을 1개 이상으로 나눈 것으로 논리적 그룹이라고 합니다.실습에 관련한 명령어들을 정리하겠습니다.pvcreate /dev/sdb1 -&amp;gt; 해당 파티션을 갖고 물리적인 불륨을 생성vgcreate 불륨그룹명 /dev/sdb1 /dev/sdc1 -&amp;gt; 불륨그룹을 생성하는 명령어vgdisplay -&amp;gt; 불륨 그룹출력lvcreate --size 1G --name myLG1 myVG -&amp;gt; myVG에서 1G 사이즈의 논리불륨은 myLG1이라는 이름으로 생성lvcreate --extents 100%FREE --name myLG2 myVG -&amp;gt; myVG에서 남은 용량을 모두할당한 논리불륨 myLG2를 생성6.4 사용자별로 공간 할당하기리눅스는 여러 명의 사용자가 동시에 접속해서 사용할 수 있습니다. 어떤 사용자가 치명적인 문제를 일으킬 가능성이 있으므로 각 사용자별로 용량을 제한해야 합니다.쿼터(Quota)를 정의하면 다음과 같습니다.파일 시스템마다 사용자나 그룹이 생성할 수 있는 파일의 용량과 개수를 제한하는 것사용자를 만들고 해당 사용자에게 공간을 할당하는 실습입니다. 1.가상머신에 1GB짜리 하드디스크를 새로 장착합니다. 2.root로 접속해 /dev/sdb의 파티션 생성과 포맷을 한 후 ‘/userHome’ 디렉터리에 마운트한다. fdisk /dev/sdbnp1enterenterpwmkfs.ext4 /dev/sdb1mkdir /userHomemount /dev/sdb1 /userHomevi /etc/fstab -&amp;gt; 수정해주기 3.사용자 john과 bann을 만들고 비밀번호도 사용자 이름과 동일하게 설정 useradd -d /userHome/john johnuseradd -d /userHome/bann bannpasswd johnpasswd bann 4./etc/fstab 파일을 편집합니다. vi /etc/fstab 5.재마운팅 후 확인 mount --options remount /userHomemount 6.쿼터를 사용하기 위해 DB생성cd /userHomequotaoff -avug -&amp;gt; 쿼터를 일단 끈다.quotacheck -augmn -&amp;gt; 파일 시스템의 쿼터 관련 체크를 한다.rm -rf aquota.* -&amp;gt; 생성된 쿼터 관련 파일을 일단 삭제quotacheck -augmn -&amp;gt; 다시 확인touch aquota.user aquota.group -&amp;gt; 쿼터 관련 파일을 생성chmod 600 aquota.* -&amp;gt; 보안을 위해 root 외에는 접근하지 못하게함.quotacheck -augmn -&amp;gt; 확인quotaon -avug -&amp;gt; 설정된 쿼터를 시작ls -l -&amp;gt; 확인 7.사용자 별로 공간을 할당해줍니다.edquota -u john -&amp;gt; john사용자의 할당량을 편집 Filesystem : 사용자별 쿼터를 할당하는 파일 시스템을 의미 /etc/fstab 파일에 /dev/sdb1를 쿼터로 설정했다. block,soft,hard : 사용자가 사용하는 블록과 소프트 사용한도, 하드 사용한도 0은 한도를 제한하지 않았다는 것. inodes,soft,hard : 파일의갯수 한도를 의미한다. 현재 7개의 파일을 사용하며 제한은 없다는 것을 의미.다음과 같이 바꿔줍니다. 8.john으로 접속하여 확인해봅니다.quota -&amp;gt; 현재 사용자에게 할당된 하드디스크 확인 해석 : grace(유예기간)동안 soft로 설정한 10240에서 5120KB을 정리해야한다. (15360KB 모두 사용했으므로)//root에서 사용해야함.repquota /userHome -&amp;gt; 사용자별 현재 사용량 확인 가능 10.bann사용자에게도 john 사용자와 똑같이 사용량 할당하기edquota -p john bann -&amp;gt; bann에게도 john과 같은 사항을 적용.repquota /userHome -&amp;gt; 확인" }, { "title": "Spring - 3 스프링 AOP,PSA(강의 끝)", "url": "/posts/Springbjs03/", "categories": "Java, 2. Spring_백기선_예제로 배우는 스프링입문", "tags": "Spring Novice", "date": "2021-01-13 21:00:00 +0900", "snippet": "해당 자료는 인프런 백기선님의 예제로 배우는 스프링 입문(개정판) 강의노트입니다..1. 스프링 AOP AOP가 필요한 이유는 다음과 같습니다.class A { method a () { AAAA -&amp;gt; AAA 오늘은 7월 4일 미국 독립 기념일이래요. BBBB -&amp;gt; BB } method b () { AAAA -&amp;gt; AAA 저는 아침에 운동을 다녀와서 밥먹고 빨래를 했습니다. BBBB -&amp;gt; BB }}class B { method c() { AAAA -&amp;gt; AAA 점심은 이거 찍느라 못먹었는데 저녁엔 제육볶음을 먹고 싶네요. BBBB -&amp;gt; BB }}만약 코드를 AAAA에서 AAA를 고쳐야한다하면 메소드를 다 찾아서 고쳐야하는 것은 고된 작업입니다.때문에 위의 AAAA와 BBBB를 따로 클래스로 빼놓은개념을 AOP라 할 수 있습니다. 예제는 1월2일에 작성한 스프링 포스트와 비슷하니 따로 작성하지 않겠습니다. (메소드 수행시간 출력 예제)구현 방법에는 3가지가 있습니다. 컴파일 A.java —- (AOP) —-&amp;gt; A.class (컴파일한 코드에는 조작을 한것처럼 AspectJ가 제공) 바이트코드 조작 -&amp;gt; Class Loader가 class를 읽어오고 메모리에 올릴 때 조작함 (AspectJ가 제공) 프록시 패턴 -&amp;gt; Spring AOP프록시 패턴 예제는 애노테이션을 먼저 달아두고 단축키를 이용해 애노테이션을 제작하였습니다. @Target을 통해 메소드에 사용할 것이라고 알려주고, @Retention을 통해 Runtime까지 유지할 것이라고 알려줍니다.@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface LogExecutionTime {}여기까지는 주석과 비슷하게 달려있는 것입니다. 애노테이션을 읽어서 처리하는 Aspect를 만들어야합니다.@Component@Aspectpublic class LogAspect { Logger logger = LoggerFactory.getLogger(LogAspect.class); @Around(&quot;@annotation(LogExecutionTime)&quot;) public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable { StopWatch stopWatch = new StopWatch(); stopWatch.start(); Object proceed = joinPoint.proceed(); stopWatch.stop(); logger.info(stopWatch.prettyPrint()); return proceed; }} joinPoint는 실행할 메소드가 들어옵니다. 나머지 내용은 수행시간을 읽어서 다시 리턴하는 것입니다.후에 PSA와 스프링 캐시, 트랜잭션 등에 대한 설명을 하십니다. 제가 글로 잘 녹여낼 수 없어서 듣는 것을 추천합니다." }, { "title": "Baekjoon11051-이항 계수 2", "url": "/posts/baekjoon11051/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, DP", "date": "2021-01-13 19:00:00 +0900", "snippet": "백준 사이트 11051 - 이항 계수 2 문제입니다.1. 문제https://www.acmicpc.net/problem/110512. Input , Output3. 분류 및 난이도DB문제입니다.이항계수는 dp문제로 유명합니다. 10007로 나눠주는 것을 어디에 해주느냐에 따라 정답이 갈리는 것 같습니다.백준에서는 Slive1의 난이도를 책정하고 있습니다.4. 생각한 것들 이항 계수의 특징을 알아야해서 위키피디아에 들어가서 특징을 확인 후 코드에 옮겼다.5. code#include&amp;lt;iostream&amp;gt;using namespace std;int dp[1001][1001] = { 0, };int nCr(int n, int k){ if (n == k) return 1; if (k == 0) return 1; else if (dp[n][k] != 0) return dp[n][k]; return dp[n][k] = (nCr(n - 1, k - 1) + nCr(n - 1, k)) % 10007;}void Solve(int n, int k){ int result = nCr(n, k); cout &amp;lt;&amp;lt; result;}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); int n, k; cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k; Solve(n, k); return 0;}6. 후기푸는데 3분걸렸다.틀리겠지 하면서 냈는데 맞아버려서 당황" }, { "title": "이것이 리눅스다. - 6. 하드디스크 할당과 사용자별 공간할당(2)", "url": "/posts/ThisisLinuxC6_1/", "categories": "Linux, ThisisLinux(since2016Stop)", "tags": "This is Linux", "date": "2021-01-13 16:00:00 +0900", "snippet": "한빛 미디어의 이것이 리눅스다. 책을 정리한 자료입니다.6.2 여러 개의 하드디스크를 하나처럼 사용하기 만약 본인이 3TB의 하드가 필요한데 누군가가 1TB + 2TB를 주면 이것을 어떻게 해결할 것인지 생각해야합니다. 각 하드디스크의 용량을 넘지 않게 잘 분배해서 사용해야하나? 라는 문제를 해결하기 위해 RAID라는 기술이 나왔습니다. 6.2.1 RAID의 정의와 개념 Redundant Array of Inexpensive/Independent Disks의 약자인 RAID는 하드웨어방식 소프트웨어 방식으로 나뉩니다. RAID는 여러 개의 하드디스크를 하나의 하드디스크처럼 사용할 수 있도록 도와줍니다. 비용을 절감하면서도 더 신뢰성을 높이고 성능까지 향상시킬 수 있습니다.하드웨어 RAID 하드웨어 RAID는 하드웨어 제조업체에서 여러 개의 하드디스크를 연결한 장비를 만들어서 그 자체를 제공합니다.소프트웨어 RAID 소프트웨어 RAID는 고가의 하드웨어 RAID의 대안으로 신뢰성이나 속도 등이 떨어질 수 있지만 저렴한 비용으로 데이터를 안전하게 저장할 수 있는 방식입니다.6.2.2 RAID 레벨 RAID는 Linear RAID, RAID0, RAID1, RAID2, RAID3, RAID4, RAID5 총 일곱 가지로 분류됩니다.실무에서는 주로 Linear, RID0,1,5,6, 1+0의 혼합을 사용합니다.Linear RAID, RAID0두 방식 모두 최소 2개의 하드디스크가 필요합니다.그림과 같이 저장됩니다. Linear 방식은 앞 하드디스크에 데이터가 완전히 저장된 후 다음 하드디스크에 데이터를 저장합니다. 즉 앞 하드디스크에 데이터가 완전히 저장되지 않는다면 다음 하드디스크는 사용되지 않습니다. RAID0방식은 각각 하드디스크에 데이터를 고르게 저장합니다. 모든 작업은 동시에 진행되므로 Linear방식보다 빠릅니다. RAID0의 방식의 문제점은 빠르지만 하드디스크 하나가 고장나면 데이터를 복구하기가 어렵다는 것입니다. 만약 하드디스크 1이 고장났으면 위의 그림에서 데이터는 ‘이x은txstx문구x니다.’ 처럼 예측하기 어려운 데이터가 되어버립니다. 또하나의 단점은 만약 100TB 하드와 1TB하드가 장착되어 있을 경우 2TB만 사용할 수 있습니다. 동시에 작업하기에 1TB하드가 차버리면 더 이상 저장할 수 없기 때문입니다. 이것은 Linear RAID가 해결하므로 Linear의 장점이 될 수 있습니다. RAID1 RAID1 방식은 RAID0에서 나타난 데이터 결함 문제를 해결하기 위해 다른 하나의 저장소에 똑같은 데이터를 저장합니다. 데이터를 저장하는 것은 동시에 일어나므로 속도의 차이는 없지만 공간을 2배쓴다는 단점이 있습니다.RAID5만약 하디드스크 4개에 ‘000 111 010 011’라는 12비트 데이터를 저장한다고 가정해보면 RAID5에서는 다음과 같이 저장됩니다.?에는 패리티 방식을 사용하는데 간단하게 짝수 패리티방식은 데이터들의 각행이 짝수가 되게 만드는 것입니다.맨 위의 000 경우 ?에 1이 들어가면 짝수가 되지 않으므로 ?에는 0이 들어가게 됩니다.이런 식으로결과가 만들어지게 됩니다. 이러한 방식을 선택하는 이유는 데이터손실을 방지하기 위함입니다.하드디스크 1개가 고장나도 패리티 결과값을 통해 값을 유추할 수 있습니다.만약 하드디스크 2개가 고장나면 데이터를 복구할 수 없게됩니다. 이것을 해결하기 위해 RAID6방식이 나왔습니다.RAID6 RAID5와 달리 패리티를 2개 사용합니다. 공간효율은 더 낮아지지만 안정적입니다. RAID5는 최소 3개의 하드디스크 RAID6는 최소 4개의 하드디스크로 구성해야합니다.조합 RAID1+0 방식은 RAID1로 구성한 데이터를 다시 RAID0으로 구성하는 방법입니다. 외에도 RAID1+6 등이 있습니다.책에서 위의 RAID들을 구현, 오류 발생 대처법을 예제로 만들었는데, 블로그에 전부 담기에는 너무 내용이 커져서 저 혼자 실습하고 넘어갔습니다.사용한 명령어들만 정리하겠습니다.‘mdadm’ -&amp;gt; Centos에서 RAID 장치를 생성/관리하는 명령어mdadm --create /dev/md9 --level==linear --raid-devices=2 /dev/sdb1 dev/sdc1mdadm --detail --scanmdadm /dev/md1 --add /dev/sdg1 –create /dev/md9 -&amp;gt; md9장치에 RAID를 생성 –level=linear -&amp;gt; Linear RAID를 지정 0은 RAID 0 … –raid-devices=2 ~ -&amp;gt; 2개 하드디스크 사용 뒤에는 어떤 장치를 쓸 지 정의 mdadm –stop /dev/md9 -&amp;gt; RAID 장치인 /dev/md9를 중지 mdadm –run /dev/md9 -&amp;gt; 중지된 RAID 장치 가동 mdadm –detail /dev/md9 -&amp;gt; 장치 상세내용 출력 mdadm –add -&amp;gt; add 앞의 RAID장치에 add뒤의 파티션을 추가하라는 명령어복구과정은 다음과 같습니다.새로운 장치를 끼워줌 -&amp;gt; 위에서 했던 fdisk로 초기화 작업을 해주고 mdadm –create명령어를 통해 덮어씌웁니다." }, { "title": "이것이 리눅스다. - 6. 하드디스크 할당과 사용자별 공간할당(1)", "url": "/posts/ThisisLinuxC6/", "categories": "Linux, ThisisLinux(since2016Stop)", "tags": "This is Linux", "date": "2021-01-13 15:00:00 +0900", "snippet": "한빛 미디어의 이것이 리눅스다. 책을 정리한 자료입니다.6.1 하드디스크 한 개 추가하기6.1.1 IDE 장치와 SCSI 장치 구성현재 서버의 하드디스크 구성 상태입니다.IDE0, IDE1에 각각 2개의 IDE장치를 장착할 수 있어 총 4개의 IDE장치를 장착할 수 있습니다.일반적으로 사용되는 하드디스크나 CD/DVD 장치가 IDE장치라고 생각하면 됩니다.서버용으로는 주로 SCSI 하드디스크를 사용한다고 합니다.밑의 사진은 VMware에서 제공하는 SCSI 하드디스크 갯수인데 엄청 많습니다.처음 장착된 SCSI 하드디스크의 이름을 /dev/sda라고 부릅니다. 그 이후 장착될 때마다 /dev/sdb, /dev/sdc … 이렇게 부릅니다.또한 /dev/sda의 파티션을 나누면 /dev/sda1, /dev/sda2 … 이렇게 불립니다.하드 디스크를 하나 추가하는 예제를 할 것인데, 리눅스는 특정 디렉터리에 마운트를 해야하므로, ‘/mydata’라는 디렉터리를 만들고 마운트할 것입니다. 1.VMware에서 가상서버를 선택해 [Edit virtual machine settings]에 들어가 HardwareType에서 [Add]를 눌러 모든 설정을 그대로 두고 넘어갑니다. 하드디스크 용량 설정하는 란에서 [Store virtual disk as a single file]를 체크해주셔야합니다. 2.root권한으로 로그인해주고 VMware 상단에 하드디스크 2개가 장착되어 있는 지 확인합니다. 3.하드디스크에 파티션을 할당해야합니다. 터미널을 키고 다음 명령어들을 입력합니다. fidsk /dev/sdb // SCSI 0:1 하드디스크 선택n //새로운 파티션 분할 (위의 명령어를 통해 메뉴얼이 나와야합니다.)p // Primary 파티션 선택1 // 몇개의 파티션으로 나눌것인지 물어봅니다 1개만 사용할 것이므로 1로 입력합니다.first sector : Enter // 1개만 사용할 것이므로 디폴트값을 넣습니다.second sector : Enter // 1개만 사용할 것이므로 디폴트값을 넣습니다.p // 설정된 내용 확인w // 설정을 저장합니다. 시작섹터가 2048번인 이유는 0~2047부분은 시스템 성능 향상을 위해 사용하지 않는 부분이라고 합니다.mkfs.ext4 /dev/sdb1 //새로운 하드디스크 포맷과 비슷한 과정을 거침. 4./dev/sdb1 파일 시스템을 사용하기 위해 디렉터리에 마운트해야합니다. 과정을 눈으로 보기 위해 임시 디렉터리를 하나 만들어 놓습니다. mkdir /mydata -&amp;gt; 마운트할 디렉터리 cp anaconda-ks.cfg /mydata/test1 -&amp;gt; 굳이 anaconda-ks 아니여도 아무 임시파일이면 됩니다. ls -l /mydata/ -&amp;gt; test1파일이 있는지 확인합니다. 이것이 /dev/sdb1를 마운트하면 잠시 사라질 것입니다. 마운트를 하겠습니다. mount /dev/sdb1 /mydata -&amp;gt; /mydata에 마운트를 합니다. ls -l /mydata/ -&amp;gt; lost+found 디렉터리가 있을텐데 무시해도됩니다. cp anaconda-ks.cfg /mydata/test2 -&amp;gt; test2파일로 바꿔 복사시킵니다. ls -l /mydata/ -&amp;gt; test2가 생겼는데 위에서 생성한 test1이 사라졌습니다. 왜냐하면 /mydata는 마운트를 해주는 순간 /dev/sdb1의 소유가 됩니다. 그렇기에 위에서 작성한 test1파일은 잠시 sda2(기존 하드)의 어딘가에 숨어 있습니다. 확인을 위해 마운트를 해제하겠습니다. umount /dev/sdb1 -&amp;gt; 마운트 해제 ls -l /mydata -&amp;gt; test1파일이 나타났습니다. 마찬가지로 test2파일은 마운트를 다시해주면 생길 것입니다. 5.컴퓨터를 켤 때 /dev/sdb1 장치가 항상 /mydata에 마운트되도록 설정하겠습니다.vi /etc/fstab // 파일을 엽니다. 밑과같이 맨 밑줄에 설정을 하나 추가합니다. 설정 파일의 내용은 다음과 같습니다. 장치이름, 마운트될 디렉터리, 속성, dump 사용여부, 파일 시스템 체크 여부 파일 시스템과 속성을 defaults로 설정 시 읽기/쓰기/실행 등의 작업이 대부분 가능 dump를 1로 설정하면 dump 명령어를 이용한 백업이 가능합니다. 체크 시스템의 숫자는 2인경우 1인 파일시스템을 먼저 체크하고 체크하게 되는 순서를 입력합니다. 0인경우 체크하지 않아 부팅이 빠릅니다. 설정을 저장한 후 ‘reboot’로 재부팅을 해준 뒤 ‘ls -l /mydata’ 명령어를 통해 test2가 있는지 확인합니다." }, { "title": "Baekjoon2636-치즈", "url": "/posts/baekjoon2636/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, BFS", "date": "2021-01-12 19:30:00 +0900", "snippet": "백준 사이트 2636 - 치즈 문제입니다.1. 문제https://www.acmicpc.net/problem/26362. Input , Output3. 분류 및 난이도BFS문제입니다.정답률이 높은데 예외가 없어서 그런것 같습니다.이 문제가 만약 정사각형판이 주어지지 않았다면 난이도가 더욱 많이 올라갔을거라 생각합니다. 이유는 밑에 써보겠습니다. 백준에서는 Gold5난이도를 책정하고 있습니다.4. 생각한 것들 기존 문제와 다른 것은 종료 전의 치즈 갯수를 기억해야한다는 것입니다. 알아두면 구현은 어렵지 않습니다. queue에 넣고 한번에 처리하는 문제도 있는데 이문제는 치즈의 “겉 부분”만 제거해주면 되기에 한번에 처리안해도 됩니다. BFS를 돌 때 0,0부터 돌아야하나 생각이 있었습니다. 정사각형판이 ‘외부’로 판단하고 문제를 출제하여 0,0부터 돌아도 상관없습니다. 만약 판이 없었다면 공기가 통하는 부분을 따로 찾아줘야 했을 것입니다.. 종합해보면 BFS를 0,0부터 돌면서 치즈를 만나면 공기로 바꿔버리면서 BFS 도는 횟수(day)와 치즈의 갯수를 비교하면 문제는 풀립니다.5. code#include&amp;lt;iostream&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;cstring&amp;gt;using namespace std;const int MAX = 101;int row, col;int MAP[MAX][MAX] = { };bool v[MAX][MAX] = { false };int result = 0;int Ccount = 0;int day = 0;int dx[4] = { -1,0,1,0 };int dy[4] = { 0,1,0,-1 };//없어도됨.void print(){ for (int i = 0; i &amp;lt; row; ++i) { for (int j = 0; j &amp;lt; col; ++j) cout &amp;lt;&amp;lt; MAP[i][j] &amp;lt;&amp;lt; &quot; &quot;; cout &amp;lt;&amp;lt; &#39;\\n&#39;; }}void Input(){ cin &amp;gt;&amp;gt; row &amp;gt;&amp;gt; col; for (int i = 0; i &amp;lt; row; ++i) { for (int j = 0; j &amp;lt; col; ++j) { cin &amp;gt;&amp;gt; MAP[i][j]; if (MAP[i][j] == 1) ++Ccount; } }}void Solve(){ queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; q; while (Ccount != 0) { day++; result = Ccount; memset(v, false, sizeof(v)); q.push(make_pair(0, 0)); while (!q.empty()) { int airx = q.front().first; int airy = q.front().second; q.pop(); for (int k = 0; k &amp;lt; 4; ++k) { int newAx = airx + dx[k]; int newAy = airy + dy[k]; if (0 &amp;lt;= newAx &amp;amp;&amp;amp; newAx &amp;lt; row &amp;amp;&amp;amp; 0 &amp;lt;= newAy &amp;amp;&amp;amp; newAy &amp;lt; col &amp;amp;&amp;amp; v[newAx][newAy] == false) { if (MAP[newAx][newAy] == 1)//치즈인경우 { MAP[newAx][newAy] = 0; --Ccount; } else //공기인경우 q.push(make_pair(newAx, newAy)); v[newAx][newAy] = true; } } } }}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); Input(); Solve(); cout &amp;lt;&amp;lt; day &amp;lt;&amp;lt; &#39;\\n&#39; &amp;lt;&amp;lt; result &amp;lt;&amp;lt; &#39;\\n&#39;;}6. 후기이제 골드5 난이도의 BFS문제는 한 10분 정도 생각하고 바로바로 푸는 것 같다. 속도가 늘었다.좋긴한데 더 어려운 난이도에 대한 겁이 아직도 난다." }, { "title": "Baekjoon9251-LCS", "url": "/posts/baekjoon9251/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, DP", "date": "2021-01-12 19:00:00 +0900", "snippet": "백준 사이트 9251 - LCS 문제입니다.1. 문제https://www.acmicpc.net/problem/92512. Input , Output3. 분류 및 난이도DB문제입니다.LCS라는 따로 알고리즘이 존재할 정도로 유명한 문제입니다.백준에서는 Gold5난이도를 책정하고 있습니다.4. 생각한 것들 LCS 들어는 봤지만 직접 짜본 적이 없어서 위키백과에서 개념만 이해하고 코드는 직접 짰습니다. 문자열의 길이가 큰 것이 먼저 들어올 경우 등 예외를 생각했으나 코드를 짜고나니 길이와는 상관이 없었습니다. 위키백과에서 이해를 하고나니 코드를 짜는건 어렵지 않았습니다. https://ko.wikipedia.org/wiki/%EC%B5%9C%EC%9E%A5_%EA%B3%B5%ED%86%B5_%EB%B6%80%EB%B6%84_%EC%88%98%EC%97%B45. code#include&amp;lt;iostream&amp;gt;#include&amp;lt;string&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;int const MAX = 1001;int LCS[MAX][MAX] = { 0, };int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); string input1, input2; cin &amp;gt;&amp;gt; input1 &amp;gt;&amp;gt; input2; int result = 0; //LCS만들기 for (int i = 1; i &amp;lt; input1.size() + 1; ++i) { for (int j = 1; j &amp;lt; input2.size() + 1; ++j) { if (input1[i - 1] == input2[j - 1]) { LCS[i][j] = LCS[i - 1][j - 1] + 1; } else { LCS[i][j] = max(LCS[i - 1][j], LCS[i][j - 1]); } result = max(result, LCS[i][j]); } } cout &amp;lt;&amp;lt; result; return 0;}/*위키피디아 예제XMJYAUZMZJAWXU*/6. 후기처음에 틀려서 질문을 보다가 많은 사람들이 LCS배열을 char형으로 작성했다.당장 문자열의 길이가 MAX 1천이 되는데 char형으로 왜 작성했을 지 의문이 들었다." }, { "title": "이것이 리눅스다. - 5. X 윈도 사용법", "url": "/posts/ThisisLinuxC5/", "categories": "Linux, ThisisLinux(since2016Stop)", "tags": "This is Linux", "date": "2021-01-12 16:00:00 +0900", "snippet": "한빛 미디어의 이것이 리눅스다. 책을 정리한 자료입니다.5.1 그놈 데스크톱 환경 설정 X 윈도 바탕화면 변경하기 바탕화면에서 마우스 오른쪽 키를 눌러 [바탕화면 배경 바꾸기]를 선택합니다. 또는 firefox에 들어가 http://gnome-look.org에서 마음에 드는 배경을 다운받아서 적용시킵티다. 나같은 경우는 블로그 메인 고양이 사진을 배경화면으로 바꾸었습니다. 테마 변경하기 먼저 ‘rpm -qa gnome-tweak-tool’ 명령어를 통해 패키지가 설치되어있는지 확인합니다. 확인을 한 뒤 설치가 되어있지 않다면 ‘su -c “yum -y install gnome-tweak-tool”’ 명령어를 통해 관리자 권한으로 패키지 설치를 수행합니다. ‘gnome-tweak-tool’ 명령어를 통해 켜야한다고 책에 나와있지만, 현재는 버전이 바뀌어서 ‘gnome-tweaks’명령어를 쳐야합니다. gnome-tweaks로 통합되었다고 합니다. 참고 : https://wnw1005.tistory.com/44 그 다음 테마 탭이나 모양새 탭에 들어가 원하는 테마로 바꾸주면 됩니다. GURB 화면 바꾸기 책에 있는 순서대로 안됩니다. 이유는 boot/grub2에 theme 폴더에 관련 자료를 넘거야하는데 theme 폴더가 없습니다. 보아하니 이것 또한 세월이 지나면서 패키지명이 바뀌거나 그런것 같은데 찾아봐도 내용이 없어서 다음 블로그를 참고하여 설치해줬습니다. https://powerade-kim.blogspot.com/2018/11/ 설치해주니 없던 theme 폴더가 생겼습니다. 먼저 위의 링크를 참고해 패키지를 다운 받습니다. su -c &#39;gedit /etc/default/grub&#39; 를 통해 문서를 열고 맨 밑에 ‘GRUB_THEME=”/boot/grub2/themes/system/theme.txt”를 입력해 부트 시 참고해야할 문서경로를 적어줍니다. 그리고 GRUB_TERMINAL_OUTPUT=”console”은 ‘#’을 이용해 주석처리합니다. 자신이 원하는 이미지를 인터넷에서 다운받고 다음 명령어들을 쳐줍니다. cd ~/다운로드/ -&amp;gt; 기본적으로 다운받은 파일이 저장되는 경로 pwd -&amp;gt; 맞게왔는지 확인 ls -l -&amp;gt; 자신이 다운받은 파일명과 확장자를 기억합니다. su -c &#39;mv 자신의파일명.확장자 /boot/grub2/themes/system/&#39; -&amp;gt; 뒤의 폴더에 자신이 다운받은 파일을 옮깁니다. su -c &#39;gedit /boot/grub2/themes/system/theme.txt&#39; -&amp;gt; theme.txt 파일을 엽니다. theme.txt 파일에서 밑에 내리다보면 desktop-image : “firefox.png”를 자신의 파일명으로 바꿔줍니다. su -c &#39;grub2-mkconfig -o /boot/grub2/grub.cfg&#39; -&amp;gt; grub.cfg를 변경합니다. reboot -&amp;gt; 재부팅해서 확인합니다. 5.2 X 윈도 응용프로그램5.2.1 파일브라우저 - 노틸러스 노틸러스는 그놈 데스크톱 환경에서 제공되는 파일관리자 windows의 ‘파일 탐색기’와 비슷 사용방법은 프로그램 -&amp;gt; 보조프로그램 -&amp;gt; 파일 선택 or 터미널에 ‘nautilus’ 명령어 입력5.2.2 인터넷 응용프로그램 Firefox (최신 버전으로 업그레이드하는 예제가 있지만 저는 이미 최신버전이라 생략) 메일 클라이언트 - 에볼루션 -&amp;gt; 터미널에 ‘evolution’ 명령어 입력 or [프로그램] -&amp;gt; [오피스] -&amp;gt; [에볼루션] -&amp;gt; 저는 없어서 ‘su -c “yum -y install evolution”‘으로 설치해줬습니다. 메신저 - 엠퍼시 -&amp;gt; 엠퍼시는 대부분의 메신저 서비스 프로그램을 사용할 수 있다. -&amp;gt; [프로그램] -&amp;gt; [인터넷] -&amp;gt; [엠퍼시] or ‘empathy’ 명령어 입력 FTP 클라이언트 - gFTP -&amp;gt; CentOs7에서 제공하지 않으므로 다른 리눅스의 패키지를 가져와 설치해야한다.5.2.3 그 외 명령어들rhythmbox -&amp;gt; 라디오totem -&amp;gt; 동영상 플레이어gedit -&amp;gt; 텍스트 편집기evince -&amp;gt; PDF,XPS 등이 다중 문서를 볼 수 있는 뷰어 프로그램brasero -&amp;gt; CD/DVD 레코딩gimp -&amp;gt; 그래픽 편집 프로그램eog -&amp;gt; 그림 보기gnomoe-screenshot -&amp;gt; 화면 캡쳐libreoffice -&amp;gt; MSoffice와 비슷한 것 호환성이 뛰어남libreoffice --writer -&amp;gt; 워드 프로세서libreoffice --calc -&amp;gt; 스프레드시트libreoffice --impress -&amp;gt; 프로제테이션 툴5.3 KDE 환경 사용해보기yum grouplist | grep KDE -&amp;gt; KDE 그룹 관련 리스트 확인su -c &#39;yum -y groupinstall &quot;KDE Plasma Workspaces&quot; -&amp;gt; 그룹 패키지 설치reboot -&amp;gt; 재부팅재부팅을 하고 로그인을 하기 전 톱니바퀴를 눌러줘서 KDE Plasma 작업공간으로 바꿔주면 KDE를 사용하게 됩니다." }, { "title": "Spring - 2 스프링 IOC", "url": "/posts/Springbjs02/", "categories": "Java, 2. Spring_백기선_예제로 배우는 스프링입문", "tags": "Spring Novice", "date": "2021-01-12 00:00:00 +0900", "snippet": "해당 자료는 인프런 백기선님의 예제로 배우는 스프링 입문(개정판) 강의노트입니다..1. 스프링 IOCInversion of Control의 약자로 일반적으로 밑과 같이 OwnerController가 직접 의존성을 관리하는게 아니고class OwnerController { private OwnerRepository repository = new OwnerRepository();}class OwnerController { private OwnerRepository repo; public OwnerController(OwnerRepository repo) { this.repo = repo; } // repo를 사용합니다.}이 처럼 OwnerController 밖에서 관리해주는 것을 제어권이 역전되었다고 볼 수 있다.이를 의존성 주입(DI)이라고 하는데 이것또한 IOC라고 볼 수 있다.Bean이라는 스프링이 관리하는 객체들의 모임에 저장되어 관리되어진다. 김영한 선생님의 강의를 먼저 듣고나니 이해는 한결 쉬워졌다.2. 스프링 IOC 컨테이너 ApplicationContext와 BeanFactory가 있는데, ApplicationContext가 Bean을 상속받고 다양한 기능을한다. 스프링 IOC 컨테이너 안에 있는 객체끼리 의존성 주입이 가능하다. 복잡한 방법으로 컨테이너 밖의 객체와 연결할 수 있으나 권장하지 않는다. ApplicationContext를 사용할 일은 거의 없다. 왜냐하면 작성할 코드들은 이미 주입이 된 상태이기 때문에 따로 주입할 필요가 없다. 직접 주입을 한 것과 이미 주입된 것을 꺼내어 확인하면 같은 해시값이 찍힌다. 이를 싱글톤으로 빈을 생성한다고 한다. 3. 스프링 빈(Bean) IOC 컨테이너가 관리하는 객체를 빈이라고 부른다. 일반적으로 new로 해서 만든 인스턴스는 Bean이 아니다. 빈으로 만들기 위해서는 2가지 방법이 있다. 컴포넌트 스캔(Component Scanning)과 직접 빈에 등록하는 방법이 있다. 컴포넌트라는 애노테이션(@Component, @Service, @Controller, @Configuration…)이 붙어있는 모든 클래스를 찾아서 빈으로 등록하는 애노테이션 처리기가 등록되어 있다. 예제에서는 @ComponentScan이 범위를 정해준다. Repository는 JPA를 통해 특별하게 관리된다. 직접 빈에 등록하는 방법은 자바설정 파일이나, XML을 쓰느냐에 따라 다르다. 보통 자바설정 파일을 쓰는데 강의에서 쓴 예제는 ‘김영한 선생님’ 강의 포스트의 예제와 비슷하므로 참고하자.(@Configuration 사용)4. 의존성 주입(Dependency Injection) 생성자에 @Autowired를 붙여 사용할 수 있지만, 어떤 클래스의 생성자가 1개뿐이고 레퍼런스들이 빈에 등록되어 있다면 그 빈을 자동으로 주입해주도록 @Autowired 애노테이션을 스프링 4.3버전 이상부터 생략할 수 있다. Setter()에 @Autowired를 붙이는 방법도 있다. 빈에서 해당 객체를 찾아서 넣어준다. 빈에 등록되어 있지 않은 객체를 넣으려하면 ‘No qualifying bean ~’에러가 발생한다. 스프링에서 권장하는 방법은 생성자를 통해 의존성을 주입하는 방법이다. 필수적으로 사용해야하는 레퍼런스 없이는 인스턴스를 만들지 못하도록 강제할 수 있기 때문이다.필드 주입이나 Setter()는 만들 수 있다. 둘은 또한 순환참조가 발생할 수 있다. 1.예제에서의 필드 주입@Autowired private PetRepository petRepository;2.생성자 주입 private PetRepository petRepository; public OwnerController(OwnerRepository clinicService, VisitRepository visits,PetRepository petRepository) { this.owners = clinicService;//원래코드 this.visits = visits;//원래코드 this.petRepository = petRepository; }3.Setter주입 private PetRepository petRepository; public void setPetRepository(PetRepository petRepository) { this.petRepository = petRepository; }듣는데 이해는 완벽하지 않아도 이제는 각각 어떤 느낌인지 알 것 같다. 하지만 김영한 선생님의 강의를 듣지 않았다면 이렇게 이해하기 어려웠을 것이다.백기선 선생님의 강의는 귀에 잘 들어오고 스프링에 대해 다시 한번 듣게되서 어떤 것들을 중점적으로 이해해야할 지 생각이 들게 만든다." }, { "title": "Baekjoon1963-소수 경로", "url": "/posts/baekjoon1963/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, BFS", "date": "2021-01-11 21:00:00 +0900", "snippet": "백준 사이트 1963 - 소수 경로 문제입니다.1. 문제https://www.acmicpc.net/problem/19632. Input , Output3. 분류 및 난이도BFS 문제입니다.백준에서는 Gold5 난이도를 책정하고 있습니다.4. 생각한 것들 일단 시간복잡도 생각을 안하고 풀었습니다. 에라토스테네스 체를 이용해서 배열에 소수값들을 저장해놓았습니다. 각 자릿수를 1증가, 1감소 시키면서 소수 배열에 담겨져있는 소수가 있다면 queue에 넣고 queue가 다 돌 때까지 없으면 impossble을 출력하게 만들었습니다.5. code#include&amp;lt;iostream&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;cstring&amp;gt;#include&amp;lt;cmath&amp;gt;using namespace std;const int MAX = 10001;int T;int first, second;int tenes[MAX] = { 0, };bool v[MAX] = { false };int result = 0;int cal(int one, int two, int three, int four){ return one * 1000 + two * 100 + three * 10 + four;}int BFS(){ //첫번째는 first 두번째는 카운트값 queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; q; q.push(make_pair(first, 0)); v[first] = true; while (!q.empty()) { int num = q.front().first; int count = q.front().second; if (num == second) { return count; } q.pop(); int one = num / 1000; int two = (num % 1000) / 100; int three = (num % 100) / 10; int four = num % 10; for (int i = 0; i &amp;lt; 9; ++i) { one += 1; if (one &amp;gt; 9) one = 1; int result = cal(one, two, three, four); if (v[result] == false &amp;amp;&amp;amp; tenes[result] != 0) { q.push(make_pair(result, count + 1)); v[result] = true; } } for (int i = 0; i &amp;lt; 10; ++i) { //cout &amp;lt;&amp;lt; &quot;two : &quot; &amp;lt;&amp;lt; two &amp;lt;&amp;lt; &quot;\\n&quot;; two += 1; if (two &amp;gt; 9) two = 0; int result = cal(one, two, three, four); if (v[result] == false &amp;amp;&amp;amp; tenes[result] != 0) { q.push(make_pair(result, count + 1)); v[result] = true; } } for (int i = 0; i &amp;lt; 10; ++i) { //cout &amp;lt;&amp;lt; &quot;three : &quot; &amp;lt;&amp;lt; three &amp;lt;&amp;lt; &quot;\\n&quot;; three += 1; if (three &amp;gt; 9) three = 0; int result = cal(one, two, three, four); if (v[result] == false &amp;amp;&amp;amp; tenes[result] != 0) { q.push(make_pair(result, count + 1)); v[result] = true; } } for (int i = 0; i &amp;lt; 10; ++i) { four += 1; if (four &amp;gt; 9) four = 0; int result = cal(one, two, three, four); if (v[result] == false &amp;amp;&amp;amp; tenes[result] != 0) { q.push(make_pair(result, count + 1)); v[result] = true; } } } return -1;// 없음.}void Solve(){ //에라토스테네스의 체 for (int i = 2; i &amp;lt; MAX; ++i) { tenes[i] = i; } for (int i = 2; i &amp;lt;= sqrt(MAX); ++i) { if (tenes[i] == 0) continue; for (int j = i + i; j &amp;lt; MAX; j += i) tenes[j] = 0; } cin &amp;gt;&amp;gt; T; for (int i = 0; i &amp;lt; T; ++i) { memset(v, false, sizeof(v)); cin &amp;gt;&amp;gt; first &amp;gt;&amp;gt; second; result = BFS(); if (result == -1) cout &amp;lt;&amp;lt; &quot;Impossible\\n&quot;; else cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; &#39;\\n&#39;; }}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); Solve(); return 0;}6. 후기시간복잡도 생각을안하고 방문처리만 믿고 풀었는데, 되서 다행이다. 질문 글보니 시간초과도 꽤나 많았는데.." }, { "title": "Baekjoon2293-동전 1", "url": "/posts/baekjoon2293/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, DP", "date": "2021-01-11 19:00:00 +0900", "snippet": "백준 사이트 2293 - 동전 1 문제입니다.1. 문제https://www.acmicpc.net/problem/22932. Input , Output3. 분류 및 난이도DB문제입니다.저같은 경우 코드로 짜기 생각보다 어려워했습니다.백준에서는 Sliver1의 난이도를 책정하고 있습니다.4. 생각한 것들 배수이거나 새로운 조합인 경우에 경우의 수가 증가하는 것을 알았지만 코드로 짜기가 힘들었습니다.5. code#include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;int dp[10001] = { 0, };int arr[101] = { 0, };int n, k;void Input(){ cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k; for (int i = 0; i &amp;lt; n; ++i) { cin &amp;gt;&amp;gt; arr[i]; } sort(arr, arr + n);}void Solve(){ dp[0] = 1; for (int i = 0; i &amp;lt; n; ++i) { for (int j = arr[i]; j &amp;lt;= k; ++j) { if (j - arr[i] &amp;gt;= 0) dp[j] += dp[j - arr[i]]; } } cout &amp;lt;&amp;lt; dp[k];}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); Input(); Solve(); return 0;}6. 후기생각보다 어려웠다." }, { "title": "이것이 리눅스다. - 4. 리눅스 명령어, 개념(3)", "url": "/posts/ThisisLinuxC4_3/", "categories": "Linux, ThisisLinux(since2016Stop)", "tags": "This is Linux", "date": "2021-01-11 16:00:00 +0900", "snippet": "한빛 미디어의 이것이 리눅스다. 책을 정리한 자료입니다.4.4 네트워크 관련 설정과 명령어 네트워크 설정 정보를 출력 ifconfig ens33(장치이름) 네트워크 장치 가동, 정지 ifup ens33ifdown ens33 nmtui(Network Manager Text User Interface) 자동 IP주소 또는 고정 IP주소 사용 결정 IP 주소, 서브넷 마스크, 게이트웨이 정보 입력 DNS 정보입력 네트워크 카드 드라이버 설정 네트워크 장치의 설정 systemctl start/stop/restart/status network네트워크 설정을 변경한 후에 변경된 내용을 시스템에 적용시키는 명령어들 네트워크 설정과 관련된 주요파일 /etc/sysconfig/network -&amp;gt; 네트워크 기본 정보가 설정되어 있는 파일로 네트워크 사용 여부가 써 있다. /etc/sysconfig/network-scripts/ifcfg-ens33 -&amp;gt; 해당 장치에 설정된 네트워크 정보가 들어있다. /etc/resolv.conf -&amp;gt; DNS 서버의 정보와 호스트 이름이 들어 있는 파일 /etc/hosts -&amp;gt; 현 컴퓨터의 호스트 이름과 FQDN이 들어 있는 파일 SELinux 시스템에서 보안에 영향을 미치는 서비스, 권한 등을 제어 강제(enforcing), 허용(permissive), 비활성(disabled) 라는 3가지 레벨을 지원. 설정 파일은 /etc/sysconfig/selinux 파일이다. 4.5 파이프, 필터, 리다이렉션 파이프 파이프는 2개의 프로그램을 연결해주는 통로 ls -l /etc | more -&amp;gt; ls -l /etc + more명령어 필터 필터는 필요한 거만 걸러주는 명령어 ‘grep’, ‘tail’, ‘wc’, ‘sort’, ‘awk’, ‘sed’ 등의 명령어가 있다. ps -ef | grep bash -&amp;gt; bash라는 글자가 들어간 프로세스만 출력하게 된다. 리다이렉션 리다이렉션은 표준 입출력의 방향을 바꿔준다. 4.6 프로세스, 데몬, 서비스4.6.1 프로세스 포그라운드 프로세스 백그라운드 프로세스 프로세스번호 작업 번호 부모 프로세스, 자식 프로세스 ps kill pstree이름을 들어봤으므로 설명은 적지 않겠습니다.4.6.2 서비스 서비스=데몬=서버 프로세스4.7 서비스와 소켓서비스는 평상시에도 늘 가동하는 서버 프로세스, 소켓은 필요할 때만 작동하는 서버 프로세스이다.‘systemd’라고 부르는 서비스 매니저 프로그램으로 작동시키거나 관리.4.7.1 서비스 웹 서버(httpd), DB 서버(mysqld), FTP서버(vsftpd) 등이 있다. 서비스의 실행 스크립트 파일은 /usr/lib/systemd/system/ 디렉터리에 ‘서비스이름.service’로 존재4.7.2 소켓 서비스와 달리 요청이 끝나면 소켓도 종료됨. systemd가 서비스를 새로 구동하는 데 시간이 소요되므로 서비스보다 연결시간이 오래 걸릴 수 있다. 소켓의 실행 스크립트 파일은 /usr/lib/systemd/system/ 디렉터리에 ‘소켓이름.socket’로 존재4.8 응급복구root 사용자의 비밀번호를 잊어버렸을 때 해결하는 예제 처음 부트 시에 E키를 눌러서 다음 화면으로 진입해야한다. 키보드 아래를 눌러 ‘linux16 /boot ~’ 행에 커서를 놓고 마지막 문장인 ‘rhgb quiet ~’ 를 삭제하고 ‘init=/bin/sh’를 추가한다. ctrl+x 를 눌러 부팅을 하고 sh4-2# 라는 프롬프트가 나올 것이다. ‘whoami’ 명령어를 입력해 현재 사용자가 root인지 확인한다. ‘passwd’ 명령어를 통해 비밀번호를 바꾼다. /(root) 파티션이 읽기 전용으로 마운트 되어 있어서 권한 오류가 발생할 것이다. ‘mount -o remount,rw /’ 명령어를 입력해 읽기/쓰기 모드로 다시 마운트 시킨다. ‘passwd’ 명령어를 다시 입력해서 비밀번호를 바꾼다. 재부팅을 하고 새로운 비밀번호를 입력하면 로그인에 성공한다." }, { "title": "이것이 리눅스다. - 4. 리눅스 명령어, 개념(2)", "url": "/posts/ThisisLinuxC4_2/", "categories": "Linux, ThisisLinux(since2016Stop)", "tags": "This is Linux", "date": "2021-01-11 13:00:00 +0900", "snippet": "한빛 미디어의 이것이 리눅스다. 책을 정리한 자료입니다.4.3 리눅스 관리자를 위한 명령어4.3.1 프로그램 설치를 위한 RPM YUM이 나오기 전에 RPM(Redhat Package Manager)이 사용되었으나, YUM이 RPM의 상위호환이기에 YUM을 사용하면 됩니다. 레드햇사에서 프로그램 설치를 어려워하는 초보자를 위해 setup.exe과 비슷하게 프로그램을 설치한 후에 바로 실행할 수 있는 실행 파일을 제작하였다. 이를 *.rpm이며 이를 ‘패키지’라고 부릅니다.-자주 사용하는 rpm 명령어 옵션은 다음과 같습니다.rpm -Uvh 패키지파일이름.rpm // 패키지 설치 명령어 U : 기존에 패키지가 설치되어 있어도 업그레이드를 한다. v : 설치과정 확인 h : 설치과정을 &#39;#&#39;기호로 화면에 출력 rpm -e 패키지이름 // 패키지 삭제 명령어e(erase)의 약자 밑의 둘은 아직 설치되지 않은 rpm 파일 조회rpm -qlp 패키지이름.rpm // 패키지 파일에 어떤 파일들이 포함되었는지 확인rpm -qip 패키지이름.rpm // 패키지 파일의 상세 정보 RPM의 단점은 의존성 문제가 있다. Centos의 기본 웹 브라우저인 Firefox는 X 윈도상에서 가동되는데 X 윈도가 설치되지 않았다면 Firefox 설치될 수 없습니다. 이러한 불편한 점을 해결한 것이 yum이라고 합니다.의존성 문제4.3.2 편리하게 패키지를 설치하는 YUM YUM(Yellowdog Updater Modified)은 rpm의 의존성 문제를 해결한 명령어입니다. 의존성이 필요한 패키지들을 찾아서 먼저 설치해주는 명령어입니다. CentOS 프로젝트가 제공하는 rpm 저장소에서 설치할 rpm파일 뿐만아니라 인터넷에서 의존성이 있는 파일을 찾아서 설치합니다. rpm저장소는 /etc/yum.repos.d/에 있습니다. 인터넷을 통해 패키지를 설치하므로 인터넷에 연결되어 있어야합니다.YUM의 기본 사용법 기본 설치방법 yum -y install 패키지이름 -y 옵션은 yes/no를 묻는 부분을 무조건 yes로 입력한것으로 간주 rpm 파일 설치 방법 yum localinstall rpm파일이름.rpm기존 rpm과 달리 의존성이 있는 파일을 모두 설치해준다. 업데이트 가능한 목록보기 yum check-update패키지 중에서 업데이트가 가능한 목록을 출력한다. 업데이트 yum update 패키지이름어차피 yum install을 하면 업데이트기능을 수행하므로 잘 사용하지 않음. 삭제 yum remove 패키지이름 정보 확인 yum info 패키지이름 패키지 그룹 설치 yum groupinstall &quot;패키지그룹이름&quot; 패키지 리스트 확인 yum list 패키지이름 특정 파일이 속한 패키지 이름 확인 yum provides 파일이름 GPG 키 검사 생략 yum install --nogpgcheck rpm파일이름.rpm 기존 저장소 목록 지우기 yum clean all 4.3.3 파일 압축과 묶기파일 압축 xz&#39;파일 이름&#39;을 압축파일인 ~.xz로 만듬 기존파일은 삭제된다.xz 파일이름&#39;파일 이름.xz&#39;를 일반 파일인 ~로 만듬. d는 Decompressxz -d 파일이름.xz&#39;파일이름.xz&#39; 압축 파일에 포함된 파일 목록과 압축률 등을 출력l는 listxz -l 파일이름.xz압축 후에 기존 파일을 삭제하지 않고 그대로 둔다.k는 keepxz -k 파일이름외에도 bzip2, bunzip2(bzip2 압축을 품.), gzip, gunzip(gzip 압축을 품.), zip, unzip이있다. 사용법은 다 비슷합니다.파일 묶기 tar동작c -&amp;gt; 새로운 묶음을 만듬.x -&amp;gt; 묶인 파일을 푼다.t -&amp;gt; 묶음을 풀기 전에 묶인 경로를 보여준다.C -&amp;gt; 묶음을 풀 때 지정된 디렉터리에 압축을 푼다. 지정하지 않으면 같은 디렉터리에 푼다.옵션f(필수) -&amp;gt; 묶음 파일 이름 지정.v -&amp;gt; visual의 의미로 파일이 묶이거나 풀리는 과정을 보여줌 J -&amp;gt; tar + xzz -&amp;gt; tar + gzipj -&amp;gt; tar + bzip24.3.4 시스템 설정 날짜 및 설정 system-config-date //패키지 없다고 뜨면 yum으로 설치 네트워크 설정 nmtui 방화벽 설정 firewall-config 서비스(데몬) 설정 ntsysv 그 외에 사용되는 설정 명령어 system-config-keyboardsystem-config-languagesystem-config-printersystem-config-userssystem-config-kickstart키보드, 언어, 프린터, 사용자, 킥스타트 설정 4.3.5 CRONT과 ATcron cron은 주기적으로 반복되는일을 자동으로 실행할 수 있도록 시스템 작업을 예약해 놓는 것. 00 05 1 * * root cp -r /home /backup분 시 일 월 요일 사용자 실행명령 *는 매월, 모든 요일을 칭함. 해석을 하면 매월 1일 새벽 5시 00분에 ‘cp -r /home /backup’ 명령어를 실행한다. cron은 주기적으로 실행할 내용을 디렉터리에 넣어 놓고 작동한다.at at 명령어는 cron과 달리 일회성 작업을 예약하는 것이다. 예약 : at 시간 at 3:00am tomorrowat now + 1 hours 확인 : at -l 취소 : atrm 작업번호" }, { "title": "Spring - 1 스프링 에제 프로젝트 PetClinic", "url": "/posts/Springbks01/", "categories": "Java, 2. Spring_백기선_예제로 배우는 스프링입문", "tags": "Spring", "date": "2021-01-11 00:00:00 +0900", "snippet": "해당 자료는 인프런 백기선님의 예제로 배우는 스프링 입문(개정판) 강의노트입니다..1. 프로젝트 설정준비물은 Intellij입니다.https://github.com/spring-projects/spring-petclinic 해당 URL에서 적당한 폴더에 git clone을 해줘서 프로젝트를 가져오고 intellij에서 열어줬습니다.강의를 보면 git bash가 intellij와 연동되어 있지만, 저는 연동되어 있지 않았습니다.https://violetboralee.medium.com/intellij-idea%EC%99%80-git-bash-%EC%97%B0%EB%8F%99%ED%95%98%EA%B8%B0-63e8216aa7de이 블로그를 통해 cmd에서 gitbash로 바꿀 수 있었습니다.그리고 해당 깃 Readme.md에 있는 순서대로 초기설정을 해주었습니다../mvnw packagejava -jar target/*.jar //jar파일을 실행함.&amp;lt;localhost:8080&amp;gt;으로 확인이후 FIND OWNERS 탭에서 ADD Owner와 ADD Pet을 통해 정보를 추가.또한, Add visit을 통해 방문일정을 추가해주었습니다. 예전에 배운 Intellij에서 main method를 run을 시켜 실행해버리는 것은 ./mvnw package(메이븐 패키징)를 안해주면 오류가 날 수 있다고합니다. 플러그인이 먼저 동작해야하는데 하지 않으면 로컬에서 화면이 깨질 수도 있습니다.2. 프로젝트 살펴보기해당 웹이 어떻게 돌아가는 지 알려주셨다.Log를 찍기 위해 application.properties에서 주석문을 제거해줍니다.logging.level.org.springframework.web=DEBUG 디버거 찍는법은 vs와 같이 빨간점으로 찍고 디버그모드로 돌리면 된다.3. 프로젝트 과제 풀이 LastName이 아니라 FirstName으로 검색해 볼까? 정확히 일치하는게 아니라 해당 키워드가 들어있는 걸 찾아볼까? Owner에 age 추가이 세가지를 고치기로 했습니다.3.1. LastName을 FirstNamed으로 바꾸기화면에 보이는 Lastname을 Firstname으로 바꾸기위해 findOwners.html에서&amp;lt;input class=&quot;form-control&quot; th:field=&quot;*{Lastname}&quot; size=&quot;30&quot; -&amp;gt; &amp;lt;input class=&quot;form-control&quot; th:field=&quot;*{firstName}&quot; size=&quot;30&quot;OwnerController.java 파일에서@GetMapping(&quot;/owners&quot;) public String processFindForm(Owner owner, BindingResult result, Map&amp;lt;String, Object&amp;gt; model) { // allow parameterless GET request for /owners to return all records if (owner.getFirstName() == null) { owner.setFirstName(&quot;&quot;); // empty string signifies broadest possible search } // find owners by first name Collection&amp;lt;Owner&amp;gt; results = this.owners.findByFirstName(owner.getFirstName()); if (results.isEmpty()) { // no owners found result.rejectValue(&quot;lastName&quot;, &quot;notFound&quot;, &quot;not found&quot;); return &quot;owners/findOwners&quot;; } else if (results.size() == 1) { // 1 owner found owner = results.iterator().next(); return &quot;redirect:/owners/&quot; + owner.getId(); } else { // multiple owners found model.put(&quot;selections&quot;, results); return &quot;owners/ownersList&quot;; } }이렇게 LastName과 관련된 메소드를 다 firstName메소드로 바꿔줍니다.또한 OwnerRepository.java 파일에서@Query(&quot;SELECT DISTINCT owner FROM Owner owner left join fetch owner.pets WHERE owner.firstName LIKE :firstName%&quot;) @Transactional(readOnly = true) Collection&amp;lt;Owner&amp;gt; findByFirstName(@Param(&quot;firstName&quot;) String firstName);이렇게 새로운 Query문을 만들어주고 firstName()을 반환하도록 합니다.3.2. 정확히 일치하는게 아니라 해당 키워드가 들어있는 걸 찾아볼까?위에서 작성한 쿼리문을 수정해줍니다.@Query(&quot;SELECT DISTINCT owner FROM Owner owner left join fetch owner.pets WHERE owner.firstName LIKE %:firstName&quot;) @Transactional(readOnly = true) Collection&amp;lt;Owner&amp;gt; findByFirstName(@Param(&quot;firstName&quot;) String firstName); :%firstName이 아닌 %:firstName으로 적어야 :firtName이 매개변수로 치환된다고 합니다.3.3.Owner에 age 추가Owner.java 파일에private Integer age;public Integer getAge() { return age; }public void setAge(Integer age) { this.age = age;}을 추가해주고 서버를 재시작하면 DB에 age가 없기에 Query문 오류가 납니다.따라서 resources/db/hsqldb/schema.sql을 수정해줘야합니다.age INTERGER를 추가해주고, INSERT문에서 age도 추가해주기 위해 /resources/db/hsqldb/data.sql에 임의의 나이를 설정해줍니다.INSERT INTO owners VALUES (1, &#39;George&#39;, &#39;Franklin&#39;, 20, &#39;110 W. Liberty St.&#39;, &#39;Madison&#39;, &#39;6085551023&#39;);INSERT INTO owners VALUES (2, &#39;Betty&#39;, &#39;Davis&#39;,20, &#39;638 Cardinal Ave.&#39;, &#39;Sun Prairie&#39;, &#39;6085551749&#39;);INSERT INTO owners VALUES (3, &#39;Eduardo&#39;, &#39;Rodriquez&#39;,20, &#39;2693 Commerce St.&#39;, &#39;McFarland&#39;, &#39;6085558763&#39;);INSERT INTO owners VALUES (4, &#39;Harold&#39;, &#39;Davis&#39;,20, &#39;563 Friendly St.&#39;, &#39;Windsor&#39;, &#39;6085553198&#39;);INSERT INTO owners VALUES (5, &#39;Peter&#39;, &#39;McTavish&#39;,20, &#39;2387 S. Fair Way&#39;, &#39;Madison&#39;, &#39;6085552765&#39;);INSERT INTO owners VALUES (6, &#39;Jean&#39;, &#39;Coleman&#39;,20, &#39;105 N. Lake St.&#39;, &#39;Monona&#39;, &#39;6085552654&#39;);INSERT INTO owners VALUES (7, &#39;Jeff&#39;, &#39;Black&#39;,20, &#39;1450 Oak Blvd.&#39;, &#39;Monona&#39;, &#39;6085555387&#39;);INSERT INTO owners VALUES (8, &#39;Maria&#39;, &#39;Escobito&#39;,20, &#39;345 Maple St.&#39;, &#39;Madison&#39;, &#39;6085557683&#39;);INSERT INTO owners VALUES (9, &#39;David&#39;, &#39;Schroeder&#39;,20, &#39;2749 Blackhawk Trail&#39;, &#39;Madison&#39;, &#39;6085559435&#39;);INSERT INTO owners VALUES (10, &#39;Carlos&#39;, &#39;Estaban&#39;,20, &#39;2335 Independence La.&#39;, &#39;Waunakee&#39;, &#39;6085555487&#39;);화면에서 나이를 물어봐야하기때문에 createOrUpdateOwnerForm.html도 고쳐줘야합니다.&amp;lt;input th:replace=&quot;~{fragments/inputField :: input (&#39;Age&#39;, &#39;age&#39;, &#39;text&#39;)}&quot; /&amp;gt;다음 코드를 추가해줍니다.쿼리문을 보내려하면 에러가 뜨는데 강의 버전이랑 clone한 프로젝트 버전이 달라서 application.proterties를 바꿔줘야합니다.database=h2 를database=hsqldb로 바꿔줍니다.검색을 했을 때 나이를 출력해주기 위해ownerList.html의 코드를 손봐줍시다.&amp;lt;th style=&quot;width: 200px;&quot;&amp;gt;Age&amp;lt;/th&amp;gt;&amp;lt;td th:text=&quot;${owner.age}&quot;/&amp;gt;이렇게 추가해주면성공적으로 들어가는 것을 볼 수 있습니다.또한 User를 누르면 age에 대한 정보가 누락되어있으므로 해당사항도 해결해주어야 합니다.ownerDetails.html에서 코드를 추가해줍니다.~ &amp;lt;tr&amp;gt; &amp;lt;th&amp;gt;Age&amp;lt;/th&amp;gt; &amp;lt;td&amp;gt;&amp;lt;b th:text=&quot;*{age}&quot;&amp;gt;&amp;lt;/b&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt;~성공했고 마지막에 유저를 임의적으로 만들었을 때 제대로 들어가는 지 확인해봅니다.제대로 들어갔습니다." }, { "title": "Baekjoon11057-오르막 수", "url": "/posts/baekjoon11057/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, DP", "date": "2021-01-10 18:30:00 +0900", "snippet": "백준 사이트 11057 - 오르막 수 문제입니다.1. 문제https://www.acmicpc.net/problem/110572. Input , Output3. 분류 및 난이도DP문제입니다.비슷한 문제를 안풀어봤으면 어렵다는 생각이 들 수 밖에 없습니다.DP를 2차원으로 써야하기 때문입니다.공책으로 먼저 그려나가면서 규칙을 찾으면 쉽게 풀 수 있습니다.백준에서는 Sliver1의 난이도를 책정하고 있습니다.4. 생각한 것들dp[2][2]인 경우 (02,12,22) 세 가지 경우인데 (02,12)는 이미 DP[2][1]에서 세준거나 다름 없습니다.중요한건 뒷자리수가 아니라 그 앞에 뭐가 오느냐가 중요한 것이기 때문입니다.dp[3][2]인 경우 (002,012,112,022,122,222)로 총 6가지입니다. 여기서 022,122,222는 맨 뒷숫자 2를 제외하면 02,12,22인데 이것은 앞에서 설명한 dp[2][2]와 같습니다.나머지 002,012,112도 맨 뒷숫자 2를 제외하면 00,01,11인데 이것은 dp[3][1]와 같습니다.dp[N][0]인 끝자리가 0으로 끝나는 경우 0,00,000 .. 밖에 못오므로 무조건 1입니다.마지막에 10007로 나눠주는 것도 까먹지 않고 수행해야합니다.5. code#include&amp;lt;iostream&amp;gt;using namespace std;int dp[1001][10] = { 0, };int n;int result = 1;void Input(){ cin &amp;gt;&amp;gt; n; for (int i = 0; i &amp;lt; 10; ++i) dp[1][i] = 1; for (int i = 0; i &amp;lt;= n; ++i) dp[i][0] = 1;}void Solve(){ for (int i = 2; i &amp;lt;= n; ++i) { for (int j = 1; j &amp;lt; 10; ++j) { dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % 10007; if (i == n) { result += dp[i][j]; result %= 10007; } } }}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); Input(); Solve(); if (n == 1) cout &amp;lt;&amp;lt; 10; else cout &amp;lt;&amp;lt; result;}6. 후기안풀어봤으면 어떻게 이런문제를 다시 생각하기 힘들지 않을까" }, { "title": "Baekjoon2589-보물섬", "url": "/posts/baekjoon2589/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, BFS", "date": "2021-01-10 17:30:00 +0900", "snippet": "백준 사이트 2589 - 보물섬 문제입니다.1. 문제https://www.acmicpc.net/problem/25892. Input , Output3. 분류 및 난이도bfs문제입니다.기존 bfs와 달리 변수 하나를 더 저장하면 쉽게 풀 수 있습니다.백준에서는 Gold5난이도를 책정하고 있습니다.4. 생각한 것들 변수 하나를 더 저장하기 위해 pair를 두 개 겹쳐 썼습니다. 마지막에 카운트 값을 비교하기위해 count라는 변수를 함수의 지역변수로 선언했습니다. (값이 사라지지 않기 위하여)5. code#define _CRT_SECURE_NO_WARNINGS#include&amp;lt;cstdio&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;algorithm&amp;gt;#include&amp;lt;cstring&amp;gt;const int MAX = 51;char MAP[MAX][MAX] = { &#39;0&#39;, };bool v[MAX][MAX] = { false, };using namespace std;int row, col;int result = 0;int dx[4] = { -1,0,1,0 };int dy[4] = { 0,1,0,-1 };void Input(){ scanf(&quot;%d %d&quot;, &amp;amp;row, &amp;amp;col); getchar(); for (int i = 0; i &amp;lt; row; ++i) { for (int j = 0; j &amp;lt; col; ++j) scanf(&quot;%1c&quot;, &amp;amp;MAP[i][j]); getchar(); }}void BFS(int x, int y){ memset(v, false, sizeof(v)); queue&amp;lt;pair&amp;lt;pair&amp;lt;int, int&amp;gt;, int&amp;gt;&amp;gt; q;//첫번째와 두번째는 좌표 값, 세번째는 거리 q.push(make_pair(make_pair(x, y), 0)); v[x][y] = true; int count = 0; while (!q.empty()) { int x = q.front().first.first; int y = q.front().first.second; count = q.front().second; q.pop(); for (int k = 0; k &amp;lt; 4; ++k) { int newX = x + dx[k]; int newY = y + dy[k]; if (0 &amp;lt;= newX &amp;amp;&amp;amp; newX &amp;lt; row &amp;amp;&amp;amp; 0 &amp;lt;= newY &amp;amp;&amp;amp; newY &amp;lt; col &amp;amp;&amp;amp; v[newX][newY] == false &amp;amp;&amp;amp; MAP[newX][newY] == &#39;L&#39;) { q.push(make_pair(make_pair(newX, newY), count + 1)); v[newX][newY] = true; } } } //비교문 if (result &amp;lt; count) result = count;}void Solve(){ for (int i = 0; i &amp;lt; row; ++i) { for (int j = 0; j &amp;lt; col; ++j) { if (MAP[i][j] == &#39;L&#39;) BFS(i, j); } } printf(&quot;%d&quot;, result);}int main(){ Input(); Solve();}6. 후기원큐 성공." }, { "title": "이것이 리눅스다. - 4. 리눅스 명령어, 개념(1)", "url": "/posts/ThisisLinuxC4/", "categories": "Linux, ThisisLinux(since2016Stop)", "tags": "This is Linux", "date": "2021-01-07 23:00:00 +0900", "snippet": "한빛 미디어의 이것이 리눅스다. 책을 정리한 자료입니다.4.1 시작과 종료터미널/콘솔에서 시스템 종료 명령 실행하는 법이 있습니다. poweroff / shutdown -P now/ halt -p / init () -P, -p 는 시스템 종료를 의미한다. shutdown -P +10 // 10분 후에 종료 (P:powerOff)shutdown -r 22:00 // 오후 10시에 재부팅(r:reboot)shutdown -c // 예약된 shutdown을 취소 (c: cancel)shutdown -k +15 // 현재 접속한 사용자에게 15분 후에 종료된다는 메시지를 보내지만 실제로 종료는 안됨. 재부팅 명령어shutdown -r nowrebootinit 6 로그아웃 명령어 logoutexit 4.1.1 가상콘솔 사용하기centos는 총 6개의 가상 콘솔을 제공한다. X 윈도가 1번째이고 2~6번째는 텍스트모드로 제공된다.키는 ‘Ctrl + Alt + F1~F6 ‘ 이다. 런레벨런레벨은 init 명령어 뒤에 붙는 숫자를 런레벨이라고 한다. 런레벨 영문모드 설명 비고 0 Power Off 종료모드   1 Rescue 시스템 복구 모드 단일 사용자모드 2 Muti-User   사용하지 않음 3 Muti-User 텍스트 모드의 다중 사용자 모드   4 Muti-User   사용하지않음 5 Graphical 그래픽 모드의 다중 사용자 모드   6 Reboot     런레벨 모드 확인하려면 /lib/systemd/system 디렉터리의 runlevel?.target 파일을 확인한다.(링크파일이다.)4.1.2 부팅 시에 텍스트 모드로 부팅되도록 런레벨을 변경시키기ls -l /etc/systemd/system/default.target이 명령어를 사용하면~ system/graphical.target 이렇게 나와있는데, 현재 그래픽모드로 부팅이된다는 것이다.텍스트 모드로 부팅되도록 런레벨을 바꾸려면 다음 명령어를 치면 된다.ln -sf /lib/systemd/system/multi-user.target /etc/systemd/system/default.targetls -l /etc/systemd/system/default.targetreboot // 재접속4.1.3 텍스트모드를 그래픽 모드로 변경시키기ln -sf /lib/system/graphical.target /etc/systemd/system/default.targetreboot //재접속4.1.4 자동 완성과 히스토리 사용하기history // 사용했던 명령어를 볼 수 있다.history -c // 기억되었던 명령어를 삭제한다.밑은 history를 쓰고 다시 history -c를 통해 기억되었던 명령어를 삭제시킨 것이다.자동완성은 Tab 키를 눌러 확인할 수 있다. 비슷한 이름이 많을 경우 Tab 키를 두 번 누르면 된다.4.1.5 vi 편집기 사용하기vi //vi편집기 키기esc를 누르면 나오는 것은 ‘ex 모드’, ‘라인 명령 모드’라 부른다.일반모드는 ‘명령 모드’라고 한다. 이 상태에서 ‘a’(append), ‘I’(insert) 키를 누르면 ‘입력 모드’로 바뀐다.‘wq!’는 저장(Write)하고 종료(Quit)된다.만약 수정 작업중 정상적으로 종료되지 않았으면 .swp 파일이 생겼을 것이다.rm -f 파일명 //으로 삭제하자.vi 파일명 오류를 무시하고 spacebar를 두 번 누르고 ‘:q!’ 로 나온다.임시파일이 만들어진 것은 전의 작업이 제대로 종료되지 않았을 경우 나타나는 것이다.ex 모드에서 문자열을 치환하려면 ‘%s/기존문자열/새문자열’형식으로 사용해야 한다.:%s/centos/linux //centos를 linux로 바꿈.4.1.6 마운트와 CD/DVD/USB의 활용cd나 dvd를 잘 사용하지 않으므로 간단히 봤습니다.ISO 파일을 생성하는 명령어는 ‘genisoimage’이다.ISO 파일을 cd로 굽는 명령어는 ‘cdrecord’이다.ISO 파일을 dvd로 굽는 명령어는 ‘growisofs’이다.다음 명령어로 위의 명령어를 사용하기 위한 패키지가 설치되어있는 지 확인할 수 있다.설치가 되어있지 않다면 아무것도 출력되지 않는다.rpm -qa genisoimagerpm -qa wodimrpm -qa dvd+rw-tools yum -y install 패키지명 으로 설치가 가능하다.4.2 사용자 관리와 파일 속성4.2.1 사용자와 그룹사용자 확인하는 명령어vi /etc/passwdgedit /etc/passwd 사용자 이름 : 암호 : 사용자 ID : 사용자가 소속된 그룹 ID : 전체 이름 : 홈 디렉터리 : 기본 쉘암호가 x로 표시되어 있는 것은 /etc/shadow 파일에 비밀번호가 저장되어 있다는 뜻.그룹 확인하는 명령어vi /etc/group 그룹 이름 : 비밀번호 : 그룹 ID : 그룹에 속한 사용자 이름사용자 및 그룹과 관련된 명령어useradd [옵션] 사용자 이름 // 새로운 사용자 추가 /etc/password,/shadow,/group파일에 새로운 행 생김.passwd 사용자 이름 // 사용자의 비밀번호를 지정하거나 변경usermod [옵션] 사용자 이름 // 사용자의 속성을 변경usedel [옵션] 사용자 이름 // 사용자 삭제chage [옵션] 사용자 이름 // 사용자의 암호를 주기적으로 변경하도록 설정.groups [사용자이름] // 사용자가 소속된 그룹을 보여준다.groupadd [옵션] 그룹이름 // 새로운 그룹을 생성한다.groupmod [옵션] 그룹이름 // 그룹의 속성을 변경한다.groupdel 그룹이름 // 그룹을 삭제한다.gpasswd [옵션] 그룹이름 // 그룹의 암호를 설정하거나 그룹 관리를 수행한다.‘/etc/skel’는 사용자가 생성될 때 해당 디렉토리의 내용을 사용자폴더에 복사시킴.사용자가 생성될 때마다 배포를 하기원하는 파일이 있으면 skel 디렉터리에 파일을 넣어놓으면 된다.‘yum -y install system-config-users’를 통해 해당 패키지를 설치 후 ‘system-config-users-‘ 명령어를 입력하면 X 윈도에서 사용자를 쉽게 관리할 수 있는 UI를 제공한다.4.2.2 파일 디렉토리의 소유와 허가권파일 유형디렉토리 : d일반적인 파일 : -블록 디바이스 : b -&amp;gt; 하드디스크, 플로피 디스크, CD 등문자 디바이스 : c -&amp;gt; 마우스, 키보드, 프린터 등링크 : l -&amp;gt; window의 바로 가기 아이콘과 비슷한 역할로 연결된 파일을 의미. 실제 파일은 다른 곳에 존재함.파일 허가권읽기 : r (read)쓰기 : w (write)실행 : x (execute)위의 예제에서 뿐만아니라 ‘rw-‘, ‘r–’, ‘r–’ 이런 식으로 3개씩 끊어서 봐야한다.첫 번째는 소유자(User) 권한, 두 번째는 그룹(Group) 권한, 세 번째는 그 외 사용자(Other) 권한이다.‘rw-‘에서첫 번째 칸은 ‘4’ 두 번째칸은 ‘2’ 세 번째 칸은 ‘1’로 표현되며 ‘rw-‘는 6으로 표현될 수 있다.‘rwx’인 경우는 4+2+1로 7로 표현된다.위의 예제는 소유자는 읽고 쓸 수 있으며 그룹과 다른사용자는 읽기만 가능하다. 라는 뜻이다.파일 소유권파일 소유권은 파일을 소유한 사용자와 그룹을 의미한다.‘chown’ 명령어를 통해 바꿀 수 있다.chown centos sample.txt // sample.txt 파일의 소유자를 centos로 바꾸라는 의미chwon centos.centos sample.txt // sample.txt 파일의 그룹도 centos 그룹으로 바꾸라는 의미.chgrp centos sample.txt // 그룹만 centos로 바꾸라는 명령어링크하드 링크 파일과 심볼릭 링크파일이라는 두 가지 종류의 링크파일이 있다.이해를 돕기위한 간단한 예제가 있다.vi basefile // basefile 을 만들고 안에 아무 내용이나 넣고 저장하고 끄자.ln basefile hardlink // basefile을 기반한 hardlink파일을 만든다.ln -s basefile softlink // basefile을 기반한 softlink파일을 만든다.ls -il // -il 옵션을 통해 inode 번호를 제일 앞에 출력한다.cat hardlink // 하드 링크 내용을 확인 cat softlink // 소프트 링크 내용을 확인위의 결과를 보면 hardlink파일과 basefile의 inode값은 같다. softlink는 일종의 포인터라 생각하면 쉽다.만약 softlink 파일과 원본 파일이 다른 디렉토리에 위치하게 되면 연결이 끊어져 열리지 않는다." }, { "title": "Baekjoon1780-종이의 개수", "url": "/posts/baekjoon1780/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, divide", "date": "2021-01-07 19:30:00 +0900", "snippet": "백준 사이트 1780 - 종이의 개수 문제입니다.1. 문제https://www.acmicpc.net/problem/17802. Input , Output3. 분류 및 난이도분할정복 문제입니다.재귀를 많이 사용하지 않아 뇌가 굳어버린 저는 어려웠습니다.다른 사람의 코드를 참고하여 작성하였습니다.백준에서는 sliver2 난이도를 책정하고 있습니다.4. 생각한 것들 솔직히 무슨 말 하는지는 알겠는데 코드로 그려지지가 않았다.5. code#include&amp;lt;iostream&amp;gt;using namespace std;int MAP[2200][2200];int n;int result[3] = { 0,0,0 };void Input(){ cin &amp;gt;&amp;gt; n; for (int i = 0; i &amp;lt; n; ++i) { for (int j = 0; j &amp;lt; n; ++j) cin &amp;gt;&amp;gt; MAP[i][j]; }}bool check(int i, int j,int size){ int start = MAP[i][j]; for (int row = i; row &amp;lt; i + size; ++row) { for (int col = j; col &amp;lt; j + size; ++col) { if (start != MAP[row][col]) return false; } } return true;}void divide(int i, int j,int size){ //MAP[i][j]+1 을 해주는 이유는 -1이 들어왔을 경우 0으로 바꿔줘야함. -1인덱스는 없으므로. if (check(i, j, size)) result[MAP[i][j] + 1]++; else { int div = size / 3; for (int row = 0; row &amp;lt; 3; ++row) { for (int col = 0; col &amp;lt; 3; ++col) divide(i + row * div, j + col * div, div); } }}void Solve(){ divide(0, 0,n); cout &amp;lt;&amp;lt; result[0] &amp;lt;&amp;lt; &#39;\\n&#39; &amp;lt;&amp;lt; result[1] &amp;lt;&amp;lt; &#39;\\n&#39; &amp;lt;&amp;lt; result[2] &amp;lt;&amp;lt; &#39;\\n&#39;;}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); Input(); Solve(); return 0;}6. 후기분할정복 어렵다." }, { "title": "Baekjoon1149-RGB 거리", "url": "/posts/baekjoon1149/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, BFS", "date": "2021-01-07 17:30:00 +0900", "snippet": "백준 사이트 1149 - 카드 구매 문제입니다.1. 문제https://www.acmicpc.net/problem/11492. Input , Output3. 분류 및 난이도DP문제입니다.이 문제가 어렵다고 느껴지는 것은 배열자체가 입력으로 들어와서 어려움을 느끼지 않나 싶습니다.백준에서는 sliver1의 난이도를 책정하고 있습니다.4. 생각한 것들 정석 DP대로 풀었습니다. 풀다보니 DP라는 배열이 필요할까? 라고 생각하며 없애고 제출하였습니다. -&amp;gt; 성공5. code#include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;int arr[1001][3] = { 0, };int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); int n; cin &amp;gt;&amp;gt; n; for (int i = 1; i &amp;lt;= n; ++i) { for (int j = 0; j &amp;lt; 3; ++j) cin &amp;gt;&amp;gt; arr[i][j]; } for (int i = 2; i &amp;lt;= n; ++i) { arr[i][0] += (min(arr[i - 1][1], arr[i - 1][2])); arr[i][1] +=(min(arr[i - 1][0], arr[i - 1][2])); arr[i][2] += (min(arr[i - 1][0], arr[i - 1][1])); } cout&amp;lt;&amp;lt;min(min(arr[n][0], arr[n][1]), arr[n][2]); return 0;}6. 후기dp없이 그냥 제출해봤는데 성공해서 나이스." }, { "title": "Baekjoon5014-스타트 링크", "url": "/posts/baekjoon5014/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, BFS", "date": "2021-01-07 15:30:00 +0900", "snippet": "백준 사이트 5014 - 스타트링크 문제입니다.1. 문제https://www.acmicpc.net/problem/50142. Input , Output3. 분류 및 난이도BFS문제입니다.count에 대한 정보를 갖고 있어야합니다.백준에서는 gold5 난이도를 책정하고 있습니다.4. 생각한 것들 어렵지 않았습니다.5. code#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstring&amp;gt;#include&amp;lt;queue&amp;gt;using namespace std;int F, S, G, U, D;void Input(){ cin &amp;gt;&amp;gt; F &amp;gt;&amp;gt; S &amp;gt;&amp;gt; G &amp;gt;&amp;gt; U &amp;gt;&amp;gt; D;}int Solve(){ //BFS bool* v = new bool[F + 1]; memset(v, false, sizeof(bool) * (F + 1)); queue&amp;lt;pair&amp;lt;int,int&amp;gt;&amp;gt; q; q.push(make_pair(S,0)); v[S] = true; while (!q.empty()) { int x = q.front().first; int cnt = q.front().second; q.pop(); if (x == G) { delete v; return cnt; } if (x+U &amp;lt;= F &amp;amp;&amp;amp; !v[x + U]) { v[x + U] = true; q.push(make_pair(x + U,cnt+1)); } if (x-D &amp;gt;0 &amp;amp;&amp;amp; !v[x - D]) { v[x - D] = true; q.push(make_pair(x - D,cnt+1)); } } delete v; return -1;}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); Input(); int result = Solve(); if (result == -1) { cout &amp;lt;&amp;lt; &quot;use the stairs&quot;; } else { cout &amp;lt;&amp;lt; result; } return 0;}6. 후기런타임 에러가 2번 떴다. 한 번은 double free라고 메모리 해제를 두 번 해줬다해서 전역변수로 놓은 v[]배열을 지역변수로 놓고 관리해줬다.1월7일 부로 baekjoon에서 런타임 에러 이유를 일부 알려준다. solved.ac에도 갱신 주기가 줄었던데.. baekjoon 개발자들 일을 열심히 하는 것 같다." }, { "title": "이것이 리눅스다. - 3.Centos 설치", "url": "/posts/ThisLinuxC3/", "categories": "Linux, ThisisLinux(since2016Stop)", "tags": "This is Linux", "date": "2021-01-07 01:00:00 +0900", "snippet": "한빛 미디어의 이것이 리눅스다. 책을 정리한 자료입니다.Chapter2는 거의 아는 내용이라 스킵하였습니다.Chapter3는 Centos를 설치하는 것인데, 기존에 사용하던 oracle vritual box가네트워크 오류가 생겼고, 해결하기 어려워 vmware 16 버전으로 환경설정을 다시하고 있습니다.vmware16 무료버전은 네트워크 설정하는 방법들이 편법이므로 그냥 vmware에서 제공하는 ip로 실습을 진행하였습니다.Chapter3에서 말하는 환경들은 다음과 같습니다.Server환경을 위해 Centos 업데이트를 끔, network설정, SELinux 기능 끄기network 설정 부분에서 버전차이인지 오류가 너무 많이 나서 그냥 진행하기로 했습니다. 구글링을 해본 결과 많은 사람들이 네트워크 관련 부분에서 오류를 많이 겪더군요.flashplayer를 다운받아야하는데, 2020년 이후로 서비스가 종료되었으므로 그냥 진행.. 찾아보니 없어도 된다해서 진행하였습니다.Clientroot로 로그인 못하게 막기뭘 잘못했는 지 몰라도 root가 아니여도 접속이 안된다.결국 client 재설치 했다. root권한 그냥 안막았습니다. flash 깔기 -&amp;gt; 생략했습니다. 서버와 같이 버전 유지하기 자동로그인 기능 활성화Server(B) vi로 Server에 해줬던 설정해주기 네트워크 설정(고정 ip 할당) -&amp;gt; 또 오류날 것 같아서 생략 보안 기능 끄기 해상도 변경 -&amp;gt; 생략 wget 설치 wget을 이용해서 필수적인 패키지 설치WinClient window를 설치하기 위해 윈도우 10 평가판.iso을 다운받음 window를 좀 더 부드럽게 해준다는 VMware Tools 설치.2017년 책이라 그런지 지금과는 다른 부분도 있고 그 부분에서 오류가 많이 발생하는 것 같다.뭘하든 환경설정이 항상 오래걸리는 것 같다.텐서플로 깔 때도 몇시간 걸린것 같은데.." }, { "title": "Baekjoon11052-카드 구매하기", "url": "/posts/baekjoon11052/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, DP", "date": "2021-01-06 19:30:00 +0900", "snippet": "백준 사이트 11052 - 카드 구매하기 문제입니다.1. 문제https://www.acmicpc.net/problem/110522. Input , Output3. 분류 및 난이도DP문제입니다.백준에서는 sliver1의 난이도를 책정하고 있습니다.4. 생각한 것들 입력 값들이 크지 않아서 for문 2개로 해결이 가능합니다. 처음에는 배수들만 생각해줬는데, 그것에도 문제가 있습니다. 모든 경우를 따졌습니다.5. code#include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;int n;int dp[10001];void Input(){ cin &amp;gt;&amp;gt; n; for (int i = 1; i &amp;lt;= n; ++i) cin &amp;gt;&amp;gt; dp[i];}void Solve(){ for (int i = 2; i &amp;lt;= n; ++i) { dp[i] = max(dp[i - 1] + dp[1], dp[i]); // i까지 합들을 계산해서 갱신 위의 점화식이 맞는지는 모르지만, 맞았기에 for (int j = 1; j &amp;lt;= i; ++j) { dp[i] = max(dp[i - j] + dp[j], dp[i]); } /* 처음에 실수한 배수로 계산하기 int temp=1; for (int j = i; j &amp;lt;= n; j =i* temp) { dp[j] = max(dp[j], dp[i] * temp); ++temp; } */ }}void printdp(){ for (int i = 0; i &amp;lt;= n; ++i) cout &amp;lt;&amp;lt; dp[i] &amp;lt;&amp;lt; &quot; &quot;;}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); Input(); Solve(); cout &amp;lt;&amp;lt; dp[n];}6. 후기고치는데 오래걸리진 않아서 다행이다." }, { "title": "Baekjoon16234-인구 이동", "url": "/posts/baekjoon16234/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, BFS", "date": "2021-01-06 15:30:00 +0900", "snippet": "백준 사이트 11723 - 집합 문제입니다.1. 문제https://www.acmicpc.net/problem/162342. Input , Output3. 분류 및 난이도BFS문제입니다. 분기별로 처리해줘야할 것들이 있어서 신경써야할 부분이 있습니다.백준에서는 gold5 난이도를 책정하고 있습니다.4. 생각한 것들 당연한 말이겠지만 문제해석에 시간을 많이 썼습니다. 저 같은 경우 예제 4번이 이해가 안되서 먼저 그려보고 같은 방식으로 예제 5번에 대입하여 결과를 얻었습니다. 절대값을 구하기 위해 “cmath” library의 trunc()함수를 사용하였습니다. trunc() 함수는 인자1개를 받고 그 값의 소수점을 버리는 함수입니다. 5. code너무 하드코딩해서 안될 줄 알았는데 성공해서.. 수정안하겠습니다.주석은 보기편하게 그냥 포함하겠습니다.#include&amp;lt;iostream&amp;gt;// 입출력#include&amp;lt;queue&amp;gt;// BFS#include&amp;lt;cmath&amp;gt;// trunc#include&amp;lt;cstring&amp;gt;// memsetusing namespace std;const int MAX = 51;int MAP[MAX][MAX];bool v[MAX][MAX];int n, l, r;//결과int counting = 0;//좌표 이동을 위한int dx[4] = { -1,0,1,0 };int dy[4] = { 0,1,0,-1 };void Input(){ cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r; for (int i = 0; i &amp;lt; n; ++i) { for (int j = 0; j &amp;lt; n; ++j) cin &amp;gt;&amp;gt; MAP[i][j]; }}//중간 출력void printarr(){ for (int i = 0; i &amp;lt; n; ++i) { for (int j = 0; j &amp;lt; n; ++j) cout &amp;lt;&amp;lt; MAP[i][j] &amp;lt;&amp;lt; &#39; &#39;; cout &amp;lt;&amp;lt; &#39;\\n&#39;; }}void BFS(){ queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; q; queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; q2;// 값을 바꿔줄 때 필요 // 구역 갯수 int num; //제일 큰 반복문을 끝내기 위한 변수 int temp; //특정 조건을 거챠야 couting할 수 있도록 하는 변수 bool check = false; //먼저 선언 int add; do { //이전 값을 저장 temp = counting; //초기화를 안해주면 무한루프 돈다. check = false; //이걸 해주는 이유는 MAP어디에 조건을 만족하는 좌표가 있을지 모르므로 순차접근 for (int i = 0; i &amp;lt; n; ++i) { for (int j = 0; j &amp;lt; n; ++j) { //이미 queue에 들어갔던 것이면 skip if (v[i][j] == false) { //일단 넣고보는 거라 효율적이지 않지만 복잡하게는 생각하기 힘듬 q.push(make_pair(i, j)); num = 1; add = 0; while (!q.empty()) { int x = q.front().first; int y = q.front().second; v[x][y] = true; q.pop(); //일단 더함 add += MAP[x][y]; //일단 넣음. q2.push(make_pair(x, y)); //범위를 돌면서 조건에 맞는건 queue에 넣음. for (int k = 0; k &amp;lt; 4; ++k) { int newX = dx[k] + x; int newY = dy[k] + y; if (0 &amp;lt;= newX &amp;amp;&amp;amp; newX &amp;lt; n &amp;amp;&amp;amp; 0 &amp;lt;= newY &amp;amp;&amp;amp; newY &amp;lt; n &amp;amp;&amp;amp; v[newX][newY] == false) { //메인 조건 절대값이 주어진 조건보다 &amp;lt;=,&amp;gt;= int absnum = abs(MAP[x][y] - MAP[newX][newY]); if (absnum &amp;gt;= l &amp;amp;&amp;amp; absnum &amp;lt;= r)// 절대값이 범위안에 들어옴. { ++num; q.push(make_pair(newX, newY)); v[newX][newY] = true; } } } } //cout &amp;lt;&amp;lt; add &amp;lt;&amp;lt;&quot; &quot;&amp;lt;&amp;lt; num &amp;lt;&amp;lt; &#39;\\n&#39;; //1개 이상의 좌표에 접근했을 시 인구이동이 일어난 것. if (num &amp;gt; 1) check = true; //임시 큐인 q2에 든 값들을 다 수정해줌. while (!q2.empty()) { int x = q2.front().first; int y = q2.front().second; q2.pop(); MAP[x][y] = trunc(add / num); } } } } //다음 인구이동을 위해 초기화 memset(v, false, sizeof(v)); //인구이동이 일어났는 지 체크 if (check) ++counting; //printarr(); //cout &amp;lt;&amp;lt; &#39;\\n&#39; &amp;lt;&amp;lt; counting&amp;lt;&amp;lt;&#39;\\n&#39;; } while (counting != temp); cout &amp;lt;&amp;lt; counting;}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); Input(); BFS(); return 0;}6. 후기한번에 성공해서 기분이 좋다.알고리즘 푸는 맛은 이거지." }, { "title": "Baekjoon11723-집합", "url": "/posts/baekjoon11723/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, String", "date": "2021-01-06 13:30:00 +0900", "snippet": "백준 사이트 11723 - 집합 문제입니다.1. 문제https://www.acmicpc.net/problem/117232. Input , Output3. 분류 및 난이도간단한 string 문제입니다.백준에서는 sliver5 난이도를 책정하고 있습니다.4. 생각한 것들 어렵지 않습니다. c++을 주로 사용하는 저는 문자열 자르기 귀찮아서 python으로 풀려고 했으나.. 오히려 저한텐 python으로 푸는게 더 어려워서 관뒀습니다. 참고로 밑의 코드의 string.compare() 함수는 같으면 0 사전순으로 앞에 있으면 -1, 뒤에있으면 1을 뱉어냅니다.5. code#include&amp;lt;iostream&amp;gt;#include&amp;lt;string&amp;gt;#include&amp;lt;cstring&amp;gt;using namespace std;bool v[21] = { false, };int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); int m; cin &amp;gt;&amp;gt; m; for (int i = 0; i &amp;lt; m; ++i) { string query; int temp = 0; cin &amp;gt;&amp;gt; query; if (query.compare(&quot;all&quot;) &amp;amp;&amp;amp; query.compare(&quot;empty&quot;))// all이나 empty아닌 경우 cin &amp;gt;&amp;gt; temp; if (!query.compare(&quot;add&quot;)) v[temp] = true; else if (!query.compare(&quot;remove&quot;)) v[temp] = false; else if (!query.compare(&quot;check&quot;)) { cout &amp;lt;&amp;lt; v[temp] &amp;lt;&amp;lt; &#39;\\n&#39;; } else if (!query.compare(&quot;toggle&quot;)) { v[temp] = !v[temp]; } else if (!query.compare(&quot;all&quot;)) memset(v, true, sizeof(v)); else if (!query.compare(&quot;empty&quot;)) memset(v, false, sizeof(v)); } return 0;}6. 후기난 왜 python이 더 어렵지.." }, { "title": "Baekjoon1463-1로 만들기", "url": "/posts/baekjoon1463/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, DP, BFS", "date": "2021-01-05 18:30:00 +0900", "snippet": "백준 사이트 1463 - 1로 만들기 문제입니다.1. 문제https://www.acmicpc.net/problem/14632. Input , Output3. 분류 및 난이도DP문제입니다.저는 bfs와 dp를 이용해서 풀었습니다.백준에서는 sliver3난이도를 책정하고 있습니다.4. 생각한 것들 3가지의 경우의 수로 반복되는 문제이므로 dp가 떠오르고 재귀함수가 떠오르는데, 재귀를 잘 못 쓰므로 bfs를 쓰기로 했습니다. 로직은 간단했습니다. 3가지 경우의 수 모두 queue에 넣어주고 1을 가장 빨리 pop()할 경우의 count값을 출력해주었습니다.5. code주석이 없는 것#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstring&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;bool* v;int bfs(int n){ int result = 0; queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; q; q.push(make_pair(n, 0)); v[n] = true; while (!q.empty()) { int temp = q.front().first; int count = q.front().second; if (temp == 1) return count; q.pop(); if (temp % 3 == 0 &amp;amp;&amp;amp; v[temp / 3] == false)//나누어 떨어짐. { v[temp / 3] = true; q.push(make_pair(temp / 3, count + 1)); } if (temp % 2 == 0 &amp;amp;&amp;amp; v[temp / 2] == false) { v[temp / 2] = true; q.push(make_pair(temp / 2, count + 1)); } if (v[temp - 1] == false) { v[temp - 1] = true; q.push(make_pair(temp - 1, count + 1)); } }}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); int n; cin &amp;gt;&amp;gt; n; v = new bool[n + 1]; memset(v, false, sizeof(bool) * n + 1); cout &amp;lt;&amp;lt; bfs(n); return 0;}주석이 있는 것#include&amp;lt;iostream&amp;gt;#include&amp;lt;cstring&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;bool* v;int bfs(int n){ int result = 0; queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; q; q.push(make_pair(n, 0)); v[n] = true; while (!q.empty()) { int temp = q.front().first; int count = q.front().second; if (temp == 1) return count; q.pop(); if (temp % 3 == 0 &amp;amp;&amp;amp; v[temp / 3] == false)//나누어 떨어짐. { //cout &amp;lt;&amp;lt; &quot;3 &quot; &amp;lt;&amp;lt; temp&amp;lt;&amp;lt;&quot; &quot; &amp;lt;&amp;lt; count &amp;lt;&amp;lt; &#39;\\n&#39;; v[temp / 3] = true; q.push(make_pair(temp / 3, count + 1)); } if (temp % 2 == 0 &amp;amp;&amp;amp; v[temp / 2] == false) { //cout &amp;lt;&amp;lt; &quot;2 &quot; &amp;lt;&amp;lt; temp &amp;lt;&amp;lt;&quot; &quot;&amp;lt;&amp;lt; count &amp;lt;&amp;lt; &#39;\\n&#39;; v[temp / 2] = true; q.push(make_pair(temp / 2, count + 1)); } if (v[temp - 1] == false) { //cout &amp;lt;&amp;lt;&quot;1 &quot;&amp;lt;&amp;lt; temp&amp;lt;&amp;lt;&quot; &quot;&amp;lt;&amp;lt;count&amp;lt;&amp;lt;&#39;\\n&#39;; v[temp - 1] = true; q.push(make_pair(temp - 1, count + 1)); } }}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); int n; cin &amp;gt;&amp;gt; n; v = new bool[n + 1]; memset(v, false, sizeof(bool) * n + 1); cout &amp;lt;&amp;lt; bfs(n); return 0;}6. 후기1년 전에 3번 시도해서 틀린 적이 있는데, 이번에는 10분만에 풀어서 기분이 좋았다." }, { "title": "Baekjoon14502-연구소", "url": "/posts/baekjoon14502/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, BFS", "date": "2021-01-05 17:30:00 +0900", "snippet": "백준 사이트 14502 - 연구소 문제입니다.1. 문제https://www.acmicpc.net/problem/145022. Input , Output3. 분류 및 난이도BFS문제입니다.아마 삼성기출문제로 나왔던걸로 기억합니다.백준에서는 Gold5난이도를 책정하고 있습니다.4. 생각한 것들 벽 3개를 세워야하는데 맵의 최대 크기가 8 * 8 로 크지 않아서 3중 for문으로 넣어도 됩니다. 저 같은경우 2차원 맵에 3개의 데이터를 돌아가면서 조작한다는게 익숙하지 않아 고생했습니다. 물론 그게 이 문제를 헤쳐나가는데의 키 포인트인 것 같습니다. bfs 자체로는 어렵지 않습니다. 벽 3개를 꼭 세워야합니다. 3 30 0 01 1 12 2 2result : 0입니다. 과정을 머릿속에 생각했습니다. MAP을 만든다. 벽 3개를 세우고 바이러스를 뿌려야하기 때문에 이전 맵에 대한 정보가 필요합니다. 따라서 원본 맵의 정보를 갖고 있는 임시 맵을 생성합니다. 맵에서 0(빈공간)의 갯수를 세주되, 이것 또한 벽이 세워졌을 때 마다의 값에 대한 정보를 갖고 비교를 해야하므로 신경써줘야 했습니다. 벽을 세우기 위한 인덱스 범위를 잘 조절해주어야합니다. 간혹 벽 3개가 같은 곳에 세워지는 경우 등을 조심했습니다. 5. code주석이 없는 것#include&amp;lt;iostream&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;cstring&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;const int MAX = 8;int N, M;int arr[MAX][MAX];bool v[MAX][MAX] = { false };int result = 0;int dx[4] = { -1,0,1,0 };int dy[4] = { 0,1,0,-1 };void Input(){ cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; M; for (int i = 0; i &amp;lt; N; ++i) { for (int j = 0; j &amp;lt; M; ++j) cin &amp;gt;&amp;gt; arr[i][j]; }}void checknum(){ result = 0; for (int i = 0; i &amp;lt; N; ++i) { for (int j = 0; j &amp;lt; M; ++j) if (arr[i][j] == 0) { ++result; } }}//바이러스를 퍼트리기 위한void bfs(){ memset(v, false, sizeof(v)); queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; q; for (int i = 0; i &amp;lt; N; ++i) { for (int j = 0; j &amp;lt; M; ++j) { if (arr[i][j] == 2) { q.push(make_pair(i, j)); v[i][j] = true; } } } while (!q.empty()) { int x = q.front().first; int y = q.front().second; q.pop(); for (int k = 0; k &amp;lt; 4; ++k) { int newX = x + dx[k]; int newY = y + dy[k]; if (0 &amp;lt;= newX &amp;amp;&amp;amp; newX &amp;lt; N &amp;amp;&amp;amp; 0 &amp;lt;= newY &amp;amp;&amp;amp; newY &amp;lt; M &amp;amp;&amp;amp; arr[newX][newY] != 1 &amp;amp;&amp;amp; v[newX][newY] != true) { q.push(make_pair(newX, newY)); v[newX][newY] = true; arr[newX][newY] = 2; } } } checknum();}void make_wall(int x, int y){ int temp[MAX][MAX]; //복사 해두기 memcpy(temp, arr, sizeof(arr)); int wall = 0; int wall2 = 0; int wall3 = 0; for (int i = 0; wall &amp;lt; N; ++i) { if (i &amp;gt;= M) { i = 0; wall++; if (wall &amp;gt;= N) break; } wall2 = wall; if (arr[wall][i] != 0) continue; for (int j = i + 1; wall2 &amp;lt; N; ++j) { if (j &amp;gt;= M) { j = 0; wall2++; if (wall2 &amp;gt;= N) break; } wall3 = wall2; if (arr[wall2][j] != 0) continue; for (int k = j + 1; wall3 &amp;lt; N; ++k) { if (k &amp;gt;= M) { k = 0; wall3++; if (wall3 &amp;gt;= N) break; } if (arr[wall3][k] != 0) continue; arr[wall][i] = 1; arr[wall2][j] = 1; arr[wall3][k] = 1; int resultbefore = result; bfs(); result = max(result, resultbefore); memcpy(arr, temp, sizeof(temp)); } wall3 = wall2; } wall2 = wall; }}void Solve(){ //input data Input(); //make wall make_wall(0, 0); cout &amp;lt;&amp;lt; result;}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); Solve();}주석이 있는 것#include&amp;lt;iostream&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;cstring&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;const int MAX = 8;int N, M;//직접 조작할 배열int arr[MAX][MAX];//방문 기록bool v[MAX][MAX] = { false };//결과int result = 0;//좌표 이동int dx[4] = { -1,0,1,0 };int dy[4] = { 0,1,0,-1 };//배열을 출력하기 위한 함수 -&amp;gt; 불필요void printma(){ for (int i = 0; i &amp;lt; N; ++i) { for (int j = 0; j &amp;lt; M; ++j) cout &amp;lt;&amp;lt; arr[i][j] &amp;lt;&amp;lt; &quot; &quot;; cout &amp;lt;&amp;lt; &#39;\\n&#39;; }}void Input(){ cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; M; for (int i = 0; i &amp;lt; N; ++i) { for (int j = 0; j &amp;lt; M; ++j) cin &amp;gt;&amp;gt; arr[i][j]; }}//빈공간의 갯수를 세주는 함수.void checknum(){ result = 0; for (int i = 0; i &amp;lt; N; ++i) { for(int j=0;j&amp;lt;M;++j) if (arr[i][j] == 0) { ++result; } } //cout &amp;lt;&amp;lt; &quot;result : &quot; &amp;lt;&amp;lt; result&amp;lt;&amp;lt;&#39;\\n&#39;; 각 인덱스의 result를 검사해주기 위한 구문}//바이러스를 퍼트리기 위한void bfs(){ //방문기록을 초기화 해주고 바이러스인 것은 다 큐에 넣습니다. memset(v, false, sizeof(v)); queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; q; for (int i = 0; i &amp;lt; N; ++i) { for (int j = 0; j &amp;lt; M; ++j) { if (arr[i][j] == 2) { q.push(make_pair(i, j)); v[i][j] = true; } } } while (!q.empty()) { int x = q.front().first; int y = q.front().second; q.pop(); for (int k = 0; k &amp;lt; 4; ++k) { int newX = x + dx[k]; int newY = y + dy[k]; if (0 &amp;lt;= newX &amp;amp;&amp;amp; newX &amp;lt; N &amp;amp;&amp;amp; 0 &amp;lt;= newY &amp;amp;&amp;amp; newY &amp;lt; M &amp;amp;&amp;amp; arr[newX][newY] !=1 &amp;amp;&amp;amp; v[newX][newY] != true) { q.push(make_pair(newX, newY)); v[newX][newY] = true; arr[newX][newY] = 2; } } } //바이러스가 다 퍼졌으면 빈공간의 갯수를 세줍니다 checknum(); }void make_wall(int x,int y){ //원본 배열을 복사하기 위한 배열 int temp[MAX][MAX]; //복사 해두기 memcpy(temp, arr, sizeof(arr)); //wall은 첫 번째 벽의 세로축 값 wall2 ... int wall = 0; int wall2 = 0; int wall3 = 0; for (int i = 0; wall&amp;lt;N; ++i) { if (i &amp;gt;= M) { i = 0; wall++; if (wall &amp;gt;= N) break; } //왼쪽 위에서부터 오른쪽 아래로 훑어버려야하므로 wall2가 wall보다 작은 경우는 없음. //하지만 커질 경우는 많다. 매번 이렇게 초기화 해줘야 오류가 안남. //ex) wall이 2이고 wall2가 4인 경우 밑의 for문을 돌고 wall2가 3인경우를 안돌아서 오류가 나는 경우가 있다. wall2 = wall; if (arr[wall][i] != 0) continue; for (int j = i + 1;wall2&amp;lt;N; ++j) { if (j &amp;gt;= M) { j = 0; wall2++; if (wall2 &amp;gt;= N) break; } wall3 = wall2; if (arr[wall2][j] != 0) continue; for (int k = j + 1;wall3&amp;lt;N; ++k) { if (k &amp;gt;= M) { k = 0; wall3++; if (wall3 &amp;gt;= N) break; } if (arr[wall3][k] != 0) continue; arr[wall][i] = 1; arr[wall2][j] = 1; arr[wall3][k] = 1; int resultbefore = result; bfs(); result = max(result, resultbefore); /* i와 j와 k가 잘 들어갔는지, 그에 따른 wall,wall2,wall3를 초기화 */ //cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; j &amp;lt;&amp;lt; k &amp;lt;&amp;lt; &#39;\\n&#39;; //cout &amp;lt;&amp;lt; wall &amp;lt;&amp;lt; wall2 &amp;lt;&amp;lt; wall3 &amp;lt;&amp;lt; &#39;\\n&#39;; //cout &amp;lt;&amp;lt; &#39;\\n&#39;; //arr에 다시 원본 데이터를 넣어줌. memcpy(arr, temp, sizeof(temp)); } //사실 위에 초기화를 해줘서 필요없을 것 같은데 잘 모르겠음. wall3 = wall2; } wall2 = wall; }}void Solve(){ //input data Input(); //make wall make_wall(0, 0); cout &amp;lt;&amp;lt; result; }int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); Solve();}6. 후기이 문제를 풀기 위해서 꽤 많은 시간을 투자했다.다시 첨부터 풀어본 게 한 3번은 되는 듯.. 따지고보면 어렵지는 않지만 3중 for문을 이용해 2차원 배열을 조작한다는 것은 너무 머리 아팠다." }, { "title": "Baekjoon17626-Four Squares", "url": "/posts/baekjoon17626/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, DP", "date": "2021-01-04 17:30:00 +0900", "snippet": "백준 사이트 17626 - Four Squares 문제입니다.1. 문제https://www.acmicpc.net/problem/176262. Input , Output3. 분류 및 난이도DP문제입니다.백준에서는 Sliver5의 난이도를 책정하고 있습니다.저는 어렵게 생각했으므로 Sliver5보다 높게주고 싶습니다..4. 생각한 것들 0.5초 내로 값을 도출해내야하기 때문에 경우의 수를 다 따져가며 도는것은 불가능합니다. 5만 이하의 모든 수가 4개 이하의 제곱수로 표현이 된다는 것은 이미 증명되었으므로 이것을 이용해야합니다. 따라서 4보다 큰 경우는 생각안해도 됩니다. 1에서 5만까지 갈수록 결국 모든 수는 그 보다 작은 제곱수들로 표현됩니다. 어떤 수는 결국 어떠한 제곱수들로 표현되기 때문이죠.따라서 해당 수가 원래 제곱수인지, 제곱수에서 어떤 제곱수를 더한 수인지만 판별하면 됩니다.5. code#include&amp;lt;iostream&amp;gt;#include&amp;lt;cmath&amp;gt;#include&amp;lt;algorithm&amp;gt;#include&amp;lt;cstring&amp;gt;using namespace std;int dp[50001] = { 0,1,0 };int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); int n; cin &amp;gt;&amp;gt; n; for (int i = 1; i &amp;lt;=n;++i) { if ((int)sqrt(i) * (int)sqrt(i) == i) dp[i] = 1;//제곱 수는 1 else dp[i] = 500;// 턱없이 크게함. 5이상이면 뭐든 ok } for (int j = 1; j &amp;lt;= n; ++j) { for (int k = 1; k &amp;lt;= (int)sqrt(j); ++k) { dp[j] = min(dp[j], dp[k * k] + dp[j - k * k]); } } cout &amp;lt;&amp;lt; dp[n];}6. 후기이 문제가 왜 sliver5인지 알거 같기도하면서도 모르겠다." }, { "title": "Enable Google Page Views", "url": "/posts/enable-google-pv/", "categories": "Blogging, Tutorial", "tags": "google analytics, pageviews", "date": "2021-01-04 08:32:00 +0900", "snippet": "This post is to enable Page Views on the Chirpy theme based blog that you just built. This requires technical knowledge and it’s recommended to keep the google_analytics.pv.* empty unless you have a good reason. If your website has low traffic, the page views count would discourage you to write more blogs. With that said, let’s start with the setup.Set up Google AnalyticsCreate GA account and propertyFirst, you need to set up your account on Google analytics. While you create your account, you must create your first Property as well. Head to https://analytics.google.com/ and click on Start Measuring Enter your desired Account Name and choose the desired checkboxes Enter your desired Property Name. This is the name of the tracker project that appears on your Google Analytics dashboard Enter the required information About your business Hit Create and accept any license popup to set up your Google Analytics account and create your propertyCreate Data StreamWith your property created, you now need to set up Data Stream to track your blog traffic. After you signup, the prompt should automatically take you to create your first Data Stream. If not, follow these steps: Go to Admin on the left column Select the desired property from the drop-down on the second column Click on Data Streams Add a stream and click on Web Enter your blog’s URLIt should look like this:Now, click on the new data stream and grab the Measurement ID. It should look something like G-V6XXXXXXXX. Copy this to your _config.yml file:google_analytics: id: &#39;G-V6XXXXXXX&#39; # fill in your Google Analytics ID # Google Analytics pageviews report settings pv: proxy_endpoint: # fill in the Google Analytics superProxy endpoint of Google App Engine cache_path: # the local PV cache data, friendly to visitors from GFW regionWhen you push these changes to your blog, you should start seeing the traffic on your Google Analytics. Play around with the Google Analytics dashboard to get familiar with the options available as it takes like 5 mins to pick up your changes. You should now be able to monitor your traffic in real time.Setup Page ViewsThere is a detailed tutorial available to set up Google Analytics superProxy. But, if you are interested to just quickly get your Chirpy-based blog display page views, follow along. These steps were tested on a Linux machine. If you are running Windows, you can use the Git bash terminal to run Unix-like commands.Setup Google App Engine Visit https://console.cloud.google.com/appengine Click on Create Application Click on Create Project Enter the name and choose the data center close to you Select Python language and Standard environment Enable billing account. Yeah, you have to link your credit card. But, you won’t be billed unless you exceed your free quota. For a simple blog, the free quota is more than sufficient. Go to your App Engine dashboard on your browser and select API &amp;amp; Services from the left navigation menu Click on Enable APIs and Services button on the top Enable the following APIs: Google Analytics API On the left, Click on OAuth Consent Screen and accept Configure Consent Screen. Select External since your blog is probably hosted for the public. Click on Publish under Publishing Status Click on Credentials on the left and create a new OAuth Client IDs credential. Make sure to add an entry under Authorized redirect URIs that matches: https://&amp;lt;project-id&amp;gt;.&amp;lt;region&amp;gt;.r.appspot.com/admin/auth Note down the Your Client ID and Your Client Secret. You’ll need this in the next section. Download and install the cloud SDK for your platform: https://cloud.google.com/sdk/docs/quickstart Run the following commands: [root@bc96abf71ef8 /]# gcloud init~snip~Go to the following link in your browser: https://accounts.google.com/o/oauth2/auth?response_type=code&amp;amp;client_id=XYZ.apps.googleusercontent.com&amp;amp;redirect_uri=ABCDEFGEnter verification code: &amp;lt;VERIFICATION CODE THAT YOU GET AFTER YOU VISIT AND AUTHENTICATE FROM THE ABOVE LINK&amp;gt;You are logged in as: [blah_blah@gmail.com].Pick cloud project to use:[1] chirpy-test-300716[2] Create a new projectPlease enter numeric choice or text value (must exactly match listitem): 1[root@bc96abf71ef8 /]# gcloud info# Your selected project info should be displayed here Setup Google Analytics superProxy Clone the Google Analytics superProxy project on Github: https://github.com/googleanalytics/google-analytics-super-proxy to your local. Remove the first 2 lines in the src/app.yaml file: - application: your-project-id- version: 1 In src/config.py, add the OAUTH_CLIENT_ID and OAUTH_CLIENT_SECRET that you gathered from your App Engine Dashboard. Enter any random key for XSRF_KEY, your config.py should look similar to this #!/usr/bin/python2.7__author__ = &#39;pete.frisella@gmail.com (Pete Frisella)&#39;# OAuth 2.0 Client SettingsAUTH_CONFIG = { &#39;OAUTH_CLIENT_ID&#39;: &#39;YOUR_CLIENT_ID&#39;, &#39;OAUTH_CLIENT_SECRET&#39;: &#39;YOUR_CLIENT_SECRET&#39;, &#39;OAUTH_REDIRECT_URI&#39;: &#39;%s%s&#39; % ( &#39;https://chirpy-test-XXXXXX.ue.r.appspot.com&#39;, &#39;/admin/auth&#39; )}# XSRF SettingsXSRF_KEY = &#39;OnceUponATimeThereLivedALegend&#39; You can configure a custom domain instead of https://PROJECT_ID.REGION_ID.r.appspot.com.But, for the sake of keeping it simple, we will be using the Google provided default URL. From inside the src/ directory, deploy the app [root@bc96abf71ef8 src]# gcloud app deployServices to deploy:descriptor: [/tmp/google-analytics-super-proxy/src/app.yaml]source: [/tmp/google-analytics-super-proxy/src]target project: [chirpy-test-XXXX]target service: [default]target version: [VESRION_NUM]target url: [https://chirpy-test-XXXX.ue.r.appspot.com]Do you want to continue (Y/n)? YBeginning deployment of service [default]...╔════════════════════════════════════════════════════════════╗╠═ Uploading 1 file to Google Cloud Storage ═╣╚════════════════════════════════════════════════════════════╝File upload done.Updating service [default]...done.Setting traffic split for service [default]...done.Deployed service [default] to [https://chirpy-test-XXXX.ue.r.appspot.com]You can stream logs from the command line by running:$ gcloud app logs tail -s defaultTo view your application in the web browser run:$ gcloud app browse Visit the deployed service. Add a /admin to the end of the URL. Click on Authorize Users and make sure to add yourself as a managed user. If you get any errors, please Google it. The errors are self-explanatory and should be easy to fix. If everything went good, you’ll get this screen:Create Google Analytics QueryHead to https://PROJECT_ID.REGION_ID.r.appspot.com/admin and create a query after verifying the account. GA Core Reporting API query request can be created in Query Explorer.The query parameters are as follows: start-date: fill in the first day of blog posting end-date: fill in today (this is a parameter supported by GA Report, which means that it will always end according to the current query date) metrics: select ga:pageviews dimensions: select ga:pagePathIn order to reduce the returned results and reduce the network bandwidth, we add custom filtering rules 1: filters: fill in ga:pagePath=~^/posts/.*/$;ga:pagePath!@=. Among them, ; means using logical AND to concatenate two rules. If the site.baseurl is specified, change the first filtering rule to ga:pagePath=~^/BASE_URL/posts/.*/$, where BASE_URL is the value of site.baseurl. After Run Query, copy the generated contents of API Query URI at the bottom of the page and fill in the Encoded URI for the query of SuperProxy on GAE.After the query is saved on GAE, a Public Endpoint (public access address) will be generated, and we will get the query result in JSON format when accessing it. Finally, click Enable Endpoint in Public Request Endpoint to make the query effective, and click Start Scheduling in Scheduling to start the scheduled task.Configure Chirpy to Display Page ViewOnce all the hard part is done, it is very easy to enable the Page View on Chirpy theme. Your superProxy dashboard should look something like below and you can grab the required values.Update the _config.yml file of Chirpy project with the values from your dashboard, to look similar to the following:google_analytics: id: &#39;G-V6XXXXXXX&#39; # fill in your Google Analytics ID pv: proxy_endpoint: &#39;https://PROJECT_ID.REGION_ID.r.appspot.com/query?id=&amp;lt;ID FROM SUPER PROXY&amp;gt;&#39; cache_path: # the local PV cache data, friendly to visitors from GFW regionNow, you should see the Page View enabled on your blog.Reference Google Analytics Core Reporting API: Filters &amp;#8617; " }, { "title": "이것이 리눅스다. - 1.실습환경 구축", "url": "/posts/ThisLinuxC1/", "categories": "Linux, ThisisLinux(since2016Stop)", "tags": "This is Linux", "date": "2021-01-04 01:00:00 +0900", "snippet": "한빛 미디어의 이것이 리눅스다. 책을 정리한 자료입니다.책입니다. 군대에 있을 때 산 책이며, 읽어보자 했지만 군대에서 리눅스 운영체제를 다룰 수 없어서 이제야 읽게 되었습니다.당시에는 최신 책이었지만, 지금은 4년이 지난 책으로 빠르게 읽어볼 예정입니다.이 책에서는 VMware 이용하여 실습을 진행합니다. AWS를 이용하고 싶었지만, 원할한 진행을 하려면 VMware를 사용해야할 것 같습니다.linux server 2대, window clinet 1대, linux client 1대를 가상환경에서 이용한다고 합니다.1. 실습환경 구축 가상환경의 개념 컴퓨터에 설치된 운영체제 안에 가상의 컴퓨터를 만들고, 그 가상의 컴퓨터 안에 또 다른 운영체제를 설치/운영할 수 있도록 제작된 SWVMware를 설치해야하지만 저는 예전에 사용한 oracle virtual box를 사용하였습니다.virtual box에서 centos7버전을 받으려면 다음 링크에서 iso파일을 다운받아야합니다.http://isoredirect.centos.org/centos/7/isos/x86_64/ Server에 RAM 1GB, harddisk 80GB, Network는 NAT,CPU는 싱글코어 Server(B)에 RAM 512MB, harddisk 40GB, NAT, 싱글코어 LinuxClient에 RAM 512MB, hard 40GB, NAT, 싱글코어 windowClient에 RAM 1GB, hard 20GB, NAT, 싱글코어 , 버전은 8버전이상 으로 맞춰줍니다.centos7버전 설치과정은 다음 블로그를 참고해주세요.https://jackerlab.com/virtualbox-centos7-install/그 다음 VMWare에 대한 장점에 대해 설명하고 있습니다.스냅숏 기능, 여러 OS를 킬 수 있다는 점, 하드디스크 탈부착으로 인한 장점, PC상태를 그대로 저장해 놓고 재실행 시 그 지점으로 돌아간다는 점 등 있습니다.2. 가상머신 IP 설정실습을 요구하는 책에서는 IP를 192.168.111.??로 지정하길 원하기 때문에 ip설정을 해줘야합니다.책과 달리 저는 virtual box를 쓰므로 다른 방법으로 ip설정을 해주었습니다. 네트워크 관리자를 통해 수동으로 수정해주었습니다.https://www.runit.cloud/2020/02/virtualbox-host-only-network-setting.html네트워크를 설정했는데, centos 설치과정에서 네트워크 ip가 변경되어 일단 이 상태로 진행하기로 했습니다.centos 설치 시 오류나는 경우 iso파일이 깨진 가능성이 크므로, 재설치를 하거나 다른 링크로 들어가 설치하셔야합니다.위의 방법으로 해결이 안될 경우 부팅 디스크에 넣지 않고 controllerIDE에 넣습니다.책의 Chapter2는 리눅스 소개인데, 저는 어느정도 아는 내용이므로 스킵하고 바로 다음장으로 넘어가겠습니다." }, { "title": "Baekjoon2504-괄호의 값", "url": "/posts/baekjoon2504/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, Stack", "date": "2021-01-03 17:30:00 +0900", "snippet": "백준 사이트 2504 - 괄호의 값 문제입니다.1. 문제https://www.acmicpc.net/problem/25042. Input , Output3. 분류 및 난이도Stack을 이용해야합니다. 생각보다 어려운 문제였습니다.백준에서는 Sliver2의 난이도를 책정하고 있습니다.4. 생각한 것들 이 문제가 어려운 이유는 어느 시점에서 계산을 도출해낼 지, 그 시점에서 전의 값을 가지고 계산을 해줘야할 지 분기를 잘 정해야한다는 것입니다.-&amp;gt; 위의 예시에서 (2 + (3 * 3)) *2 이런 식으로 계산하는 방식은 생각이 안나서, 분배 법칙을 이용한 2 * 2 + 3 * 3 * 2 이런식으로 계산하였습니다. 예외인 짝이 안맞는 경우 말고도 하나 더 있습니다.-&amp;gt; 예를 들어 “((())” 인 경우 ‘)’에서 스택의 top이 ‘(‘이고 스택이 비어있지 않다 라고만 예외를 처리하면 0을 뱉어내야하지만 값을 내놓는 경우가 있습니다. 밑의 코드를 참고하시면 될 것 같습니다. 따라서 마지막에 따로 예외처리를 해주었습니다. 5. code#include&amp;lt;iostream&amp;gt;#include&amp;lt;stack&amp;gt;#include&amp;lt;string&amp;gt;using namespace std;int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); string str = &quot;&quot;; cin &amp;gt;&amp;gt; str; long long result = 0; stack&amp;lt;char&amp;gt; s; int temp = 1; for (unsigned int i = 0; i &amp;lt; str.size(); ++i) { if (str[i] == &#39;(&#39;) { s.push(str[i]); temp *= 2; } else if (str[i] == &#39;[&#39;) { s.push(str[i]);; temp *= 3; } else if (str[i] == &#39;)&#39;) { if (s.empty() || s.top() == &#39;[&#39;) { cout &amp;lt;&amp;lt; 0; return 0; } if (str[i - 1] == &#39;(&#39;) result += temp; temp /= 2; s.pop(); } else if (str[i] == &#39;]&#39;) { if (s.empty() || s.top() == &#39;(&#39;) { cout &amp;lt;&amp;lt; 0; return 0; } if (str[i - 1] == &#39;[&#39;) result += temp; temp /= 3; s.pop(); } } //((()) 등의 경우 if (!s.empty()) cout &amp;lt;&amp;lt; 0; else cout &amp;lt;&amp;lt; result; return 0;}6. 후기생각보다 어려운 난이도에 당황했다." }, { "title": "Baekjoon2133-타일 채우기", "url": "/posts/baekjoon2133/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, DP", "date": "2021-01-03 16:30:00 +0900", "snippet": "백준 사이트 2133 - 타일 채우기 문제입니다.1. 문제https://www.acmicpc.net/problem/21332. Input , Output3. 분류 및 난이도dp문제입니다. 기존 타일 문제과 달리 해줘야할 전처리들이 있습니다.백준에서는 Sliver2의 난이도를 책정하고 있습니다.4. 생각한 것들 홀수인 경우 타일을 채울 수 없습니다. 직접그려보면 알 수 있습니다. n이 4 이상인 경우 새로운 타일들이 생겨납니다.구상도는 밑과 같습니다. (1)에서 특수한 경우만 세주는 이유는 특수한 경우가 아닐 경우 3 * 2 + 3 * 2 + 3 * 2 로 나눠지므로 이는 다시 3 * 2 + 3 * 4로 합쳐지므로 사실상 (2)에서 이미 세졌기 때문입니다.5. code#include&amp;lt;iostream&amp;gt;using namespace std;int main(){ ios::sync_with_stdio(false); int n; cin &amp;gt;&amp;gt; n; int dp[31] = { 1,0,3,0 }; for (int i = 4; i &amp;lt;= n; i+=2) { //일반적인 case dp[i] = dp[i - 2] * 3; for (int j = 4; i - j &amp;gt;= 0; j += 2) { dp[i] += dp[i - j] * 2; } } cout &amp;lt;&amp;lt; dp[n];}6. 후기타일 채우기에 좀 익숙해진 것 같다." }, { "title": "Spring - 6 AOP (강의 끝)", "url": "/posts/Springnovice11/", "categories": "Java, 1. Spring_김영한_스프링 입문", "tags": "Spring Novice", "date": "2021-01-03 01:00:00 +0900", "snippet": "해당 자료는 인프런 김영한님의 스프링 입문 - 코드로 배우는 스프링 부트, 웹MVC, DB 접근 기술 강의 노트입니다.1. AOP가 필요한 상황AOP가 필요한 상황은 예로 들어서 모든 메소드의 호출 시간을 측정하고 싶다면(이를 공통 관심 사항 이라고 칭합니다.) 여러가지 방법이 있겠지만, 간단한 방법으로 로직안에 그대로 넣는 방법이 있을 것입니다.저번에 작성한 회원가입 코드 예시로 /* *회원가입 1. 중복 회원 고려 */ public Long join(Member member){ long start = System.currentTimeMillis(); try{ validateDuplicateMember(member);//중복회원 검증 Method refactoring 했음. //밑의 함수를 간단하게 위의 메소드로 작성한 것입니다. /* Optional&amp;lt;Member&amp;gt; result = memberRepositroy.findByName(member.getName()); result.ifPresent(m -&amp;gt; { throw new IllegalStateException(&quot;이미 존재하는 회원입니다.&quot;); }); */ memberRepositroy.save(member); return member.getId(); }finally { long finish = System.currentTimeMillis(); long timeMs = finish - start; System.out.println(&quot;join = &quot; + timeMs + &quot;ms&quot;); } }이 코드는 기존 코드에서 수행시간 측정 코드만 넣은 것입니다. 위의 상항에서는 다음과같은 문제가 있습니다. 회원가입, 회원 조회에 시간을 측정하는 기능은 핵심 관심 사항이 아니다. 시간을 측정하는 로직은 공통 관심 사항이다. 시간을 측정하는 로직과 핵심 비즈니스의 로직이 섞여서 유지보수가 어렵다. 시간을 측정하는 로직을 별도의 공통 로직으로 만들기 매우 어렵다. 시간을 측정하는 로직을 변경할 때 모든 로직을 찾아가면서 변경해야 한다. 수행시간 코드를 많은 메소드에 다 넣는다는 것은 굉장히 불편한 일입니다.2. AOPAspect Oriented Programming 이라고도 합니다.출처 : 김영한님 강의자료AOP를 적용하기 위해hello.hellospring 밑에 aop라는 패키지를 만들고 TimeTraceAop라는 java파일을 만듭니다.package hello.hellospring.aop;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.springframework.stereotype.Component;@Aspect@Componentpublic class TimeTraceAop { //프록시라는 기술로 발동된다. //패키지 전부에 적용. 문법 //joinPoint로 여러가지 조작이 가능하다. @Around(&quot;execution(* hello.hellospring..*(..))&quot;) public Object execute(ProceedingJoinPoint joinPoint) throws Throwable{ long start = System.currentTimeMillis(); System.out.println(&quot;Start: &quot; + joinPoint.toString()); try{ return joinPoint.proceed(); }finally { long finish = System.currentTimeMillis(); long timeMs = finish-start; System.out.println(&quot;End: &quot; + joinPoint.toString() + &quot; &quot; + timeMs +&quot;ms&quot;); } }}이렇게 작성하면 위에서 작성한 try finally 구문을 삭제해도 모든 메서드를 시간측정을 할 수 있습니다.서버를 다시 키고 메소드들을 실행하면 다음과 같이 확인할 수 있습니다.구조는 다음과 같이 바뀝니다.출처 : 김영한님 강의자료이로써 강의가 하나 끝났습니다.김영한님의 강의를 통해 Spring에는 많은 기술이 있고, 해당 기술을 겉핥기식으로 배웠기에 어떤 기술인지는 알았으나,작동 방식 등 좀 더 자세히 공부해야겠단 생각을 했습니다.모든 내용을 담을 수는 없었지만, 궁금하면 해당 강의를 찾아서 볼 수 있게 작성하였습니다." }, { "title": "Spring - 5 스프링 DB접근 기술 (3)", "url": "/posts/Springnovice10/", "categories": "Java, 1. Spring_김영한_스프링 입문", "tags": "Spring Novice", "date": "2021-01-02 16:00:00 +0900", "snippet": "해당 자료는 인프런 김영한님의 스프링 입문 - 코드로 배우는 스프링 부트, 웹MVC, DB 접근 기술 강의 노트입니다.1. 스프링 데이터 JPA인터페이스만으로 개발을 완료할 수 있게 도와줌. 반복 개발해온 CRUD 기능도 스프링 데이터 JPA가 모두 제공합니다.반복되는 개발 코드들이 확연하게 줄여든다는 것입니다. JPA에 대한 선행 학습이 있어야 이해하는데 도움이 된다고 합니다.JPA를 도와주는 기술이여서 JPA에 대한 선행이 필요하다고 생각하기 때문입니다.repository 패키지에서 SpringDataJpaMemberRepository라는 Interfacefile을 만들어줍니다.. 이름이 너무 긴 감이 있지만..다음 코드를 작성해줍니다.package hello.hellospring.repository;import hello.hellospring.domain.Member;import org.springframework.data.jpa.repository.JpaRepository;import javax.swing.text.html.Option;import java.util.Optional;public interface SpringDataJpaMemberRepository extends JpaRepository&amp;lt;Member,Long&amp;gt;, MemberRepository{ //구현체를 자동으로 만들어주고 Spring Bean에 등록함. 가져다 쓰기만하면 된다. @Override Optional&amp;lt;Member&amp;gt; findByName(String name);}그 다음, SpringConfig파일도 Spring이 인식할 수 있게 수정해줘야합니다.package hello.hellospring.service;import hello.hellospring.repository.*;import hello.hellospring.service.MemberService;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class SpringConfig { private final MemberRepository memberRepository; public SpringConfig(MemberRepository memberRepository) { this.memberRepository = memberRepository; } @Bean public MemberService memberService() { return new MemberService(memberRepository); }}테스트를 하고 아무일 없다면 성공 아직 초보인 제 생각에는 JPA 데이터 Spring이란, c++로 치면 STL과 같이 사람들이 많이 쓰는 함수들을 미리 작성해놓은 코드들을 말하는 것 같습니다. 다양한 함수들이 있고, 해당 함수들을 가져다 쓰면 되는 것 같습니다." }, { "title": "Spring - 5 스프링 DB접근 기술 (2)", "url": "/posts/Springnovice9/", "categories": "Java, 1. Spring_김영한_스프링 입문", "tags": "Spring Novice", "date": "2021-01-02 13:00:00 +0900", "snippet": "해당 자료는 인프런 김영한님의 스프링 입문 - 코드로 배우는 스프링 부트, 웹MVC, DB 접근 기술 강의 노트입니다.1. Spring JDBC templateJdbcTemplate이란 JDBC API에서 본 ‘connect()’와 같은 반복 코드를 줄여주는 역할을 햊부니다. 하지만 SQL은 직접 작성해야합니다.SQL은 뒤에 작성할 JPA를 통해 줄여나갈 수 있다고 합니다.repository package에서 JdbcTemplateMemberRespository라는 자바파일을 만들어줍니다.package hello.hellospring.repository;import hello.hellospring.domain.Member;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.RowMapper;import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;import org.springframework.jdbc.core.simple.SimpleJdbcInsert;import javax.sql.DataSource;import java.sql.ResultSet;import java.sql.SQLException;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.Optional;public class JdbcTemplateMemberRepository implements MemberRepository{ private final JdbcTemplate jdbcTemaplate; //spring이 자동으로 datsoruce를 injection 해줌. @Autowired public JdbcTemplateMemberRepository(DataSource dataSource){ jdbcTemaplate = new JdbcTemplate(dataSource); } //감 잡기용. @Override public Member save(Member member) { SimpleJdbcInsert jdbcInsert = new SimpleJdbcInsert(jdbcTemaplate); jdbcInsert.withTableName(&quot;member&quot;).usingGeneratedKeyColumns(&quot;id&quot;); Map&amp;lt;String, Object&amp;gt; parameters = new HashMap&amp;lt;&amp;gt;(); parameters.put(&quot;name&quot;, member.getName()); Number key = jdbcInsert.executeAndReturnKey(new MapSqlParameterSource(parameters)); member.setId(key.longValue()); return member; } @Override public Optional&amp;lt;Member&amp;gt; findById(Long id) { List&amp;lt;Member&amp;gt; result = jdbcTemaplate.query(&quot;select * from member where id = ?&quot;,memberRowMapper(),id); return result.stream().findAny(); } @Override public Optional&amp;lt;Member&amp;gt; findByName(String name) { List&amp;lt;Member&amp;gt; result = jdbcTemaplate.query(&quot;select * from member where name = ?&quot;, memberRowMapper(), name); return result.stream().findAny(); } @Override public List&amp;lt;Member&amp;gt; findAll() { return jdbcTemaplate.query(&quot;select * from member&quot;,memberRowMapper()); } private RowMapper&amp;lt;Member&amp;gt; memberRowMapper(){ return (rs, rowNum) -&amp;gt; { Member member = new Member(); member.setId(rs.getLong(&quot;id&quot;));; member.setName(rs.getString(&quot;name&quot;));; return member; }; }}위와같이 코드를 작성해준 다음 전에 작성했던 SpringConfig에서 스프링이 알 수 있게 다음과 같이 코드를 작성합니다. @Bean public MemberRepository memberRepositroy(){ //return new MemoryMemberRepository(); //return new JdbcMemberRepository(dataSoruce); return new JdbcTemplateMemberRepository(dataSoruce); }테스트를 실행해서 오류가 뜨지 않으면 성공입니다.2. JPASQL쿼리도 JPA가 자동으로 처리하여 개발 생산성을 크게 늘려주는 기술 –&amp;gt; 객체 중심의 설계로 패러다임을 전환할 수 있다고 합니다.마이바티스에 비해 JPA는 해외적으로 비교도 안 될 정도로 많이 사용하고 있다.먼저 jpa,h2 데이터베이스 관련 라이브러리를 추가하기 위해build.gradle의 코드를 바꿔줍니다.plugins { id &#39;org.springframework.boot&#39; version &#39;2.4.1&#39; id &#39;io.spring.dependency-management&#39; version &#39;1.0.10.RELEASE&#39; id &#39;java&#39;}group = &#39;hello&#39;version = &#39;0.0.1-SNAPSHOT&#39;sourceCompatibility = &#39;11&#39;repositories { mavenCentral()}dependencies { implementation &#39;org.springframework.boot:spring-boot-starter-thymeleaf&#39; implementation &#39;org.springframework.boot:spring-boot-starter-web&#39; //implementation &#39;org.springframework.boot:spring-boot-starter-jdbc&#39; //jdbc,jpa 포함 implementation &#39;org.springframework.boot:spring-boot-starter-data-jpa&#39; runtimeOnly &#39;com.h2database:h2&#39; testImplementation &#39;org.springframework.boot:spring-boot-starter-test&#39;}test { useJUnitPlatform()}그 후, apllication.properties에서spring.datasource.url=jdbc:h2:tcp://localhost/~/testspring.datasource.driver-class-name=org.h2.Driverspring.datasource.username=saspring.jpa.show-sql=true spring.jpa.hibernate.ddl-auto=none로 밑의 2줄을 추가해줍니다.spring.jpa.show-sql=true 는 jpa가 생성하는 SQL을 출력합니다.spring.jpa.hibernate.ddl-auto=none은 jpa가 자동으로 테이블을 생성하는 기능을 none을 통해 해당 기능을 끕니다. 왜냐하면 이미 만들어진 테이블을 갖고 테스트를 진행하기 때문입니다.예전에 작성했던 domain/Member.java 파일을 수정해줘야합니다.package hello.hellospring.domain;import javax.persistence.*;//jpa가 관리하는 entity가 되는 것.@Entitypublic class Member { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id;//시스템이 정하는 id private String name; public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; }}그리고 repository pakage에서 JpaMemberRepository.java를 만들어주고 다음 코드를 넣습니다.package hello.hellospring.repository;import hello.hellospring.domain.Member;import org.hibernate.type.EntityType;import org.springframework.transaction.annotation.Transactional;import javax.persistence.EntityManager;import javax.swing.text.html.Option;import java.util.List;import java.util.Optional;public class JpaMemberRepository implements MemberRepository{ //주입받아야한다. private final EntityManager em; public JpaMemberRepository(EntityManager em){ this.em = em; } @Override public Member save(Member member) { //영속적으로 저장한다. jpa가 insert query만들어서 db에 집어넣는다. //혁식적 em.persist(member); return member; } @Override public Optional&amp;lt;Member&amp;gt; findById(Long id) { //조회할 타입이랑 식별자를 넣어줌. Member member = em.find(Member.class,id); return Optional.ofNullable(member); } @Override public Optional&amp;lt;Member&amp;gt; findByName(String name) { List&amp;lt;Member&amp;gt; result = em.createQuery(&quot;select m from Member m where m.name = :name&quot;, Member.class) .setParameter(&quot;name&quot;,name) .getResultList(); return result.stream().findAny(); } @Override public List&amp;lt;Member&amp;gt; findAll() { //멤버 entity 대상으로 쿼리를 보냄. //select문을 보면 m entity 객체 자체를 select함. return em.createQuery(&quot;select m from Member m&quot;, Member.class).getResultList(); }}마지막으로 MemberSerivce.java파일인 서비스계층에 트랜잭션을 추가해줘야합니다.@Transactionalpublic class MemberService {~~}@Transactional을 추가해줍니다. 스프링은 해당 클래스의 메서드를 실행할 때 트랜잭션을 시작하고, 메서드가 정상 종료되면 트랜잭션을 커밋합니다. 만약 런타임 예외가 발생하면 롤백합니다. JPA를 통한 모든 데이터 변경은 트랜잭션 안에서 실행되어야 합니다.마지막으로 JPA를 사용하도록 스프링 설정을 변경해야합니다.SpringConfig.java파일에서package hello.hellospring.service;import hello.hellospring.repository.JdbcMemberRepository;import hello.hellospring.repository.JdbcTemplateMemberRepository;import hello.hellospring.repository.JpaMemberRepository;import hello.hellospring.repository.MemberRepository;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import javax.persistence.EntityManager;import javax.sql.DataSource;@Configurationpublic class SpringConfig { private EntityManager em; public SpringConfig(EntityManager em){ this.em = em; } /* private final DataSource dataSoruce; @Autowired public SpringConfig(DataSource dataSource){ this.dataSoruce = dataSource; } */ @Bean public MemberService memberService(){ return new MemberService(memberRepositroy()); } @Bean public MemberRepository memberRepositroy(){ //return new MemoryMemberRepository(); //return new JdbcMemberRepository(dataSoruce); //return new JdbcTemplateMemberRepository(dataSoruce); return new JpaMemberRepository(em); }}이처럼 Jpa를 사용할 수 있게 객체 생성, Bean에 담아줍니다.테스트를 해보면처럼 insert ~ 문구가 뜨면 테스트가 진행된 것이고만약 값이 들어가는 지 눈으로 확인하고 싶다면 전에 작성한 MemberServiceIntegrationTest.java 파일에서 회원가입()위에~~~ //중복 에러가 뜨면 DB를 비워주자. test용 DB를 구축 @Test //DB에 반영하도록 함. //@Commit void 회원가입() { //given 무언가 주어졌을 때 Member member = new Member(); member.setName(&quot;spring&quot;); //when 어떤 상황에서 Long saveId = memberService.join(member); //then 무언가 나와야한다. Member findMember = memberService.findOne(saveId).get(); assertThat(member.getName()).isEqualTo(findMember.getName()); }~~~@Commit이란 것을 달아주면 DB에 직접 반영됩니다. 하지만 나중에 데이터를 지워줘야합니다." }, { "title": "Spring - 5 스프링 DB접근 기술 (1)", "url": "/posts/Springnovice8/", "categories": "Java, 1. Spring_김영한_스프링 입문", "tags": "Spring Novice", "date": "2021-01-01 13:00:00 +0900", "snippet": "해당 자료는 인프런 김영한님의 스프링 입문 - 코드로 배우는 스프링 부트, 웹MVC, DB 접근 기술 강의 노트입니다.1. H2 데이터베이스 설치개발이나 테스트 용도로 가볍고 편리한 DB, 웹화면 제공하는 H2 DB를 설치해야합니다.https://www.h2database.com 에서 windows Installer를 눌러 다운받습니다.설치 경로로 갑니다. 보통 경로는 &amp;gt; C:\\Program Files (x86)\\H2\\bin 입니다. 해당 경로에서 ‘h2w.bat’를 눌러서 DB를 켜줍니다. cmd에서 다음과 같이 명령어를 쳐줍니다.dir여기서 test.mv.db 파일이 있으면 성공입니다.누르게 되면 다음과 같은 화면이 나옵니다. 다음과 적어주고, 테이블을 만들어 줍니다.drop table if exists member CASCADE;create table member( id bigint generated by default as identity, name varchar(255), primary key (id)); insert into member(name) values(&#39;spring&#39;) select * from MEMBER 뜨면 성공입니다.Intellij에서 다음과 같이 sql 디렉토리를 만들어주고 위의 코드를 넣어줍니다.2. 20년대 방식 JDBC순수 JDBC를 사용하기 위해서build.gradle 파일에 jdbc,h2 데이터베이스 관련 라이브러리를 추가해야합니다.implementation &#39;org.springframework.boot:spring-boot-starter-jdbc&#39;runtimeOnly &#39;com.h2database:h2&#39;그 다음 스프링 부트 데이터베이스 연결 설정을 추가해야합니다.resoruces/apllication.properties로 들어가spring.datasource.url=jdbc:h2:tcp://localhost/~/testspring.datasource.driver-class-name=org.h2.Driverspring.datasource.username=sa를 추가해야합니다.그다음 repository 패키지에서JdbcMemberRepository 파일을 만들어줍니다.밑의 코드는 참고용으로 자세히 볼 필요는 없습니다.만약 데이터베이스를 바꿀 일이 생기면 밑의 코드들을 수정해야한다는 불편한 점이 있다는 것입니다.package hello.hellospring.repository;import hello.hellospring.domain.Member;import org.springframework.jdbc.datasource.DataSourceUtils;import javax.sql.DataSource;import java.sql.*;import java.util.ArrayList;import java.util.List;import java.util.Optional;public class JdbcMemberRepository implements MemberRepository { private final DataSource dataSource; public JdbcMemberRepository(DataSource dataSource) { this.dataSource = dataSource; } @Override public Member save(Member member) { String sql = &quot;insert into member(name) values(?)&quot;; Connection conn = null; PreparedStatement pstmt = null; //ResultSet은 결과를 받음. ResultSet rs = null; //try catch문이 굉장히 많다. try { conn = getConnection(); //Return~ pstmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS); pstmt.setString(1, member.getName()); //db에 실제 쿼리 보냄. pstmt.executeUpdate(); //index키를 꺼내줌. rs = pstmt.getGeneratedKeys(); if (rs.next()) { //값을 꺼내고 셋팅함. member.setId(rs.getLong(1)); } else { throw new SQLException(&quot;id 조회 실패&quot;); } return member; } catch (Exception e) { throw new IllegalStateException(e); } finally { close(conn, pstmt, rs); } } @Override public Optional&amp;lt;Member&amp;gt; findById(Long id) { String sql = &quot;select * from member where id = ?&quot;; Connection conn = null; PreparedStatement pstmt = null; ResultSet rs = null; try { conn = getConnection(); pstmt = conn.prepareStatement(sql); pstmt.setLong(1, id); rs = pstmt.executeQuery(); if(rs.next()) { Member member = new Member(); member.setId(rs.getLong(&quot;id&quot;)); member.setName(rs.getString(&quot;name&quot;)); return Optional.of(member); } else { return Optional.empty(); } } catch (Exception e) { throw new IllegalStateException(e); } finally { close(conn, pstmt, rs); } } @Override public List&amp;lt;Member&amp;gt; findAll() { String sql = &quot;select * from member&quot;; Connection conn = null; PreparedStatement pstmt = null; ResultSet rs = null; try { conn = getConnection(); pstmt = conn.prepareStatement(sql); rs = pstmt.executeQuery(); List&amp;lt;Member&amp;gt; members = new ArrayList&amp;lt;&amp;gt;(); while(rs.next()) { Member member = new Member(); member.setId(rs.getLong(&quot;id&quot;)); member.setName(rs.getString(&quot;name&quot;)); members.add(member); } return members; } catch (Exception e) { throw new IllegalStateException(e); } finally { close(conn, pstmt, rs); } } @Override public Optional&amp;lt;Member&amp;gt; findByName(String name) { String sql = &quot;select * from member where name = ?&quot;; Connection conn = null; PreparedStatement pstmt = null; ResultSet rs = null; try { conn = getConnection(); pstmt = conn.prepareStatement(sql); pstmt.setString(1, name); rs = pstmt.executeQuery(); if(rs.next()) { Member member = new Member(); member.setId(rs.getLong(&quot;id&quot;)); member.setName(rs.getString(&quot;name&quot;)); return Optional.of(member); } return Optional.empty(); } catch (Exception e) { throw new IllegalStateException(e); } finally { close(conn, pstmt, rs); } } //DataSourceUtils를 사용해야함. private Connection getConnection() { return DataSourceUtils.getConnection(dataSource); } private void close(Connection conn, PreparedStatement pstmt, ResultSet rs) { try { if (rs != null) { rs.close(); } } catch (SQLException e) { e.printStackTrace(); } try { if (pstmt != null) { pstmt.close(); } } catch (SQLException e) { e.printStackTrace(); } try { if (conn != null) { close(conn); } } catch (SQLException e) { e.printStackTrace(); } } //닫을 때에도 DataSourceUtils를 사용해야한다. private void close(Connection conn) throws SQLException { DataSourceUtils.releaseConnection(conn, dataSource); }}Spring을 이용해보는 방법입니다.SpringConfig을 다음과 같이 수정해줍니다.package hello.hellospring.service;import hello.hellospring.repository.JdbcMemberRepository;import hello.hellospring.repository.MemberRepository;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import javax.sql.DataSource;@Configurationpublic class SpringConfig { private final DataSource dataSoruce; @Autowired public SpringConfig(DataSource dataSource){ this.dataSoruce = dataSource; } @Bean public MemberService memberService(){ return new MemberService(memberRepositroy()); } @Bean public MemberRepository memberRepositroy(){ //return new MemoryMemberRepository(); return new JdbcMemberRepository(dataSoruce); }}이것을 넣어줍니다.이제는 DB객체를 바꿔줄 땐 저 소스들만 수정하면 되게됩니다.자세한 설명은 제가 좀 더 공부해서 나중에 추가하겠습니다.넣어준 다음 실행을 친행하게 되면,웹사이트DB이런식으로 동일하게 뜨게되면 성공입니다." }, { "title": "Baekjoon10844-쉬운 계단 수", "url": "/posts/baekjoon10844/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, DP", "date": "2020-12-30 18:30:00 +0900", "snippet": "백준 사이트 10844 - 쉬운 계단 수 문제입니다.1. 문제https://www.acmicpc.net/problem/108442. Input , Output3. 분류 및 난이도dp문제입니다. 어려운 dp문제는 아니지만 예외처리를 잘 해줘야합니다.백준에서는 Sliver1의 난이도를 책정하고 있습니다.4. 생각한 것들 입력크기가 n이면 100자리 수라 입력을 string으로 받아야할까라고 생각했지만, 일단 1부터 넣어서 특징을 찾기로 했습니다. 끝자리가 0일때, 9일 때 조심해야합니다.구상도는 밑과 같습니다..설명을 매끄럽게 못하겠지만, 위를 참고로 어떤 의미인지 찾아가시면 좋겠습니다.5. code//주석은 바로 밑의 코드에 대한 설명입니다.#include&amp;lt;iostream&amp;gt;using namespace std;const int row = 101;// 만약 j가 9일 때 10인덱스에 접근해도 0을 더할 수 있게 도와준다.const int col = 11;int result[row][col] = { 0, };int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); int n; cin &amp;gt;&amp;gt; n; long long count = 9; for (int i = 1; i &amp;lt; 10; ++i) result[1][i] = 1; for (int i = 2; i &amp;lt;= n; ++i) { count = 0; result[i][0] += result[i - 1][1]; count += result[i][0]; for (int j = 1; j &amp;lt; 10; ++j) { result[i][j] = (result[i - 1][j - 1] + result[i - 1][j + 1])%1000000000; //확인용 cout &amp;lt;&amp;lt; j &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; result[i][j] &amp;lt;&amp;lt; &#39;\\n&#39;; count += result[i][j]; } } // 해주는 이유는 count가 위에서 계속 더해지므로 언제 10억을 넘어갈 지 모름 마지막에 다시 10억으로 나눠줘야한다. cout &amp;lt;&amp;lt; count% 1000000000; }6. 후기크게 어렵지는 않았다." }, { "title": "Baekjoon18870-좌표 압축", "url": "/posts/baekjoon18870/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, Sort", "date": "2020-12-30 16:30:00 +0900", "snippet": "백준 사이트 18870 - 좌표 압축 문제입니다.1. 문제https://www.acmicpc.net/problem/188702. Input , Output3. 분류 및 난이도sort문제입니다. 정렬 후에 인덱스를 기준으로 탐색을 해줘야합니다.백준에서는 Sliver2의 난이도를 책정하고 있습니다.4. 생각한 것들 입력크기가 백만이여서, 정렬과 탐색을 해줘야하므로 이진탐색을 먼저 생각했습니다.-&amp;gt; 시간초과가 납니다. 왜인지는 ..? 잘모르겠습니다. 메모리 제한이 512MB로 메모리를 많이 사용해도 된다는 점을 토대로 벡터를 두 개 사용하여 인데스에 대한 정보를 저장하기로 했습니다.구상도는 밑과 같습니다..result라는 vector를 만들어준 이유는 중복된 값에 대한 인덱스 조정을 마음대로 할 수 없기에 인덱스를 저장하는 벡터를 따로 만든 것입니다.5. code#include&amp;lt;iostream&amp;gt;#include&amp;lt;vector&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; vec1; vector&amp;lt;int&amp;gt;result(1000001); int n; cin &amp;gt;&amp;gt; n; int temp = 0; for (int i = 0; i &amp;lt; n; ++i) { cin &amp;gt;&amp;gt; temp; vec1.push_back(make_pair(temp,i)); } sort(vec1.begin(), vec1.end()); //중복제거 int count = 0; int val = vec1[0].first; result[vec1[0].second] = 0; for (int i = 1; i &amp;lt; n; ++i) { if (val == vec1[i].first) result[vec1[i].second] = count; else { result[vec1[i].second] = ++count; val = vec1[i].first; } } for (int i = 0; i &amp;lt; n; ++i) { cout &amp;lt;&amp;lt; result[i] &amp;lt;&amp;lt; &#39; &#39;; } return 0;}6. 후기인덱스의 인데스를 생각한다는게 머리가 어질어질했다." }, { "title": "Spring - 4 회원 관리 예제 (2)웹 MVC개발", "url": "/posts/Springnovice7/", "categories": "Java, 1. Spring_김영한_스프링 입문", "tags": "Spring Novice", "date": "2020-12-30 13:00:00 +0900", "snippet": "해당 자료는 인프런 김영한님의 스프링 입문 - 코드로 배우는 스프링 부트, 웹MVC, DB 접근 기술 강의 노트입니다.1. 회원 웹 기능 - 홈 화면 추가간단한 홈페이지를 작성하겠습니다.다음 경로에 새로운 자바파일을 생성해줍니다.package hello.hellospring.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;@Controllerpublic class HomeController { @GetMapping(&quot;/&quot;) public String home() { return &quot;home&quot;; }}Get방식으로 홈페이지를 뿌려줍니다.뿌려주기 위해서 resources -&amp;gt; templates에 ‘home.html’을 만들어 줍니다.&amp;lt;!DOCTYPE HTML&amp;gt;&amp;lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&amp;gt;&amp;lt;body&amp;gt;&amp;lt;div class=&quot;container&quot;&amp;gt; &amp;lt;div&amp;gt; &amp;lt;h1&amp;gt;Hello Spring&amp;lt;/h1&amp;gt; &amp;lt;p&amp;gt;회원 기능&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; &amp;lt;a href=&quot;/members/new&quot;&amp;gt;회원 가입&amp;lt;/a&amp;gt; &amp;lt;a href=&quot;/members&quot;&amp;gt;회원 목록&amp;lt;/a&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;회원 가입을 누르면 /members/new 경로로, 회원 목록을 누르면 /members 경로로 이동합니다.2. 회원 웹 기능 - 회원 등록 추가전에 작성한 MemberController.java에 다음 코드들을 추가해줍니다.@Controllerpublic class MemberController { private final MemberService memberService; @Autowired public MemberController(MemberService memberService) { this.memberService = memberService; } @GetMapping(value = &quot;/members/new&quot;) public String createForm() { return &quot;members/createMemberForm&quot;; }}‘members/new’로 요청이 들어오면 ‘members/createMemberForm.html’을 찾아서 뿌려줍니다.해당 경로인 resources -&amp;gt; templates -&amp;gt; members에 createMemberForm.html 파일을 만들어줍니다.&amp;lt;!DOCTYPE HTML&amp;gt;&amp;lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&amp;gt;&amp;lt;body&amp;gt; &amp;lt;div class=&quot;container&quot;&amp;gt; &amp;lt;form action=&quot;/members/new&quot; method=&quot;post&quot;&amp;gt; &amp;lt;div class=&quot;form-group&quot;&amp;gt; &amp;lt;label for=&quot;name&quot;&amp;gt;이름&amp;lt;/label&amp;gt; &amp;lt;input type=&quot;text&quot; id=&quot;name&quot; name=&quot;name&quot; placeholder=&quot;이름을입력하세요&quot;&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;button type=&quot;submit&quot;&amp;gt;등록&amp;lt;/button&amp;gt; &amp;lt;/form&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;!-- /container --&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;홈에서 ‘회원 가입’ 버튼을 누르면 다음과 같이 뜨면 됩니다.여기서 ‘등록’ 버튼을 누르면 입력한 값이 저장소에 저장되고, 다시 홈화면을 띄워줘야합니다. 새로운 컨트롤러를 작성해야합니다.컨트롤러 안에 새로운 자바파일인 MemberForm.java를 생성해줍니다.package hello.hellospring.controller;public class MemberForm { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; }}다시 MemberController.java로 가서 다음 코드를 추가해줍니다.@PostMapping(&quot;members/new&quot;) public String create(Member form){ Member member = new Member(); member.setName(form.getName()); //값이 잘 전달되었는 지 확인 System.out.println(&quot;member =&quot; + member.getName()); memberService.join(member); //home 화면으로 돌림 return &quot;redirect:/&quot;; }3. 회원 웹 기능 - 회원 조회 추가MemberController.java에 다음 조회를 위한 다음 코드를 추가해줍니다.@GetMapping(&quot;/members&quot;) public String list(Model model){ List&amp;lt;Member&amp;gt; members = memberService.findMembers(); model.addAttribute(&quot;members&quot;,members); return &quot;members/memberList&quot;; }List로 찾은 값들을 모델에 넣어주고 members/memberList.html을 반환합니다.뿌려주기위해 resources/templates/members에 memberList.html파일을 만들어줍니다.&amp;lt;!DOCTYPE HTML&amp;gt;&amp;lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&amp;gt;&amp;lt;body&amp;gt;&amp;lt;div class=&quot;container&quot;&amp;gt; &amp;lt;div&amp;gt; &amp;lt;table&amp;gt; &amp;lt;thead&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;th&amp;gt;#&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;이름&amp;lt;/th&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;/thead&amp;gt; &amp;lt;tbody&amp;gt; &amp;lt;tr th:each=&quot;member : ${members}&quot;&amp;gt; &amp;lt;td th:text=&quot;${member.id}&quot;&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;td th:text=&quot;${member.name}&quot;&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;/tbody&amp;gt; &amp;lt;/table&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;!-- /container --&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;Thymleaf 문법인 th:each 문으로 리스트를 돌면서 값들을 꺼내옵니다.제가 만약 ‘안녕’, ‘넹’, ‘ ‘ 등을 넣었다면 F12로 소스를 보면 다음과 같이 나옵니다.위의 사진을 보시면, Thymleaf 분법인 th:each가 html문법으로 치환되어 나타나는 것을 볼 수 있습니다." }, { "title": "Spring - 4 스프링 빈과 의존관계", "url": "/posts/Springnovice6/", "categories": "Java, 1. Spring_김영한_스프링 입문", "tags": "Spring Novice", "date": "2020-12-30 02:00:00 +0900", "snippet": "해당 자료는 인프런 김영한님의 스프링 입문 - 코드로 배우는 스프링 부트, 웹MVC, DB 접근 기술 강의 노트입니다.1. 회원 컨트롤러에 의존관계 추가회원 컨트롤러가 회원서비스와 회원 리포지토리를 사용할 수 있게 의존관계를 준비하겠습니다.방식은 2가지가 있는데, 먼저 첫 번째 방법인 컴포넌트 스캔 방법입니다.MemberController에 들어가 다음 코드를 추가해줍니다.@Controller// controller라는 것을 알림.public class MemberController { private final MemberService memberService; //스프링 컨테이너에서 멤버 서비스를 가져옴. Dependency injection = DI 의존성 주입. @Autowired public MemberController(MemberService memberService){ this.memberService = memberService; }}코드를 실행해보면 오류가 납니다.오류내용을 보면 memberService가 스프링 빈으로 등록되어 있지 않아서 나타나는 오류입니다. 참고로 helloController는 스프링이 제공하는 컨트롤러여서 스프링 빈으로 자동 등록됩니다.(@Controller가 있어야함.) @Component 애노테이션이 있으면 스프링 빈으로 자동 등록됩니다. @Controller 컨트롤러가 스프링 빈으로 자동 등록된 이유도 컴포넌트 스캔 때문입니다. @Component를 포함하는 다음 애노테이션도 스프링 빈으로 자동 등록됩니다. @Controller, @Service, @Repository 에 들어가면 @Component를 가지고 있습니다.Service와 Repository를 등록하기 위해 MemberRepository에@Servicepublic class MemberService { private final MemberRepository memberRepository; @Autowired public MemberService(MemberRepository memberRepository) { this.memberRepository = memberRepository; }}repository를 등록하기 위해 MemoryMemberRepository@Repositorypublic class MemoryMemberRepository implements MemberRepository {}스프링은 스프링 컨테이너에 스프링 빈을 등록할 때, 기본으로 싱글톤으로 등록합니다. 따라서 같은 스프링 빈으로 모두 같은 인스턴스입니다.두번째 방법은 자바코드로 직접 스프링 빈에 등록하는 방법입니다.위에서 작성한 @Service, @Repository, @Autowired 애노테이션을 제거하고 진행합니다.Service 패키지에 SpringConfig라는 java파일을 만들어줍니다.package hello.hellospring.service;import hello.hellospring.repository.MemberRepositroy;import hello.hellospring.repository.MemoryMemberRepository;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class SpringConfig { @Bean public MemberService memberService(){ return new MemberService(memberRepositroy()); } @Bean public MemberRepositroy memberRepositroy(){ return new MemoryMemberRepository(); }}DI에는 필드주입, setter 주입, 생성자 주입 이렇게 3가지 방법이 있습니다. 각각 자세한 내용은 여기를 참고하였습니다.https://yaboong.github.io/spring/2019/08/29/why-field-injection-is-bad/결론은 생성자 주입 사용을 권장한다는 것입니다." }, { "title": "Baekjoon1158-요세푸스 문제", "url": "/posts/baekjoon1158/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, Queue", "date": "2020-12-28 15:30:00 +0900", "snippet": "백준 사이트 1158 - 요세푸스 문제 문제입니다.1. 문제https://www.acmicpc.net/problem/11582. Input , Output3. 분류 및 난이도자료구조 문제입니다. queue를 이용하면 쉽게 풀 수 있습니다.백준에서는 Sliver5의 난이도를 책정하였습니다.4. 생각한 것들 입력크기는 5000으로 작아서 신경쓰지 않았습니다. queue에서의 연산이 얼마나 오래걸릴지 몰라 일단 단순하게 풀었는데, sliver5의 난이도라 그런지 효율성면에서 오류가 나지 않았습니다. k인 경우에 pop을해줘서 출력해주고 아닌 경우에는 pop하고 뒤에다 추가하는 방식으로 구하였습니다.5. code#include&amp;lt;iostream&amp;gt;#include&amp;lt;queue&amp;gt;using namespace std;int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); queue&amp;lt;int&amp;gt; q; int n, k; cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k; int temp = 1; int input = 0; for (int i = 1; i &amp;lt;= n; ++i) { q.push(i); } cout &amp;lt;&amp;lt; &#39;&amp;lt;&#39;; while (!q.empty()) { if (temp == k) { temp = 0; input = q.front(); q.pop(); if (q.size() != 0) cout &amp;lt;&amp;lt; input &amp;lt;&amp;lt; &quot;, &quot;; else cout &amp;lt;&amp;lt; input; } else { input = q.front(); q.pop(); q.push(input); } ++temp; } cout &amp;lt;&amp;lt; &#39;&amp;gt;&#39;; return 0;}6. 후기옛날에 풀어본 기억 덕에 풀 수 있었습니다." }, { "title": "Baekjoon11722-가장 긴 감소하는 부분 수열", "url": "/posts/baekjoon11722/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, DP", "date": "2020-12-28 14:30:00 +0900", "snippet": "백준 사이트 11722 - 가장 긴 감소하는 부분 수열 문제입니다.1. 문제https://www.acmicpc.net/problem/117222. Input , Output3. 분류 및 난이도일반적인 dp문제입니다.백준에서는 Sliver2의 난이도를 책정하고 있습니다.4. 생각한 것들 입력크기가 그렇게 크지 않아 그리디한 접근법으로 풀었습니다. 각각의 인덱스에 대해 부분 수열을 찾고 갯수를 dp에 저장한 다음 수열 조건에 맞으면 dp를 인덱스의 값을 증가시킵니다. 5. code#include&amp;lt;iostream&amp;gt;#include&amp;lt;cmath&amp;gt;using namespace std;int arr[1001] = { 0, };int dp[1001] = { 0, };int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); int n; int result = 0; cin &amp;gt;&amp;gt; n; for (int i = 1; i &amp;lt;= n; ++i) { cin &amp;gt;&amp;gt; arr[i]; for (int j = 1; j &amp;lt; i; ++j) { if (arr[j] &amp;gt; arr[i]) { dp[i] = max(dp[i], (dp[j] + 1)); } } result = max(dp[i], result); } cout &amp;lt;&amp;lt; result+1; return 0;}6. 후기비슷한 문제를 풀어서 빠르게 풀 수 있긴했다." }, { "title": "Baekjoon11055-가장 큰 증가 부분 수열", "url": "/posts/baekjoon11055/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, DP", "date": "2020-12-28 13:30:00 +0900", "snippet": "백준 사이트 11055 - 가장 큰 증가 부분 수열 문제입니다.1. 문제https://www.acmicpc.net/problem/110552. Input , Output3. 분류 및 난이도일반적인 dp문제입니다.백준에서는 Sliver2의 난이도를 책정하고 있습니다.4. 생각한 것들 입력크기가 그렇게 크지 않아 그리디한 접근법으로 풀었습니다. 각각의 인덱스에 대해 부분 수열을 찾고 합을 dp에 넣고 값을 갱신해줌. 5. code#include&amp;lt;iostream&amp;gt;#include&amp;lt;cmath&amp;gt;using namespace std;int arr[1001] = { 0, };int dp[1001] = { 0, };int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); int n; int result = 0; cin &amp;gt;&amp;gt; n; for (int i = 1; i &amp;lt;= n; ++i) { cin &amp;gt;&amp;gt; arr[i]; dp[i] = arr[i]; for (int j = 1; j &amp;lt; i; ++j) { if (arr[j] &amp;lt; arr[i] &amp;amp;&amp;amp; dp[i] &amp;lt; dp[j] + arr[i]) { dp[i] = dp[j] + arr[i]; } } result = max(dp[i], result); } cout &amp;lt;&amp;lt; result;}6. 후기너무 직접적?으로 풀어서 찝찝하다." }, { "title": "Baekjoon2004-조합 0의 개수", "url": "/posts/baekjoon2004/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, math", "date": "2020-12-28 04:00:00 +0900", "snippet": "백준 사이트 2004 - 조합 0의 개수 문제입니다.1. 문제https://www.acmicpc.net/problem/20042. Input , Output3. 분류 및 난이도수학으로 분류되어 있는 문제입니다.수의 범위가 굉장히 크고 일반적인 탐색으로는 당연히 시간초과가 날 것입니다.ex) n이 2억이고 m이 1억일 때 등..백준에서는 Sliver2의 난이도를 책정하고 있습니다.4. 생각한 것들 10거듭제곱을 찾아야하는 문제입니다. 때문에 2의 배수와 5의배수 개수를 세줘야합니다. n-m만큼 반복문을 돌면서 2의 배수와 5의 배수만 찾아주기로 했습니다.-&amp;gt; 시간초과 문득 일반적인 상황에서는 2의 갯수가 5의 갯수가 많다고 생각했습니다. 당장 1~5범위만해도 5의 배수는 1개 2의 배수는 2,4로 2개라서 그렇습니다. 그래서 5의 갯수가 곧 10거듭제곱 수라 생각했습니다.-&amp;gt; ex) n = 125, m = 1인 경우 5의 갯수 3개 이지만 거듭제곱수는 3이아닌 0이다. 따라서 2의 거듭제곱도 세줘야함. 메모제이션 방법으로 배열에 먼저 5의 배수와 2의 배수를 넣고 꺼내는 방법을 생각했습니다.-&amp;gt; n = 300, m = 200인 경우 걸치는 경우가 있다. 256을 넘어가면서 2의 거듭제곱 갯수가 달라진다는 것. 경계선을 어떻게 해결할 지 생각했습니다. 위의 방식은 너무 복잡하고 어렵다는 것을 인지하고 다른사람들의 코드를 참고하여 따로 분리하는게 낫다고 생각함.-&amp;gt; ex) n! 따로 (n-m)! 따로 m! 따로 계산해줘야함. 세 식의 5의갯수 2의 갯수를 구해줘야함. 5. code#include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;#include&amp;lt;cmath&amp;gt;using namespace std;long long divide5(long long num){ long long append = 0; for (long long i = 5; i &amp;lt;= num; i *= 5) { append += num / i; } return append;}long long divide2(long long num){ long long append = 0; for (long long i = 2; i &amp;lt;= num; i *= 2) { append += num / i; } return append;}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); long long n, m; cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; cout &amp;lt;&amp;lt; min(divide5(n) - (divide5(n - m) + divide5(m)), divide2(n) - (divide2(n - m) + divide2(m))); return 0;}6. 후기따지고보면 너무 당연한데, 이 방법을 생각하는데 너무 오랜 시간이 걸렸다.문제 가지고 1시간 정도 고민을 해버려서 뇌가 녹아버렸다. 그래서 풀이를 참고하였지만, 유도하는데에 집중했다면 풀 지 않았을까.. 아쉬웠다." }, { "title": "Spring - 3 회원 관리 예제 (2)", "url": "/posts/Springnovice5/", "categories": "Java, 1. Spring_김영한_스프링 입문", "tags": "Spring Novice", "date": "2020-12-28 02:00:00 +0900", "snippet": "해당 자료는 인프런 김영한님의 스프링 입문 - 코드로 배우는 스프링 부트, 웹MVC, DB 접근 기술 강의 노트입니다.전 포스팅을 참고하시길 바랍니다.1. 회원 서비스 만들기service package를 만든 후 MemberService.java파일을 만들어줍니다.package hello.hellospring.service;import hello.hellospring.domain.Member;import hello.hellospring.repository.MemberRepositroy;import hello.hellospring.repository.MemoryMemberRepository;import java.util.List;import java.util.Optional;public class MemberService { private final MemberRepositroy memberRepositroy = new MemoryMemberRepository(); /* *회원가입 1. 중복 회원 고려 */ public Long join(Member member){ validateDuplicateMember(member);//중복회원 검증 Method refactoring 했음. //밑의 함수를 간단하게 위의 메소드로 작성한 것입니다. /* Optional&amp;lt;Member&amp;gt; result = memberRepositroy.findByName(member.getName()); result.ifPresent(m -&amp;gt; { throw new IllegalStateException(&quot;이미 존재하는 회원입니다.&quot;); }); */ memberRepositroy.save(member); return member.getId(); } private void validateDuplicateMember(Member member) { memberRepositroy.findByName(member.getName()) .ifPresent(m -&amp;gt;{ throw new IllegalStateException(&quot;이미 존재하는 회원입니다.&quot;); }); } /* * 전체 회원 조회 */ public List&amp;lt;Member&amp;gt; findMembers(){ return memberRepositroy.findAll(); } public Optional&amp;lt;Member&amp;gt; findOne(Long memberId){ return memberRepositroy.findById(memberId); }}2. 회원 서비스 테스트먼저 위의 코드에서 수정할 부분이 있습니다.이유는 전 포스트에서 했던 방식으로 테스트부분에서 객체를 새로 생성해서 쓰는 방법은 테스트의 목적을 충족시키기 애매하기 때문입니다.MemberRepository의 메소드에 접근해야하는데 새로운 객체를 생성해서 메소드를 사용하기 보다는 객체를 이어받아서 하는게 더 깔끔해보입니다.MemberRepository의 clearstore() Method를 사용한다고 가정하면 기존 방법 MemberRepository 객체생성 MemberService 객체생성 MemberRepository 객체의 clearstore() 메소드 호출. 저장소를 비웠으니 MemberService 함수들을 호출.이 방식은 저장소와 service가 독립적으로 작동한다는 것입니다. 해야할 방법 MemberRepository 객체생성 MemberService 객체를 생성할 때 위에서 생성한 MemberRepository 객체를 이어준다.저장소와 service가 이어져 있게 된다. 위의 방식으로 해야하기 때문에 객체를 Service에서 생성해줘야합니다.private final MemberRepositroy memberRepositroy = new MemoryMemberRepository();코드를//기존의 객체를 사용하기 위해 해당 방법을 쓴다. private final MemberRepositroy memberRepositroy; public MemberService(MemberRepositroy memberRepositroy){ this.memberRepositroy = memberRepositroy; }로 바꿔줍니다.그리고 처럼 드래그를 해줍니다. window 환경 기준 ctrl + shift + t를 누르게 되면 자동으로 Test 파일이 생깁니다.package hello.hellospring.service;import hello.hellospring.domain.Member;import hello.hellospring.repository.MemoryMemberRepository;import org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import static org.assertj.core.api.AssertionsForClassTypes.assertThat;import static org.junit.jupiter.api.Assertions.assertThrows;class MemberServiceTest { //테스트는 과감하게 한글로 바꿔도 된다. 빌드될 때 포함되지 않음. MemberService memberService; MemoryMemberRepository memberRepository; //실행하기 전 해줘야할 것들 명세 @BeforeEach public void beforeEach(){ //객체들을 생성하고 이어주는 과정 memberRepository = new MemoryMemberRepository(); memberService = new MemberService(memberRepository); } //밑의 방식은 객체가 유지되지 않는 다른 방법 //MemoryMemberRepository memberRepository = new MemoryMemberRepository(); @AfterEach public void afterEach(){ //객체를 지워준다. 안지워주면 테스트순서에따라 객체를 잘못 조회하여 오류가 난다. memberRepository.clearStore(); } @Test void 회원가입() { //given 무언가 주어졌을 때 Member member = new Member(); member.setName(&quot;spring&quot;); //when 어떤 상황에서 Long saveId = memberService.join(member); //then 무언가 나와야한다. Member findMember = memberService.findOne(saveId).get(); assertThat(member.getName()).isEqualTo(findMember.getName()); } @Test public void 중복_회원_예외(){ //given //중복을 확인하기 위해 Name에 같은 값을 넣어준다. Member member1 = new Member(); member1.setName(&quot;spring&quot;); Member member2 = new Member(); member2.setName(&quot;spring&quot;); //when memberService.join(member1); //오류를 검출하기 위한 방법. 변수 e에 메시지를 넣어주고 같은지 학인하는 과정 IllegalStateException e = assertThrows(IllegalStateException.class,()-&amp;gt; memberService.join(member2)); assertThat(e.getMessage()).isEqualTo(&quot;이미 존재하는 회원입니다.&quot;); /*방법 2 이 방법은 상대적으로 직관적이지 않다. memberService.join(member1); try { memberService.join(member2); fail(); }catch (IllegalStateException e){ org.assertj.core.api.Assertions.assertThat(e.getMessage()).isEqualTo(&quot;이미 존재하는 회원입니다.&quot;); } */ //then } @Test void findMembers() { } @Test void findOne() { }}이렇게 해주고 마지막으로 테스트를 돌립니다.가 뜨면 성공." }, { "title": "Spring - 3 회원 관리 예제 (1)", "url": "/posts/Springnovice4/", "categories": "Java, 1. Spring_김영한_스프링 입문", "tags": "Spring Novice", "date": "2020-12-28 01:00:00 +0900", "snippet": "해당 자료는 인프런 김영한님의 스프링 입문 - 코드로 배우는 스프링 부트, 웹MVC, DB 접근 기술 강의 노트입니다.비즈니스 요구사항의 구조는 따로 작성하지 않겠습니다. 자세한 사항은 해당 강의를 찾아주세요.1. 회원 도메인과 레포지토리 만들기간단한 시나리오는 다음과 같습니다. 데이터 : 회원ID, 이름 기능 : 회원등록, 조회 아직 데이터 저장소는 선정되지 않음.- 회원 도메인과 리포지토리 만들기경로에 들어가서 domain package와 Member java파일을 만들어줍니다.package hello.hellospring.domain;public class Member { private Long id;//시스템이 정하는 id private String name; public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; }}간단한 set(),get() 함수를 넣어줍니다.그리고 리포지토리를 만들어주기위해똑같은 경로에 repository 패키지를 만들어주고, MemberRepository.Interface file과 MemoryMemberRepository .java파일을 만들어줍니다.인터페이스 파일이란 ? 구현된 것은 아무것도 없는 기본 설계도, 추상 메서드와 상수만을 멤버로 가질 수 있는 클래스 인터페이스는 표준, 약속, 규칙이다. 제 생각에는 c++의 헤더파일을 따로 저장하는 .h파일과 비슷한 것 같습니다.인터페이스파일 코드package hello.hellospring.repository;import hello.hellospring.domain.Member;import java.util.List;import java.util.Optional;public interface MemberRepositroy { Member save(Member member); //저장소에 회원 저장 Optional&amp;lt;Member&amp;gt; findById(Long id); // Id찾기 Optional&amp;lt;Member&amp;gt; findByName(String name); // name 찾기 List&amp;lt;Member&amp;gt; findAll();//모든 값 찾기}Optional이란? findById(), findByName()함수처럼 반환값이 NULL인 경우를 대비해 만든 타입입니다.MemoryMemberRepository파일package hello.hellospring.repository;import hello.hellospring.domain.Member;import javax.swing.text.html.Option;import java.util.*;public class MemoryMemberRepository implements MemberRepositroy{ private static Map&amp;lt;Long, Member&amp;gt; store = new HashMap&amp;lt;&amp;gt;(); private static long sequence = 0L;// 키값생성 멤버가 새로 저장될수록 값이 1씩 증가합니다. @Override public Member save(Member member) { member.setId(++sequence);// 저장할 때마다 id값을 증가시킵니다 store.put(member.getId(),member);//member 객체에 저장된 id값과 member객체를 map객체에 넣습니다. return member; // 상황에따라 member를 반환합니다. } @Override public Optional&amp;lt;Member&amp;gt; findById(Long id) { //ofNullable함수는 안에 감싸고 있는 store.get()함수가 null을 반환할 경우 empty Optional 객체를 생성합니다. //그리고 return을 통해 반환됩니다. return Optional.ofNullable(store.get(id)); } @Override public Optional&amp;lt;Member&amp;gt; findByName(String name) { //.stream.filter.findAny()는 findFirst()와 달리 순서와 관계없이 먼저 찾아지는 객체를 리턴합니다. //.stream.filter()는 함수식 안에있는 요소드들을 새로운 스트림으로 반환하는 Stream API입니다. //.stream()는 stream 객체를 말합니다. return store.values().stream() .filter(member -&amp;gt; member.getName().equals(name)) .findAny(); } @Override public List&amp;lt;Member&amp;gt; findAll() { //ArrayList형태로 Member값들을 넣고 반환합니다. return new ArrayList&amp;lt;&amp;gt;(store.values()); }}2. 테스트하기사전에 알아야할 지식 test폴더 안에 testFile을 만든다. File명도 해당 java파일+Tests로 작성합니다. ex)MemoryMemberRepositoryTests.java @Test로 작성된 소스들은 클래스단위로 돌릴 시 실행순서가 정해져있지않습니다. 그렇기 때문에 오류가 발생할 수 있습니다.전에 작성한 MemoryMemberRepository.java 파일에 public void clearStore(){ store.clear(); }메소드를 넣어줍니다.경로에 ~Tests.java파일을 생성합니다.package hello.hellospring.repository;import hello.hellospring.domain.Member;import org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.Assertions;import org.junit.jupiter.api.Test;import javax.swing.text.html.Option;import java.util.List;import static org.assertj.core.api.Assertions.*;public class MemoryMemberRepositoryTest { //테스트를 먼저 만드는 것을 테스트 주도개발 ttd //테스트 객체생성 MemoryMemberRepository repository = new MemoryMemberRepository(); //AfterEach는 콜백함수로 각각 테스트가 끝날때 마다 호출되는 함수를 넣는다. @AfterEach public void afterEach(){ //객체를 지워준다. 안지워주면 테스트순서에따라 객체를 잘못 조회하여 오류가 난다. repository.clearStore(); } //save()함수 테스트 코드 @Test public void save(){ //새로운 Member 객체를 만들어준다. Member member = new Member(); member.setName(&quot;Spring&quot;); repository.save(member); //result에 찾아온 값을 넣는다. Member result = repository.findById(member.getId()).get();//Optional이 반환값이므로 //밑의 코드들은 전부 result값이 save하기 전 넣었던 값과 같은지 확인하는 코드들이다. //간단한 방법 Assertions.assertEquals(member,result); //좀 더 간단한 방법 assertThat(member).isEqualTo(result); //오류 검출하는 코드 : Assertions.assertEquals(member,null); // 원시적인 방법 : System.out.println(&quot;result = &quot; + (result ==member)); } @Test public void findByName(){ Member member1 = new Member(); member1.setName(&quot;spring1&quot;); repository.save(member1); Member member2 = new Member(); //refactory member2.setName(&quot;spring1&quot;); repository.save(member2); Member result = repository.findByName(&quot;spring1&quot;).get(); assertThat(result).isEqualTo(member1); } @Test public void findAll(){ Member member1 = new Member(); member1.setName(&quot;spring1&quot;); repository.save(member1); Member member2 = new Member(); member2.setName(&quot;spring1&quot;); repository.save(member2); List&amp;lt;Member&amp;gt; result = repository.findAll(); assertThat(result.size()).isEqualTo(2); }}위의 코드들은 간단한 형태의 코드들이라 부연설명은 필요한 부분만 작성하였습니다." }, { "title": "Baekjoon2156-포도주 시식", "url": "/posts/baekjoon2156/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, DP", "date": "2020-12-27 01:00:01 +0900", "snippet": "백준 사이트 2156 - 포도주 시식 문제입니다.1. 문제https://www.acmicpc.net/problem/21562. Input , Output3. 분류 및 난이도dp문제이지만 저는 dp를 잘 풀지 못하여 어렵습니다. 저는 다른 사람들의 코드를 보며 참고했습니다.백준에서는 Sliver1의 난이도를 책정하고 있습니다.4. 생각한 것들 input의 최대값은 1만이므로 배열로 처리가 가능합니다. dp문제이고, 3번째 연속된 잔을 들 수 없으므로 3번째 인덱스 기준으로 점화식을 세워야한다고 생각했습니다. 연속해서 고르지 않는 경우도 있다.제가 생각했을 때 마지막 부분의 점화식은 기존의 합 보다 선택을 가정한 값이 작으면 선택을 취소한다고 생각하였습니다.제가 잘못 이해하고 있다면 말씀 부탁드립니다.5. code 및 설명#include&amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;int dp[10003] = { 0, };int arr[10003] = { 0, };int n;int result = 0;void Solve(){ for (int i = 3; i &amp;lt; n+3; ++i) { dp[i] = max(dp[i - 3] + arr[i - 1] + arr[i], dp[i - 2] + arr[i]); dp[i] = max(dp[i - 1], dp[i]); result = max(result, dp[i]); } for (int i = 3; i &amp;lt; n + 3; ++i) { cout &amp;lt;&amp;lt; dp[i] &amp;lt;&amp;lt; &#39; &#39;; } cout &amp;lt;&amp;lt; result;}void Input(){ cin &amp;gt;&amp;gt; n; for (int i = 3; i &amp;lt; n+3; ++i) { cin &amp;gt;&amp;gt; arr[i]; }}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); Input(); Solve(); return 0;}" }, { "title": "Baekjoon2583-영역구하기", "url": "/posts/baekjoon2583/", "categories": "Algorithm, Baekjoon", "tags": "Baekjoon, BFS", "date": "2020-12-27 01:00:00 +0900", "snippet": "백준 사이트 2583 - 영역구하기 문제입니다.1. 문제https://www.acmicpc.net/problem/25832. Input , Output3. 분류 및 난이도쉽게 접할 수 있는 BFS문제입니다. 백준에서는 Sliver1의 난이도를 책정하고 있습니다.4. 생각한 것들 분리된 사각형을 세야한다. 또한 각 사각형의 넓이를 저장할 변수가 필요. -&amp;gt; vector, 동적할당 map을 그려야하는 input의 최대값이 100이므로 배열은 전역변수로 처리가 가능하다. 문제에서는 맵이 왼쪽 아래에서 시작하지만, 일반적인 2차원 배열은 왼쪽 위부터 시작한다.해결법은 간단하다 위아래를 뒤집는다 생각하고 문제를 풀어나가면 된다.5. code 및 설명#include&amp;lt;iostream&amp;gt;// 입출력을 위한#include&amp;lt;vector&amp;gt;// vector에 사각형 넓이를 저장하기 위해#include&amp;lt;queue&amp;gt;// bfs를 위한 queue#include&amp;lt;algorithm&amp;gt;// 정렬함수를 쓰기 위해using namespace std;const int MAX = 100; //최대치는 100bool arr[MAX][MAX] = { false };// mapbool v[MAX][MAX] = { false }; // visitint N, M, K; int Rcount = 0;// 사각형 갯수vector&amp;lt;int&amp;gt; area; // 사각형 넓이 저장 변수int dx[4] = { -1,0,1,0 }; //맵을 이동하기 위한 좌표값int dy[4] = { 0,1,0,-1 }; //맵을 이동하기 위한 좌표값//사각형을 그림void makeRectangle(int x1, int y1, int x2, int y2){ for (int i = x1; i &amp;lt; x2; ++i) { for (int j = y1; j &amp;lt; y2; ++j) arr[j][i] = true; }}void bfs(int i, int j){ if (arr[i][j] == true)//사각형 범위일경우 return; else if (v[i][j] == true)//이미 들린 경우 return; queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; q; q.push(make_pair(i, j)); v[i][j] = true; //다 걸렀으면 빈 사각형이므로 갯수를 더해줌. ++Rcount; //0부터가 아닌 1인 이유는 해당 사각형도 세줘야하기 때문이다. int areanum = 1; while (!q.empty()) { int x = q.front().first; int y = q.front().second; q.pop(); for (int k = 0; k &amp;lt; 4; ++k) { int newX = x + dx[k]; int newY = y + dy[k]; if (0 &amp;lt;= newX &amp;amp;&amp;amp; newX &amp;lt; N &amp;amp;&amp;amp; 0 &amp;lt;= newY &amp;amp;&amp;amp; newY &amp;lt; M &amp;amp;&amp;amp; arr[newX][newY] == false &amp;amp;&amp;amp; v[newX][newY] == false) { q.push(make_pair(newX, newY)); v[newX][newY] = true; //사각형을 넓이를 세줌 ++areanum; } } } area.push_back(areanum); }void Solve(){ for (int i = 0; i &amp;lt; N; ++i) { for (int j = 0; j &amp;lt; M; ++j) { bfs(i, j); } } cout &amp;lt;&amp;lt; Rcount&amp;lt;&amp;lt;&#39;\\n&#39;; //문제에서 요청한 정렬 sort(area.begin(), area.end()); vector&amp;lt;int&amp;gt;::iterator it; for (it = area.begin(); it != area.end(); ++it) { cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &quot; &quot;; }}void Input(){ cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; M &amp;gt;&amp;gt; K; for (int i = 0; i &amp;lt; K; ++i) { int x1, y1, x2, y2; cin &amp;gt;&amp;gt; x1 &amp;gt;&amp;gt; y1 &amp;gt;&amp;gt; x2 &amp;gt;&amp;gt; y2; makeRectangle(x1, y1, x2, y2); } }int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); Input(); Solve(); return 0;}" }, { "title": "Spring - 2 웹개발 기초", "url": "/posts/Springnovice3/", "categories": "Java, 1. Spring_김영한_스프링 입문", "tags": "Spring Novice", "date": "2020-12-26 01:00:00 +0900", "snippet": "해당 자료는 인프런 김영한님의 스프링 입문 - 코드로 배우는 스프링 부트, 웹MVC, DB 접근 기술 강의 노트입니다.1. 스프링 부트의 정적 컨텐츠정적컨텐츠는 파일을 웹브라우저에 그대로 내려주는 형식을 말합니다.요즘은 mvc방식을 사용하는데, html을 서버에서 데이터 처리 후 웹브라우저에 내려주는 형식입니다.정적컨테츠를 사용하는 방식은 다음과 같습니다.경로에 들어간 뒤hello-static.html을 만들어줍니다.&amp;lt;!DOCTYPE HTML&amp;gt;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt; &amp;lt;title&amp;gt;static content&amp;lt;/title&amp;gt; &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;정적 컨텐츠 입니다.&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;코드를 작성해줍니다. http://localhost:8080/hello-static.html에 들어가시면 확인하실 수 있습니다.스프링에서 동작하는 방식은 먼저 hello-static을 스프링에 넘기고 컨트롤러에서 먼저 hello-static이란 컨트롤러를 찾습니다. 컨트롤러가 없으면 resources에 있는 hello-static을 찾고 정적컨텐츠를 뿌려줍니다.위의 코드에서는 hello-static이란 controller가 없기때문에 정적컨텐츠를 뿌려준 방식입니다.2. MVC와 컨트롤 엔진MVC란 Model, View, Controller입니다.View란 홈페이지를 그리는데에 집중합니다.Model과 Controller는 데이터 처리 등 비즈니스에 집중합니다.간단한 예제를 만들어보겠습니다.에 들어가 HelloController 파일에 다음과 같이 코드를 쳐줍니다.package hello.hellospring.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestParam;@Controllerpublic class HelloController { @GetMapping(&quot;hello-mvc&quot;) public String helloMvc(@RequestParam(value = &quot;name&quot;,required = true) String name,Model model){ model.addAttribute(&quot;name&quot;,name); return &quot;hello-template&quot;; }}이제 View를 작성해야합니다./resources/templates에 들어가 hello-template.html을 만들어줍니다.코드를 작성해줍니다.&amp;lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&amp;gt;&amp;lt;body&amp;gt;&amp;lt;p th:text=&quot;&#39;hello &#39; + ${name}&quot;&amp;gt;hello! empty&amp;lt;/p&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;http://localhost:8080/hello-mvc로 들어가면 오류가 뜹니다.왜냐하면 위에서 작성한 Controller에 helloMvc 파라미터를 보시면 ‘required = true’라고 되어있습니다. 이 뜻은 뒤에 작성한 name에 대한 요청값을 무조건 받아야한다고 명시한 것입니다. 때문에http://localhost:8080/hello-mvc?name=spring이런식으로 작성하셔야합니다. ‘spring’ 말고도 ‘hello’ 등 이런식으로 바꾸셔도 됩니다.3. API위에서 작성한 controller에서 다음 코드를 추가햊부니다.@Controllerpublic class HelloController { @GetMapping(&quot;hello-string&quot;) @ResponseBody public String helloString(@RequestParam(&quot;name&quot;) String name) { return &quot;hello &quot; + name; }}이렇게 작성하시면 return으로 본인이 작성한 ‘내용’인 hello’내용’이 출력됩니다.ex)http://localhost:8080/hello-string?name=sentences@ResponseBody를 사용하면 위에서 호출되는 viewResolver가 호출되지 않으며 HTTP의 BODY에 문자 내용을 직접 반환하는 형식으로 됩니다. 좀 더 직관적인 객체를 넘겨주는 예제를 들겠습니다. 똑같은 controller에 다음 코드를 추가해줍니다.@Controllerpublic class HelloController { @GetMapping(&quot;hello-api&quot;) @ResponseBody public Hello helloApi(@RequestParam(&quot;name&quot;) String name) { Hello hello = new Hello(); //객체 생성 hello.setName(name); //객체 값 설정 return hello; //객체를 넘겨줌. }//예제 클래스 작성 static class Hello { private String name; //get public String getName() { return name; } //set public void setName(String name) { this.name = name; } }}객체를 넘겨줄 땐 JSON형식과 XML형식으로 넘겨주는데, 별다른 지시가 없으면 JSON형태로 넘겨줍니다. JSON은 키와 값을 가진 데이터형식이라 생각하시면 편합니다.ex)http://localhost:8080/hello-api?name=Spring!동작 방식을 설명하겠습니다.@ResponseBody를 사용하면 ‘ViewResolver’ 대신에 ‘httpMessageConverter’가 동작합니다. 문자열을 넘기면 ‘httpMessageConverter’속에 있는‘StringConverter’가 객체를 넘기면 ‘JsonConverter’가 호출됩니다.해당 데이터에 맞게 알아서 호출되는 식입니다. 자세한 내용은 추후 다루겠습니다." }, { "title": "Spring - 1 hello spring만들기", "url": "/posts/Springnovice2/", "categories": "Java, 1. Spring_김영한_스프링 입문", "tags": "Spring Novice", "date": "2020-12-25 01:00:00 +0900", "snippet": "해당 자료는 인프런 김영한님의 스프링 입문 - 코드로 배우는 스프링 부트, 웹MVC, DB 접근 기술 강의 노트입니다.1. Hello 만들기위의 사진과 같이 해당 경로에 들어가서 index.html을 만들어줍니다.만드는 방법은 static폴더 위에 마우스 오른쪽 클릭 후 new-&amp;gt; html file을 눌러주시면 됩니다.그 다음 해당 index.html에 다음 코드를 넣습니다.&amp;lt;!DOCTYPE HTML&amp;gt;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt; &amp;lt;title&amp;gt;Hello&amp;lt;/title&amp;gt; &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;Hello&amp;lt;a href=&quot;/hello&quot;&amp;gt;hello&amp;lt;/a&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;그 다음 &amp;lt;localhost:8080&amp;gt;에서 결과를 보면 다음과 같이 뜰 것입니다.하지만 이것은 정적 사이트로 이미 작성된 페이지를 뿌려주는 형태라고 생각하시면 됩니다.다음은 컨트롤러를 만들어보겠습니다.해당 경로에 controller라는 package를 만들어주고 HelloController라는 java 파일을 만들어줍니다.package hello.hellospring.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.GetMapping;@Controllerpublic class HelloController { @GetMapping(&quot;hello&quot;) public String hello(Model model){ model.addAttribute(&quot;data&quot;,&quot;hello!!&quot;); return &quot;hello&quot;; }}다음 코드를 작성해주시고,다음 경로에 hello.html을 만들어줍니다.다음&amp;lt;!DOCTYPE HTML&amp;gt;&amp;lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;title&amp;gt;Hello&amp;lt;/title&amp;gt; &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;p th:text=&quot;&#39;안녕하세요. &#39; + ${data}&quot; &amp;gt;안녕하세요. 손님&amp;lt;/p&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;코드를 작성해줍니다.다음 http://localhost:8080/hello에 들어가면여기에서의 동작방식은 다음과 같습니다.웹 브라우저에서 해당 URL(~~/hello)로 요청이 오면 저희가 작성한 Controller에서 hello로 작성된 함수를 찾고, 파라미터에 있는 Model이라는 것에 data가 hello인 값을 넣어줍니다. 그리고 return hello를 해주는데, 이 hello는 hello.html을 찾기위한 리턴 값입니다.스프링 부트의 viewResolver는 hello.html에 model의 data의 키값인 hello를 넘겨주어서 ‘안녕하세요. + hello’가 출력되게 합니다.2. window에서 build하기서버에 배포하는 방법입니다.먼저 cmd를 킵니다. gradlew.bat이라는 파일이 있는 폴더로 ‘cd’ 명령어를 통해 이동합니다.다음 명령어를 쳐줍니다.gradlewgradlew build다음 폴더를 확인합니다.build -&amp;gt; libs 에 들어가시면‘해당 프로젝트 파일이름-SNAPSHOT.jar’를 볼 수 있습니다.해당 파일을 서버에서 압축풀기를 해주면 배포가 완료된 것입니다." }, { "title": "Spring - 1 프로젝트 환경설정(1)", "url": "/posts/Springnovice/", "categories": "Java, 1. Spring_김영한_스프링 입문", "tags": "Spring", "date": "2020-12-24 02:00:00 +0900", "snippet": "해당 자료는 인프런 김영한님의 스프링 입문 - 코드로 배우는 스프링 부트, 웹MVC, DB 접근 기술 강의 노트입니다.1. 프로젝트 환경 설정먼저 JAVA 11을 다운받아줍니다.저는 밑의 과정대로 진행하였습니다.https://zetawiki.com/wiki/%EC%9C%88%EB%8F%84%EC%9A%B0_OpenJDK_11_%EC%84%A4%EC%B9%98그다음 해당 강의에서는 IntelliJ를 사용하므로 intlliJ를 다운받아줍니다.https://www.jetbrains.com/ko-kr/idea/download/download-thanks.html?platform=windows&amp;amp;code=IIC스프링 부트 스타터사이트로 이동해서 스프링 프로젝트를 생성합니다.https://start.spring.io/설정 부분은 다음과 같습니다.모든 설정을 완료한 뒤 하단의 GNERATE를 눌러주시고, 자신이 기억할 수 있는 폴더에 압축을 풀어줍니다.완료한 뒤, IntelliJ를 켜서 해당 폴더를 열어줍니다.왼쪽 상단 폴더 트리에서 src -&amp;gt; main -&amp;gt; java -&amp;gt; 프로젝트 -&amp;gt; 프로젝트application을 열어줍니다.초록색 버튼을 눌러 RUN을 시켜주면와 같은 창이 뜹니다. ports. 8080 이렇게 뜨는데 아마 로컬컴퓨터 포트 8080에 무슨 일이 일어난 것 같습니다.해당 코드를 실행한 상태에서http://localhost:8080/를 주소창에 입력해주시면와 같이 뜨면 성공입니다.++ 빌드 빠르게 하는 법영상에 나온 방법입니다.IntelliJ 메뉴에서 File -&amp;gt; Settings에 들어간다음 Build, Execution, Deployment -&amp;gt; Build Tools -&amp;gt; Gradle에 들어가시면 다음과 같이 뜹니다.제가 밑줄친 Build and run using 과 Run Test using 을 IntlliJ IDEA로 바꿔줍니다." }, { "title": "OpenGL - 5 OpenGL 기본 툴 -(1)", "url": "/posts/OpenGL5/", "categories": "OpenGL, OpenGL 3D Graphics", "tags": "", "date": "2020-12-24 01:00:00 +0900", "snippet": "05_01 그래픽 입력 장치​키보드와 달리 커서를 사용하여 화면의 일정 위치를 가리키는 것들을 ‘포인팅 장치’라 부른다.ex ) 마우스, 조이스틱, 트랙볼, 스페이스 볼커서 이동 방향의 가지 수를 자유도(DOF:Degree of Freedom)이라 한다. 예를 들어서,조이스틱이나 트랙볼은 2차원 평면의 상하 좌우 4방향으로 움직일 수 있기 때문에 자유도가 4인 장치다.​물리적 입력 장치(Phyiscal Input Devices)는 상대 입력(Relative Input)과 절대 입력(Absolute Input)에 의해 구분된다.상대 입력 : 좌표 (2,3)에 있던 마우스를 (3,4)로 옮기면 컴퓨터로 입력되는 것은 (3-2,4-3) = (1,1)이다.위의 수식을 계산하는 것은 운영체제의 몫이다.절대 입력 : 좌표 (3,4)로 이동한다면 (3,4)가 운영체제에 입력된다. ex) 태블릿​터치 패널(Touch Panel) 또는 터치 스크린(Touch Screen)은 마우스 대신 손 끝 터치로 입력할 수 있는 장치이다.고속도로 휴게실의 관광 안내 화면이나 대형 건물 입구의 안내 화면 등이 이러한 터치 패널이라 볼 수 있다.​터치 패널에는 2가지 방식이 있는데, 광학 패널(Optical Panel)로서 막을 누르지 않아도 위치가 감지된다.화면 위 테두리에서 밑으로 열을 쏘는데, 손가락이 그 부분을 가리면 빛이 전달되지 않아서 그 위치를 잡는 방식이다​전기 패널(Electrical Panel)에서는 외피 바로 뒤에 얇고 투명한 내피가 손가락과 닿으면 전류가 발생하여 좌표를 알 수 있게 한다. 그러나 이러한 터치 패널 입력은 손가락을 사용하기 때문에 정확한 위치 입력은 어렵다.​SGI사의 그래픽 전용 워크스테이션에 사용되는 버튼 박스(Button Box)와 다이얼 박스(Dial Box)이다.버튼 박스는 매크로를 정의하여 각 버튼에 할당된 것이다. 다이얼은 각각 별도의 기능을 수행하는 회전식 불륨 스위치형 박스이다. 이는 일종의 아날로그 장치로, 매우 빠른 실시간대 디스플레이 기능을 갖추고 있다. 각 다이얼은물체의 회전, 이동, 확대 등 각 제각기의 기능이 있다.05_02 입력모드​입력 장치와 응용 프로그램 사이에 어떤 방법으로 상호 작용이 일어나는지에 따라서 입력 모드(Input Modes)를 나눈다. 먼저 메저(Measure)와 트리거(Trigger)를 구분할 필요가 있다.​메저(Measure)는 입력 장치가 응용 프로그램에 넘겨주는 값이다.트리거(Trigger)는 메저를 가져가라는 신호로, 일종의 방아쇠(Trigger)를 당기는 행위로 볼 수 있다.예를 들어int x;scanf(%d,&amp;amp;x);에서 내가 3 이라고 쳤으면 3은 메저값이고, 엔터는 트리거이다.마우스를 어떤 위치에 갖다놓고 클릭을 가했다면 그 위치의 좌표 (x,y)는 메저이고, 클릭은 트리거이다.​트리거에 의해 메저가 응용 프로그램에 전달되는 데는 메저가 이미 저장되어 있음을 전제로 한다.메저 프로세스(Measure Process)는 메저를 인식하여 저장하는 과정으로서 일반적으로 장치를 초기화할 때실행되기 시작한다. 예를 들어 윈도우 시스템에서 처음 시스템을 커서 마우스를 초기화한 이후에는 응용프로그램이그 값을 요구하든 말든 항상 현재의 마우스 위치 좌표가 추적되어 시스템 버퍼(System Buffer)에 저장된다.이러한 메저 프로세스와 트리거와의 관계를 기준으로 입력 모드를 세 가지로 구분할 수 있다.​ 1 리퀘스트 모드 리퀘스트 모드(Request Mode)는 프로그램이 실행 중 메저를 요구하는 방식이다. 이 경우 메저 프로세스는자신이 인식한 메저 값을 프로그램에 전달한다. 단, 이러한 전달은 트리거 신호가 프로세서로부터 자신에게 들어오는 순간에 이루어진다. 예를들어, “C”프로그램에서 scanf()함수는 Enter에 의해 트리거될때까지 프로그램을 대기신다.리퀘스트 모드를 적용하기 위한 명령어는 다음과 같다.Request_Locator (Device_ID,&amp;amp;Measure);Device_ID는 물리적 장치의 아이디로, 예를들어 마우스를 아이디 1번, 키보드를 2번 등.. 이런 값을 말한다.Measure변수는 함수로 통해 가져온 메저값을 넣는 변수이다.​ 2 샘플모드 ​​샘플 모드(Sample Mode) 또는 직접 모드(Immediate Mode)라고도 부르는 이 방식에서는 사용자 트리거가불필요하다. 프로그램이 메저 값을 요구하면 메저 프로세스는 무조건 현재의 메저 값을 제공한다.따라서 사용자로서는 프로그램의 해당 함수가 실행되기 전에 미리 필요한 메저 데이터를 입력한 상태여야한다.​위의 리퀘스트 모드와 비교를 하자면,물체를 회전한다고 하면 리퀘스트 모드에서는 “회전” 버튼을 누르고 마우스를 물체에 가져다 놓으면 메저 프로세스는 일단 해당 물체의 아이디를 인식한다. 그 후, 마우스를 누르는 순간, 즉 트리거가 일어난 순간 메저가 프로세스에 전달된다.샘플 모드에서는 회전될 물체를 미리 마우스로 눌러 선택한다. 이후 “회전” 메뉴를 선택하여, 프로그램이 자동으로이미 들어와 있는 메저(물체 아이디)값을 가져온다.​샘플모드 명령어는 다음과 같다.Sample_Loactor (Device_ID, &amp;amp;Measure);​``` 3 이벤트 모드 ​리퀘스트 모드나 샘플 모드에서는 프로그램이 Device_ID로 지정한 물리적 장치 이외의 어떤 입력 장치로부터의입력도 무시된다. 사용자는 프로그램이 실행 중에 요구하는 장치에서만 입력을 행사할 수 있다. 이러한 점은 문제가되는데, 예를들어 비행기를 조종한다하면 조이스특, 버튼, 스위치 등 다양한 물리적 입력장치가 어떠한 상황이든 유기적으로 연결되어 대응되어야 하는데, 위의 두 방식을 사용하면 문제가 생길수 밖에 없다.​이벤트모드(Event Mode)에서는 사용자가 선택한 입력 장치가 우선권을 쥔다. 아무 때나 사용자가 임의로 선택한입력 장치를 사용하여 입력 데이터를 프로그램에 전달할 수 있고, 프로그램은 이러한 요구에 맞추어 해당 작업을수행해야 한다. 이 경우 트리거되는 순간 하나의 이벤트가 발생한 것으로 본다.입력 장치별로 여러개의 이벤트가 발생할 수 있기 때문에 이러한 이벤트를 순차적으로 처리하기 위해서는이벤트 큐(Event Queue)를 사용해야 한다.​이벤트 모드를 사용하는 시스템을 이벤트 구동 시스템(Event-Driven System)이라 한다.마우스, 키보드, 트랙 볼에 각각 이벤트를 발생시키면 발생 순서대로 이벤트 레코드(Event Record)가이벤트 큐(Event Queue)에 삽입된다. 이벤트 레코드는 이벤트를 발생시킨 장치의 아이디, 메저 등으로 구성된다.​응용 프로그램은 주기적으로 이벤트 큐를 검사하는데, 큐가 비어있으면 다른 일을 하거나 기다린다.​콜백 함수(Callback Function)는 응용 프로그램이 이벤트를 처리하는 방법을 말한다. 이는 이벤트 처리기(EventHandler)라고도 불리는데, 이벤트 타입별로 수행해야 할 내용을 함수로 나타낸 것이다.예를 들어 마우스 버튼이 클릭되었을 때 응용 프로그램이 수행해야 할 함수 내용에 대한 소스 코드를 작성하는 식이다.MS 윈도우 운영체제도 일종의 이벤트 구동 시스템이다. 윈도우 프로그램의 시작점은 WinMain()이라는 함수로,이 함수는 새로운 윈도우를 만드는 즉시, 이벤트를 처리하는 루프로 들어간다.우리는 이러한 이벤트 처리를 응용 프로그램에 의해 직접 실행할 수도 있지만, GLUT API를 이용하면 더 쉬워진다.05_03 지엘 프로그램의 예#include&amp;lt;freeglut.h&amp;gt; //freeglut 헤더 포함//main함수부터 보세요./* 지엘 프로그램의 필수 요소를 모두 갖추고 있다는 점에서 지엘 프로그래밍의 기본 틀이다.*/void MyDisplay(){ glClear(GL_COLOR_BUFFER_BIT); glBegin(GL_POLYGON); // Begin과 End 사이에 제시된 정점들이 다각형을 이루고 있음을 의미한다. glVertex3f(-0.5, -0.5, 0.0); // 윈도우 한 가운데를 (0.0, 0.0, 0.0) 으로 한다. glVertex3f(0.5, -0.5, 0.0); glVertex3f(0.5, 0.5, 0.0); glVertex3f(-0.5, 0.5, 0.0); glEnd(); glFlush(); // 원래 드라이버는 명령어를 쌓아놓고 처리한다. 명령어마다 파이프라인 프로세서와 서로 교신해야 하는 시간 부담이 따르기 때문이다. } // glFlush()는 이러한 드라이버 행위를 원치 않을 때 사용한다. 명렁어를 쌓아두지않고 현재까지 쌓인 명령어 모두를 무조건 프로세서에 전달하도록 강제한다.int main(int argc, char** argv){ glutInit(&amp;amp;argc, argv); // freeglut를 사용시 이렇게 초기화를 해줘야한다. glutCreateWindow(&quot;OpenGL Drawing Exmaple&quot;); // GLUT에게 새로운 윈도우를 생성하라는 명령이다. 안의 문자열은 윈도우창 타이틀 이름이다. glutDisplayFunc(MyDisplay); // &quot;MyDisplay&quot; 라는 함수를 디스플레이 이벤트에 대한 콜백 함수로 등록한 것이다. 화면 디스플레이 이벤트가 발생할 때 실제로는 어떤 함수를 호출해야 하는지를 등록하는 함수이다. // 이 부분에서는 키보드나 마우스 등 입력 이벤트별로 콜백 함수를 등록할 수 있다. 콜백 함수는 실행 함수가 아니기에 어떤 순서로 등록해도 무방하다. glutMainLoop(); // main()함수의 마지막은 항상 glutMainLoop()로 끝나야한다. 이벤트 루프를 돌려야하기 때문이다. 그러므로, 이 명령이 실행되기 전 이벤트별로 콜백 함수를 등록해놔야한다. return 0;}장히 보기가 까다롭습니다.. 밑에 github 주소를 냄겨놓을테니 열어보는것을 추천합니다.​​지엘 프로그램은 윈도우 기능 및 입출력 제어에 있어서 GLUT 라이브러리를 이용한다.지엘 프로그램과 드라이버 사이에서 인터페이스 역할을 하므로, 프로그래머는 드라이버를 직접 상대하는 대신GLUT에게 필요한 일을 시키면 된다.​​프로그래머가 필요한 콜백 함수를 등록하고 콜백 함수에 원하는 내용을 채워 놓으면 이에 대한 호출은GLUT가 알아서 처리한다. 이를 위해 GLUT는 프로그래머가 등록한 함수를 콜백 테이블(Callback Table)형태로 저장하며 이 테이블에서는 이벤트 타입별로 불러야 할 콜백 함수명이 저장된다.(ex 위의 사진)이후, GLUT는 드라이버로부터 받은 이벤트 레코드를 참고해 이벤트 타입을 판단하고 테이블을 검색하여 그에 맞는콜백 함수를 호출한다. 이때 이벤트 레코드의 메저는 파라미터 형태로 콜백 함수에 전달된다.​일반적으로 큐에 이벤트가 하나도 없으면, 운영체제는 현재 프로그램 외에 다른 일을 실행하지만,만약 프로그램에서 아이들 콜백 함수(Idle Callback Function)​를 정의하면 아이들 콜백 함수가 자동 호출되어실행된다. (뒤에서 다룸) 이 함수는 주로 이벤트가 없는 시간을 활용하여 필요한 계산을 하는 데 사용된다.05_04 윈도우와 뷰 포트​​지엘 프로그램이 실행되면서 파이프라인 변환 프로세스를 따라가면서 기준 좌표계가 바뀌고, 그때마다새로운 좌표계를 기준으로 정점 좌표가 바뀐다.모델좌표는 물체별로 모델링에 편하게 설정된 좌표계전역 좌표는 개별 물체를 모았을 때 이를 한꺼번에 아우를 수 있는 좌표계시점 좌표는 물체를 바라보는 시점을 기준으로 표현한 좌표계절단 좌표는 시점으로부터 보이지 않는 물체를 잘라내기 편하게 설정한 좌표계까지는 뒤에서 다루고​정규 좌표계와 화면 좌표계에 대해 알아볼 것이다. 이 부분이 최종적으로 그림을 화면에 뿌리는 단계,즉 GLUT의 윈도우 기능이 관여하는 단계이기 때문이다.​모든 3차원 물체는 렌더링 결과 2차원 화면에 뿌려져야 한다. 즉, 어느 순간에 3차원 좌표에서 2차원 좌표로의변환이 필요하다. 이 변환은 절단 좌표계에서 정규 좌표계로 넘어가오면서 이루어진다.여기서 정규 좌표는 1을 기준으로 하는 2차원 좌표다.위의 그림은 3차원 좌표에 정의된 물체를 화면에 뿌리는 과정인데,여러 변환 단계를 거쳐 정규 좌표계에서 (0.5, 0.5)로 변환된다고 가정해보자.정규화라고 하는데, 이러한 정규화를 거치면 모든 정점 좌표는 1보다 작은 값으로 바뀐다.위의 사진처럼 우상단이 (1.0, 1.0)이고, 좌하단이 (-1.0, -1.0) 중앙은 (0.0, 0.0)으로 바뀌는걸 알 수 있다.​화면 좌표는 위의 사진처럼 화소 단위로 좌표를 표시한다.하지만, 화면 좌표는 위의 사진처럼 좌상단이 (0,0)으로 정규좌표와 다르므로 주의해야한다. 소프트웨어나 컴파일러 등에 따라 달라질 수도 있다.​정규 좌표에서 화면 좌표로 바꾸는 계산식은 1024 * 768 모니터 기준으로x좌표는 1023 * ((정규 좌표) + 1.0 ) * 0.5 가 된다.​뷰포트의 왜곡현상이라고 있는데, 간단히 뷰포트의 종횡비가 안맞아서사진을 위로 길게 늘리면 위로 늘여져서 깨지고, 세로로 길게 늘리면 세로로 길게 늘려져서 깨지는 현상을 말한다.​밑에서 왜곡현상을 보겠다.​위의 코드가 간단한 이유는 기본 상태 변수를 적용했기 때문이다.즉, GL의 상태 변수를 설정하는 명령 또는 GLUT 상태 변수를 설정하는 명령을 모두 생략했기 때문이다.생략된 명령을 추가하여 그 의미를 파악해보겠다.​#include&amp;lt;freeglut.h&amp;gt;void MyDisplay(){ glClear(GL_COLOR_BUFFER_BIT); // GL 상태 변수를 설정한다. 프레임 버퍼를 초기화 하라는 뜻이다. glViewport(100, 80, 200, 100); // viewport의 위치와 크기 값이다. 이 위치는 !!좌하단!!에서 부터 시작한다. 이는 GL과 GLUT가 사용하는 좌표가 다르기 때문이다. (x,y,width,height) x,y는 좌표, width, height는 폭과 높이다. 또한 해당 폭과 높이를 지정해줘서 왜곡 현상을 방지한다. glColor3f(1.0, 1.0, 1.0); glBegin(GL_POLYGON); glVertex3f(-0.5, -0.5, 0.0); glVertex3f(0.5, -0.5, 0.0); glVertex3f(0.5, 0.5, 0.0); glVertex3f(-0.5, 0.5, 0.0); glEnd(); glFlush();}int main(int argc, char** argv){ glutInit(&amp;amp;argc, argv); // GLUT window 초기화 함수 - GLUT 라이브러리를 초기화하고 윈도우 운영체제와 연결하는 하나의 세션을 형성한다. glutInitDisplayMode(GLUT_RGB); // 윈도우의 기본 컬러 모드를 RGB 모드로 설정하기 위한 것이다. glutInitWindowSize(300, 300); // 윈도우 폭을 300(첫 파라미터), 높이를 300화소로 하라는 것이다. glutInitWindowPosition(0, 0); // GLUT의 화면 좌표계는 운영체제의 화면 좌표계를 따른다. 이 함수는 만든윈도우의 좌상단을 좌표(0,0) 화면 좌표계의 원점에 위치 시키라는 것이다. glutCreateWindow(&quot;OpenGL Sample Drawing&quot;); // window창을 만들라는 뜻이다. glClearColor(0.0, 0.0, 0.0, 1.0); // 프로그램 전반에 걸쳐 적용되어야 할 GL의 상태 변수가 정의된다. 수시로 바뀌어야 할 때는 디스플레이 콜백 함수인 MyDisplay()에서 정의하면 된다. // 안의 파라미터 값은 초기화 색이라는 상태 변수의 값을 설정한다. 각 첫번째 파라미터 부터 R, G, B, Alpha(불투명도) 값이다. glMatrixMode(GL_PROJECTION); glLoadIdentity(); glOrtho(-1.0, 1.0, -1.0, 1.0, -1.0, 1.0); glutDisplayFunc(MyDisplay); glutMainLoop(); return 0;}주석을 따로 안단 함수는 뒤에서 나올 예정입니다.​​++ 이 외에 사용자 편의를 위해 이미 모델링된 몇가지 물체를 제공합니다.정육면체, 원구, 원한체, 원뿔, 정4면체… 등 따로 정의된 명령어가 있으므로 참고하시고 여기에 따로 적지는 않겠습니다.​​++왜곡현상​위의 코드에서​//glViewport(100, 80, 200, 100);따로 크기를 지정해주지 않는다면 왜곡현상이 일어납니다.​초기 실행화면가로를 늘렸을 경우이런식으로 1:1 비율이 안맞는 것을 왜곡 현상이라고 합니다.위의 소스코드를 주석처리 안하고 종횡비를 맞춘 소스를 넣은 경우glViewport(0, 0, 300, 300);" }, { "title": "OpenGL - 4 OpenGL API", "url": "/posts/OpenGL4/", "categories": "OpenGL, OpenGL 3D Graphics", "tags": "", "date": "2020-12-23 01:00:00 +0900", "snippet": "04_01 그래픽스 표준​-1 국제 표준표준화(Standardization)는 “ 주어진 여건에서 최적의 질서를 유지하기 위해, 현존하거나 잠재하는 문제들에 대해, 공유성과 재사용성을 높이기 위해 규정을 재정하는 행위로 정의된다.​컴퓨터 그래픽스 분야는 ISO 표준이 제정되어 있다.​컴퓨터 그래픽스의 표준에 의하면 컴퓨터 그래픽스는 “컴퓨터 하드웨어와 소프트웨어를 사용하여 물체와 물체영상을 생성, 변형, 디스플레이, 저장하는 것”으로 정의된다.그래픽스 분야의 표준은 다음과 같은 개념을 염두에 두고 제정된다.​ 1 주 전산기 독립성(Host Machine Independence) 동일한 프로그램으로 다양한 하드웨어에서 사용할 수 있어야 한다. 2 장비 독립성(Device Independence) 입출력 장비의 종류가 달라도 동일 기능을 수행하기 위한 프로그램 명령은 동일해야 한다. 3 프로그램 언어 독립성(Programming Language Independence) 프로그램을 작성할 때 어떠한 프로그램 언어를 사용해도 된다. 4 운영자 이식성(Operator Portability) 새로운 프로그램 사용법을 누구든지 쉽게 터득할 수 있어야 한다. ​-2 기본 요소와 시스템 리스트​​​여기서 (b) - 1 처럼 둥글게 처리한 것을 원형 캡(Round cap) (b) - 2 처럼 끝을 수직으로 잘라버린 것을 버트 캡(Butt cap) (b) - 3 처럼 선 두께의 반만큼 확장한 것을 확장 캡(Projecting Cap) (c) - 1 처럼 둥글게 처리한 것을 원형 연결(Round Join) (c) - 2 처럼 잘라낸 것을 베벨 연결(Bevel Join) (c) - 3 처럼 뾰족하게 처리한 것을 마이터 연결(Miter Join) (d) - 1 처럼 다각형 내부를 어떤 색상으로 채워넣은 채움 다각형(Filled Polygon) (d) - 2 처럼 점층적 변화를 준것(Gradation) (d) - 3 처럼 사선 패턴으로 채운 것 (d) - 4 처럼 윤곽선 제거(outline)​을 통틀어서 기본 요소 외양(Primitive Aspects) - 요소들이 매 순간 어떤 모습을 띠고 화면에 표시되는 지를 말함.​기본 요소 외양이 가지고 있는 외양값을 기본 요소 속성(Primitive Attribute)라고 한다.​​-3 GKS,PHIGS​그래픽스 표준은 표준이 언급하는 내용에 따라 4가지로 분류, 이는 계층 구조로 이루어져 있다. 상위 -&amp;gt; 하위응용 프로그램 레벨(Application Level) - 가상 레벨(Virtual Level) -&amp;gt; 논리적 레벨(Logical Level) -&amp;gt; 물리적 레벨(Physical Level)​ISO 그래픽 표준에는 크게 두 가지 흐름이 있다.1985년 제정된 GKS - 주로 2차원을 위주로 다룸.1989년 제정된 PHIGS - 주로 3차원을 위주로 다룸.​bitmap 파일은 가장 저급하고 단순히 화소값을 저장하지만, GKS는 그림을 저장할 때 기본 요소의 위치,속성, 가시성 등의 정보를 저장한다. GKS 메타파일(Metafile)은 그림을 저장하는 대신 그림을 만들어 낼 때사용하는 순차적 명령어들을 저장하기도 함.​PHIGS는 GKS보다 더욱 상위 레벨의 메타파일을 사용하는데,예를 들어서 오른쪽 로봇팔을 움직일 때 왼쪽 로봇팔은 자연스럽게 흔들고, 그 왼쪽 팔에 있는 관절들을 또 움직여주는 구조체의 최상위 객체로부터 시작하여 계층구조의 위에서 아래로 관통하면서 해당 물체를 그려낸다.​-4 언어 바인딩​언어 바인딩(Language Binding)은 그래픽 소프트 웨어 개발자를 위한 것이다.​표준을 지키라는 뜻이다.int max(int a,int b){ return (a &amp;gt; b ? a : b);}에서 max라는 함수는 내가 지정한 것이지만, 표준으로 이미 지정되어 있다 치고,또 이미 지정되있다.첫번째 파라미터에는 비교할 정수 a , 두번째 파라미터에는 비교할 정수 b를 넣으란 소리다.내가 string(문자열)을 넣거나 하는건 표준에 어긋나는 행위라는 것이다.​표준이 제정되기까지는 오랜시간이 걸리는데, 심사에 의해 제정된 표준을 심사 표준표준이 제정되면서 새로운 하드웨어, 소프트웨어 출현으로 표준보다 앞선 규칙이 통용되는 경우를사실 표준 이라고한다.​04_02 API(application Programming Interface)​API는 라이브러리 함수를 만한다. 라이브러리 함수는 그래픽 하드웨어와 응용 프로그램 사이에 위치하여,사용자가 좀 더 쉽게 그래픽 하드웨어를 제어할 수 있게 도와주는 함수들이라고 할 수 있다.​2차원 그래픽 API - PDL(page Description Language) 3차원 그래픽 API - 펙스(PEX)나 렌더맨(Renderman)을 들 수 있다. 펙스는 윈도우에서만 돌아가기 때문에 범용성이 좋지 않다. ​3차원 그래픽 API는 라이브러리 함수의 구체성을 기준으로 크게 두 가지로 분류한다.고수준 API(High - Level API)에서는 그림을 그리기 위한 세부 과정을 명시하는 대신, 물체를 정의하고 물체 사이의 관계를 묘사함으로써 프로그램 작성이 완료. ex) OpenInventor, VRML, Java3D 등저수준 API(Low - Level API)에서는 실제 그림을 그리는 세부적인 과정을 일일이 명시ex) OpenGL,Direct 3D​04_03 오픈지엘 개괄​OpenGL은 실리콘 그래픽스사의 워크스테이션용 API인 GL이 발전한 것.아이리스 지엘(Iris GL)이 개인용 컴퓨터에 이식되기 시작했고, 이를 오픈지엘(OpenGL)이라 부르기 시작했다.저수준 API인 OpenGL이 고수준 API보다 좀 더 세부적인 사항 수정이 쉽다.​지엘의 설계 원리는 범용성, 효율성, 독립성, 완전성 등으로 구성되어 있다.​범용성 : MS 윈도우 운영체제 뿐만아니라 유닉스 등 운영체제에서도 실행될 수 있다.효율성 : 하드웨어 기능 중 공통적인 부분을 찾아내어 그 성능을 극대화 하는 것.독립성 : 어떤 행위가 다른 행위에 영향을 미치지 않아야 한다.완전성 : 특정 하드웨어 기능에 대해서는 ARB 확장 형태로 명령어를 제공함으로써 사용자마다 다른 그래픽 하드웨어를 가지고 있어, 그 하드웨어를 어떤 API가 수용하지 않으면 다른 API를 찾는 문제를 해결상호 작업성 : 지엘 프로그램이 클라이언트가 되고 그래픽 서버가 그 명령을 서비스하는 클라이언트 - 서버 모델​지엘의 입력을 기하 기본 요소(Geometry Primitives) 나 영상 기본 요소(Image Primitives)로 구성된다.​04_04 오픈지엘 프로그래밍​이하 지엘 데이터 타입이다.​지엘 프로그램은 세 가지 요소로 구성된다. 지엘 라이브러리(GL : OpenGL Core Library) 지엘 유틸리티 라이브러리(GLU : OpenGL Utility Library) 지엘 유틸리티 툴 킷(GLUT : OpenGL Utility Toolkit) ​GLU 라이브러리는 GL 라이브러리 위에 구축된 것이므로, GLU 함수 호출은 결국 GL 함수 호출로 바뀐다.GLUT 라이브러리는 입출력 및 윈도우를 제어하기 위한 것이므로 운영체제를 호출한다.GLUT 함수는 명령어의 번역이 운영체제 마다 달라서 프로그래머가 신경쓸 이유가 없고, 이러기에 호환성이 좋다.GLUT의 기능 중 가장 중요한 것 중의 하나가 콜백 함수다.​GLUT에는 프로그램 제어 상태 변수 와 시스템 고정 상태 변수 등이 있다.​​04_05 오픈지엘 설치와 설정​은 각자 알아서..​라고 했으나​– 추가 수정—-​R패키지 설치했던것과 똑같이 오픈지엘 설치하는데 거의 1시간을 썼습니다.​일단 일반 glut라는 것과 freeglut라는게 있는데, 예전에는 glut를 썼는데, opengl 홈페이지 들어가보면 freeglut로 대체되었습니다. 때문에, 인터넷에 검색하다보면 glut설치법과 freeglut 설치법이 따로 나뉘어져 있어 혼돈을 줍니다.​freeglut를 설치하는 것을 opengl 홈페이지에서 권하므로, freeglut를 설치하고 그에 맞는 .lib 파일과 .h파일은visualstudio 헤더파일 있는곳과 라이브러리 있는 곳에 복사 붙여넣기 해주시면 됩니다.​그리고 freeglut를 사용시glutInit(&amp;amp;argc, argv); 로 초기화를 꼭 해줘야 한다고 하네요..​다른분들은 저처럼 고생하시길 마세요.​감사합니다..실험 예제#include&amp;lt;freeglut.h&amp;gt;void MyDisplay(){ glClear(GL_COLOR_BUFFER_BIT); glBegin(GL_POLYGON); glVertex3f(-0.5, -0.5, 0.0); glVertex3f(0.5, -0.5, 0.0); glVertex3f(0.5, 0.5, 0.0); glVertex3f(-0.5, 0.5, 0.0); glEnd(); glFlush();}int main(int argc,char** argv){ glutInit(&amp;amp;argc, argv); glutCreateWindow(&quot;OpenGL Drawing Example&quot;); glutDisplayFunc(MyDisplay); glutMainLoop();} 4장연습문제​ 1 그래픽 분야의 ISO 표준 중 하나인 PHIGS에는 구조체 개념이 포함되어 있다. (True/False)-&amp;gt; True PHIGS는 물체의 집합을 다루는데, 그것을 구조체라 한다.​ 2 API는 프로그램 언어다. (TRUE/FALSE)-&amp;gt; API는 프로그램 언어가 아닌, 프로그램 언어로 만들어진 라이브러리 함수 집합이다.( 개인생각 )​ 3 고수준 API는 장면 묘사 위주로, 구조체 렌더링 방식이 포함되어 있지 않다. (TRUE/FALSE)-&amp;gt; TRUE​ 4 파라미터 리스트를 사용할 경우 시스템 테이블은 불필요하다. (TRUE/FALSE)-&amp;gt; FALSE 파라미터 리스트를 사용하는 경우가 불편해서 시스템 테이블이 생겨난 것이다.​ 5 파이프라인 구조에서 서브 프로세서의 논리는 하드웨어적으로 고정되어 있다. (TRUE/FALSE)-&amp;gt; TRUE​ 6 지엘이 C 함수에 대한 호출이라면 GLU는 지엘에 대한 호출이다. (TRUE/FALSE)-&amp;gt; TRUE​ 7 점, 선, 삼각형 등 렌더링의 최소단위를 그래픽 ()이라 한다.-&amp;gt; 기본요소​ 8 심사 표준이 제정되지 않는 상태에서 현실 시장에서 통용되는 표준을 ()이라 한다.-&amp;gt; 사실 표준​ 9 ISO에서 시스템 테이블은 지엘의 ()에 해당한다.-&amp;gt; 상태변수 도표​ 10 GLUT는 지엘과 () 운영체제 사이의 인터페이스다.-&amp;gt; 윈도우즈​ 11 장면묘사 API에서 () 노드는 2개 이상의 노드로 구성된다.-&amp;gt; 그룹​ 12 윈도우 좌상단을 화면 좌표(30,10)에 위치시키기 위한 GLUT 함수는 ()이다.-&amp;gt; glutinitWindowPosition(30,10)​ 13 C 언어의 부동 소수 타입인 float에 해당하는 지엘 타입은 () 이다.-&amp;gt; GLfloat​ 14 어떤 모드를 활성화하기 위한 지엘 함수는 () 이다.-&amp;gt; glEnabled()​ 15 ISO 그래픽스 표준 내용을 인터넷에서 조사하여 발표해보라-&amp;gt; …" }, { "title": "OpenGL - 3 그래픽 컬러 처리", "url": "/posts/OpenGL3/", "categories": "OpenGL, OpenGL 3D Graphics", "tags": "", "date": "2020-12-22 01:00:00 +0900", "snippet": "01 컬러이론​빛은 전자기파의 일종이다. 전자기파에서 빛 에너지의 세기는 장의 세기를 말하며, 이는 주기적으로 크고 작아지기를 반복한다. 장의 세기가 초당 몇 번이나 바뀌는지를 나타낸 것이 주파수(Frequency)다.주파수와 파장(Wave Length)은 서로 역수 관계이므로 주파수가 높을수록 파장의 길이는 작아진다.​두가지 색을 동일한 양으로 섞었을 때 결과색이 백색이면 각각을 ​보색(Complementary Colors)라고 한다.​02 컬러 모델​RGB 컬러 모델 - 우리 눈이 주로 빨강, 녹색, 청색 파장에 가장 민감하게 반응한다는 것에서 도출 되었다.우리 눈이 주로 이 세 가지 파장의 빛의 세기를 합성하여 색을 인식한다는 삼중 자극 이론(Tri - stimulus Theory)를 따른다. RGB 모델을 ​가산 모델(Additive Model)이라고도 한다.일반적인 컬러 모니터는 RGB모델을 사용한다. 그러나 RGB 모델로 사람이 인식할 수 있는 모든 색을 표현하기는 불가능이다.컴퓨터 모니터에는 RGB에 대한 표준이 없어서 서로 다른 RGB색 공간을 지닌다. 따라서 컴퓨터 모니터 마다 같은 물체의 색이 다른것이다.​CMY 컬러 모델 - CMY 컬러 모델(CMY Color Model)은 RGB(빛의 합성에 대한 모델) 과 달리 빛이 물체 표면에 반사 되었을 때의 색에 관한 모델이다.CMY를 사용한 빼기 계산으로 필요한 색을 만들어 낸다. 이러한 점에서 CMY 모델을 감산 모델(Subtractive Model) 이라고 한다.​CMYK 컬러 모델(CMYK Color Model)은 CMY 모델을 확장한 것이다. 회색 농도(K : Chromatic)을 포함하여CMY 감산 시 좀 더 편하게 함. 직접 흑색 잉크를 칠함으로써 어떤 색 내부의 회색 농도를 좀 더 정밀하게 표현이 가능하다.​HSV 컬러 모델 - Hue, Saturation, Value Color Model or HSB(Hue, Saturation, Brightness) - 색상, 채도, 명도를 명시하여 색을 지정하는 방법이다.​YUV 모델과 YIQ 모델 - Y(명도) U,V는 색상 정보를 나타낸다.​​03 컬러모드​컬러 모드는 컬러 모델과는 별개의 개념이다. 프레임 버퍼의 내용이 R, G, B 직접 담고 있는 경우를 RGB 컬러 모드(RGB Color Mode)라 한다.​프로엠 버퍼의 비트값이 R, G, B 컬러 값이 아니라 컬러 보기표의 첫 칼럼인 인덱스 값을 의미하는 것은 인덱스 컬러 모드(Index Color Mode)라 한다.인덱스 컬러 모드는 그림의 색조가 유사할 때 효과적이다. ex) 청개구리 + 잎 녹색계통 등…​​04 하프 토우닝과 디더링​출력장치에서 인쇄할 수 있는 색은 제한적이다. 그러나, 사람의 눈이 지닌 속성을 이용한다면 제한된 장비에서더욱 다양한 색상이 보이게 할 수 있다.위의 사진은 흑색 잉크 한 가지로 인쇄 되었지만, 보이는건 회색처럼 보인다.이러한 눈의 특성을 이용해서 색을 느끼게 하는게 하프 토우닝(Half Toning) 기법이라 한다.컴퓨터 화면의 점 크기는 고정되어 있어, 그 점을 활성화 하거나 비활성화 하는 방식 밖에 없는데, 이를디지털 하프 토우닝(Digital Half Toning)이라 한다.​05 감마수정​감마 수정(Gamma Correction)이란, 사용자가 모니터에 출력하기 원하는 명도값이 실제 기댓값이랑 다른 것을 수정하기 위한 작업을 말한다. 이에 따른 수식이 존재하고 이 수식에 값을 넣는다.감마 값은 모니터의 종류에 따라 다르고, 이 경우 감마 수정은 하드웨어 또는 소프트웨어에 의해 이루어진다.하드웨어 스스로 감마 값 수정을 자동으로 실행하는 것을 하드웨어 감마(Hardware Gamma)라 부른다.IBM PC에는 일반적으로 하드웨어 감마 수정 기능이 없다. 따라서 소프트웨어에 의해 감마 수정을 해야한다.이를 시스템 감마(System Gamma)라 한다.파일감마(File Gamma)는 파일 자체에 해당 그림의 감마를 저장한 것이다.​3장 연습문제 1 백색광에는 모든 가시광선의 모든 주파수 성분이 동일한 양으로 분포한다. (True/False)-&amp;gt; True​ 2 RGB 컬러 모델을 사용하는 컴퓨터 모니터로 모든 자연색을 표시할 수 있다. (True/False)-&amp;gt; False 모든 자연색을 표시할 순 없다.​ 3 셰이딩을 가하면 채도가 감소하며, 틴팅을 가하면 채도가 증가한다. (True/False)-&amp;gt; False 셰이딩은 어떤 색상에 흑색을 섞어 명도와 채도를 낮추고, 틴팅은 백색을 섞어서 명도는 높이지만, 채도는 낮춘다.​ 4 인덱스 컬러 모드를 적용하더라도 한 화면에 동시에 그릴 수 있는 컬러 수는 프레임 버퍼 용량에 의해 결정된다. (True/False)-&amp;gt; True​ 5 인덱스 컬러 모드에서 표현할 수 있는 색상은 프레임 버퍼 용량과 무관하다. (True/False)-&amp;gt; True​ 6 디더링 결과 실질적 화면 해상도는 줄어든다. (True/False)-&amp;gt; False 디더링은 하프 토우닝에 비해 화면 해상도는 냅두는걸 목적으로 하는 기법이기에 줄어들지 않는다.​ 7 감마 수정이 가해지지 않으면 모든 색은 실제보다 밝게 표현된다. (True/False)-&amp;gt; False 어둡게 표현된다.​ 8 빛의 삼원색은 ()이며, 물감의 삼원색은 ()이다.-&amp;gt; RGB, CMY​ 9 HSV 컬러 모델에서 각도 값으로 표시되는 것은 색상, 명도, 채도 중 () 이다.-&amp;gt; 색상​ 10 YUV 컬러 모델에서 명도 정보는 ()에 포함되어 있다.-&amp;gt; Y​ 11 RGB의 보색은 () 이다.-&amp;gt; CMY​ 12 CMS는 ()의 약자이다.-&amp;gt; Color Management System​ 13 회색도 1.0으로 정규화 되었을 경우를 가정하고 CMY 모델에서 (C, M, Y) = (0.3, 0.4, 0.5)인 색이 있다. 이 색을 RGB 모델로 변환했을 경우 (R, G, B) 값은 () 이다.-&amp;gt; (0.7, 0.6, 0.5)​ 14 1,024 X 768 화면에서 2X2 화소 단위로 하프 토우닝을 적용하면 실질적 해상도는 ()로 바뀐다.-&amp;gt; 512 X 384​ 15 3X3 화소를 한 단위로 취급할 때, 다음 행렬로 표시된 하프토우닝 패턴을 모두 그려보라.-&amp;gt; ?​ 16 2X2 화소를 한 단위로 취급할 때 줄무늬가 일어날 수 있는 하프토운 행렬을 모두 나열해보라.-&amp;gt; ?​ 17 RGB = (0, 255, 127)인 화소가 있다. 감마 수정을 가하지 않을 때 가장 영향을 받는 컬러 값은 ()이다.-&amp;gt; B(청색)​ 18 하드웨어 감마가 1.4인 모니터에서 최종 감마를 2.5로 하려면 시스템 감마를 ()로 설정해야 한다.-&amp;gt; 1.8 총체적인 감마 수정은 (1*?) * (1/1.4) = 2.5 수식을 만족해야 하기 때문이다." }, { "title": "OpenGL - 2 그래픽 하드웨어", "url": "/posts/OpenGL2/", "categories": "OpenGL, OpenGL 3D Graphics", "tags": "", "date": "2020-12-21 01:00:00 +0900", "snippet": "01 그래픽 하드웨어 종류와 작동 원리​이 장에서는 하드웨어 구성과 컴퓨터 모니터의 기본 원리에 대해 설명합니다.​- 모니터 작동 원리필라멘트는 일종의 전자총인데, 이 전자총이 전자 흐름을 관리하는 제어 그물을 거쳐 정확히 가운데로 향하지 않는 전자빔들을 차단하는 접속 양극을 거칩니다. 그 후, 전자빔의 방향을 정해주는 수직 편향판 과 수평 편향판을 거쳐화면에 있는 인(Phosphor) 라는 형광 물질과 부딪혀 그 중 일부가 우리 눈에 도달하게 됩니다.​화면 재생률이란, 화면을 초당 몇 번 재생시키는지를 나타내는 것입니다. 위의 과정을 계속 반복하는 시간입니다.​02 래스터 그래픽 장치​래스터(Raster)는 ‘화소’를 의미합니다.한 화소는 세가지 인점의 밝기에 따라 결정됩니다.(RGB)컬러 모니터는 인점의 배열 방식에 따라 트라이어드 방식과 스트라이프 방식으로 분류 됩니다.래스터 장치의 선명도, 즉 해상도는 화소 수에 의해 결정됩니다.ex)1024 x 768 은 가로 화소 수가 1024개, 세로 화소 수가 768개 입니다.​섀도 마스크(Shadow Mask)는 각 전자총이 정확히 해당 색상의 인점을 맞추도록 도와줍니다.​인점의 배열방식이 스트라이프 형식인 경우, 에피처 그릴(Apeture Grill) 방식을 사용합니다.섀도 마스크 기법에 비해 더욱 밝고 선명한 영상을 얻을 수 있습니다.​주사선(scan line)이란, 전자빔을 화면 화소를 읽어가면서 빔을 쏘는 것인데 화면의 가로 방향 화소를 따라 진행하는 합니다. 주사선에는 수평 귀환 과 수직 귀한 이란게 있습니다.주사선이 화면을 반쪽씩 교대로 그려내는 것을 인터레이싱(Interlacing)이라고 합니다.반면, 논 - 인터레이싱(NON - Interlacing)은 한번에 화면을 그려내는 것을 말합니다.논 - 인터레이싱은 한번에 주사하기 때문에 화면 재생 속도가 느립니다.인터레이싱은 반쪽짜리 영상이지만, 두 배 속도로 뿌려지기 때문에 화면이 부드럽게 느껴집니다.​래스터 장치에서 화소는 하나의 사각형 모양으로 표시 됩니다.​​하지만 삼각형을 표현할 때 완벽히 표현되지않아, 굴곡현상이 나타나는데 이것을 에일리어스(Alias)라고합니다.​래스터 장치의 화면 그림은 프레임 버퍼(Frame Buffer)에 저장되어 있습니다. 프레임 버퍼는 컬러버퍼 또는 비디오 메모리라고도 부릅니다.프레임 버퍼의 내용을 화면에 뿌리는 것은 비디오 컨트롤러가 하는데, 비디오 컨트롤러 내부에는 DA 변환기(DAC : Digital to Analog Converter)가 내장되어 있어 조절이 가능합니다.화소당 24비트를 할애한 프레임 버퍼의 경우, 2^24의 색상 표현이 가능합니다만,한화소당 24비트의 메모리를 잡습니다.​03 벡터 그래픽 장치​벡터 그래픽 장치(Vector Display)는 화소의 개념이 없습니다. 명령어가 선을 그리는 형식을 사용합니다.​그래서 레스터 그래픽에 비해 에일리어스 는 없지만, 렌더링은 느리고, 메모리는 적게 먹습니다.​04 그래픽 출력 장치​평판형 디스플레이의 일종인 LCD(Liquid Crystal DisPlay)과 플라즈마 디스플레이(Plasma Display)LED(Light Emitting Diode), OLED(Organic Light Emitting Diode) 에 대한 이야기가 나옵니다.3차원 입체영상을 우리 눈에서 받아들이는 과정과 그에따른 3차원 물체 구현(vr) 등 에대한 기법이 나옵니다.홀로그래피(Holography)는 육각 렌즈와 레이저를 이용한 기법입니다.​05 그래픽 프로세서​그래픽 프로세서(Graphic Processor)가 하는 일은, CPU가 그리기 명령어를 그래픽 카드에 넘겨 다른 일을 처리할 수 있게 도와줍니다.드라이버 소프트웨어(Driver Software)에 의해 명령어를 해독하고 실행하는 것과, 명령어 실행 결과 최종적인그림을 프레임 버퍼에 기록하는 것은 그래픽 프로세서의 몫입니다.​2차원 영상 처리를 가속시키기 위한 것은 디스플레이 프로세서 이고,3차원 물체를 다루기 위한 것은 지오메트리 프로세서(Geometry Processor)의 일입니다.이 두 프로세서를 합쳐, GPU(Graphic Processing Unit)이라고 부릅니다.2장 연습문제01. 래스터 장치는 무한 해상도를, 벡터 장치는 유한 해상도를 보장한다. (True/False)-&amp;gt; False 래스터 장치는 유한 해상도를, 벡터 장치는 무한 해상도를 보장한다.​02. 논-인터레이싱에서 화면 재생율이 60Hz인 장치는 인터레이싱으로 말하면 30Hz 성능이다. (True/False)-&amp;gt; False 인터레이싱으로 말하면 120Hz 성능이다.​03. 벡터 그래픽 장치에서도 프레임 버퍼가 필요하다. (True/False)-&amp;gt; False 프레임 버퍼말고, 소용량 디스플레이 리스트가 필요하다.​04. 벡터 그래픽 장치의 디스플레이 리스트에는 화소별 색상이 저장되어 있다. (True/False)-&amp;gt; False 래스터 그래픽 장치에 화소별 색상이 저장되어 있다.​05. 섀도 마스크 기술은 화면의 해상도와 직결된다. (True/False)-&amp;gt; True​06. 일반적으로 내구성 면에서는 LCD가 플라즈마에 비해 유리하다. (True/False)-&amp;gt; True​07. 디지털로 표시된 화소 색 정보를 아날로그 전압으로 변환하기 위해 필요한 부품은 ( ) 이다.-&amp;gt; DAC(Digital to Analog Converter)​08. CPU로부터 전달받은 그래픽 명령어를 자체 그래픽 카드의 어셈블리 명령어로 바꾸는 프로그램을 ()소프트웨어라 한다.-&amp;gt; 드라이버​09. 그래픽 카드 부품 중 3차원 가속 기능을 지닌 프로세서는 ()프로세서다.-&amp;gt; 지오메트리​10. 화소당 9개의 비트 평면을 할당할 경우 표시 가능한 색상은 ()가지다.-&amp;gt; 2^9​11. R, G, B에 각 4비트를 할당할 경우, 순수 백색은 비트열 () 로, 순수 흑색은 비트열 ()로 표시할 수 있다.-&amp;gt; 111111111111, 000000000000​12. 1,280 x 1,024 해상도를 가진 화면에 동시에 4,096컬러를 지원하기 위해 필요한 프레임 버퍼의 용량은 () 바이트다.-&amp;gt; 1020 * 1024 * 2^12 / 8​13. DAC는 ()의 약자다.-&amp;gt; Digital to Analog Converter​14. 색상별 전자총이 해당 색상 인점의 정중앙을 맞추도록 하기 위해 필요한 것은 () 이다.-&amp;gt; 섀도우 마스크​15. LDC, LED 디스플레이에서 사용하는 논-인터레이싱 방식을 ()스캔이라 한다.-&amp;gt; 프로그레시브(Progressive)" }, { "title": "OpenGL - 1 시작 및 연습문제 풀이", "url": "/posts/OpenGL1/", "categories": "OpenGL, OpenGL 3D Graphics", "tags": "", "date": "2020-12-20 13:00:00 +0900", "snippet": "2020년 5월에 작성한 글입니다. 블로그를 옮기면서 다시 쓰고 있습니다.오늘은 제가 예전에 공부하던 OpenGL에 관하여 글을 쓰겠습니다.군대에 자기개발 비용을 이용하여 책을 샀습니다.​요즘 제가 보는 인강의 교수님이 컴퓨터그래픽스 전공이셔서 저도 궁금해서 배워볼까 해서 샀습니다.사실, 그래픽스 강의를 해주셨다면 더 좋았을 거 같지만… 한 번 사보았습니다.​이 책은 강의자료(ppt), 소스까지 다 주지만, 연습문제 풀이는 교수로 등록하지 않으면 주지 않습니다.교과서로 나온 책 같은데, 아무쪼록 별 탈 없이 책 마무리를 했으면 좋겠다…​오늘 1장을 봤으므로 1장에 대한 풀이를 올려보도록 하겠습니다.​1장 ​연습문제 풀이1. 인터넷 검색으로 영상 기반 렌더링(Image-Based Rendering)이라는 용어를 정의해보라. ETRI가 내놓은 연구결과, 여러 개의 지정된 카메라 시점에 대한 캐시 이미지들을 미리 생성해 둔다. 그런 다음 원하는 시점의 캐시 이미지를 각 픽셀에 투영되는 3차원 표면점을 역시점 변환을 통해 구하고, 이 점을 지정된 카메라 시점으로 다시 투영하여 캐시 이미지에서의 대응 픽셀을 찾는다. 대응 픽셀의 파라미터 값의 평균치를 구해 새 캐시 이미지에 설정한다. ​2. 어도비사의 대표적인 영상 처리 소프트웨어로는 포토샵을, 그래픽 처리 소프트웨어로는 일러스트레이터를 들 수 있다. 각 소프트웨어의 메뉴를 예로 영상 처리와 그래픽스의 차이점을 정의해보라. 포토샵은 ‘사진’을 다루는 프로그램으로, 사진 보정을 주 목적으로 기능이 갖춰져서 사진의 적목현상 혹은 굴절 현상 등을 제거해 주는 소프트웨어이다. 내가 생각하기에 영상 처리에서 영상은 ‘사진’ 같은이미 존재하는 이미지를 말하는 것 같다.일러스트레이터는 포토샵과는 다르게 보정에 대한 기능이 거의 없고, 도형을 그리거나 자르고 합치는 기능이나 글씨를 도형으로 변형시켜 다루는 기능이 많다. 즉 창작을 할 때 주로 쓰는 프로그램이라고 생각하면 된다.그렇기에, 그래픽스는 컴퓨터를 이용한 창작물이라고 볼 수 있다.​3. 사이 비즈 분야의 그래픽 예를 인터넷에서 검색하여 발표해보라. (SCI VIS)를 말하는 것 같다. -&amp;gt; Scientific Visualization 과학 분야 가시화요즘 내가 공부하고 있는 Rstudio에 있는 ggplot2패키지에 있는 gplot() 함수를 예로 들 수 있다. gplot() 함수는 데이터를 막대그래프 형태로 보여주는 함수로 데이터를 시각화하는데 초점이 맞춰져, 데이터의 패턴이나 추세를 파악하기 쉽다.​4. ACM SIGGRAPH의 홈페이지에서 제공하는 자료를 내용에 따라 분류해보라. 소개 글과 세미나 일정, 참가자들 커뮤니티 하는 곳 등 분류되어 있다. (?)​5. 이 장에 제시된 여덟 가지 그래픽스 응용 분야별로 활용된 실례를 인터넷에서 검색하여 발표해보라. 1. 캐드(CAD)는 이미 건축분야에서 많이 쓰는 소프트웨어 개발 툴로 인터넷에 사진 검색하면 많이 나온다. 2. 프레젠테이션 그래픽스는 학술자료 발표나, 발표 자료를 도표 등을 이용하여 보여줄 때 많이 사용한다. 3. 가상현실 : 가상현실은 내가 군대에 있을 때 3D MAX로 비행기를 만들어, Unreal engine으로 옮겨 HMD를 착용해 시뮬레이션을 돌리는 작업을 했었다. 4. 미술 : 요즘 핸드폰 어플로 나오는 카메라들은 필터라는 것을 적용시키는데 필터 적용 값은 그래픽스로 만들어진 걸로 알고 있다. 5. 애니메이션 및 게임 : 검은 사막, 테라 및 겨울 왕국 등 굉장히 많은 분야에서 쓰이고 있다. 6. 교육 및 훈련 : 위의 가상현실에서 소개한 듯, 내가 만든 시뮬레이션은 비행사들 교육목적으로 만들어졌기 때문에 여기에도 해당된다 볼 수 있다. 7. 과학 분야의 가시화 : 옛날에는 구름을 표현할 때, 격자 알고리즘과 입자 알고리즘을 사용하여 구름을 그래픽으로 표현하였다. 8. 그래픽 사용자 인터페이스 : visual studio 개발 툴의 실행창, 환경창 등은 GUI라고 볼 수 있다. ​이 책의 정답은 제공되지 않으므로, 제가 생각하는 것들을 적어봤습니다..​​책을 보며 소스코드가 있다면 올리도록 하겠습니다." }, { "title": "jekyll로 gitblog 시작하기[2] - sitemap설정", "url": "/posts/startblog2/", "categories": "Blogging, Tutorial", "tags": "start git blog", "date": "2020-12-19 13:00:00 +0900", "snippet": " 제가 많이 막혔던 sitemap 제출법 입니다.사이트맵은 사이트에 있는 파일로, 내 사이트에서 Google이 알아야 하는 페이지에 관한 정보를 담고 있습니다. 즉, Google이 블로그를 크롤링하려면 갖고있어야하는 정보들이 담겨져 있는 문서입니다.특히 sitemap의 경우 오류가 발생하면 원인을 찾기가 힘듭니다.저의 경우는 3일 정도 소요가 되었으며 모든 원인은 google의 문제가 아닌 블로그 초기설정을 할 때 read.md 파일을 읽지 않아서 발생한 것들이었습니다.꼭꼭 readme 파일을 읽으셔서 초기 진행을 하시고, 만약 안되신다면전 글에 포스팅했던 브랜치 설정을 바꿔주시길 바랍니다.시작하겠습니다.1. URL 제출 먼저 Google Search Console에 들어가서 URL 접두어에 자신의 URL을 적어줍니다. 그 후 HTML문서를 다운받으라고 할 텐데 해당 문서를 다운 받고root 디렉토리에 넣어줍니다. 2. SiteMap 제출 제출을 완료했다면 왼쪽 메뉴바에 Sitemaps에 들어갑니다.sitemap을 제출해야하는데, git blog theme에서 자동으로 sitemap.xml을 파일을 제공하는 경우도 있고, 없다면 sitemap 파일을 다운받아야합니다.타 블로그에서 sitemap source를 전부 긁어오는 것 보다는 자신의 sitemap.xml파일을 만드는 것을 추천드립니다.sitemap을 만들어주는 사이트는 https://www.xml-sitemaps.com/등 이 있습니다sitemap을 작성하였으면, Google Search Console로 돌아가 sitemap제출을 해줍니다.성공이 나오면 성공이고, 실패가 나오면 원인들이 나옵니다.사실 원인들을 봐도 뭐가 문제인지 모를 겁니다.. 찾아봐도 잘 안나오고 저같은 경우는 readme..파일을 읽고, 브랜치 설정을 해주니까 고쳐졌습니다. 제 생각으로는 github가 브랜치 설정을 안해주면 보안관련 이슈로 페이지를 못 읽는다는데 그 부분에서 Google Search Console도 오류를 뱉어내는 것 같습니다.또 다른 문의사항이 있으시다면 댓글을 남겨주세요.++ 댓글 기능 추가는 어렵지 않은 기술이기 때문에 따로 작성하지 않겠습니다. jekyll 댓글 추가 or jekyll comment 로 검색해보면 나옵니다." }, { "title": "jekyll로 gitblog 시작하기[1] - 초기설정", "url": "/posts/startblog/", "categories": "Blogging, Tutorial", "tags": "start git blog", "date": "2020-12-18 13:00:00 +0900", "snippet": "1. git blog fork, clone, init깃 블로그를 시작하기 위해서는 먼저 테마를 골라야합니다.테마사이트는 굉장히 많지만 나와같은 테마는 여기서 볼 수 있습니다.http://jekyllthemes.org/ 원하는 theme를 고르고 fork를 합니다. fork를 한 뒤 clone를 해줍니다. 그 전 각 테마에 해당하는 readme 파일을 읽어주세요.!!! git Terminal $ git clone https://github.com/USERNAME/USERNAME.github.io.git -b master --single-branch clone을 성공적으로 한 뒤, cmd로 해당 폴더로 들어간 뒤 다음 명령어를 쳐줍니다. 만약 ruby가 설치되어있지 않다는 오류가 뜨면 ruby를 설치합니다. $ bundle install 초기화 작업을 해줍니다. $ bash tools/init.sh 2. git blog push자신의 깃 주소에 들어가서 fork한 저장소의 이름을 바꿉니다.꼭 자신의 깃아이디와 똑같이 만들어야합니다.똑같이 만든 뒤, 자신의 사이트에 들어가서 홈페이지가 잘 나오는지 봅니다.예시https://kkminseok.github.io https://Username.github.io자신의 root 디렉토리에서 _config.yml의 파일을 찾아 다음을 수정해줍니다. url 자신의 깃 주소를 입력합니다. ex) https://kkminseok.github.io avatar 자신의 로고이미지를 입력합니다. ex) root기준 path /~ timezone 자신이 살고 있는 곳. ex) 한국에 사니까 Asia/Seoul theme_mode dark mode or light mode 수정이 완료되었으면, git add -&amp;gt; commit -&amp;gt; push를 해줍니다.$ git add .$ git commit -m &quot;test&quot;$ git push!git에서 설정을 해줘야할 것이 있습니다.!git Setting에 들어가서 밑으로 쭉내리다보면 GitHub Pages가 있습니다.Branch가 master로 되어있을 텐데 gh-pages로 바꿔줘서 Save버튼을 눌러줍니다.해당 브런치를 바꿔주지 않으면 git에서 보안관련 오류가 계속 뜹니다.대표적인 모습은 다음과 같습니다.. 무수히 많은 에러들 github Run filed:Automatic build - master …. 참고로 추후 포스트에 오타 등이 요인이 될 수 있습니다.뿐만아니라 추후 sitemap 제출시에도 반영이 안되는 경우가 있으므로 꼭꼭!! 바꿔줍시다.기억에 의존하여 과정이 틀릴 수 있지만, 많은 오류를 겪어본 결과 모두 readme파일을 읽지않아서 발생한 오류들 이었습니다. 꼭 readme파일을 읽고 순서대로 진행해주세요.!!다음 포스트에는 sitemap을 제출하여 구글 서치에 노출되는 방법을 알아보겠습니다. 문의 사항은 댓글에 적어주세요.저에게 도움을 주신 https://chanhuiseok.github.io/님 감사합니다." }, { "title": "github 블로그 시작하기 [md문서 다루기]", "url": "/posts/test-1/", "categories": "Blogging, Tutorial", "tags": "markdown text", "date": "2020-12-17 12:33:00 +0900", "snippet": "Link해당 md파일에서 링크 다는 법은링크달내용 + 주소이다.해당 링크는 블로그의 메인 홈페이지!한글H1 - headingH2 - headingH3 - headingH4 - headingListOrdered List‘1. 2. 3.’ 이런식으로 달면된다. one two threeBlock Quote ’&amp;gt;’를 쓰면 블러처리가 된다.!" } ]
