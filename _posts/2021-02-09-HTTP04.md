---
title: HTTP - 4 HTTP 메서드
author: 강민석
date: 2021-02-09 18:00:00 +0800
categories: [HTTP,김영한_모든 개발자를 위한 HTTP 웹 기본 지식]
tags: [HTTP]
math: true
mermaid: true
image: 
comments: true
---

**해당 자료는 인프런 김영한 선생님의 모든 개발자를 위한 HTTP 웹 기본 지식 강의노트입니다.**

-----  

## **1. HTTP API 만들기** ##

다음과 같은 요구사항이 주어지고 API를 만드는 경우가 있다고 생각해봅시다.   

- 회원 목록 조회
- 회원 조회
- 회원 등록
- 회원 수정
- 회원 삭제

처음에 설계를 하면 다음과 같이 설계할 것입니다.  

- 회원 목록 조회/read-member-list
- 회원 조회/read-member-by-id
- 회원 등록/craete-member
- 회원 수정/update-member
- 회원 삭제/delete-member


이렇게 설계하는 방식은 안좋은 방식입니다.  

가장 좋은 방법은 리소스와 행위를 분리하여 작성하는 방식입니다.  

리소스란 위에서 '회원'이라는 명사가 리소스입니다.  
행위는 '조회하다, 등록하다, 수정하다, 삭제하다' 등 동사가 행위입니다.  
리소스를 기준으로 API를 작성해야합니다.  

- 회원 목록 조회/members
- 회원 조회/members/{id}
- 회원 등록/members/{id}
- 회원 수정/members/{id}
- 회원 삭제/members/{id}

리소스 중심으로 API를 구성하였지만, 행위를 어떻게 적용해야할 지는 뒤에 적겠습니다.  

-----  

## **2. HTTP 메서드 - GET,POST** ##

HTTP 메서드 종류는 다음과 같습니다.  

- GET : 리소스 조회
- POST : 요청 데이터 처리(주로 등록에 사용)
- PUT : 리소스를 대체, 해당 리소스가 없으면 생성
- PATCH : 리소스 부분 변경
- DELETE : 리소스 삭제

<br>

- HEAD : GET과 동일하지만 메시지 부분을 제외하고, 상태 줄과 헤더만 반환
- OPTIONS : 대상 리소스에 대한 통신 가능 옵션을 설명(주로 CORS에서 사용)
- CONNECT : 대상 자원으로 식별되는 서버에 대한 터널을 설정(잘 사용 안함)
- TRACE : 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행(마찬가지로 잘 사용 안함)

**GET**

```console
GET /search?q=hello&hl=ko HTTP/1.1
HOST: www.google.com
```

리소스 조회를 담당하고, 서버에 전달하고 싶은 데이터는 query(쿼리 파라미터, 쿼리 스트링)을 통해서 전달합니다.   
메시지 바디를 통해서 데이터를 전달할 수 있지만, 지원하지 않는 곳이 많아서 권장하지 않습니다.  

**POST**

```console
POST /members HTTP/1.1
Content-Type: application/json

{
    "username":"hello",
    "age":27
}
```

- 요청 데이터 처리
- **메시지 바디를 통해 서버로 요청 데이터 전달**
- 서버는 요청 데이터를 **처리**
    + 메시지 바디를 통해 들어온 데이터를 처리하는 모든 기능을 수행
- 주로 전달된 데이터로 신규 리소스 등록, 프로세스 처리에 사용

- 스펙: POST 메서드는 대상 리소스가 리소스의 고유 한 의미 체계에 따라 요청에 포함 된 표현을 처리하도록 요청합니다.

> example

- 회원가입처럼 신규 사용자 등록
- 주문에서 '상품 id'를 보내 주문 프로세스를 처리하는 로직
- 게시판 글쓰기, 댓글달기 
- 한 문서 끝에 내용 추가 등  
이러한 것들은 URI에 POST 요청이 들어오면 요청 데이터를 어떻게 처리할지 리소스마다 따로 정의해야함. -> 정해진것이 없다.  

- 주문에서 결제완료 -> 배달시작 -> 배달완료 처럼 단순한 값 변경을 넘어 프로세스의 상태가 변경되는 경우  
배달시작을 할 경우 배달업체를 부르고, 배달 취소에대한 대비 등 많은 프로세스가 돌아가는 예시

- 다른 메서드로 처리하기 애매한 경우
JSON으로 조회 데이터를 넘겨야 하는데, GET 메서드를 사용하기 어려운 경우, 애매한 경우

## **3. HTTP 메서드 - PUT,PATH,DELETE** ##

**PUT**

- 리소스를 대체
    + 리소스가 있으면 대체
    + 리소스가 없으면 생성
    + 파일을 폴더로 옮길 때 생각(있으면 덮어버림.)
- POST와의 차이점
    + **클라이언트가 리소스를 식별**
    + ```console
        PUT /members/100 HTTP/1.1
        Content-Type: application/json

        {
            //"username": "kms"
            "age": 50
        }
      ```
      위의 '/members/100' 처럼 클라이언트가 경로를 알고 있는 것이 차이점입니다.  
      만약 username을 생략해서 age만 보내면 기존에 있던 username또한 null로 대체됩니다.  
      그렇기에 PUT은 업데이트용도가 아니고, 대체용도로 사용해야 합니다.  


**PATCH**

- 리소스 부분 변경  


```console
PATCH /members/100 HTTP/1.1
Content-Type: application/json

{
    "age": 50
}
```

PUT과 달리 기존에 있던 username은 가만히 두고 age만 바뀝니다.  

**PATCH를 지원하지 않는 경우 POST를 사용하면 됩니다.**  



**DELETE**

```console
DELETE /members/100 HTTP/1.1
Host: localhost:8080
```

리소스 삭제

**위의 스펙들은 HTTP METHOD 스펙이므로 약속을 어기지말고 개발을 잘해야 합니다.**

----- 

## **4. HTTP 메서드의 속성** ##

- 안전(Safe Methods)
- 멱등(Idempotent Methods)
- 캐시가능(Cacheable Methods)

![](/assets/img/sample/HTTP/kyh/C4/method.JPG)  

**안전**

- 호출해도 리소스를 변경하지 않는다.
- 로그가 쌓여서 시스템 에러 등 외부요인은 고려하지 않습니다.  
- GET/HEAD는 데이터 조회만 수행하므로 안전하다고 할 수 있습니다.


**멱등**

**f(fx))=f(x)**
- 한 번 호출하든 두 번 세 번 ... 호출하든 결과는 같아야한다.
- GET : 조회는 항상 결과가 같으므로 멱등
- PUT : 결과를 대체하면서 덮어버리니 멱등
- DELETE : 결과를 삭제하고, 두 번 호출하든 백 번 호출하든 결과는 삭제된 상태이므로 멱등
- POST : 결제를 POST로 작성한다고 하면 두 번 호출하면 결제가 두 번 되므로 멱등이 아니다.
- PATCH : 만약 호출할 때마다 10씩 더한다는 명세서를 작성하면 멱등이 되지 않는다. 멱등이 아니도록 작성할 수도 있다.

멱등은 주로 자동 복구 메커니즘에서 활용합니다.  
서버가 정상 응답을 주지 못했을 때, 클라이언트가 같은 요청을 다시 해도 되는지에 대한 근거가 됩니다.  


멱등도 마찬가지로 외부요인으로 인한 방해는 고려하지 않습니다.  

**캐시가능**

- 응답 결과 리소르를 캐시해서 사용해도 되는가?
- GET, HEAD, POST, PATCH는 캐시 가능입니다.
- 하지만 POST, PATCH는 본문 내용까지 캐시 키로 고려해야 하는데, 구현이 쉽지 않아서 GET, HEAD를 주로 캐시로 사용합니다.  

----- 


    