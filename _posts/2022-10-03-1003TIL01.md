---
title: 면접준비 - SOLID 정리, 상속단점
author: 
    name: minseok
    link: https://github.com/kkminseok
date: 2022-10-03 00:02:00 +0800
categories: [Interview]
tags: []
math: true
mermaid: true
image: 
    path: 
comments: true
---

> 오타, 지적 환영입니다.
{: .prompt-info}

## 개요

SOLID를 글로 봤을때와 CleanCode를 읽었을때는 달랐고, 그 차이를 한 번 정리겸 적어보려고 한다.

SOLID는 객체지향의 장점을 좀 더 효과적으로 보기 위한, 그리고 무분별한 책임을 가지는 코드 작성을 방지하기 위해 나타난 원칙이다.

## 1. S : 단일 책임 원칙 (Single Responsible Principle)

**단일 책임 원칙이란 객체는 단 하나만의 책임을 가져야한다.**

**그래서** 어떤 변화에 의해 클래스를 변경하는 경우는 단 하나의 이유여야한다.

이 말이 무슨 뜻이냐면 클래스는 하나의 책임을 가지지 않으면 여기저기 수정할 일이 생기니까 하나의 책임을 가지란 말이다.

너무나도 당연한 말이겠지만 **단 하나만**이라는 키워드를 클래스를 생성할때나 코드를 작성할때 계속 박아둬야한다.

## 2. O : 개방 폐쇄 원칙 (Open Closed Principle)

**개방 패쇄 원칙은 기존 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계 해야한다.**

나는 회사에서 이런적이 있었다. 어떤 신규화면을 만들어야하는데, 정렬기능이 있어서 여러가지 html속성들을 정렬순으로 옮겨야했다.

```text
---- box1
[제목]

[금리]

[상품명]

---- box2

[제목]

[금리]

[상품명]

---- box3

[제목]

[금리]

[상품명]

```

정렬순에 맞게 box안에 있는 제목, 금리, 상품명을 정렬해야해했다. 은행시스템이라서 순수 js와 html로 이 기능을 구현해야했기에 돔을 직접 조작해서 움직였다.

나는 제목을 옮기는 함수 `sortTitle()`, 금리를 움직이는 함수 `sortProfit()`,  상품명을 움직이는 함수 `sortItemName()`을 작성하고 `sort(정렬 기준 변수)`를 작성하고 이 안에다가 넣었다.

즉, 

```text
         ┌-> sortTitle()
sort() ----> sortProfit()
         └-> sortItemName()
```

근데 갑자기 [상품 내용]이라는게 추가되었다고 생각해보자. 

만약에 함수를 분리하지 않고 한 군데에(`sort()`) 저 모든 코드를 집어 넣었다면 [상품 내용]을 추가하기 위해서 `sort()`코드 내부를 수정해야한다.

근데 저런식으로 분리를 했다면? 나는 그냥 `sortItemContent()`라는 함수를 작성해서 넣기만 하면 된다. 이게 기존코드를 최대한 건들지 않고 추가에는 확장성있는 코드가 아닐까 생각한다.

## 3. L : 리스코프 치환 원칙

**리스코프 치환원칙이란 부모객체와 이를 상속한 자식객체가 있을때 부모 객체를 호출하는 동작에서 자식 객체가 부모 객체를 완전히 대체할 수 있다.**이다.

리스코프 치환원칙을 이해하기 위해서는 가장 대표적인 예시인 **정사각형-직사각형**문제가 있다.

<https://blog.itcode.dev/posts/2021/08/15/liskov-subsitution-principle>이 블로그를 참조하는게 편하다.

## 4. I : 인터페이스 분리 원칙

**인터페이스 분리 원칙이란 객체는 자신이 호출하지 않는 메소드에 의존하지 않아야한다.**이다.

이 또한 <https://blog.itcode.dev/posts/2021/08/16/interface-segregation-principle>블로그에 정리가 잘 되어있으니 보는게 편하다.

## 5. D : 의존관계 역전 원칙(DIP)

**의존관계 역전 원칙이란 객체는 저수준 모듈보다 고수준 모듈에 의존해야한다는 원칙이다.**

저수준 모듈은 구현된 객체이고, 고수준 모듈은 인터페이스와 같은 객체의 추상적 개념을 말한다.

Spring은 이 DIP를 제공하고 있는데, 왜 DIP가 필요할까?

만약 객체에 의존하게 된다면, 그 객체가 수정이 될때마다 바라보고 있는 객체의 코드도 수정해야할 지 모른다. 이는 의존성이 객체로 향해 있기 때문이다.

하지만 DIP원칙에 따르기 위해 인터페이스를 작성하고 의존성을 그쪽에 향하게 한다면 그 객체의 수정내용에 대해서 알 필요가 없다는 것이다.

인터페이스가 변경되지 않는 이상 그 객체가 수정되는거에 관여하게 될 일이 없기 때문이다.

![](/assets/img/interview/dip.png)


## 결론

막상 글로 설명하려니 어렵다.

클린코드 책을 3번 읽었는데도 나는 멀은것 같다.

## Reference

- <https://tothefullest08.github.io/php/2020/02/03/Cleancode17-dip/> DIP
- <https://blog.itcode.dev/posts/2021/08/16/interface-segregation-principle> 대부분의 글
- <https://github.com/backtony/Backend_Interview_for_Beginner/blob/master/Java.md> 글을 작성하게 된 이유1

